
    You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (e.g., Tailwind CSS, Shadcn UI, Radix UI). Your task is to produce the most optimized and maintainable Next.js code, following best practices and adhering to the principles of clean code and robust architecture.

    ### Objective
    - Create a Next.js solution that is not only functional but also adheres to the best practices in performance, security, and maintainability.

    ### Code Style and Structure
    - Write concise, technical TypeScript code with accurate examples.
    - Use functional and declarative programming patterns; avoid classes.
    - Favor iteration and modularization over code duplication.
    - Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`).
    - Structure files with exported components, subcomponents, helpers, static content, and types.
    - Use lowercase with dashes for directory names (e.g., `components/auth-wizard`).

    ### Optimization and Best Practices
    - Minimize the use of `'use client'`, `useEffect`, and `setState`; favor React Server Components (RSC) and Next.js SSR features.
    - Implement dynamic imports for code splitting and optimization.
    - Use responsive design with a mobile-first approach.
    - Optimize images: use WebP format, include size data, implement lazy loading.

    ### Error Handling and Validation
    - Prioritize error handling and edge cases:
      - Use early returns for error conditions.
      - Implement guard clauses to handle preconditions and invalid states early.
      - Use custom error types for consistent error handling.

    ### UI and Styling
    - Use modern UI frameworks (e.g., Tailwind CSS, Shadcn UI, Radix UI) for styling.
    - Implement consistent design and responsive patterns across platforms.

    ### State Management and Data Fetching
    - Use modern state management solutions (e.g., Zustand, TanStack React Query) to handle global state and data fetching.
    - Implement validation using Zod for schema validation.

    ### Security and Performance
    - Implement proper error handling, user input validation, and secure coding practices.
    - Follow performance optimization techniques, such as reducing load times and improving rendering efficiency.

    ### Testing and Documentation
    - Write unit tests for components using Jest and React Testing Library.
    - Provide clear and concise comments for complex logic.
    - Use JSDoc comments for functions and components to improve IDE intellisense.

    ### Methodology
    1. **System 2 Thinking**: Approach the problem with analytical rigor. Break down the requirements into smaller, manageable parts and thoroughly consider each step before implementation.
    2. **Tree of Thoughts**: Evaluate multiple possible solutions and their consequences. Use a structured approach to explore different paths and select the optimal one.
    3. **Iterative Refinement**: Before finalizing the code, consider improvements, edge cases, and optimizations. Iterate through potential enhancements to ensure the final solution is robust.

    **Process**:
    1. **Deep Dive Analysis**: Begin by conducting a thorough analysis of the task at hand, considering the technical requirements and constraints.
    2. **Planning**: Develop a clear plan that outlines the architectural structure and flow of the solution, using <PLANNING> tags if necessary.
    3. **Implementation**: Implement the solution step-by-step, ensuring that each part adheres to the specified best practices.
    4. **Review and Optimize**: Perform a review of the code, looking for areas of potential optimization and improvement.
    5. **Finalization**: Finalize the code by ensuring it meets all requirements, is secure, and is performant.
    

    # Vinci Capabilities Document

## Overview

Vinci is a sophisticated web application built with Next.js and Supabase, offering a range of features from user authentication to real-time AI-powered chat functionalities. This document outlines the primary capabilities of Vinci, providing a clear understanding of what the application can achieve.

---

## Key Capabilities

### 1. **Authentication and User Management**
- **Sign-up, Sign-in, and Password Management**: Users can create accounts, log in, and manage their passwords through secure interfaces.
  - Implemented using Supabase Auth, with dedicated pages for:
    - Sign-in (`app/(auth-pages)/sign-in/page.tsx`)
    - Sign-up (`app/(auth-pages)/sign-up/page.tsx`)
    - Forgot Password (`app/(auth-pages)/forgot-password/page.tsx`)
    - Reset Password (`app/protected/reset-password/page.tsx`)
- **User Profile Management**: Users can view and update their profile information, including full name, avatar URL, website, and bio.
  - Managed through `app/protected/profile/page.tsx`.
- **OAuth Integration**: Supports OAuth for seamless authentication with external providers.
  - OAuth callbacks are handled via `app/auth/callback/route.ts`.

---

### 2. **Chat Functionality**
- **Real-time AI Chat**: Users can engage in conversations with AI models from multiple providers such as Groq, Anthropic, OpenAI, Cohere, Mistral, Google, xAI, Together AI, and Perplexity.
  - Chat requests are processed through `app/api/chat/route.ts`, with provider configurations in `config/models.ts`.
  - The chat interface uses components like `components/ui/chat-message.tsx` and `components/ui/unified-input.tsx` for a seamless user experience.
- **Conversation Management**: Users can organize chats into spaces and conversations for better context and management.
  - Spaces are managed via `lib/stores/space-store.ts` and `app/actions.ts`.
  - Conversations are managed via `lib/stores/conversation-store.ts` and `components/ui/conversations-list.tsx`.
- **Rich Text and Code Support**: The chat system supports displaying and interacting with formatted text and code blocks.
  - Markdown rendering is handled by `components/ui/markdown-renderer.tsx`.
  - Code blocks are enhanced with `components/ui/code-block.tsx`, including syntax highlighting and copy functionality.

---

### 3. **UI Components**
- **Reusable Components**: Repomix provides a library of customizable UI components such as avatars, badges, buttons, and cards.
  - Built with shadcn/ui and Radix UI, styled using Tailwind CSS, and located in `components/ui/`.
  - Examples include `components/ui/avatar.tsx`, `components/ui/button.tsx`, and `components/ui/dropdown-menu.tsx`.
- **Advanced Chat Components**: Specialized components for displaying chat messages, code blocks, and markdown content.
  - Key components include `components/ui/chat-messages.tsx`, `components/ui/chat-messages-skeleton.tsx`, and `components/ui/unified-input.tsx`.

---

### 4. **State Management**
- **Global State Handling**: Utilizes Zustand for managing application state, ensuring data consistency across components.
  - Spaces are managed in `lib/stores/space-store.ts`.
  - Conversations are managed in `lib/stores/conversation-store.ts`.
  - Chat messages are managed in `store/chatStore.ts`.

---

### 5. **Database Integration**
- **Supabase Backend**: Leverages Supabase for authentication and database management, ensuring secure and scalable data handling.
  - Database schema is defined in `supabase/migrations/`, with tables for spaces, conversations, and messages.
  - Row-Level Security (RLS) policies ensure data privacy.
- **Schema Management**: Database schema is managed through migrations, supporting tables for spaces, conversations, and messages.
  - Migrations are located in `supabase/migrations/`, such as `20250204124800_create_complete_schema.sql`.

---

### 6. **Performance Optimization**
- **Server-Side Rendering (SSR)**: Uses Next.js SSR and React Server Components for improved performance and SEO.
  - Implemented in `app/protected/page.tsx` and other server-rendered pages.
- **Caching**: Implements Redis caching to enhance response times for frequently accessed data.
  - Redis caching is configured in `app/actions.ts`, with cache keys and TTL settings in `lib/constants.ts`.

---

### 7. **Accessibility and Internationalization**
- **Accessibility Features**: Incorporates semantic HTML and ARIA attributes to support accessibility.
  - Components like `components/ui/button.tsx` and `components/ui/dropdown-menu.tsx` include ARIA support.
- **Internationalization Support**: Designed to accommodate internationalization libraries for multi-language support, although not currently implemented.

---

### 8. **Deployment and Development**
- **Vercel Deployment**: Easily deployable to Vercel with automatic environment variable configuration.
  - Deployment settings are configured in `next.config.ts`.
- **Desktop Application Support**: Integrated with Electron for creating desktop applications.
  - Electron configuration is in `electron/main.ts`, with build settings in `tsup.config.ts`.

---

## Detailed Description

### **Authentication and User Management**
- The application provides a comprehensive authentication system using Supabase Auth. Users can sign up, sign in, reset their passwords, and manage their profiles securely.
- OAuth callbacks ensure secure authentication processes, enhancing user experience.

### **Chat Functionality**
- Repomix features a sophisticated chat system that integrates with multiple AI providers. The chat interface is user-friendly, supporting real-time interactions and rich text formatting.
- Conversations can be organized into spaces, allowing users to manage multiple chat contexts efficiently.

### **UI Components**
- The application leverages a rich set of UI components from shadcn/ui and Radix UI, customized with Tailwind CSS. These components ensure a consistent and modern look and feel, enhancing usability.
- Specialized components like `components/ui/code-block.tsx` and `components/ui/markdown-renderer.tsx` enhance the display of code and formatted text.

### **State Management**
- State management is handled efficiently using Zustand, ensuring that data like active spaces and conversations are easily accessible and reactive across components.

### **Database Integration**
- Supabase handles backend services, with migrations defining the schema for spaces, conversations, and messages. RLS policies ensure secure data access, protecting user privacy.

### **Performance Optimization**
- The application is optimized by minimizing client-side JavaScript, leveraging Next.js's SSR capabilities, and using Redis caching for frequently accessed data.

### **Accessibility and Internationalization**
- While not fully implemented, the foundation is set for adding accessibility features and multi-language support, ensuring inclusivity and global reach.

### **Deployment and Development**
- The application supports deployment to Vercel and local development with Electron, providing flexibility for both web and desktop environments.

---

# Repomix Architecture Document

## Overview

Repomix is architected using a modern stack that combines Next.js for the frontend, Supabase for the backend, and Zustand for state management. This document provides an in-depth look at how Repomix is structured, detailing the interaction between its various components to ensure a modular, scalable, and maintainable system.

---

## Architectural Components

### 1. **Frontend**
- **Next.js App Router**: Manages routing and server-side rendering.
  - Utilizes Next.js's App Router for efficient page navigation, implemented in `app/layout.tsx` and various page components.
- **React Components**: Organized under `components/ui/` for reusability.
  - Components are modular, built with shadcn/ui and Radix UI, and styled with Tailwind CSS.
  - Examples include `components/ui/avatar.tsx`, `components/ui/button.tsx`, and `components/ui/chat-messages.tsx`.
- **Hooks**: Manage side effects and state logic.
  - Custom hooks like `hooks/use-stick-to-bottom.ts` and `hooks/use-toast.ts` enhance component functionality.

---

### 2. **Backend**
- **Supabase**: Provides authentication and database services.
  - Authentication is managed through Supabase Auth, with utilities in `utils/supabase/`.
  - Database schema and migrations are defined in `supabase/migrations/`, ensuring secure data management.
- **API Routes**: Handle server-side logic, such as chat interactions.
  - API routes like `app/api/chat/route.ts` manage chat requests and AI provider interactions.
  - Server-side actions are defined in `app/actions.ts`, including space, conversation, and message management.

---

### 3. **State Management**
- **Zustand Stores**: Manage global application state.
  - Spaces are managed in `lib/stores/space-store.ts`.
  - Conversations are managed in `lib/stores/conversation-store.ts`.
  - Chat messages are managed in `store/chatStore.ts`, ensuring reactive state across components.

---

### 4. **Styling**
- **Tailwind CSS**: Utility-first styling for consistency and responsiveness.
  - Configured in `tailwind.config.ts`, with global styles in `app/globals.css`.
- **Custom Styles**: Defined in `styles/` and component-specific files.
  - Custom styles, such as `styles/prism.css`, enhance code block rendering.

---

### 5. **Utilities and Configurations**
- **Utility Functions**: Abstract common operations in `utils/`.
  - Includes Supabase utilities in `utils/supabase/` and Pinecone utilities in `utils/pinecone.ts`.
- **Configurations**: Manage settings like AI models in `config/`.
  - AI provider and model configurations are defined in `config/models.ts`.

---

### 6. **Database Schema**
- **Supabase Migrations**: Define and manage the database schema.
  - Tables for spaces, conversations, and messages are created with migrations in `supabase/migrations/`.
  - RLS policies ensure secure data access, with indexes for performance optimization.

---

## Interaction Flow

### **User Authentication**
- Users interact with authentication pages, which communicate with Supabase Auth via API routes.
  - Sign-in and sign-up flows are managed through `app/(auth-pages)/sign-in/page.tsx` and `app/(auth-pages)/sign-up/page.tsx`.
  - OAuth callbacks are handled by `app/auth/callback/route.ts`.

### **Chat Interactions**
- Users send messages through the chat interface, processed by API routes that interact with AI providers and store data in Supabase.
  - Chat requests are handled by `app/api/chat/route.ts`, with messages stored in the `messages` table.
  - The frontend displays responses using components like `components/ui/chat-message.tsx`.

### **State Updates**
- Changes in state, such as switching spaces, are managed by Zustand stores, ensuring the UI reflects the current state.
  - Active spaces are managed in `lib/stores/space-store.ts`, with updates synchronized across components.

### **Data Retrieval**
- Data is fetched from Supabase, with caching mechanisms in place to optimize performance.
  - Redis caching is implemented in `app/actions.ts`, with cache invalidation for data consistency.

---

## Detailed Description

### **Frontend Architecture**
- The application uses Next.js's App Router for routing, allowing for efficient page navigation and server-side rendering.
- React components are organized under `components/ui/`, following a modular approach for reusability.
- Hooks manage side effects and state, enhancing component functionality without cluttering logic.

### **Backend Architecture**
- Supabase serves as the backend, providing authentication and database services. Utilities in `utils/supabase/` handle interactions from both server and client sides.
- API routes manage server-side logic, including processing chat requests and interacting with AI providers.

### **State Management Architecture**
- Zustand provides a centralized state management solution, ensuring state consistency across components.
- Stores like `space-store.ts` and `conversation-store.ts` hold application state, making it accessible reactively.

### **Styling Architecture**
- Tailwind CSS is the primary styling framework, providing utility classes for rapid development.
- Custom styles are applied where necessary, ensuring a cohesive design across the application.

### **Utilities and Configurations**
- Utility functions in `utils/` abstract common operations, promoting code reuse and maintainability.
- Configurations in `config/` define settings like available AI models, making updates straightforward.

### **Database Schema Architecture**
- The database schema is defined in Supabase migrations, creating tables for spaces, conversations, and messages.
- RLS policies ensure users can only access their own data, with indexes enhancing query performance.

---

## Conclusion

These documents provide a comprehensive overview of Repomix's capabilities and architecture, offering insights into its functionality and design. By understanding these aspects, developers can better navigate the codebase, contribute effectively, and leverage the application's features to their full potential.