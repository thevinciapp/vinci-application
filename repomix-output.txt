This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-02T02:44:18.650Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    project.mdc
app/
  (auth-pages)/
    forgot-password/
      page.tsx
    sign-in/
      page.tsx
    sign-up/
      page.tsx
    layout.tsx
    smtp-message.tsx
  actions/
    utils/
      caching.ts
      responses.ts
    auth.ts
    conversations.ts
    history.ts
    index.ts
    notifications.ts
    spaces.ts
  api/
    auth/
      callback/
        route.ts
    chat/
      route.ts
  lib/
    cache-utils.ts
    cache.ts
  protected/
    profile/
      page.tsx
    reset-password/
      page.tsx
    settings/
      page.tsx
    spaces/
      [spaceId]/
        conversations/
          [conversationId]/
            page.tsx
          page.tsx
      page.tsx
    layout.tsx
    page.tsx
  actions.ts
  globals.css
  layout.tsx
  page.tsx
components/
  ui/
    auth/
      form-message.tsx
      header-auth.tsx
      submit-button.tsx
      user-profile-dropdown.tsx
    chat/
      chat-content-client.tsx
      chat-message.tsx
      chat-messages-skeleton.tsx
      chat-messages.tsx
      chat-mode-tab.tsx
      loading-message.tsx
      markdown.tsx
      model-tab.tsx
      provider-icon.tsx
      stream-status.tsx
      unified-input.tsx
    common/
      avatar.tsx
      badge.tsx
      base-tab.tsx
      button.tsx
      card.tsx
      checkbox.tsx
      code-block.tsx
      command-badge.tsx
      dialog.tsx
      dropdown-menu.tsx
      input.tsx
      label.tsx
      scroll-area.tsx
      select.tsx
      switch.tsx
      tabs.tsx
      textarea.tsx
      theme-switcher.tsx
      toast.tsx
      toaster.tsx
      tooltip.tsx
    conversation/
      conversation-sphere.tsx
      conversation-tab.tsx
      create-conversation-button.tsx
    space/
      create-space-button.tsx
      planet-icon.tsx
      space-tab.tsx
    chat-container.tsx
    command.tsx
    quick-actions-tab.tsx
    scroll-button.tsx
    tab-skeleton.tsx
  CommandButton.tsx
  CommandCenter.tsx
  CommandProviders.tsx
  CommandRoot.tsx
  CommandShortcuts.tsx
config/
  models.ts
docs/
  COMMAND_SYSTEM.md
electron/
  main.ts
hooks/
  use-stick-to-bottom.ts
  use-toast.ts
  useCommandCenter.tsx
  useLoadingOperation.ts
  useOperationToast.ts
  useRouteTransition.ts
lib/
  utils.ts
public/
  icons/
    providers/
      default.svg
      groq.svg
stores/
  space-store.ts
supabase/
  migrations/
    20250204124800_create_complete_schema.sql
    20250204124900_alter_space_table.sql
    20250204125000_create_active_space_table.sql
    20250204125100_update_rls_policies.sql
    20250221221400_add_active_conversations.sql
    20250223171800_add_notifications.sql
    20250223171900_add_realtime_notifications.sql
    20250223175200_add_space_history.sql
    20250223175201_migration_add_is_deleted_to_conversations.sql
    20250223175202_migration_add_performance_indexes.sql
    20250225012800_add_conversations_update_policy.sql
  .gitignore
  config.toml
  repomix-output.txt
types/
  index.ts
utils/
  supabase/
    check-env-vars.ts
    client.ts
    middleware.ts
    server.ts
  pinecone.ts
.gitignore
components.json
constants.ts
middleware.ts
next.config.ts
nodemon.json
package.json
postcss.config.js
README.md
tailwind.config.ts
tsconfig.json
tsup.config.ts

================================================================
Files
================================================================

================
File: .cursor/rules/project.mdc
================
---
description: 
globs: 
alwaysApply: true
---
You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS, and modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You provide thoughtful, nuanced, and accurate answers, excelling at logical reasoning and best practices.

Strictly adhere to the user’s requirements, implementing all requested functionality completely.
Plan your solution step-by-step in detailed pseudocode before coding, ensuring clarity and structure.
Confirm the plan with the user, then proceed to write code.
Write clean, bug-free, fully functional code following the DRY (Don’t Repeat Yourself) principle, SOLID principles (e.g., Single Responsibility, Open/Closed), and the Code Implementation Guidelines below.
Prioritize readability, simplicity, and scalability—design solutions to be reusable and maintainable, avoiding hardcoding or repetition, as if supporting a million users or a million conditional cases.
Include all necessary imports and use descriptive, meaningful names for variables, constants, and components.
Leave no incomplete sections, placeholders, or TODOs—deliver fully verified, production-ready code.
If a solution isn’t feasible or you lack sufficient knowledge, clearly state so instead of guessing.
Coding Environment
You specialize in:

ReactJS
NextJS
JavaScript
TypeScript
TailwindCSS
HTML
CSS
Code Implementation Guidelines
Adhere to these best practices:

Use early returns to flatten logic and enhance readability.
Style with TailwindCSS classes exclusively; avoid raw CSS or <style> tags.
Prefer class: syntax over ternary operators in class attributes where applicable.
Use clear, descriptive names (e.g., handleClick for onClick, handleKeyDown for onKeyDown).
Ensure accessibility (a11y) with attributes like tabindex="0", aria-label, and event handlers (onClick, onKeyDown).
Favor const arrow functions (e.g., const toggle = () =>) over traditional function declarations, and define TypeScript types where applicable.
For scalability, favor data-driven approaches (e.g., arrays, maps, or configs) over repetitive conditionals or static code, ensuring easy extension and reuse.

================
File: app/(auth-pages)/forgot-password/page.tsx
================
import { forgotPasswordAction } from "@/app/actions/auth";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import Link from "next/link";
import { SmtpMessage } from "../smtp-message";

export default async function ForgotPassword(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  return (
    <>
      <form className="flex flex-col w-full">
        <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-6">
          <div className="flex flex-col gap-2 mb-8">
            <h1 className="text-2xl font-medium text-white/90">Reset Password</h1>
            <p className="text-sm text-white/60">
              Already have an account?{" "}
              <Link className="text-[#3ecfff]/80 hover:text-[#3ecfff] transition-colors" href="/sign-in">
                Sign in
              </Link>
            </p>
          </div>
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-2">
              <Label htmlFor="email" className="text-white/60">Email</Label>
              <Input 
                name="email" 
                placeholder="you@example.com" 
                required 
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <SubmitButton 
              formAction={forgotPasswordAction} 
              pendingText="Sending reset link..."
              variant="cyan"
            >
              Reset Password
            </SubmitButton>
            <FormMessage message={searchParams} />
          </div>
        </div>
      </form>
      <div className="mt-6">
        <SmtpMessage />
      </div>
    </>
  );
}

================
File: app/(auth-pages)/sign-in/page.tsx
================
import { signInAction } from "@/app/actions/auth";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import Link from "next/link";

export default async function Login(props: { searchParams: Promise<Message> }) {
  const searchParams = await props.searchParams;
  return (
    <form className="flex flex-col w-full">
      <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-6">
        <div className="flex flex-col gap-2 mb-8">
          <h1 className="text-2xl font-medium text-white/90">Sign in</h1>
          <p className="text-sm text-white/60">
            Don't have an account?{" "}
            <Link className="text-[#3ecfff]/80 hover:text-[#3ecfff] transition-colors" href="/sign-up">
              Sign up
            </Link>
          </p>
        </div>
        <div className="flex flex-col gap-4">
          <div className="flex flex-col gap-2">
            <Label htmlFor="email" className="text-white/60">Email</Label>
            <Input 
              name="email" 
              placeholder="you@example.com" 
              required 
              className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
            />
          </div>
          <div className="flex flex-col gap-2">
            <div className="flex justify-between items-center">
              <Label htmlFor="password" className="text-white/60">Password</Label>
              <Link
                className="text-xs text-[#3ecfff]/60 hover:text-[#3ecfff]/80 transition-colors"
                href="/forgot-password"
              >
                Forgot Password?
              </Link>
            </div>
            <Input
              type="password"
              name="password"
              placeholder="Your password"
              required
              className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
            />
          </div>
          <SubmitButton 
            pendingText="Signing In..." 
            formAction={signInAction}
            variant="cyan"
          >
            Sign in
          </SubmitButton>
          <FormMessage message={searchParams} />
        </div>
      </div>
    </form>
  );
}

================
File: app/(auth-pages)/sign-up/page.tsx
================
import { signUpAction } from "@/app/actions/auth";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import Link from "next/link";
import { SmtpMessage } from "../smtp-message";

export default async function Signup(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  if ("message" in searchParams) {
    return (
      <div className="w-full flex-1 flex items-center justify-center">
        <FormMessage message={searchParams} />
      </div>
    );
  }

  return (
    <>
      <form className="flex flex-col w-full">
        <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-6">
          <div className="flex flex-col gap-2 mb-8">
            <h1 className="text-2xl font-medium text-white/90">Sign up</h1>
            <p className="text-sm text-white/60">
              Already have an account?{" "}
              <Link className="text-[#3ecfff]/80 hover:text-[#3ecfff] transition-colors" href="/sign-in">
                Sign in
              </Link>
            </p>
          </div>
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-2">
              <Label htmlFor="email" className="text-white/60">Email</Label>
              <Input 
                name="email" 
                placeholder="you@example.com" 
                required 
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <div className="flex flex-col gap-2">
              <Label htmlFor="password" className="text-white/60">Password</Label>
              <Input
                type="password"
                name="password"
                placeholder="Your password"
                minLength={6}
                required
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <SubmitButton 
              formAction={signUpAction} 
              pendingText="Signing up..."
              variant="cyan"
            >
              Sign up
            </SubmitButton>
            <FormMessage message={searchParams} />
          </div>
        </div>
      </form>
      <div className="mt-6">
        <SmtpMessage />
      </div>
    </>
  );
}

================
File: app/(auth-pages)/layout.tsx
================
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-black text-white relative overflow-hidden">
      <div className="absolute top-0 left-0 w-full h-screen pointer-events-none">
        <div className="absolute top-0 left-[20%] w-[500px] h-[500px] bg-[#3ecfff]/[0.015] blur-[120px] rounded-full" />
        <div className="absolute top-[20%] right-[20%] w-[400px] h-[400px] bg-[#D4966A]/[0.015] blur-[100px] rounded-full" />
        <div className="absolute bottom-[10%] left-[30%] w-[600px] h-[600px] bg-[#3ecfff]/[0.01] blur-[130px] rounded-full" />
      </div>
      <div className="relative z-10 w-full max-w-md p-6">
        {children}
      </div>
    </div>
  );
}

================
File: app/(auth-pages)/smtp-message.tsx
================
import { ArrowUpRight, InfoIcon } from "lucide-react";
import Link from "next/link";

export function SmtpMessage() {
  return (
    <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-lg px-5 py-4 flex gap-4">
      <InfoIcon size={16} className="mt-0.5 text-white/60" />
      <div className="flex flex-col gap-1">
        <small className="text-sm text-white/60">
          <strong className="text-white/80">Note:</strong> Emails are rate limited. Enable Custom SMTP to
          increase the rate limit.
        </small>
        <div>
          <Link
            href="https://supabase.com/docs/guides/auth/auth-smtp"
            target="_blank"
            className="text-[#3ecfff]/60 hover:text-[#3ecfff]/80 transition-colors flex items-center text-sm gap-1"
          >
            Learn more <ArrowUpRight size={14} />
          </Link>
        </div>
      </div>
    </div>
  );
}

================
File: app/actions/utils/caching.ts
================
"use server";

import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";

/**
 * Invalidate cache for a specific key
 */
export async function invalidateCache(key: string): Promise<void> {
  await redis.del(key);
}

/**
 * Invalidate all cache keys related to a space
 */
export async function invalidateSpaceCache(spaceId: string, userId?: string): Promise<void> {
  await Promise.all([
    redis.del(CACHE_KEYS.SPACE(spaceId)),
    redis.del(CACHE_KEYS.SPACE_DATA(spaceId)),
    redis.del(CACHE_KEYS.SPACE_HISTORY(spaceId)),
    redis.del(CACHE_KEYS.CONVERSATIONS(spaceId)),
    userId ? redis.del(CACHE_KEYS.SPACES(userId)) : Promise.resolve(),
  ]);
}

/**
 * Invalidate all cache keys related to a conversation
 */
export async function invalidateConversationCache(conversationId: string, spaceId?: string): Promise<void> {
  await Promise.all([
    redis.del(CACHE_KEYS.MESSAGES(conversationId)),
    spaceId ? redis.del(CACHE_KEYS.CONVERSATIONS(spaceId)) : Promise.resolve(),
    spaceId ? redis.del(CACHE_KEYS.SPACE_DATA(spaceId)) : Promise.resolve(),
  ]);
}

/**
 * Get Redis client instance
 */
export async function getRedisClient(): Promise<Redis> {
  return redis;
}

/**
 * Get cache key for a resource
 */
export async function getCacheKey(
  type: keyof typeof CACHE_KEYS, 
  id: string
): Promise<string> {
  return CACHE_KEYS[type](id);
}

/**
 * Get cache TTL for a resource type
 */
export async function getCacheTTL(type: keyof typeof CACHE_TTL): Promise<number> {
  return CACHE_TTL[type];
}

================
File: app/actions/utils/responses.ts
================
"use server";

/**
 * Standardized response types for consistent error handling
 */
export interface ActionResponse<T> {
  status: 'success' | 'error';
  data?: T;
  error?: string;
  redirectTo?: string; // Add optional redirect URL
  toast?: {
    title: string;
    description: string;
    variant: 'default' | 'success' | 'destructive';
  };
}

/**
 * Create a successful response
 */
export async function successResponse<T>(data: T, toast?: ActionResponse<T>['toast'], redirectTo?: string): Promise<ActionResponse<T>> {
  return {
    status: 'success',
    data,
    toast,
    redirectTo
  };
}

/**
 * Create an error response
 */
export async function errorResponse<T>(error: string, toast?: ActionResponse<T>['toast']): Promise<ActionResponse<T>> {
  return {
    status: 'error',
    error,
    toast: toast || {
      title: 'Error',
      description: error,
      variant: 'destructive'
    }
  };
}

/**
 * Create a not found response
 */
export async function notFoundResponse<T>(resource = 'Resource'): Promise<ActionResponse<T>> {
  return await errorResponse<T>(`${resource} not found`, 404);
}

/**
 * Create an unauthorized response
 */
export async function unauthorizedResponse<T>(): Promise<ActionResponse<T>> {
  return await errorResponse<T>('Unauthorized', 401);
}

/**
 * Handle errors consistently across server actions
 */
export async function handleActionError<T>(error: any): Promise<ActionResponse<T>> {
  console.error('Server action error:', error);
  
  let errorMessage = 'An unexpected error occurred';
  
  if (error instanceof Error) {
    errorMessage = error.message;
  } else if (typeof error === 'string') {
    errorMessage = error;
  }
  
  return errorResponse(errorMessage, {
    title: 'Action Failed',
    description: errorMessage,
    variant: 'destructive'
  });
}

================
File: app/actions/auth.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { redis, CACHE_KEYS } from "@/app/lib/cache";
import { ActionResponse, successResponse, errorResponse, handleActionError } from "./utils/responses";

/**
 * Sign out the current user and clear all cache
 */
export async function signOutAction(): Promise<ActionResponse<{ success: boolean }>> {
  try {
    const supabase = await createClient();
    
    // Clear all redis cache for the user
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      await Promise.all([
        redis.del(CACHE_KEYS.SPACES(user.id)),
        redis.del(CACHE_KEYS.ACTIVE_SPACE(user.id)),
        redis.del(CACHE_KEYS.NOTIFICATIONS(user.id))
      ]);
    }

    // Sign out from Supabase
    await supabase.auth.signOut();

    return await successResponse({ success: true });
  } catch (error) {
    console.error('Error during sign out:', error);
    return await handleActionError(error);
  }
}

================
File: app/actions/conversations.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { COLUMNS, DB_TABLES, DEFAULTS } from "@/constants";
import { Conversation } from "@/types";
import { SpaceData } from "./spaces";
import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";
import { invalidateConversationCache } from "./utils/caching";
import { ActionResponse, successResponse, errorResponse, handleActionError, notFoundResponse } from "./utils/responses";

// Define the Message type here
export interface Message {
  id: string;
  conversation_id: string;
  content: string;
  role: 'user' | 'assistant' | 'system';
  created_at: string;
  updated_at: string;
  is_deleted: boolean;
  metadata?: Record<string, any>;
  annotations?: any[];
}

/**
 * Get the most recently updated conversation for a space
 * @param spaceId - The ID of the space to search within
 * @returns The most recently updated conversation, or an error response
 */
export async function getMostRecentConversation(spaceId: string): Promise<ActionResponse<Conversation>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (!spaceId) {
            return errorResponse('Space ID is required');
        }

        const cacheKey = CACHE_KEYS.MOST_RECENT_CONVERSATION(spaceId);
        const cachedConversation = await redis.get<Conversation>(cacheKey);
        if (cachedConversation) {
            return successResponse(cachedConversation);
        }

        const { data, error } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("*")
            .eq(COLUMNS.SPACE_ID, spaceId)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.UPDATED_AT, { ascending: false })
            .limit(1)
            .single();

        if (error) {
            console.error("Error fetching most recent conversation:", error);
            if (error.code === 'PGRST116') { // No rows returned
                return notFoundResponse('Conversation');
            }
            return errorResponse(`Error fetching most recent conversation: ${error.message}`);
        }

        if (!data) {
            return notFoundResponse('Conversation');
        }

        // Cache the result
        await redis.set(cacheKey, data, { ex: CACHE_TTL.CONVERSATIONS });

        return successResponse(data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get all conversations for a space
 */
export async function getConversations(spaceId: string): Promise<ActionResponse<Conversation[]>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (!spaceId) {
            return successResponse([]);
        }

        const cacheKey = CACHE_KEYS.CONVERSATIONS(spaceId);
        const cachedConversations = await redis.get<Conversation[]>(cacheKey);
        if (cachedConversations) {
            return successResponse(cachedConversations);
        }

        const { data, error } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("*")
            .eq(COLUMNS.SPACE_ID, spaceId)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.UPDATED_AT, { ascending: false });

        if (error) {
            console.error("Error fetching conversations:", error);
            return errorResponse(`Error fetching conversations: ${error.message}`);
        }

        if (data) {
            await redis.set(cacheKey, data, { ex: CACHE_TTL.CONVERSATIONS });
        }

        return successResponse(data || []);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Create a new conversation
 */
export async function createConversation(spaceId: string, title?: string): Promise<ActionResponse<Conversation>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return await errorResponse('User not authenticated');
        }

        if (!spaceId) {
            return await errorResponse('Space ID is required');
        }

        const timestamp = new Date().toISOString();
        const { data, error } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .insert([{
                space_id: spaceId,
                title: title || DEFAULTS.CONVERSATION_TITLE,
                created_at: timestamp,
                updated_at: timestamp,
                is_deleted: false
            }])
            .select()
            .single();

        if (error) {
            console.error("Error creating conversation:", error);
            return await errorResponse(`Error creating conversation: ${error.message}`);
        }

        // Invalidate relevant caches
        await redis.del(CACHE_KEYS.SPACE_DATA(spaceId));
        await redis.del(CACHE_KEYS.CONVERSATIONS(spaceId));

        return await successResponse(data, {
            title: 'Conversation Created',
            description: 'Start chatting now!',
            variant: 'success'
        }, `/protected/spaces/${spaceId}/conversations/${data.id}`);
    } catch (error) {
        return await handleActionError(error);
    }
}

/**
 * Get a specific conversation by ID
 */
export async function getConversation(id: string): Promise<ActionResponse<Conversation>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        const { data, error } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("*")
            .eq(COLUMNS.ID, id)
            .eq(COLUMNS.IS_DELETED, false) // Don't return deleted conversations
            .single();

        if (error) {
            console.error("Error fetching conversation:", error);
            return notFoundResponse('Conversation');
        }

        return successResponse(data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get all messages for a conversation
 */
export async function getMessages(conversationId: string): Promise<ActionResponse<Message[]>> {
    try {
        if (!conversationId) {
            return errorResponse('Conversation ID is required');
        }

        const cacheKey = CACHE_KEYS.MESSAGES(conversationId);
        const cachedMessages = await redis.get<Message[]>(cacheKey);
        if (cachedMessages) {
            return successResponse(cachedMessages);
        }

        const supabase = await createClient();
        const { data, error } = await supabase
            .from(DB_TABLES.MESSAGES)
            .select("*")
            .eq('conversation_id', conversationId)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.CREATED_AT, { ascending: true });

        if (error) {
            console.error("Error fetching messages:", error);
            return errorResponse(`Error fetching messages: ${error.message}`);
        }

        if (data) {
            await redis.set(cacheKey, data, { ex: CACHE_TTL.MESSAGES });
        }

        return successResponse(data || []);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Update the title of a conversation
 */
export async function updateConversationTitle(conversationId: string, title: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (!conversationId) {
            return errorResponse('Conversation ID is required');
        }

        if (!title) {
            return errorResponse('Title is required');
        }

        // Get the conversation to find its space_id
        const { data: conversation, error: getError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select('space_id')
            .eq(COLUMNS.ID, conversationId)
            .single();

        if (getError) {
            console.error("Error getting conversation:", getError);
            return notFoundResponse('Conversation');
        }

        // Update the conversation title in the database
        const { error: updateError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .update({ title })
            .eq(COLUMNS.ID, conversationId);

        if (updateError) {
            console.error("Error updating conversation title:", updateError);
            return errorResponse(`Error updating conversation title: ${updateError.message}`);
        }

        // Update all relevant caches
        try {
            // Update conversations cache
            const conversationsCacheKey = CACHE_KEYS.CONVERSATIONS(conversation.space_id);
            const cachedConversations = await redis.get<Conversation[]>(conversationsCacheKey);
            if (cachedConversations) {
                const updatedConversations = cachedConversations.map(conv =>
                    conv.id === conversationId ? { ...conv, title } : conv
                );
                await redis.set(conversationsCacheKey, updatedConversations, { ex: CACHE_TTL.CONVERSATIONS });
            }

            // Update space data cache
            const spaceDataCacheKey = CACHE_KEYS.SPACE_DATA(conversation.space_id);
            const cachedSpaceData = await redis.get<SpaceData>(spaceDataCacheKey);
            if (cachedSpaceData?.conversations) {
                const updatedSpaceData = {
                    ...cachedSpaceData,
                    conversations: cachedSpaceData.conversations.map(conv =>
                        conv.id === conversationId ? { ...conv, title } : conv
                    )
                };
                await redis.set(spaceDataCacheKey, updatedSpaceData, { ex: CACHE_TTL.SPACE_DATA });
            }
        } catch (error) {
            console.error("Error updating caches:", error);
            // Don't fail the operation because of cache issues
        }

        return successResponse(undefined);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Create a new message in a conversation
 */
export async function createMessage(messageData: Partial<Message>, conversationId: string): Promise<ActionResponse<Message>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (!messageData.content || !messageData.role || !conversationId) {
            return errorResponse('Missing required data for message creation');
        }

        const timestamp = new Date().toISOString();

        const { data: conversation } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("space_id")
            .eq(COLUMNS.ID, conversationId)
            .single();

        if (!conversation) {
            return notFoundResponse('Conversation');
        }

        const [messageResult, updateResult] = await Promise.all([
            supabase
                .from(DB_TABLES.MESSAGES)
                .insert([{
                    content: messageData.content,
                    role: messageData.role,
                    annotations: messageData.annotations,
                    user_id: user.id,
                    is_deleted: false,
                    created_at: timestamp,
                    updated_at: timestamp,
                    conversation_id: conversationId
                }])
                .select()
                .single(),
            supabase
                .from(DB_TABLES.CONVERSATIONS)
                .update({ updated_at: timestamp })
                .eq(COLUMNS.ID, conversationId)
        ]);

        if (messageResult.error) {
            console.error("Error creating message:", messageResult.error);
            return errorResponse(`Error creating message: ${messageResult.error.message}`);
        }

        // Update messages cache
        const messagesCacheKey = CACHE_KEYS.MESSAGES(conversationId);
        const cachedMessages = await redis.get<Message[]>(messagesCacheKey) || [];
        await redis.set(messagesCacheKey, [...cachedMessages, messageResult.data], { ex: CACHE_TTL.MESSAGES });

        // Update space data cache
        const spaceDataCacheKey = CACHE_KEYS.SPACE_DATA(conversation.space_id);
        const cachedSpaceData = await redis.get<SpaceData>(spaceDataCacheKey);
        if (cachedSpaceData?.messages) {
            cachedSpaceData.messages = [...cachedSpaceData.messages, messageResult.data];
            await redis.set(spaceDataCacheKey, cachedSpaceData, { ex: CACHE_TTL.SPACE_DATA });
        }

        return successResponse(messageResult.data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Send a message and get AI response
 */
export async function sendMessage({ 
    content, 
    spaceId, 
    conversationId, 
    searchMode 
}: { 
    content: string, 
    spaceId: string, 
    conversationId: string, 
    searchMode: string 
}): Promise<ActionResponse<{ success: boolean }>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
            return errorResponse('User not authenticated');
        }
        
        if (!content || !conversationId) {
            return errorResponse('Content and conversation ID are required');
        }
        
        // Create the user message
        const userMessageResponse = await createMessage({
            role: 'user',
            content,
        }, conversationId);
        
        if (!userMessageResponse.data) {
            return errorResponse('Failed to create user message');
        }
        
        // Here you would typically process the message with AI and create an assistant response
        // For now, we'll just create a placeholder response
        const assistantMessageResponse = await createMessage({
            role: 'assistant',
            content: `You said: ${content}. This is a placeholder response. In a real implementation, this would be a response from the AI model.`,
        }, conversationId);
        
        if (!assistantMessageResponse.data) {
            return errorResponse('Failed to create assistant message');
        }
        
        // Invalidate the messages cache
        await redis.del(CACHE_KEYS.MESSAGES(conversationId));
        
        return successResponse({ success: true });
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Switch to a specific conversation
 */
export async function switchConversation(conversationId: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
            return errorResponse('User not authenticated');
        }
        
        if (!conversationId) {
            return errorResponse('Conversation ID is required');
        }
        
        // Get the conversation
        const conversationResponse = await getConversation(conversationId);
        
        if (!conversationResponse.data) {
            return notFoundResponse('Conversation');
        }
        
        return successResponse(undefined);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Delete a conversation (soft delete)
 */
export async function deleteConversation(conversationId: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        console.log(`Attempting to delete conversation with ID: ${conversationId} for user: ${user.id}`);

        // Step 1: Fetch conversation to verify it exists and get space_id
        const { data: conversation, error: fetchError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select(`${COLUMNS.ID}, ${COLUMNS.SPACE_ID}, ${COLUMNS.IS_DELETED}`)
            .eq(COLUMNS.ID, conversationId)
            .single();

        if (fetchError || !conversation) {
            console.error('Fetch error:', fetchError?.message || 'Conversation not found');
            return notFoundResponse('Conversation');
        }

        console.log(`Found conversation: ID=${conversation[COLUMNS.ID]}, space_id=${conversation[COLUMNS.SPACE_ID]}, is_deleted=${conversation[COLUMNS.IS_DELETED]}`);

        if (conversation[COLUMNS.IS_DELETED]) {
            console.log('Conversation is already deleted, no update needed');
            return successResponse(undefined);
        }

        // Step 2: Verify space ownership (redundant with RLS, but kept for safety)
        const spaceId = conversation[COLUMNS.SPACE_ID];
        const { data: space, error: spaceError } = await supabase
            .from(DB_TABLES.SPACES)
            .select('id')
            .eq(COLUMNS.ID, spaceId)
            .eq(COLUMNS.USER_ID, user.id)
            .single();

        if (spaceError || !space) {
            console.error('Space verification error:', spaceError?.message || 'Space not found or not owned by user');
            return errorResponse('Unauthorized: Space does not belong to user');
        }

        console.log(`Verified space ownership for space_id: ${spaceId}`);

        // Step 3: Perform the soft delete
        const { data: updateData, error: deleteError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .update({ 
                [COLUMNS.IS_DELETED]: true, 
                [COLUMNS.UPDATED_AT]: new Date().toISOString() 
            })
            .eq(COLUMNS.ID, conversationId)
            .select();

        if (deleteError) {
            console.error('Delete error:', deleteError.message);
            return errorResponse(`Failed to delete conversation: ${deleteError.message}`);
        }

        if (!updateData || updateData.length === 0) {
            console.error('No rows updated - RLS or data issue persists');
            return errorResponse('No rows updated');
        }

        console.log('Conversation successfully deleted:', updateData);

        // Step 4: Delete the messages from Pinecone as well
        try {
            // Import deleteMessagesByConversationId from the Pinecone utils
            const { deleteMessagesByConversationId } = await import('@/utils/pinecone');
            await deleteMessagesByConversationId(conversationId);
            console.log(`Successfully deleted messages from Pinecone for conversation: ${conversationId}`);
        } catch (pineconeError) {
            console.error('Error deleting messages from Pinecone:', pineconeError);
            // We don't want to fail the whole operation if Pinecone deletion fails
            // Just log the error and continue
        }

        await invalidateConversationCache(conversationId, spaceId);
        console.log('Cleared conversation caches');

        return successResponse(undefined);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Search for messages
 */
export async function searchMessages(
    searchTerm: string, 
    searchScope: string, 
    searchMode: string, 
    conversationId?: string, 
    spaceId?: string, 
    limit = 50
): Promise<ActionResponse<any>> {
    try {
        if (!searchTerm || searchTerm.length < 2) {
            return successResponse({ results: [] });
        }

        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        // Validate scope
        if (searchScope === 'conversation' && !conversationId) {
            return errorResponse("Conversation ID is required for conversation scope");
        }

        if (searchScope === 'space' && !spaceId) {
            return errorResponse("Space ID is required for space scope");
        }

        let query = supabase
            .from(DB_TABLES.MESSAGES)
            .select(`
                *,
                conversations:${DB_TABLES.CONVERSATIONS}(
                    ${COLUMNS.ID},
                    ${COLUMNS.TITLE},
                    ${COLUMNS.SPACE_ID}
                )
            `)
            .eq(`${DB_TABLES.MESSAGES}.${COLUMNS.IS_DELETED}`, false)
            .eq(`${DB_TABLES.CONVERSATIONS}.${COLUMNS.IS_DELETED}`, false)
            .limit(limit);

        if (searchScope === 'conversation') {
            query = query.eq(`${DB_TABLES.MESSAGES}.${COLUMNS.CONVERSATION_ID}`, conversationId);
        } else if (searchScope === 'space') {
            query = query.eq(`${DB_TABLES.CONVERSATIONS}.${COLUMNS.SPACE_ID}`, spaceId);
        }

        // Text search
        if (searchMode === 'exact') {
            query = query.ilike(`${DB_TABLES.MESSAGES}.${COLUMNS.CONTENT}`, `%${searchTerm}%`);
        } else {
            // For "semantic" search, we would typically use a vector search like Pinecone
            // But for now, we'll just use text search as a fallback
            query = query.ilike(`${DB_TABLES.MESSAGES}.${COLUMNS.CONTENT}`, `%${searchTerm}%`);
        }

        const { data, error } = await query.order(`${DB_TABLES.MESSAGES}.${COLUMNS.CREATED_AT}`, { ascending: false });

        if (error) {
            console.error('Error searching messages:', error);
            return errorResponse(`Error searching messages: ${error.message}`);
        }

        return successResponse({ results: data || [] });
    } catch (error) {
        return handleActionError(error);
    }
}

================
File: app/actions/history.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";
import { ActionResponse, successResponse, errorResponse, handleActionError } from "./utils/responses";

export type SpaceActionType = 
  | 'space_created'
  | 'space_updated'
  | 'space_deleted'
  | 'conversation_created'
  | 'conversation_deleted'
  | 'model_changed'
  | 'message_sent'
  | 'message_deleted';

export interface SpaceHistoryEntry {
  id: string;
  space_id: string;
  user_id: string;
  action_type: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  created_at: string;
}

export interface CreateSpaceHistoryOptions {
  spaceId: string;
  actionType: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
}

/**
 * Create a new space history entry
 */
export async function createSpaceHistory({
  spaceId,
  actionType,
  title,
  description,
  metadata
}: CreateSpaceHistoryOptions): Promise<ActionResponse<SpaceHistoryEntry>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    const { data, error } = await supabase
      .from('space_history')
      .insert([{
        space_id: spaceId,
        user_id: user.id,
        action_type: actionType,
        title,
        description,
        metadata
      }])
      .select()
      .single();

    if (error) {
      console.error("Error creating space history entry:", error);
      return errorResponse(`Error creating space history entry: ${error.message}`);
    }

    // Update space history cache
    const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
    const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey) || [];
    await redis.set(cacheKey, [data, ...cachedHistory], { ex: CACHE_TTL.SPACE_HISTORY });

    return successResponse(data);
  } catch (error) {
    return handleActionError(error);
  }
}

/**
 * Get space history entries
 */
export async function getSpaceHistory(spaceId: string, limit = 50): Promise<ActionResponse<SpaceHistoryEntry[]>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
    const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey);
    if (cachedHistory) {
      return successResponse(cachedHistory);
    }

    const { data, error } = await supabase
      .from('space_history')
      .select("*")
      .eq("space_id", spaceId)
      .order("created_at", { ascending: false })
      .limit(limit);

    if (error) {
      console.error("Error fetching space history:", error);
      return errorResponse(`Error fetching space history: ${error.message}`);
    }

    // Cache the result
    if (data) {
      await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE_HISTORY });
    }

    return successResponse(data || []);
  } catch (error) {
    return handleActionError(error);
  }
}

================
File: app/actions/index.ts
================
"use server";

// Re-export all actions

// Space Actions
export * from './spaces';

// Conversation Actions
export * from './conversations';

// Notification Actions
export * from './notifications';

// History Actions
export * from './history';

// Auth Actions
export * from './auth';

// Export response utilities
export * from './utils/responses';

================
File: app/actions/notifications.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { COLUMNS, DB_TABLES } from "@/constants";
import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";
import { ActionResponse, successResponse, errorResponse, handleActionError } from "./utils/responses";

export type NotificationType = 
  | 'space_created'
  | 'space_deleted'
  | 'model_changed'
  | 'conversation_created'
  | 'conversation_deleted';

export interface Notification {
  id: string;
  user_id: string;
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  is_read: boolean;
  created_at: string;
  updated_at: string;
}

export interface CreateNotificationOptions {
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  isInApp?: boolean; // If true, notification will be marked as read automatically
}

/**
 * Create a new notification
 */
export async function createNotification({
  type,
  title,
  description,
  metadata,
  isInApp = true // Default to true for backward compatibility
}: CreateNotificationOptions): Promise<ActionResponse<Notification>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    const { data, error } = await supabase
      .from(DB_TABLES.NOTIFICATIONS)
      .insert([{
        user_id: user.id,
        type,
        title,
        description,
        metadata,
        is_read: isInApp, // Automatically mark as read if it's an in-app notification
      }])
      .select()
      .single();

    if (error) {
      console.error("Error creating notification:", error);
      return errorResponse(`Error creating notification: ${error.message}`);
    }

    // Update notifications cache
    const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
    const cachedNotifications = await redis.get<Notification[]>(cacheKey) || [];
    await redis.set(cacheKey, [data, ...cachedNotifications], { ex: CACHE_TTL.NOTIFICATIONS });

    return successResponse(data);
  } catch (error) {
    return handleActionError(error);
  }
}

/**
 * Get all notifications for the current user
 */
export async function getNotifications(limit = 50): Promise<ActionResponse<Notification[]>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
    const cachedNotifications = await redis.get<Notification[]>(cacheKey);
    if (cachedNotifications) {
      return successResponse(cachedNotifications);
    }

    const { data, error } = await supabase
      .from(DB_TABLES.NOTIFICATIONS)
      .select("*")
      .eq("user_id", user.id)
      .order("created_at", { ascending: false })
      .limit(limit);

    if (error) {
      console.error("Error fetching notifications:", error);
      return errorResponse(`Error fetching notifications: ${error.message}`);
    }

    // Cache the result
    if (data) {
      await redis.set(cacheKey, data, { ex: CACHE_TTL.NOTIFICATIONS });
    }

    return successResponse(data || []);
  } catch (error) {
    return handleActionError(error);
  }
}

/**
 * Mark a notification as read
 */
export async function markNotificationAsRead(notificationId: string): Promise<ActionResponse<boolean>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    const { error } = await supabase
      .from(DB_TABLES.NOTIFICATIONS)
      .update({ is_read: true })
      .eq("id", notificationId)
      .eq("user_id", user.id);

    if (error) {
      console.error("Error marking notification as read:", error);
      return errorResponse(`Error marking notification as read: ${error.message}`);
    }

    // Update cache
    const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
    const cachedNotifications = await redis.get<Notification[]>(cacheKey);
    if (cachedNotifications) {
      const updatedNotifications = cachedNotifications.map(n =>
        n.id === notificationId ? { ...n, is_read: true } : n
      );
      await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
    }

    return successResponse(true);
  } catch (error) {
    return handleActionError(error);
  }
}

/**
 * Mark all notifications as read
 */
export async function markAllNotificationsAsRead(): Promise<ActionResponse<boolean>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    const { error } = await supabase
      .from(DB_TABLES.NOTIFICATIONS)
      .update({ is_read: true })
      .eq("user_id", user.id)
      .eq("is_read", false);

    if (error) {
      console.error("Error marking all notifications as read:", error);
      return errorResponse(`Error marking all notifications as read: ${error.message}`);
    }

    // Update cache
    const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
    const cachedNotifications = await redis.get<Notification[]>(cacheKey);
    if (cachedNotifications) {
      const updatedNotifications = cachedNotifications.map(n => ({ ...n, is_read: true }));
      await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
    }

    return successResponse(true);
  } catch (error) {
    return handleActionError(error);
  }
}

================
File: app/actions/spaces.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { COLUMNS, DB_TABLES, DEFAULTS } from "@/constants";
import { Space, Conversation } from "@/types";
import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";
import { invalidateSpaceCache } from "./utils/caching";
import { ActionResponse, successResponse, errorResponse, handleActionError, notFoundResponse } from "./utils/responses";

export interface SpaceData {
    space: Space | null;
    conversations: Conversation[] | null;
    messages: any[] | null;
    activeConversation: Conversation | null;
}

/**
 * Get all spaces for the current user
 */
export async function getSpaces(): Promise<ActionResponse<Space[]>> {
    try {
        const supabase = await createClient();
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        // Try to get from cache first
        const cacheKey = CACHE_KEYS.SPACES(user.id);
        const cachedSpaces = await redis.get<Space[]>(cacheKey);
        if (cachedSpaces) {
            return successResponse(cachedSpaces);
        }

        // If not in cache, get from DB
        const { data, error } = await supabase
            .from(DB_TABLES.SPACES)
            .select("*")
            .eq(COLUMNS.USER_ID, user.id)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.UPDATED_AT, { ascending: false });

        if (error) {
            console.error("Error fetching spaces:", error);
            return errorResponse(`Error fetching spaces: ${error.message}`);
        }

        // Cache the result
        if (data) {
            await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACES });
        }

        return successResponse(data || []);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get a specific space by ID
 */
export async function getSpace(id: string): Promise<ActionResponse<Space>> {
    try {
        const supabase = await createClient();
        const {
          data: { user },
        } = await supabase.auth.getUser();
      
        if (!user) {
            return errorResponse('User not authenticated');
        }

        // Try to get from cache first
        const cacheKey = CACHE_KEYS.SPACE(id);
        const cachedSpace = await redis.get<Space>(cacheKey);
        if (cachedSpace) {
            return successResponse(cachedSpace);
        }

        const { data, error } = await supabase
            .from(DB_TABLES.SPACES)
            .select("*")
            .eq(COLUMNS.ID, id)
            .eq(COLUMNS.USER_ID, user.id)
            .single();

        if (error) {
            console.error("Error fetching space:", error);
            return notFoundResponse('Space');
        }

        // Cache the result
        if (data) {
            await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE });
        }

        return successResponse(data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Create a new space
 */
export async function createSpace(
    name: string,
    description: string,
    model: string,
    provider: string,
    setActive: boolean,
    color?: string
): Promise<ActionResponse<Space>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return await errorResponse('User not authenticated');
        }

        const { data: space, error } = await supabase
            .from(DB_TABLES.SPACES)
            .insert([{
                [COLUMNS.NAME]: name || DEFAULTS.SPACE_NAME,
                [COLUMNS.DESCRIPTION]: description || '',
                [COLUMNS.USER_ID]: user.id,
                [COLUMNS.MODEL]: model,
                [COLUMNS.PROVIDER]: provider,
                [COLUMNS.COLOR]: color || '#3ecfff',
            }])
            .select()
            .single();

        if (error) {
            console.error("Error creating space:", error);
            return await errorResponse(`Error creating space: ${error.message}`);
        }

        if (space) {
            // Invalidate spaces cache
            await redis.del(CACHE_KEYS.SPACES(user.id));
            
            if (setActive) {
                await setActiveSpace(space.id);
            }

            // Create a default conversation for the new space
            const timestamp = new Date().toISOString();
            const { data: conversation, error: convError } = await supabase
                .from(DB_TABLES.CONVERSATIONS)
                .insert([{
                    space_id: space.id,
                    title: "Welcome",
                    created_at: timestamp,
                    updated_at: timestamp,
                    is_deleted: false
                }])
                .select()
                .single();

            if (convError) {
                console.error("Error creating default conversation:", convError);
                // Don't return error here as the space was created successfully
            }

            // Invalidate relevant caches
            await invalidateSpaceCache(space.id);
            
            // Return success with redirect to the new conversation if one was created
            let redirectTo = `/protected/spaces/${space.id}/conversations`;
            if (conversation) {
                redirectTo = `${redirectTo}/${conversation.id}`;
            }
            
            return await successResponse(space, {
                title: 'Space Created',
                description: 'Your new workspace is ready',
                variant: 'success'
            }, redirectTo);
        }

        return await successResponse(space);
    } catch (error) {
        return await handleActionError(error);
    }
}

/**
 * Update an existing space
 */
export async function updateSpace(id: string, updates: Partial<Space>): Promise<ActionResponse<Space>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        const { data, error } = await supabase
            .from(DB_TABLES.SPACES)
            .update(updates)
            .eq(COLUMNS.ID, id)
            .eq(COLUMNS.USER_ID, user.id)
            .select()
            .single();

        if (error) {
            console.error('Error updating space:', error);
            return errorResponse(`Error updating space: ${error.message}`);
        }

        if (data) {
            // Invalidate related caches
            await invalidateSpaceCache(id, user.id);
        }

        return successResponse(data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Set a space as the active space for the current user
 */
export async function setActiveSpace(spaceId: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        const { error: deleteError } = await supabase
            .from(DB_TABLES.ACTIVE_SPACES)
            .delete()
            .eq(COLUMNS.USER_ID, user.id);

        if (deleteError) {
            console.error("Error removing existing active space:", deleteError);
            return errorResponse(`Error removing existing active space: ${deleteError.message}`);
        }

        const { error: insertError } = await supabase
            .from(DB_TABLES.ACTIVE_SPACES)
            .insert({
                [COLUMNS.USER_ID]: user.id,
                [COLUMNS.SPACE_ID]: spaceId
            });

        if (insertError) {
            console.error("Error setting active space:", insertError);
            return errorResponse(`Error setting active space: ${insertError.message}`);
        }

        // Update cache
        const spaceResponse = await getSpace(spaceId);
        if (spaceResponse.data) {
            await redis.set(CACHE_KEYS.ACTIVE_SPACE(user.id), spaceResponse.data, { ex: CACHE_TTL.ACTIVE_SPACE });
        }

        return successResponse(undefined);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get the active space for the current user
 */
export async function getActiveSpace(): Promise<ActionResponse<Space>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        // Try to get from cache first
        const cacheKey = CACHE_KEYS.ACTIVE_SPACE(user.id);
        const cachedSpace = await redis.get<Space>(cacheKey);
        if (cachedSpace) {
            return successResponse(cachedSpace);
        }

        const { data: activeSpaceData, error: activeSpaceError } = await supabase
            .from(DB_TABLES.ACTIVE_SPACES)
            .select(COLUMNS.SPACE_ID)
            .eq(COLUMNS.USER_ID, user.id)
            .single();

        if (activeSpaceError || !activeSpaceData) {
            return notFoundResponse('Active space');
        }

        const { data: space, error: spaceError } = await supabase
            .from(DB_TABLES.SPACES)
            .select("*")
            .eq(COLUMNS.ID, activeSpaceData.space_id)
            .eq(COLUMNS.USER_ID, user.id)
            .single();

        if (spaceError) {
            console.error("Error fetching active space:", spaceError);
            return notFoundResponse('Active space');
        }

        // Cache the result
        if (space) {
            await redis.set(cacheKey, space, { ex: CACHE_TTL.ACTIVE_SPACE });
        }

        return successResponse(space);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get comprehensive data for a space including conversations and messages
 */
export async function getSpaceData(spaceId: string): Promise<ActionResponse<SpaceData>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (!spaceId) {
            return successResponse({ space: null, conversations: [], messages: null, activeConversation: null });
        }

        const cacheKey = CACHE_KEYS.SPACE_DATA(spaceId);
        const cachedData = await redis.get<SpaceData>(cacheKey);
        if (cachedData) {
            return successResponse(cachedData);
        }

        const [space, conversations] = await Promise.all([
            supabase
                .from(DB_TABLES.SPACES)
                .select("*")
                .eq(COLUMNS.ID, spaceId)
                .eq(COLUMNS.USER_ID, user.id)
                .single()
                .then(({ data, error }) => {
                    if (error) {
                        console.error("Error fetching space:", error);
                        return null;
                    }
                    return data;
                }),
            supabase
                .from(DB_TABLES.CONVERSATIONS)
                .select("*")
                .eq(COLUMNS.SPACE_ID, spaceId)
                .eq(COLUMNS.IS_DELETED, false)
                .order(COLUMNS.UPDATED_AT, { ascending: false })
                .then(({ data, error }) => {
                    if (error) {
                        console.error("Error fetching conversations:", error);
                        return [];
                    }
                    return data || [];
                })
        ]);

        // Get the most recently updated conversation as the active one
        const activeConversation = conversations && conversations.length > 0 ? conversations[0] : null;

        let messages = null;
        if (activeConversation) {
            const { data: messageData, error: messagesError } = await supabase
                .from(DB_TABLES.MESSAGES)
                .select("*")
                .eq('conversation_id', activeConversation.id)
                .eq(COLUMNS.IS_DELETED, false)
                .order(COLUMNS.CREATED_AT, { ascending: true });

            if (messagesError) {
                console.error("Error fetching messages:", messagesError);
            } else {
                messages = messageData;
            }
        }

        const spaceData = { space, conversations, messages, activeConversation };
        await redis.set(cacheKey, spaceData, { ex: CACHE_TTL.SPACE_DATA });

        return successResponse(spaceData);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Delete a space
 */
export async function deleteSpace(spaceId: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return await errorResponse('User not authenticated');
        }

        // Mark space as deleted
        const { error } = await supabase
            .from(DB_TABLES.SPACES)
            .update({ is_deleted: true })
            .eq(COLUMNS.ID, spaceId)
            .eq(COLUMNS.USER_ID, user.id);

        if (error) {
            console.error("Error deleting space:", error);
            return await errorResponse(`Error deleting space: ${error.message}`);
        }

        // Mark all conversations in the space as deleted
        const { error: conversationError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .update({ is_deleted: true })
            .eq(COLUMNS.SPACE_ID, spaceId);

        if (conversationError) {
            console.error("Error marking conversations as deleted:", conversationError);
            // Don't return error since the space was deleted successfully
        }

        // Invalidate caches
        await invalidateSpaceCache(spaceId, user.id);

        return await successResponse(undefined);
    } catch (error) {
        return await handleActionError(error);
    }
}

================
File: app/api/auth/callback/route.ts
================
import { createClient } from "@/utils/supabase/server";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  // The `/auth/callback` route is required for the server-side auth flow implemented
  // by the SSR package. It exchanges an auth code for the user's session.
  // https://supabase.com/docs/guides/auth/server-side/nextjs
  const requestUrl = new URL(request.url);
  const code = requestUrl.searchParams.get("code");
  const origin = requestUrl.origin;
  const redirectTo = requestUrl.searchParams.get("redirect_to")?.toString();

  if (code) {
    const supabase = await createClient();
    await supabase.auth.exchangeCodeForSession(code);
  }

  if (redirectTo) {
    return NextResponse.redirect(`${origin}${redirectTo}`);
  }

  // URL to redirect to after sign up process completes
  return NextResponse.redirect(`${origin}/protected`);
}

================
File: app/api/chat/route.ts
================
import { createDataStreamResponse, generateId, generateText, smoothStream, streamText, wrapLanguageModel } from 'ai';
import { groq } from '@ai-sdk/groq';
import { anthropic } from '@ai-sdk/anthropic';
import { openai } from '@ai-sdk/openai';
import { cohere } from '@ai-sdk/cohere';
import { mistral } from '@ai-sdk/mistral';
import { google } from '@ai-sdk/google';
import { xai } from '@ai-sdk/xai';
import { togetherai } from '@ai-sdk/togetherai';
import { perplexity } from '@ai-sdk/perplexity';
import { createClient } from '@/utils/supabase/server';
import { COLUMNS, DB_TABLES, ERROR_MESSAGES } from '@/constants';
import { type Provider } from '@/config/models';
import { NextResponse } from 'next/server';
import { createMessage, getMessages, updateConversationTitle } from '@/app/actions';
import { searchSimilarMessages, upsertChatMessage } from '@/utils/pinecone';
import { extractReasoningMiddleware } from 'ai';

const middleware = extractReasoningMiddleware({
  tagName: 'think',
  separator: '\n',
});

const providers: Record<Provider, (model: string) => any> = {
  groq: (model) => groq(model),
  anthropic: (model) => anthropic(model),
  openai: (model) => openai(model),
  cohere: (model) => cohere(model),
  mistral: (model) => mistral(model),
  google: (model) => google(model),
  xai: (model) => xai(model),
  togetherai: (model) => togetherai(model),
  perplexity: (model) => perplexity(model),
};

function getCurrentFormattedDate(): string {
  const now = new Date()
  const month = now.toLocaleString('default', { month: 'long' })
  const day = now.getDate()
  const year = now.getFullYear()
  const daySuffix = getDaySuffix(day)
  return `${month} ${day}${daySuffix}, ${year}`
}

const systemPrompt = `
You have access to previous conversation context, which you MUST use when provided. Context will be wrapped in <context> </context> tags. Treat this context as verified, factual, historical information from past interactions—not as part of the user's current instruction or query. Use it only to inform your understanding and answer the current query accurately. Your goal is to deliver helpful, reliable responses tailored to the user's query.

### Response Guidelines
- **Always format responses in Markdown** for readability and structure. Use:
  - Headers (#, ##, ###) to organize content
  - **Bold** and *italics* for emphasis
  - Lists (- or *) for clarity
  - \`inline code\` and \`\`\`code blocks\`\`\` for technical content
  - Links ([text](url)) for references
- Keep responses concise, focused, and directly relevant to the query.
- Avoid unnecessary fluff, repetition, or speculation.

### Handling Context
When previous conversation context is provided within <context> </context> tags:
1. **Use it confidently** as historical data to answer the query.
2. Do NOT treat it as the user's current instruction.
3. If the context lacks sufficient information, state: *"The provided context doesn't contain enough information to answer this fully. Based on what I have..."* and proceed with a reasoned response.
4. Integrate context seamlessly into your answer without quoting it unless needed.

### Tone and Style
- Maintain a professional yet approachable tone.
- Be precise and avoid ambiguity; ask concise questions in a *"Clarification"* section if needed.
- Use pure Markdown, no HTML tags.

### Date Formatting Rules
- Use the current date, ${getCurrentFormattedDate()}, as a reference.
- For dates in ${new Date().getFullYear()}, format as "Month Day<suffix>" (e.g., "January 25th").
- For previous years, include the year (e.g., "January 25th, 2024").
- Day suffix: "st" for 1, 21, 31; "nd" for 2, 22; "rd" for 3, 23; "th" for others.
`;

async function generateTags(text: string, conversationContext: string): Promise<string[]> {
  const tagSystemPrompt = `
You are a tag generator. Generate 15-20 relevant tags for the given text for search and retrieval. Tags should be general yet specific enough to distinguish categories. Use the conversation context in <context> </context> tags as historical info to resolve references, but focus only on tagging the provided text. Return a JSON list of strings (e.g., ["tag1", "tag2"]).

Example input: "What is my age?"
Example context: "My age is 24"

Example output: ["age", "24", "personal information", "user details"]
`;

  const fastModel = providers['xai']('grok-2-1212');
  try {
    const { text: tagsJson } = await generateText({
      model: fastModel,
      system: tagSystemPrompt,
      prompt: `<context>\n${conversationContext}\n</context>\n\nText to Tag:\n${text}`,
      temperature: 0.3,
      maxTokens: 200,
    });
    const tags = JSON.parse(tagsJson.replace(/```json|```/g, '').trim());
    return Array.isArray(tags) ? tags : [];
  } catch (error) {
    console.error("Failed to generate tags:", error);
    return extractTagsFromText(text);
  }
}

function extractTagsFromText(text: string): string[] {
  const stopwords = new Set(['i', 'am', 'a', 'the', 'to', 'and', 'is', 'in', 'of']);
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .split(/\s+/)
    .filter((word) => word.length > 2 && !stopwords.has(word))
    .slice(0, 10);
}

async function validateUser(supabase: any) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error(JSON.stringify(ERROR_MESSAGES.UNAUTHORIZED));
  return user;
}

// Define a type for annotations to properly include similarMessages
type MessageAnnotation = {
  [COLUMNS.MODEL_USED]?: string;
  [COLUMNS.PROVIDER]?: Provider;
  [COLUMNS.SPACE_ID]?: string;
  [COLUMNS.CONVERSATION_ID]?: string;
  similarMessages?: Array<{
    id: string;
    content: string;
    role: string;
    createdAt: number;
    score: number;
    metadata?: Record<string, any>;
  }>;
};

async function saveMessage({
  content,
  role,
  model,
  provider,
  spaceId,
  conversationId,
  parentId,
  tags,
  similarMessages,
}: {
  content: string;
  role: 'user' | 'assistant';
  model: string;  
  provider: Provider;
  spaceId: string;
  conversationId: string;
  parentId?: string;
  tags: string[];
  similarMessages?: Array<{
    id: string;
    content: string;
    role: string;
    createdAt: number;
    score: number;
    metadata?: Record<string, any>;
  }>;
}) {
  const annotations: MessageAnnotation[] = [{ [COLUMNS.MODEL_USED]: model, [COLUMNS.PROVIDER]: provider }];
  
  if (similarMessages && similarMessages.length > 0) {
    annotations.push({ similarMessages });
  }

  const dbMessage = await createMessage(
    {
      [COLUMNS.CONTENT]: content,
      [COLUMNS.ROLE]: role,
      [COLUMNS.ANNOTATIONS]: annotations,
    },
    conversationId
  );

  await upsertChatMessage({
    id: dbMessage.id,
    content,
    role,
    createdAt: Date.now(),
    spaceId,
    conversationId,
    ...(parentId && { parentId }),
    metadata: { model, provider, tags }
  });

  return dbMessage;
}

function buildContextString(relevantMessages: any[]): string {
  if (!relevantMessages.length) return '';
  const currentYear = 2025; // As of February 21, 2025
  const contextContent = relevantMessages
    .map((msg) => {
      const date = new Date(msg.createdAt);
      const year = date.getFullYear();
      const month = date.toLocaleString('default', { month: 'long' });
      const day = date.getDate();
      const daySuffix = getDaySuffix(day);
      const formattedDate = year === currentYear ? `${month} ${day}${daySuffix}` : `${month} ${day}${daySuffix}, ${year}`;
      return msg.role === 'assistant' && msg.parentId
        ? `**${formattedDate}**\nQ: ${msg.content}\nA: ${msg.content}`
        : `**${formattedDate}**\n${msg.role.toUpperCase()}: ${msg.content}`;
    })
    .join('\n');
  return `<context>\n${contextContent}\n</context>`;
}

function getDaySuffix(day: number): string {
  if (day >= 11 && day <= 13) return 'th';
  switch (day % 10) {
    case 1: return 'st';
    case 2: return 'nd';
    case 3: return 'rd';
    default: return 'th';
  }
}

export async function POST(req: Request) {
  const supabase = await createClient();

  const [user, { messages, spaceId, conversationId, provider, model }] = await Promise.all([
    validateUser(supabase),
    req.json(),
  ]);

  if (!spaceId) throw new Error(JSON.stringify(ERROR_MESSAGES.MISSING_SPACE_ID));
  if (!conversationId) throw new Error(JSON.stringify(ERROR_MESSAGES.MISSING_CONVERSATION_ID));

  return createDataStreamResponse({
    execute: async (dataStream) => {
      try {
        const userMessage = messages[messages.length - 1];
        const conversationContext = messages.slice(0, -1)
          .map((msg: { role: string; content: string }) => `${msg.role.toUpperCase()}: ${msg.content}`)
          .join('\n');

        const numberOfMessages = 15;

        dataStream.writeData('Searching for similar messages');
        const userTags = await generateTags(userMessage.content, conversationContext);
        const similarMessages = await searchSimilarMessages(userMessage.content, numberOfMessages, userTags);
        console.log('Similar messages found:', similarMessages.length);

        dataStream.writeData('Building context');
        const contextString = buildContextString(similarMessages.map((result) => result.message));

        const systemPromptWithContext = contextString
          ? `${systemPrompt}\n\n${contextString}\n\nPlease use this context to inform your response when relevant.`
          : systemPrompt;

        const createModel = providers[provider as Provider];
        if (!createModel) throw new Error(JSON.stringify(ERROR_MESSAGES.INVALID_PROVIDER));
        const modelInstance = createModel(model);
        const wrappedLanguageModel = wrapLanguageModel({ model: modelInstance, middleware });

        dataStream.writeData('Generating response');
        
        const result = streamText({
          model: wrappedLanguageModel,
          messages,
          system: systemPromptWithContext,
          experimental_transform: smoothStream(),
          onChunk: (() => {
            let isFirstChunk = true;
            return () => {
              if (isFirstChunk) {
                dataStream.writeMessageAnnotation({
                  id: generateId(),
                  [COLUMNS.MODEL_USED]: model,
                  [COLUMNS.PROVIDER]: provider,
                  [COLUMNS.SPACE_ID]: spaceId,
                  [COLUMNS.CONVERSATION_ID]: conversationId,
                  similarMessages: similarMessages.map(result => ({
                    id: result.message.id,
                    content: result.message.content,
                    role: result.message.role,
                    createdAt: result.message.createdAt,
                    score: result.score ?? 0,
                    conversationId: result.message.conversationId,
                    metadata: result.message.metadata || {}
                  }))
                });
                isFirstChunk = false;
              }
            };
          })(),
        });

        result.mergeIntoDataStream(dataStream);
        
        result.text.then(async (text) => {
          const userTags = await generateTags(userMessage.content, conversationContext);
          const assistantTags = await generateTags(text, conversationContext);
          
          const dbUserMessage = await saveMessage({
            content: userMessage.content,
            role: 'user',
            model,
            provider,
            spaceId,
            conversationId,
            tags: userTags,
            similarMessages: similarMessages.map(result => ({
              id: result.message.id,
              content: result.message.content,
              role: result.message.role,
              createdAt: result.message.createdAt,
              score: result.score ?? 0,
              conversationId: result.message.conversationId,
              metadata: result.message.metadata || {}
            }))
          });

          await saveMessage({
            content: text,
            role: 'assistant',
            model,
            provider,
            spaceId,
            conversationId,
            parentId: dbUserMessage.id,
            tags: assistantTags,
            similarMessages: similarMessages.map(result => ({
              id: result.message.id,
              content: result.message.content,
              role: result.message.role,
              createdAt: result.message.createdAt,
              score: result.score ?? 0,
              conversationId: result.message.conversationId,
              metadata: result.message.metadata || {}
            })),
          });

          const allMessages = await getMessages(conversationId);
          if (allMessages && allMessages.length >= 3) {
            const titleSystemPrompt = `
              You are a title generator. Generate a concise title (2-4 words) capturing the conversation's main topic. Return only the title.
              Example: Python Learning Path
            `;
            const fastModel = providers['groq']('llama-3.1-8b-instant');
            const messageTexts = allMessages.map((m) => m.content).join('\n');
            const { text: newTitle } = await generateText({
              model: fastModel,
              system: titleSystemPrompt,
              prompt: messageTexts,
              temperature: 0.3,
              maxTokens: 20,
            });
            await updateConversationTitle(conversationId, newTitle);
          }
          
        }).catch((error) => {
        });
      } catch (error) {
        let errorMessage;
        if (error instanceof Error) {
          try {
            errorMessage = JSON.parse(error.message);
          } catch {
            errorMessage = ERROR_MESSAGES.SERVER_ERROR(error.message);
          }
        } else {
          errorMessage = ERROR_MESSAGES.SERVER_ERROR("Error processing request");
        }
      }
    },
    onError: (error) => {
      let errorMessage;
      if (error instanceof Error) {
        try {
          errorMessage = JSON.parse(error.message);
        } catch {
          errorMessage = ERROR_MESSAGES.SERVER_ERROR(error.message);
        }
      } else {
        errorMessage = ERROR_MESSAGES.SERVER_ERROR("Error processing request");
      }
      return errorMessage.message || String(errorMessage);
    },
  });
}

================
File: app/lib/cache-utils.ts
================
import { redis, CACHE_KEYS } from "@/app/lib/cache";

/**
 * Invalidate all space-related caches 
 * This ensures that all components that depend on space data will get fresh data
 */
export async function invalidateSpaceCache(spaceId: string): Promise<void> {
  const cacheKeys = [
    CACHE_KEYS.SPACE_DATA(spaceId),
    CACHE_KEYS.CONVERSATIONS(spaceId),
    CACHE_KEYS.SPACE_HISTORY(spaceId)
  ];
  
  await Promise.all(cacheKeys.map(key => redis.del(key)));
}

/**
 * Invalidate conversation-related caches
 */
export async function invalidateConversationCache(
  conversationId: string, 
  spaceId: string
): Promise<void> {
  const cacheKeys = [
    CACHE_KEYS.MESSAGES(conversationId),
    CACHE_KEYS.SPACE_DATA(spaceId),
    CACHE_KEYS.CONVERSATIONS(spaceId)
  ];
  
  await Promise.all(cacheKeys.map(key => redis.del(key)));
}

/**
 * Invalidate user-related caches
 */
export async function invalidateUserCache(userId: string): Promise<void> {
  const cacheKeys = [
    CACHE_KEYS.SPACES(userId),
    CACHE_KEYS.NOTIFICATIONS(userId)
  ];
  
  await Promise.all(cacheKeys.map(key => redis.del(key)));
}

/**
 * Invalidate multiple related caches at once for a specific operation
 */
export async function invalidateOperationCaches(options: {
  userId?: string;
  spaceId?: string;
  conversationId?: string;
}): Promise<void> {
  const { userId, spaceId, conversationId } = options;
  const invalidationPromises: Promise<void>[] = [];
  
  if (userId) {
    invalidationPromises.push(invalidateUserCache(userId));
  }
  
  if (spaceId) {
    invalidationPromises.push(invalidateSpaceCache(spaceId));
  }
  
  if (conversationId && spaceId) {
    invalidationPromises.push(invalidateConversationCache(conversationId, spaceId));
  }
  
  await Promise.all(invalidationPromises);
}

================
File: app/lib/cache.ts
================
import { Redis } from "@upstash/redis";

// Initialize Redis client
export const redis = Redis.fromEnv();

// Cache keys for different resources
export const CACHE_KEYS = {
  SPACE_HISTORY: (spaceId: string) => `space_history:${spaceId}`,
  NOTIFICATIONS: (userId: string) => `notifications:${userId}`,
  SPACES: (userId: string) => `spaces:${userId}`,
  SPACE: (spaceId: string) => `space:${spaceId}`,
  ACTIVE_SPACE: (userId: string) => `active_space:${userId}`,
  CONVERSATIONS: (spaceId: string) => `conversations:${spaceId}`,
  MESSAGES: (conversationId: string) => `messages:${conversationId}`,
  SPACE_DATA: (spaceId: string) => `space_data:${spaceId}`,
  MOST_RECENT_CONVERSATION: (spaceId: string) => `most_recent_conversation:${spaceId}`,
};

// Cache TTL for different resources (in seconds)
export const CACHE_TTL = {
  SPACE_HISTORY: 60 * 5, // 5 minutes
  NOTIFICATIONS: 60 * 5, // 5 minutes
  SPACES: 60 * 5, // 5 minutes
  SPACE: 60 * 5, // 5 minutes
  ACTIVE_SPACE: 60 * 60, // 1 hour
  CONVERSATIONS: 60 * 5, // 5 minutes
  MESSAGES: 60 * 5, // 5 minutes
  SPACE_DATA: 60 * 5, // 5 minutes
};

================
File: app/protected/profile/page.tsx
================
import { redirect } from 'next/navigation'
import { Button } from '@/components/ui/common/button'
import { Input } from '@/components/ui/common/input'
import { Label } from '@/components/ui/common/label'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/common/avatar'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/common/card'
import { ChevronLeft } from 'lucide-react'
import Link from 'next/link'
import { User } from '@supabase/supabase-js'
import { createClient } from '@/utils/supabase/server'

interface Profile {
  full_name: string
  avatar_url: string
  website: string
  bio: string
}

interface PageProps {
  user: User | null
  initialProfile: Profile
  error?: string
}

async function getProfile() {
  const supabase = await createClient()

  try {
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return {
        user: null,
        initialProfile: {
          full_name: '',
          avatar_url: '',
          website: '',
          bio: ''
        },
        error: 'Not authenticated'
      }
    }

    const profile = {
      full_name: user.user_metadata?.full_name || '',
      avatar_url: user.user_metadata?.avatar_url || '',
      website: user.user_metadata?.website || '',
      bio: user.user_metadata?.bio || ''
    }

    return {
      user,
      initialProfile: profile,
    } as PageProps      
  } catch (error) {
    console.error('Error fetching profile:', error)
    return {
      user: null,
      initialProfile: {
        full_name: '',
        avatar_url: '',
        website: '',
        bio: ''
      },
      error: 'Error loading user data'
    }
  }
}

export default async function ProfilePage() {
  const { user, initialProfile, error } = await getProfile()
  
  if (error === 'Not authenticated') {
    redirect('/auth/login')
  }
  
  return (
    <div className="min-h-screen bg-black">
      <div className="fixed top-4 left-4 z-50 flex items-center space-x-4 text-sm">
        <Link 
          href="/protected" 
          className="flex items-center space-x-2 text-white/40 hover:text-white/60 transition-colors duration-200"
        >
          <ChevronLeft className="h-4 w-4" />
          <span>Back to Chat</span>
        </Link>
        <div className="flex items-center space-x-2 text-white/40">
          <span>/</span>
          <span className="text-white/90">Profile</span>
        </div>
      </div>
      
      <div className="container max-w-2xl py-8 space-y-6 relative z-10">
        <Card className="border border-white/[0.05] bg-white/[0.03] backdrop-blur-xl shadow-[0_4px_20px_rgba(0,0,0,0.2)]">
          <CardHeader>
            <div className="flex items-center space-x-4">
              <Avatar className="h-20 w-20">
                <AvatarImage src={initialProfile.avatar_url} />
                <AvatarFallback className="text-white/60">
                  {initialProfile.full_name?.substring(0, 2).toUpperCase() || user?.email?.substring(0, 2).toUpperCase()}
                </AvatarFallback>
              </Avatar>
              <div>
                <CardTitle className="text-2xl font-medium text-white/90">
                  {initialProfile.full_name || 'Your Profile'}
                </CardTitle>
                <CardDescription className="text-white/50">
                  {user?.email}
                </CardDescription>
              </div>
            </div>
          </CardHeader>
          <CardContent className="space-y-6">
            <form action="/api/update-profile" method="POST" className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="full_name">
                  Full Name
                </Label>
                <Input
                  id="full_name"
                  name="full_name"
                  type="text"
                  defaultValue={initialProfile.full_name}
                  className="bg-white/[0.03] border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="avatar_url">
                  Avatar URL
                </Label>
                <Input
                  id="avatar_url"
                  name="avatar_url"
                  type="url"
                  defaultValue={initialProfile.avatar_url}
                  className="bg-white/[0.03] border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="website">
                  Website
                </Label>
                <Input
                  id="website"
                  name="website"
                  type="url"
                  defaultValue={initialProfile.website}
                  className="bg-white/[0.03] border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="bio">
                  Bio
                </Label>
                <Input
                  id="bio"
                  name="bio"
                  type="text"
                  defaultValue={initialProfile.bio}
                  className="bg-white/[0.03] border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="flex justify-end">
                <Button
                  type="submit"
                  variant="cyan"
                >
                  Save Changes
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card className="border border-white/[0.05] bg-white/[0.03] backdrop-blur-xl shadow-[0_4px_20px_rgba(0,0,0,0.2)]">
          <CardHeader>
            <CardTitle className="text-lg font-medium text-white/90">
              Account Settings
            </CardTitle>
            <CardDescription className="text-white/50">
              Manage your account settings and preferences
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-medium text-white/90">Email Notifications</h3>
                <p className="text-sm text-white/50">Receive email notifications about your account</p>
              </div>
              <Button variant="cyan">
                Configure
              </Button>
            </div>
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-medium text-white/90">Password</h3>
                <p className="text-sm text-white/50">Change your password</p>
              </div>
              <Button variant="cyan">
                Change
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}

================
File: app/protected/reset-password/page.tsx
================
import { resetPasswordAction } from "@/app/actions/auth";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";

export default async function ResetPassword(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  return (
    <form className="flex flex-col w-full max-w-md p-4 gap-2 [&>input]:mb-4">
      <h1 className="text-2xl font-medium">Reset password</h1>
      <p className="text-sm text-foreground/60">
        Please enter your new password below.
      </p>
      <Label htmlFor="password">New password</Label>
      <Input
        type="password"
        name="password"
        placeholder="New password"
        required
      />
      <Label htmlFor="confirmPassword">Confirm password</Label>
      <Input
        type="password"
        name="confirmPassword"
        placeholder="Confirm password"
        required
      />
      <SubmitButton formAction={resetPasswordAction}>
        Reset password
      </SubmitButton>
      <FormMessage message={searchParams} />
    </form>
  );
}

================
File: app/protected/settings/page.tsx
================
// app/protected/settings/page.tsx

const SettingsPage = () => {
  return (
    <div>
      <h1>Settings Page</h1>
      {/* Add settings content here */}
    </div>
  );
};

export default SettingsPage;

================
File: app/protected/spaces/[spaceId]/conversations/[conversationId]/page.tsx
================
import { redirect } from "next/navigation";
import ClientChatContent from "@/components/ui/chat/chat-content-client";
import { createClient } from "@/utils/supabase/server";
import { getSpaceData, setActiveSpace, getSpaces } from "@/app/actions/spaces";
import { getMessages } from "@/app/actions/conversations";
import { getNotifications } from "@/app/actions/notifications";
import { Toaster } from "@/components/ui/common/toaster";
import { CommandProvider } from "@/hooks/useCommandCenter";
import { AllCommandProviders } from "@/components/CommandProviders";
import CommandRoot from "@/components/CommandRoot";

export default async function ConversationPage({
  params
}: {
  params: { spaceId: string; conversationId: string }
}) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/sign-in");
  }

  const { spaceId, conversationId } = params;
  
  const [spaceDataResponse, messagesResponse, spacesResponse, notificationsResponse] = 
    await Promise.all([
      getSpaceData(spaceId),          // Get space data with conversations
      getMessages(conversationId),    // Get messages for this conversation
      getSpaces(),                    // Get all spaces
      getNotifications()              // Get notifications
    ]);
  
  if (!spaceDataResponse.data || !spaceDataResponse.data.space) {
    redirect("/protected/spaces");
  }
  
  const { space, conversations: spaceConversations } = spaceDataResponse.data;
  const conversations = spaceConversations || [];
  
  const activeConversation = conversations.find(
    conversation => conversation.id === conversationId
  );
  
  if (!activeConversation) {
    redirect(`/protected/spaces/${spaceId}/conversations`);
  }
  
  const allMessages: Record<string, any[]> = {};  
  allMessages[conversationId] = messagesResponse.data || [];
  
  const initialData = {
    spaces: spacesResponse.data || [],
    activeSpace: space,
    conversations,
    activeConversation,
    messages: messagesResponse.data || [],
    allMessages,
    notifications: notificationsResponse.data || [],
  };

  return (
    <CommandProvider>
        <AllCommandProviders
          spaces={initialData.spaces}
          activeSpace={initialData.activeSpace}
          conversations={initialData.conversations}
          activeConversation={initialData.activeConversation}
          user={user}
          messages={initialData.messages}
          >
            <div className="flex flex-col h-screen bg-black text-white">
            <ClientChatContent
                user={user}
                initialData={initialData}
            />
            </div>
            <CommandRoot />
            <Toaster />
        </AllCommandProviders>
    </CommandProvider>                      
  );
}

================
File: app/protected/spaces/[spaceId]/conversations/page.tsx
================
import { getMostRecentConversation } from "@/app/actions/conversations"
import { createClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation"


export default async function SpaceConversationsPage({
  params
}: {
  params: { spaceId: string }
}) {
  const { spaceId } = params

  const supabase = await createClient();
  
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/sign-in");
  }

  const { data: conversation } = await getMostRecentConversation(spaceId)

  if (!conversation) {
    redirect(`/protected/spaces/${spaceId}/conversations`)
  }

  redirect(`/protected/spaces/${spaceId}/conversations/${conversation.id}`)
}

================
File: app/protected/spaces/page.tsx
================
import { redirect } from "next/navigation";
import { createClient } from "@/utils/supabase/server";
import { createSpace, getSpaces, getActiveSpace } from "@/app/actions/spaces";
import { createConversation } from "@/app/actions/conversations";
import { DEFAULTS } from "@/constants";
import { AVAILABLE_MODELS, type Provider } from "@/config/models";

const DEFAULT_PROVIDER: Provider = 'anthropic'
const DEFAULT_MODEL = AVAILABLE_MODELS[DEFAULT_PROVIDER][0].id

export default async function SpacesIndexPage() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/sign-in");
  }

  // Fetch all spaces
  const spacesResponse = await getSpaces();
  
  // Create default space if needed
  if (!spacesResponse.data || spacesResponse.data.length === 0) {
    const spaceResponse = await createSpace(
      DEFAULTS.SPACE_NAME,
      '',
      DEFAULT_MODEL,
      DEFAULT_PROVIDER,
      true
    );

    if (!spaceResponse.data) {
      throw new Error("Failed to create default space");
    }

    const conversationResponse = await createConversation(spaceResponse.data.id, "Welcome");
    if (!conversationResponse.data) {
      throw new Error("Failed to create initial conversation");
    }
    
    // Redirect to the new space and conversation
    redirect(`/protected/spaces/${spaceResponse.data.id}/conversations/${conversationResponse.data.id}`);
  }

  // Get active space, or default to first space
  const activeSpaceResponse = await getActiveSpace();
  const targetSpace = activeSpaceResponse.data || spacesResponse.data[0];
  
  // Redirect to the space's conversations
  redirect(`/protected/spaces/${targetSpace.id}/conversations`);
}

================
File: app/protected/layout.tsx
================
export default async function ProtectedLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="h-full w-full">
        {children}
    </div>
  );
}

================
File: app/protected/page.tsx
================
import { redirect } from "next/navigation";
import { createClient } from "@/utils/supabase/server";
import { getSpaces } from "@/app/actions/spaces";

export default async function ProtectedPage() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/sign-in");
  }

  const spacesResponse = await getSpaces();
  
  if (spacesResponse.status === 'success' && spacesResponse.data && spacesResponse.data.length > 0) {
    redirect("/protected/spaces");
  }
}

================
File: app/actions.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import {
  COLUMNS,
  DB_TABLES,
  DEFAULTS,
} from "@/constants";
import { Conversation, Space } from "@/types";
import { Message } from "ai";
import { headers } from 'next/headers';
import { redirect } from 'next/navigation';
import { encodedRedirect } from "@/lib/utils";
import { Redis } from "@upstash/redis";

const redis = Redis.fromEnv();

const CACHE_KEYS = {
  SPACE_HISTORY: (spaceId: string) => `space_history:${spaceId}`,
  NOTIFICATIONS: (userId: string) => `notifications:${userId}`,
  SPACES: (userId: string) => `spaces:${userId}`,
  SPACE: (spaceId: string) => `space:${spaceId}`,
  ACTIVE_SPACE: (userId: string) => `active_space:${userId}`,
  CONVERSATIONS: (spaceId: string) => `conversations:${spaceId}`,
  MESSAGES: (conversationId: string) => `messages:${conversationId}`,
  SPACE_DATA: (spaceId: string) => `space_data:${spaceId}`,
};

const CACHE_TTL = {
  SPACE_HISTORY: 60 * 5, // 5 minutes
  NOTIFICATIONS: 60 * 5, // 5 minutes
  SPACES: 60 * 5, // 5 minutes
  SPACE: 60 * 5, // 5 minutes
  ACTIVE_SPACE: 60 * 60, // 1 hour
  CONVERSATIONS: 60 * 5, // 5 minutes
  MESSAGES: 60 * 5, // 5 minutes
  SPACE_DATA: 60 * 5, // 5 minutes
};

export async function getSpaces(): Promise<Space[] | null> {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.SPACES(user.id);
    const cachedSpaces = await redis.get<Space[]>(cacheKey);
    if (cachedSpaces) {
        return cachedSpaces;
    }

    // If not in cache, get from DB
    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .select("*")
        .eq(COLUMNS.USER_ID, user.id)
        .eq(COLUMNS.IS_DELETED, false)
        .order(COLUMNS.UPDATED_AT, { ascending: false });

    if (error) {
        console.error("Error fetching spaces:", error);
        return null;
    }

    // Cache the result
    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACES });
    }

    return data;
}

export async function getSpace(id: string): Promise<Space | null> {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.SPACE(id);
    const cachedSpace = await redis.get<Space>(cacheKey);
    if (cachedSpace) {
        return cachedSpace;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .select("*")
        .eq(COLUMNS.ID, id)
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (error) {
        console.error("Error fetching space:", error);
        return null;
    }

    // Cache the result
    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE });
    }

    return data;
}

export async function createSpace(
    name: string,
    description: string,
    model: string,
    provider: string,
    setActive: boolean,
    color?: string
): Promise<Space | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    const { data: space, error } = await supabase
        .from(DB_TABLES.SPACES)
        .insert([
            {
                [COLUMNS.NAME]: name || DEFAULTS.SPACE_NAME,
                [COLUMNS.DESCRIPTION]: description || '',
                [COLUMNS.USER_ID]: user.id,
                [COLUMNS.MODEL]: model,
                [COLUMNS.PROVIDER]: provider,
                [COLUMNS.COLOR]: color || '#3ecfff',
            },
        ])
        .select()
        .single();

    if (error) {
        console.error("Error creating space:", error);
        return null;
    }

    if (space) {
        // Invalidate spaces cache
        await redis.del(CACHE_KEYS.SPACES(user.id));
        
        if (setActive) {
            await setActiveSpace(space.id);
        }

        // Create a default conversation for the new space
        const timestamp = new Date().toISOString();
        const { data: conversation, error: convError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .insert([{
                space_id: space.id,
                title: "Welcome",
                created_at: timestamp,
                updated_at: timestamp,
                is_deleted: false
            }])
            .select()
            .single();

        if (convError) {
            console.error("Error creating default conversation:", convError);
            // Don't return null here as the space was created successfully
        }

        // Invalidate relevant caches
        await Promise.all([
            redis.del(CACHE_KEYS.SPACE_DATA(space.id)),
            redis.del(CACHE_KEYS.CONVERSATIONS(space.id))
        ]);
    }

    return space;
}

export async function updateSpace(id: string, updates: Partial<Space>): Promise<Space | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .update(updates)
        .eq(COLUMNS.ID, id)
        .eq(COLUMNS.USER_ID, user.id)
        .select()
        .single();

    if (error) {
        console.error('Error updating space:', error);
        return null;
    }

    if (data) {
        // Invalidate related caches
        await Promise.all([
            redis.del(CACHE_KEYS.SPACES(user.id)),
            redis.del(CACHE_KEYS.SPACE(id)),
            redis.del(CACHE_KEYS.ACTIVE_SPACE(user.id)),
            redis.del(CACHE_KEYS.SPACE_DATA(id))
        ]);
    }

    return data;
}

export async function setActiveSpace(spaceId: string): Promise<void> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return;
    }

    const { error: deleteError } = await supabase
        .from(DB_TABLES.ACTIVE_SPACES)
        .delete()
        .eq(COLUMNS.USER_ID, user.id);

    if (deleteError) {
        console.error("Error removing existing active space:", deleteError);
    }

    const { error: insertError } = await supabase
        .from(DB_TABLES.ACTIVE_SPACES)
        .insert({
            [COLUMNS.USER_ID]: user.id,
            [COLUMNS.SPACE_ID]: spaceId
        });

    if (insertError) {
        console.error("Error setting active space:", insertError);
    } else {
        // Update cache
        const space = await getSpace(spaceId);
        if (space) {
            await redis.set(CACHE_KEYS.ACTIVE_SPACE(user.id), space, { ex: CACHE_TTL.ACTIVE_SPACE });
        }
    }
}

export async function getActiveSpace(): Promise<Space | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.ACTIVE_SPACE(user.id);
    const cachedSpace = await redis.get<Space>(cacheKey);
    if (cachedSpace) {
        return cachedSpace;
    }

    const { data: activeSpaceData, error: activeSpaceError } = await supabase
        .from(DB_TABLES.ACTIVE_SPACES)
        .select(COLUMNS.SPACE_ID)
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (activeSpaceError || !activeSpaceData) {
        return null;
    }

    const { data: space, error: spaceError } = await supabase
        .from(DB_TABLES.SPACES)
        .select("*")
        .eq(COLUMNS.ID, activeSpaceData.space_id)
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (spaceError) {
        console.error("Error fetching active space:", spaceError);
        return null;
    }

    // Cache the result
    if (space) {
        await redis.set(cacheKey, space, { ex: CACHE_TTL.ACTIVE_SPACE });
    }

    return space;
}

export interface SpaceData {
    space: Space | null;
    conversations: Conversation[] | null;
    messages: Message[] | null;
    activeConversation: Conversation | null;
}

export async function getSpaceData(spaceId: string): Promise<SpaceData | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    if (!spaceId) {
        return { space: null, conversations: [], messages: null, activeConversation: null };
    }

    const cacheKey = CACHE_KEYS.SPACE_DATA(spaceId);
    const cachedData = await redis.get<SpaceData>(cacheKey);
    if (cachedData) {
        return cachedData;
    }

    const [space, conversations] = await Promise.all([
        supabase
            .from(DB_TABLES.SPACES)
            .select("*")
            .eq(COLUMNS.ID, spaceId)
            .eq(COLUMNS.USER_ID, user.id)
            .single()
            .then(({ data, error }) => {
                if (error) {
                    console.error("Error fetching space:", error);
                    return null;
                }
                return data;
            }),
        supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("*")
            .eq(COLUMNS.SPACE_ID, spaceId)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.UPDATED_AT, { ascending: false })
            .then(({ data, error }) => {
                if (error) {
                    console.error("Error fetching conversations:", error);
                    return [];
                }
                return data || [];
            })
    ]);

    // Get the most recently updated conversation as the active one
    const activeConversation = conversations && conversations.length > 0 ? conversations[0] : null;

    let messages = null;
    if (activeConversation) {
        const { data: messageData, error: messagesError } = await supabase
            .from(DB_TABLES.MESSAGES)
            .select("*")
            .eq('conversation_id', activeConversation.id)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.CREATED_AT, { ascending: true });

        if (messagesError) {
            console.error("Error fetching messages:", messagesError);
        } else {
            messages = messageData;
        }
    }

    const spaceData = { space, conversations, messages, activeConversation };
    await redis.set(cacheKey, spaceData, { ex: CACHE_TTL.SPACE_DATA });
    return spaceData;
}

export async function getConversations(spaceId: string): Promise<Conversation[] | null> {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    if (!spaceId) {
        return [];
    }

    const cacheKey = CACHE_KEYS.CONVERSATIONS(spaceId);
    const cachedConversations = await redis.get<Conversation[]>(cacheKey);
    if (cachedConversations) {
        return cachedConversations;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("*")
        .eq(COLUMNS.SPACE_ID, spaceId)
        .eq(COLUMNS.IS_DELETED, false)
        .order(COLUMNS.UPDATED_AT, { ascending: false });

    if (error) {
        console.error("Error fetching conversations:", error);
        return null;
    }

    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.CONVERSATIONS });
    }

    return data;
}

export async function createConversation(spaceId: string, title?: string): Promise<Conversation | null> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user || !spaceId) {
        console.error("Missing required data for conversation creation");
        return null;
    }

    const timestamp = new Date().toISOString();
    const { data, error } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .insert([{
            space_id: spaceId,
            title: title || DEFAULTS.CONVERSATION_TITLE,
            created_at: timestamp,
            updated_at: timestamp,
            is_deleted: false
        }])
        .select()
        .single();

    if (error) {
        console.error("Error creating conversation:", error);
        return null;
    }

    await redis.del(CACHE_KEYS.SPACE_DATA(spaceId));
    await redis.del(CACHE_KEYS.CONVERSATIONS(spaceId));

    return data;
}

export async function getConversation(id: string): Promise<Conversation | null> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("*")
        .eq(COLUMNS.ID, id)
        .eq(COLUMNS.IS_DELETED, false) // Don't return deleted conversations
        .single();

    if (error) {
        console.error("Error fetching conversation:", error);
        return null;
    }

    return data;
}

export async function getMessages(conversationId: string): Promise<Message[] | null> {
    if (!conversationId) {
        console.error("Invalid conversation ID: Cannot fetch messages without a valid conversation ID");
        return null;
    }

    const cacheKey = CACHE_KEYS.MESSAGES(conversationId);
    const cachedMessages = await redis.get<Message[]>(cacheKey);
    if (cachedMessages) {
        return cachedMessages;
    }

    const supabase = await createClient();
    const { data, error } = await supabase
        .from(DB_TABLES.MESSAGES)
        .select("*")
        .eq('conversation_id', conversationId)
        .eq(COLUMNS.IS_DELETED, false)
        .order(COLUMNS.CREATED_AT, { ascending: true });

    if (error) {
        console.error("Error fetching messages:", error);
        return null;
    }

    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.MESSAGES });
    }

    return data;
}

export async function updateConversationTitle(conversationId: string, title: string): Promise<void> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return;
    }

    // Get the conversation to find its space_id
    const { data: conversation, error: getError } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select('space_id')
        .eq(COLUMNS.ID, conversationId)
        .single();

    if (getError) {
        console.error("Error getting conversation:", getError);
        return;
    }

    // Update the conversation title in the database
    const { error: updateError } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .update({ title })
        .eq(COLUMNS.ID, conversationId);

    if (updateError) {
        console.error("Error updating conversation title:", updateError);
        return;
    }

    // Update all relevant caches
    try {
        // Update conversations cache
        const conversationsCacheKey = CACHE_KEYS.CONVERSATIONS(conversation.space_id);
        const cachedConversations = await redis.get<Conversation[]>(conversationsCacheKey);
        if (cachedConversations) {
            const updatedConversations = cachedConversations.map(conv =>
                conv.id === conversationId ? { ...conv, title } : conv
            );
            await redis.set(conversationsCacheKey, updatedConversations, { ex: CACHE_TTL.CONVERSATIONS });
        }

        // Update space data cache
        const spaceDataCacheKey = CACHE_KEYS.SPACE_DATA(conversation.space_id);
        const cachedSpaceData = await redis.get<SpaceData>(spaceDataCacheKey);
        if (cachedSpaceData?.conversations) {
            const updatedSpaceData = {
                ...cachedSpaceData,
                conversations: cachedSpaceData.conversations.map(conv =>
                    conv.id === conversationId ? { ...conv, title } : conv
                )
            };
            await redis.set(spaceDataCacheKey, updatedSpaceData, { ex: CACHE_TTL.SPACE_DATA });
        }
    } catch (error) {
        console.error("Error updating caches:", error);
    }
}

export async function createMessage(messageData: Partial<Message>, conversationId: string) {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user || !messageData.content || !messageData.role || !conversationId) {
        console.error("Missing required data for message creation");
        return null;
    }

    const timestamp = new Date().toISOString();

    const { data: conversation } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("space_id")
        .eq(COLUMNS.ID, conversationId)
        .single();

    if (!conversation) {
        console.error("Conversation not found");
        return null;
    }

    const [messageResult, updateResult] = await Promise.all([
        supabase
            .from(DB_TABLES.MESSAGES)
            .insert([{
                content: messageData.content,
                role: messageData.role,
                annotations: messageData.annotations,
                user_id: user.id,
                is_deleted: false,
                created_at: timestamp,
                updated_at: timestamp,
                conversation_id: conversationId
            }])
            .select()
            .single(),
        supabase
            .from(DB_TABLES.CONVERSATIONS)
            .update({ updated_at: timestamp })
            .eq(COLUMNS.ID, conversationId)
    ]);

    if (messageResult.error) {
        console.error("Error creating message:", messageResult.error);
        return null;
    }

    // Update messages cache
    const messagesCacheKey = CACHE_KEYS.MESSAGES(conversationId);
    const cachedMessages = await redis.get<Message[]>(messagesCacheKey) || [];
    await redis.set(messagesCacheKey, [...cachedMessages, messageResult.data], { ex: CACHE_TTL.MESSAGES });

    // Update space data cache
    const spaceDataCacheKey = CACHE_KEYS.SPACE_DATA(conversation.space_id);
    const cachedSpaceData = await redis.get<SpaceData>(spaceDataCacheKey);
    if (cachedSpaceData?.messages) {
        cachedSpaceData.messages = [...cachedSpaceData.messages, messageResult.data];
        await redis.set(spaceDataCacheKey, cachedSpaceData, { ex: CACHE_TTL.SPACE_DATA });
    }

    return messageResult.data;
}

export async function sendMessage({ 
  content, 
  spaceId, 
  conversationId, 
  searchMode 
}: { 
  content: string, 
  spaceId: string, 
  conversationId: string, 
  searchMode: string 
}): Promise<any> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      throw new Error("User not authenticated");
    }
    
    // Create the user message
    await createMessage({
      role: 'user',
      content,
    }, conversationId);
    
    // Here you would typically process the message with AI and create an assistant response
    // For now, we'll just create a placeholder response
    await createMessage({
      role: 'assistant',
      content: `You said: ${content}. This is a placeholder response. In a real implementation, this would be a response from the AI model.`,
    }, conversationId);
    
    // Invalidate the messages cache
    await redis.del(CACHE_KEYS.MESSAGES(conversationId));
    
    return { success: true };
  } catch (error) {
    console.error('Error sending message:', error);
    return { success: false, error };
  }
}

export async function switchConversation(conversationId: string): Promise<void> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      throw new Error("User not authenticated");
    }
    
    // Get the conversation
    const conversation = await getConversation(conversationId);
    
    if (!conversation) {
      throw new Error("Conversation not found");
    }
    
    // Set the conversation's space as active
    await setActiveSpace(conversation.space_id);
    
    // Note: In a real implementation, you might want to track the active conversation as well
    // For now, we'll rely on URL parameters for that
    
    return;
  } catch (error) {
    console.error('Error switching conversation:', error);
    throw error;
  }
}

export const signUpAction = async (formData: FormData) => {
  const email = formData.get("email")?.toString();
  const password = formData.get("password")?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get("origin");

  if (!email || !password) {
    return encodedRedirect(
      "error",
      "/sign-up",
      "Email and password are required",
    );
  }

  const { error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: `${origin}/auth/callback`,
    },
  });

  if (error) {
    console.error(error.code + " " + error.message);
    return encodedRedirect("error", "/sign-up", error.message);
  } else {
    return encodedRedirect(
      "success",
      "/sign-up",
      "Thanks for signing up! Please check your email for a verification link.",
    );
  }
};

export const signInAction = async (formData: FormData) => {
  const email = formData.get("email") as string;
  const password = formData.get("password") as string;
  const supabase = await createClient();

  const { error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    return encodedRedirect("error", "/sign-in", error.message);
  }

  return redirect("/protected");
};

export const forgotPasswordAction = async (formData: FormData) => {
  const email = formData.get("email")?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get("origin");
  const callbackUrl = formData.get("callbackUrl")?.toString();

  if (!email) {
    return encodedRedirect("error", "/forgot-password", "Email is required");
  }

  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${origin}/auth/callback?redirect_to=/protected/reset-password`,
  });

  if (error) {
    console.error(error.message);
    return encodedRedirect(
      "error",
      "/forgot-password",
      "Could not reset password",
    );
  }

  if (callbackUrl) {
    return redirect(callbackUrl);
  }

  return encodedRedirect(
    "success",
    "/forgot-password",
    "Check your email for a link to reset your password.",
  );
};

export const resetPasswordAction = async (formData: FormData) => {
  const supabase = await createClient();

  const password = formData.get("password") as string;
  const confirmPassword = formData.get("confirmPassword") as string;

  if (!password || !confirmPassword) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Password and confirm password are required",
    );
  }

  if (password !== confirmPassword) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Passwords do not match",
    );
  }

  const { error } = await supabase.auth.updateUser({
    password: password,
  });

  if (error) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Password update failed",
    );
  }

  encodedRedirect("success", "/protected/reset-password", "Password updated");
};

export async function deleteSpace(spaceId: string): Promise<void> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new Error('Unauthorized');
  }

  // Soft delete the space
  const { error } = await supabase
    .from(DB_TABLES.SPACES)
    .update({ [COLUMNS.IS_DELETED]: true })
    .eq(COLUMNS.ID, spaceId)
    .eq(COLUMNS.USER_ID, user.id);

  if (error) {
    console.error('Error deleting space:', error);
    throw new Error('Failed to delete space');
  }

  // Delete all messages for this space from Pinecone
  try {
    // Import deleteMessagesBySpaceId from the Pinecone utils
    const { deleteMessagesBySpaceId } = await import('@/utils/pinecone');
    await deleteMessagesBySpaceId(spaceId);
    console.log(`Successfully deleted messages from Pinecone for space: ${spaceId}`);
  } catch (pineconeError) {
    console.error('Error deleting messages from Pinecone:', pineconeError);
    // We don't want to fail the whole operation if Pinecone deletion fails
    // Just log the error and continue
  }

  // Clear related cache
  const cacheKeys = [
    CACHE_KEYS.SPACES(user.id),
    CACHE_KEYS.SPACE(spaceId),
    CACHE_KEYS.SPACE_DATA(spaceId),
  ];

  await Promise.all(cacheKeys.map(key => redis.del(key)));
}

export async function deleteConversation(conversationId: string): Promise<void> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    console.error('No user authenticated');
    throw new Error('Unauthorized');
  }

  console.log(`Attempting to delete conversation with ID: ${conversationId} for user: ${user.id}`);

  // Step 1: Fetch conversation to verify it exists and get space_id
  const { data: conversation, error: fetchError } = await supabase
    .from(DB_TABLES.CONVERSATIONS)
    .select(`${COLUMNS.ID}, ${COLUMNS.SPACE_ID}, ${COLUMNS.IS_DELETED}`)
    .eq(COLUMNS.ID, conversationId)
    .single();

  if (fetchError || !conversation) {
    console.error('Fetch error:', fetchError?.message || 'Conversation not found');
    throw new Error('Failed to find conversation');
  }

  console.log(`Found conversation: ID=${conversation[COLUMNS.ID]}, space_id=${conversation[COLUMNS.SPACE_ID]}, is_deleted=${conversation[COLUMNS.IS_DELETED]}`);

  if (conversation[COLUMNS.IS_DELETED]) {
    console.log('Conversation is already deleted, no update needed');
    return;
  }

  // Step 2: Verify space ownership (redundant with RLS, but kept for safety)
  const spaceId = conversation[COLUMNS.SPACE_ID];
  const { data: space, error: spaceError } = await supabase
    .from(DB_TABLES.SPACES)
    .select('id')
    .eq(COLUMNS.ID, spaceId)
    .eq(COLUMNS.USER_ID, user.id)
    .single();

  if (spaceError || !space) {
    console.error('Space verification error:', spaceError?.message || 'Space not found or not owned by user');
    throw new Error('Unauthorized: Space does not belong to user');
  }

  console.log(`Verified space ownership for space_id: ${spaceId}`);

  // Step 3: Perform the soft delete
  const { data: updateData, error: deleteError } = await supabase
    .from(DB_TABLES.CONVERSATIONS)
    .update({ 
      [COLUMNS.IS_DELETED]: true, 
      [COLUMNS.UPDATED_AT]: new Date().toISOString() 
    })
    .eq(COLUMNS.ID, conversationId)
    .select();

  if (deleteError) {
    console.error('Delete error:', deleteError.message);
    throw new Error(`Failed to delete conversation: ${deleteError.message}`);
  }

  if (!updateData || updateData.length === 0) {
    console.error('No rows updated - RLS or data issue persists');
    throw new Error('No rows updated');
  }

  console.log('Conversation successfully deleted:', updateData);

  // Step 4: Delete the messages from Pinecone as well
  try {
    // Import deleteMessagesByConversationId from the Pinecone utils
    const { deleteMessagesByConversationId } = await import('@/utils/pinecone');
    await deleteMessagesByConversationId(conversationId);
    console.log(`Successfully deleted messages from Pinecone for conversation: ${conversationId}`);
  } catch (pineconeError) {
    console.error('Error deleting messages from Pinecone:', pineconeError);
    // We don't want to fail the whole operation if Pinecone deletion fails
    // Just log the error and continue
  }

  const cacheKeys = [
    CACHE_KEYS.CONVERSATIONS(spaceId),        
    CACHE_KEYS.SPACE_DATA(spaceId),            
  ];

  try {
    await Promise.all(cacheKeys.map(key => redis.del(key)));
    console.log(`Cleared caches: ${cacheKeys.join(', ')}`);
  } catch (cacheError) {
    console.error('Error invalidating caches:', cacheError);
  }
}

export async function searchMessages(searchTerm: string, searchScope: string, searchMode: string, conversationId?: string, spaceId?: string, limit = 50): Promise<any> {
  if (!searchTerm || searchTerm.length < 2) {
    return { results: [] };
  }

  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      throw new Error("Unauthorized");
    }

    // Validate scope
    if (searchScope === 'conversation' && !conversationId) {
      throw new Error("Conversation ID is required for conversation scope");
    }

    if (searchScope === 'space' && !spaceId) {
      throw new Error("Space ID is required for space scope");
    }

    // For keyword search
    if (searchMode === 'keyword') {
      let messagesQuery;
      
      if (searchScope === 'conversation') {
        // Ensure user has access to this conversation
        const { data: conversation, error: convError } = await supabase
          .from(DB_TABLES.CONVERSATIONS)
          .select("*")
          .eq(COLUMNS.ID, conversationId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (convError || !conversation) {
          throw new Error("Conversation not found");
        }
        
        // Search within the specific conversation
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title)
          `)
          .eq(COLUMNS.CONVERSATION_ID, conversationId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        return {
          results: (messages || []).map(msg => ({
            id: msg.id,
            content: msg.content,
            role: msg.role,
            createdAt: new Date(msg.created_at).getTime(),
            conversationId: msg.conversation_id,
            conversationTitle: msg.conversation.title || 'New Conversation',
          }))
        };
      } else if (searchScope === 'space') {
        // Ensure user has access to this space
        const { data: space, error: spaceError } = await supabase
          .from(DB_TABLES.SPACES)
          .select("*")
          .eq(COLUMNS.ID, spaceId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (spaceError || !space) {
          throw new Error("Space not found");
        }
        
        // Search across all conversations in the space
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title, space_id)
          `)
          .eq("conversation.space_id", spaceId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        return {
          results: (messages || [])
            .filter(msg => msg.conversation) // Filter out messages with invalid conversations
            .map(msg => ({
              id: msg.id,
              content: msg.content,
              role: msg.role,
              createdAt: new Date(msg.created_at).getTime(),
              conversationId: msg.conversation_id,
              conversationTitle: msg.conversation.title || 'New Conversation',
            }))
        };
      }
    } else {
      // Semantic search implementation
      // Note: Without a proper vector DB setup, we'll fallback to a keyword search
      // but simulate semantic search with mock scores
      
      let messagesQuery;
      
      if (searchScope === 'conversation') {
        // Ensure user has access to this conversation
        const { data: conversation, error: convError } = await supabase
          .from(DB_TABLES.CONVERSATIONS)
          .select("*")
          .eq(COLUMNS.ID, conversationId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (convError || !conversation) {
          throw new Error("Conversation not found");
        }
        
        // Search within the specific conversation
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title)
          `)
          .eq(COLUMNS.CONVERSATION_ID, conversationId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        // Add mock semantic scores
        return {
          results: (messages || []).map((msg, index) => {
            // Generate a fake score between 0.6 and 0.95
            const fakeScore = 0.95 - (index * 0.05);
            const score = Math.max(0.6, fakeScore);
            
            return {
              id: msg.id,
              content: msg.content,
              role: msg.role,
              createdAt: new Date(msg.created_at).getTime(),
              conversationId: msg.conversation_id,
              conversationTitle: msg.conversation.title || 'New Conversation',
              score,
            };
          })
        };
      } else if (searchScope === 'space') {
        // Ensure user has access to this space
        const { data: space, error: spaceError } = await supabase
          .from(DB_TABLES.SPACES)
          .select("*")
          .eq(COLUMNS.ID, spaceId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (spaceError || !space) {
          throw new Error("Space not found");
        }
        
        // Search across all conversations in the space
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title, space_id)
          `)
          .eq("conversation.space_id", spaceId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        // Add mock semantic scores
        return {
          results: (messages || [])
            .filter(msg => msg.conversation)
            .map((msg, index) => {
              // Generate a fake score between 0.6 and 0.95
              const fakeScore = 0.95 - (index * 0.05);
              const score = Math.max(0.6, fakeScore);
              
              return {
                id: msg.id,
                content: msg.content,
                role: msg.role,
                createdAt: new Date(msg.created_at).getTime(),
                conversationId: msg.conversation_id,
                conversationTitle: msg.conversation.title || 'New Conversation',
                score,
              };
            })
        };
      }
    }

    return { results: [] };
  } catch (error) {
    console.error('Error searching messages:', error);
    throw error;
  }
}

export type SpaceActionType = 
  | 'created'
  | 'deleted'
  | 'updated'
  | 'model_changed'
  | 'conversation_added'
  | 'conversation_deleted';

export interface SpaceHistoryEntry {
  id: string;
  space_id: string;
  user_id: string;
  action_type: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  created_at: string;
}

export interface CreateSpaceHistoryOptions {
  spaceId: string;
  actionType: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
}

export async function createSpaceHistory({
  spaceId,
  actionType,
  title,
  description,
  metadata
}: CreateSpaceHistoryOptions): Promise<SpaceHistoryEntry | null> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return null;
  }

  const { data, error } = await supabase
    .from('space_history')
    .insert([{
      space_id: spaceId,
      user_id: user.id,
      action_type: actionType,
      title,
      description,
      metadata
    }])
    .select()
    .single();

  if (error) {
    console.error("Error creating space history entry:", error);
    return null;
  }

  // Update space history cache
  const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
  const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey) || [];
  await redis.set(cacheKey, [data, ...cachedHistory], { ex: CACHE_TTL.SPACE_HISTORY });

  return data;
}

export async function getSpaceHistory(spaceId: string, limit = 50): Promise<SpaceHistoryEntry[]> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return [];
  }

  // Try to get from cache first
  const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
  const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey);
  if (cachedHistory) {
    return cachedHistory;
  }

  const { data, error } = await supabase
    .from('space_history')
    .select("*")
    .eq("space_id", spaceId)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (error) {
    console.error("Error fetching space history:", error);
    return [];
  }

  // Cache the result
  if (data) {
    await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE_HISTORY });
  }

  return data;
}

export type NotificationType = 
  | 'space_created'
  | 'space_deleted'
  | 'model_changed'
  | 'conversation_created'
  | 'conversation_deleted';

export interface Notification {
  id: string;
  user_id: string;
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  is_read: boolean;
  created_at: string;
  updated_at: string;
}

export interface CreateNotificationOptions {
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  isInApp?: boolean; // If true, notification will be marked as read automatically
}

export async function createNotification({
  type,
  title,
  description,
  metadata,
  isInApp = true // Default to true for backward compatibility
}: CreateNotificationOptions): Promise<Notification | null> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return null;
  }

  const { data, error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .insert([{
      user_id: user.id,
      type,
      title,
      description,
      metadata,
      is_read: isInApp, // Automatically mark as read if it's an in-app notification
    }])
    .select()
    .single();

  if (error) {
    console.error("Error creating notification:", error);
    return null;
  }

  // Update notifications cache
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey) || [];
  await redis.set(cacheKey, [data, ...cachedNotifications], { ex: CACHE_TTL.NOTIFICATIONS });

  return data;
}

export async function getNotifications(limit = 50): Promise<Notification[]> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return [];
  }

  // Try to get from cache first
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey);
  if (cachedNotifications) {
    return cachedNotifications;
  }

  const { data, error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .select("*")
    .eq("user_id", user.id)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (error) {
    console.error("Error fetching notifications:", error);
    return [];
  }

  // Cache the result
  if (data) {
    await redis.set(cacheKey, data, { ex: CACHE_TTL.NOTIFICATIONS });
  }

  return data;
}

export async function markNotificationAsRead(notificationId: string): Promise<boolean> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return false;
  }

  const { error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .update({ is_read: true })
    .eq("id", notificationId)
    .eq("user_id", user.id);

  if (error) {
    console.error("Error marking notification as read:", error);
    return false;
  }

  // Update cache
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey);
  if (cachedNotifications) {
    const updatedNotifications = cachedNotifications.map(n =>
      n.id === notificationId ? { ...n, is_read: true } : n
    );
    await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
  }

  return true;
}

export async function markAllNotificationsAsRead(): Promise<boolean> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return false;
  }

  const { error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .update({ is_read: true })
    .eq("user_id", user.id)
    .eq("is_read", false);

  if (error) {
    console.error("Error marking all notifications as read:", error);
    return false;
  }

  // Update cache
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey);
  if (cachedNotifications) {
    const updatedNotifications = cachedNotifications.map(n => ({ ...n, is_read: true }));
    await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
  }

  return true;
}

export const signOutAction = async () => {
  const supabase = await createClient();
  
  try {
    // Clear all redis cache for the user
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      await Promise.all([
        redis.del(CACHE_KEYS.SPACES(user.id)),
        redis.del(CACHE_KEYS.ACTIVE_SPACE(user.id)),
        redis.del(CACHE_KEYS.NOTIFICATIONS(user.id))
      ]);
    }

    // Sign out from Supabase
    await supabase.auth.signOut();

    // No need to return redirect since we handle navigation client-side
    return { success: true };
  } catch (error) {
    console.error('Error during sign out:', error);
    return { success: false, error };
  }
};

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@keyframes command-item-click {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.05);
  }
  15% {
    box-shadow: 0 0 20px 4px rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.15);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
    border-color: rgba(255, 255, 255, 0.05);
  }
}

.glass-effect {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(12px);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease;
}

.glass-effect:hover {
  background: rgba(255, 255, 255, 0.04);
  border-color: rgba(255, 255, 255, 0.08);
}

.glass-effect .header {
  background: rgba(255, 255, 255, 0.03);
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

/* Style modifications for code with glass effect */
.glass-effect pre, 
.glass-effect code, 
.glass-effect .shiki {
  background: transparent !important;
  backdrop-filter: none !important;
  box-shadow: none !important;
}

/* Add a subtle blue glow to code blocks for emphasis */
.code-block-glow {
  box-shadow: 0 0 20px rgba(0, 150, 255, 0.05);
}

/* Create a better glass effect specifically for code blocks */
.glass-code-content {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.02) 100%);
  border-radius: 0 0 0.5rem 0.5rem;
  background: transparent !important;
}

/* Forcefully remove all backgrounds from code elements */
.glass-highlight,
.glass-highlight *,
.glass-highlight .shiki,
.glass-highlight .shiki *,
.glass-highlight pre,
.glass-highlight code,
.glass-highlight .line {
  background: transparent !important;
  background-color: transparent !important;
  box-shadow: none !important;
}

/* Additional styles to ensure code content shows up well on a transparent background */
.glass-highlight .shiki {
  color: rgba(255, 255, 255, 0.9) !important;
}

/* Remove any box-shadow within code blocks that might give a gray appearance */
.shiki, 
.shiki span, 
.shiki div {
  box-shadow: none !important;
  background: transparent !important;
}

/* Force all background colors in syntax highlighting to be transparent */
[class*="mtk"], 
[class*="token"] {
  background: transparent !important;
}

/* Improve token visibility on glass background */
.glass-effect .token.comment,
.glass-effect .token.prolog,
.glass-effect .token.doctype,
.glass-effect .token.cdata {
  color: rgba(128, 147, 166, 0.8) !important;
}

.glass-effect .token.punctuation {
  color: rgba(192, 202, 212, 0.8) !important;
}

.glass-effect .token.property,
.glass-effect .token.tag,
.glass-effect .token.boolean,
.glass-effect .token.number,
.glass-effect .token.constant,
.glass-effect .token.symbol {
  color: rgba(121, 182, 242, 0.9) !important;
}

.glass-effect .token.selector,
.glass-effect .token.attr-name,
.glass-effect .token.string,
.glass-effect .token.char,
.glass-effect .token.builtin {
  color: rgba(126, 231, 135, 0.9) !important;
}

.glass-effect .token.operator,
.glass-effect .token.entity,
.glass-effect .token.url,
.glass-effect .language-css .token.string,
.glass-effect .style .token.string {
  color: rgba(255, 203, 139, 0.9) !important;
}

.glass-effect .token.keyword {
  color: rgba(224, 108, 117, 0.9) !important;
}

.animate-command-item-click {
  animation: command-item-click 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

:root {
  color-scheme: dark;
  --surface: #151515;
  --surface-elevated: #1f1f1f;
  --primary: #5E6AD2;
  --primary-light: #8A94F0;
  --text: #FFFFFF;
  --text-secondary: rgba(255, 255, 255, 0.6);
  --border: rgba(255, 255, 255, 0.1);
  --radius: 0.5rem;
}

body {
  margin: 0;
  overflow: hidden;
  font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
  scroll-behavior: smooth;
}

input, textarea {
  background: transparent;
  color: var(--text);
  font-size: 14px;
  line-height: 1.5;
  transition: all 0.2s ease;
}

input:focus, textarea:focus {
  outline: none;
  background: rgba(255, 255, 255, 0.03);
}

.btn {
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.btn-primary {
  background: var(--primary);
  color: white;
}

.btn-primary:hover {
  background: var(--primary-light);
}

::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.15);
}

.command-content {
  transition: opacity 0.2s ease, transform 0.2s ease;
}

.command-content-enter {
  opacity: 0;
  transform: translateY(10px);
}

.command-content-exit {
  opacity: 0;
  transform: translateY(-10px);
}

/* Updated shine effect for modern look */
.dark {
  [cmdk-root]:after {
    content: '';
    background: linear-gradient(
      45deg,
      rgba(62, 207, 255, 0.03) 0%,
      rgba(62, 207, 255, 0.05) 25%,
      rgba(62, 207, 255, 0.1) 50%,
      rgba(62, 207, 255, 0.05) 75%,
      rgba(62, 207, 255, 0.03) 100%
    );
    z-index: -1;
    position: absolute;
    border-radius: 12px;
    top: -1px;
    left: -1px;
    width: calc(100% + 2px);
    height: calc(100% + 2px);
    animation: shine 3s ease infinite;
    background-size: 200% 200%;
  }

  [cmdk-item][data-selected="true"]:after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 8px;
    padding: 1px;
    background: linear-gradient(
      to right,
      rgba(62, 207, 255, 0.1),
      rgba(255, 255, 255, 0.1)
    );
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
  }
}

/* Animations (added to global scope)*/

@keyframes border {
  to {
    box-shadow: 0 0 0 1px var(--gray6); /* Using your existing --gray6 */
  }
}
@keyframes loadingDots {
  0% { content: '.' }
  33% { content: '..' }
  66% { content: '...' }
  100% { content: '.' }
}

.loading-dots::after {
  content: '.';
  display: inline-block;
  animation: loadingDots 1.5s infinite;
}

@keyframes showTopShine {
    to {
      opacity: 1;
    }
  }

/* Loading animation, adapted for Tailwind */
@keyframes loading {
  0% {
    opacity: 0;
    transform: translateX(0);
  }
  50% {
    opacity: 1;
    transform: translateX(100%);
  }
  100% {
    opacity: 0;
    transform: translateX(0);
  }
}

/* add these in if needed in components*/
/*.cmdk-loading-placeholder, .cmdk-loading-spinner {}*/

/* Added Keyframes */
/* For consistency, I'm adding slideIn/slideOut here even if not used *yet*. */
@keyframes slideIn {
 0% {
  opacity: 0;
  transform: scale(0.96);
 }

 100% {
  opacity: 1;
  transform: scale(1);
 }
}

@keyframes slideOut {
 0% {
  opacity: 1;
  transform: scale(1);
 }

 100% {
  opacity: 0;
  transform: scale(0.96);
 }
}

/* Add additional custom variables as needed*/
:root {
   /* ...other variables...*/
    --cmdk-shadow: 0 16px 70px rgb(0 0 0 / 20%); /* Example, might need adjustment */

}

/* Tailwind config or separate CSS file */
@keyframes rotate-slow {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes halo-pulse {
  0% { transform: scale(1); opacity: 0.6; }
  50% { transform: scale(1.1); opacity: 0.8; }
  100% { transform: scale(1); opacity: 0.6; }
}

@keyframes pulse-slow {
  0% { opacity: 0.4; }
  50% { opacity: 0.7; }
  100% { opacity: 0.4; }
}

@keyframes shimmer {
  0% { background-position: 0% 50%; }
  100% { background-position: 100% 50%; }
}

@keyframes bounce-slow {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes glow {
  0% { box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.8); }
  50% { box-shadow: inset 0 0 12px rgba(255, 255, 255, 1); }
  100% { box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.8); }
}

@keyframes float {
  0% { transform: translateY(0) translateX(0); opacity: 0.5; }
  50% { transform: translateY(-2px) translateX(1px); opacity: 0.7; }
  100% { transform: translateY(0) translateX(0); opacity: 0.5; }
}

/* Apply animation durations */
.animate-rotate-slow { animation: rotate-slow 10s linear infinite; }
.animate-halo-pulse { animation: halo-pulse 4s ease-in-out infinite; }
.animate-pulse-slow { animation: pulse-slow 6s ease-in-out infinite; }
.animate-shimmer { animation: shimmer 3s linear infinite; }
.animate-bounce-slow { animation: bounce-slow 4s ease-in-out infinite; }
.animate-glow { animation: glow 3s ease-in-out infinite; }
.animate-float { animation: float 3s ease-in-out infinite; }

@layer base {}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Override code highlighter background */
.shiki, 
.shiki *, 
pre[class*="language-"],
code[class*="language-"],
pre[class*="shiki"],
code[class*="shiki"] {
  background: transparent !important;
  background-color: transparent !important;
}

/* Remove background from the root element */
.glass-effect, 
.code-block-glow,
.glass-code-content,
.glass-highlight {
  --glass-bg: rgba(255, 255, 255, 0.02);
  --glass-border: rgba(255, 255, 255, 0.05);
  --glass-shadow: rgba(0, 0, 0, 0.1);
  background: var(--glass-bg) !important;
  border: 1px solid var(--glass-border) !important;
  backdrop-filter: blur(12px) !important;
}

/* Ensure root elements of glass containers are transparent */
.glass-effect > div, 
.code-block-glow > div,
.glass-code-content > div, 
.glass-highlight > div {
  background-color: transparent !important;
}

/* Ensure all child elements of glass containers are also transparent 
   while preserving foreground colors for syntax highlighting */
.glass-effect > *, 
.code-block-glow > *,
.glass-code-content > *, 
.glass-highlight > * {
  background-color: transparent !important;
}

/* Special rule to handle Shiki line backgrounds */
.shiki .line {
  background: transparent !important;
}

/* Make line numbers more subtle */
.shiki .line-number {
  color: rgba(255, 255, 255, 0.3) !important;
}

/* Special styles for Shiki span tokens */
.glass-effect .shiki span[style],
.code-block-glow .shiki span[style],
.glass-highlight .shiki span[style] {
  background: transparent !important;
}

/* Add specific styling for Shiki tokens to enhance readability on glass backgrounds */
.glass-effect .shiki span[style] {
  color: inherit;
}

.glass-effect .shiki .line {
  background: transparent !important;
}

.glass-effect .shiki .line:hover {
  background: rgba(255, 255, 255, 0.04) !important;
}

.glass-effect .shiki {
  background: transparent !important;
  color: rgba(255, 255, 255, 0.85) !important;
}

/* Colors for different syntax tokens optimized for glass background */
.glass-effect .shiki .mtk1 { color: rgba(230, 237, 243, 0.85) !important; }  /* Default text */
.glass-effect .shiki .mtk2 { color: rgba(121, 184, 255, 0.85) !important; }  /* Keywords, variables */
.glass-effect .shiki .mtk3 { color: rgba(126, 231, 135, 0.85) !important; }  /* Strings */
.glass-effect .shiki .mtk4 { color: rgba(224, 108, 117, 0.85) !important; }  /* Numbers, boolean */
.glass-effect .shiki .mtk5 { color: rgba(209, 154, 102, 0.85) !important; }  /* Function names */
.glass-effect .shiki .mtk6 { color: rgba(180, 142, 173, 0.85) !important; }  /* Classes, types */
.glass-effect .shiki .mtk7 { color: rgba(127, 127, 127, 0.85) !important; }  /* Comments */
.glass-effect .shiki .mtk8 { color: rgba(255, 203, 139, 0.85) !important; }  /* Operators */

/* Enhanced command item styles to ensure hover effects work */
[cmdk-item] {
  cursor: pointer !important;
  transition: all 0.2s ease !important;
  position: relative !important;
}

[cmdk-item]:hover {
  transform: translateY(-1px);
  background: rgba(255, 255, 255, 0.04) !important;
  backdrop-filter: blur(4px) !important;
}

[cmdk-item]:active {
  transform: translateY(1px);
}

/* Subtle shimmer animation for selected items */
[cmdk-item][data-selected="true"]::before {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.03);
  pointer-events: none;
  border-radius: 0.375rem;
  backdrop-filter: blur(8px);
}

/* Enhanced glass effect styling */
.glass-effect {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(12px);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease;
}

.glass-effect:hover {
  background: rgba(255, 255, 255, 0.04);
  border-color: rgba(255, 255, 255, 0.08);
}

.glass-effect .header {
  background: rgba(255, 255, 255, 0.03);
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

/* Enhanced Command Center styling */
[cmdk-dialog] {
  animation: command-dialog-overlay 0.2s ease-out;
}

@keyframes command-dialog-overlay {
  0% {
    background: transparent;
  }
  100% {
    background: transparent;
  }
}

[cmdk-dialog] [cmdk-root] {
  animation: command-dialog-content 0.2s ease-out;
  transform-origin: center center;
}

@keyframes command-dialog-content {
  0% {
    opacity: 0;
    transform: scale(0.98);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

[cmdk-root] {
  position: relative;
}

[cmdk-root]:before {
  content: '';
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: 0.75rem;
  padding: 1px;
  background: linear-gradient(
    135deg,
    rgba(255, 255, 255, 0.02) 0%,
    rgba(255, 255, 255, 0.04) 50%,
    rgba(255, 255, 255, 0.02) 100%
  );
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.6;
}

[cmdk-item] {
  position: relative;
  height: auto;
  transform-origin: center;
  transition: all 0.2s ease;
}

[cmdk-item]:hover {
  transform: translateY(-1px);
  background: rgba(255, 255, 255, 0.04) !important;
  backdrop-filter: blur(4px) !important;
}

[cmdk-item]:active {
  transform: translateY(1px);
}

/* Subtle shimmer animation for selected items */
[cmdk-item][data-selected="true"]::before {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.03);
  pointer-events: none;
  border-radius: 0.375rem;
  backdrop-filter: blur(8px);
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Common glassy UI styling */
.glass-panel {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.05);
  transition: all 0.2s ease;
}

.glass-panel:hover {
  background: rgba(255, 255, 255, 0.03);
}

.glass-border {
  border: 1px solid rgba(255, 255, 255, 0.05);
}

.glass-border-hover:hover {
  border-color: rgba(255, 255, 255, 0.08);
}

.glass-item-hover:hover {
  background: rgba(255, 255, 255, 0.03);
}

.glass-text {
  color: rgba(255, 255, 255, 0.9);
}

.glass-text-secondary {
  color: rgba(255, 255, 255, 0.7);
}

.glass-text-tertiary {
  color: rgba(255, 255, 255, 0.5);
}

.glass-input {
  background: transparent;
  border: 1px solid rgba(255, 255, 255, 0.05);
  color: rgba(255, 255, 255, 0.9);
}

.glass-input:focus {
  background: rgba(255, 255, 255, 0.03);
  border-color: rgba(255, 255, 255, 0.1);
}

/* Command Center Dialog styles */
[cmdk-dialog] {
  animation: command-dialog-overlay 0.2s ease-out;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
}

@keyframes command-dialog-overlay {
  0% {
    background: transparent;
  }
  100% {
    background: transparent;
  }
}

[cmdk-dialog] [cmdk-root] {
  animation: command-dialog-content 0.2s ease-out;
  max-width: 640px;
  width: 100%;
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-radius: 0.75rem;
  overflow: hidden;
  backdrop-filter: blur(12px);
}

@keyframes command-dialog-content {
  0% {
    opacity: 0;
    transform: scale(0.98);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

[cmdk-input] {
  border: none;
  width: 100%;
  font-size: 0.875rem;
  padding: 0.75rem 1rem;
  outline: none;
  background: transparent;
  color: rgba(255, 255, 255, 0.9);
}

[cmdk-input]::placeholder {
  color: rgba(255, 255, 255, 0.4);
}

[cmdk-item] {
  content-visibility: auto;
  cursor: pointer;
  height: auto;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;
  color: rgba(255, 255, 255, 0.8);
  user-select: none;
  will-change: background, color;
  transition: all 0.15s ease;
  position: relative;
  margin: 0.2rem 0;
}

[cmdk-item][data-selected="true"] {
  background: rgba(255, 255, 255, 0.05);
  color: rgba(255, 255, 255, 1);
}

[cmdk-item]:hover {
  background: rgba(255, 255, 255, 0.05);
  color: rgba(255, 255, 255, 1);
  backdrop-filter: blur(4px);
}

[cmdk-item]:active {
  background: rgba(255, 255, 255, 0.06);
  color: white;
}

[cmdk-group-heading] {
  user-select: none;
  font-size: 0.75rem;
  color: rgba(255, 255, 255, 0.6);
  padding: 0.5rem 0.75rem;
  display: flex;
  align-items: center;
}

/* Updated to remove "none" from backdrop-filter */
.glass-effect,
.glass-effect:hover,
.glass-item-hover:hover,
[cmdk-item]:hover,
[cmdk-item][data-selected="true"]::before {
  backdrop-filter: blur(12px);
}

/* Override existing animations */
@keyframes command-dialog-overlay {
  0%, 100% {
    background: transparent;
  }
}

/* Custom animation for the root element */
[cmdk-root]:before {
  content: '';
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: 0.75rem;
  padding: 1px;
  background: linear-gradient(
    135deg,
    rgba(255, 255, 255, 0.02) 0%,
    rgba(255, 255, 255, 0.04) 50%,
    rgba(255, 255, 255, 0.02) 100%
  );
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.7;
}

/* Dialog styling to match command center */
.glass-dialog:before {
  content: '';
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: 0.75rem;
  padding: 1px;
  background: linear-gradient(
    135deg,
    rgba(255, 255, 255, 0.02) 0%,
    rgba(255, 255, 255, 0.04) 50%,
    rgba(255, 255, 255, 0.02) 100%
  );
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.7;
}

/* Dialog animations */
@keyframes dialog-content-in {
  0% {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
  100% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
}

@keyframes dialog-content-out {
  0% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
}

/* Dialog input styling */
.glass-dialog input,
.glass-dialog textarea,
.glass-dialog select {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.05);
  color: rgba(255, 255, 255, 0.9);
  transition: all 0.2s ease;
}

.glass-dialog input:focus,
.glass-dialog textarea:focus,
.glass-dialog select:focus {
  background: rgba(255, 255, 255, 0.03);
  border-color: rgba(255, 255, 255, 0.1);
  outline: none;
}

.glass-dialog input::placeholder,
.glass-dialog textarea::placeholder {
  color: rgba(255, 255, 255, 0.4);
}

.glass-dialog button {
  transition: all 0.2s ease;
}

.glass-dialog button:not([data-variant="primary"]):hover {
  background: rgba(255, 255, 255, 0.05);
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Toaster } from "@/components/ui/common/toaster";
import { CommandProvider } from "@/hooks/useCommandCenter";
import CommandRoot from "@/components/CommandRoot";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Vinci",
  description: "Vinci App",
};
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

================
File: app/page.tsx
================
import { redirect } from "next/navigation";
import { createClient } from "@/utils/supabase/server";
import CommandButton, { TypedCommandButton } from "@/components/CommandButton";
import { MessageSquare, Users, Brain, Play } from 'lucide-react';

export default async function Home() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  // If user is logged in, redirect to conversations
  if (user) {
    redirect("/conversations");
  }

  // Otherwise redirect to sign in
  redirect("/sign-in");
}

================
File: components/ui/auth/form-message.tsx
================
export type Message =
  | { success: string }
  | { error: string }
  | { message: string };

export function FormMessage({ message }: { message: Message }) {
  return (
    <div className="flex flex-col gap-2 w-full max-w-md text-sm">
      {"success" in message && (
        <div className="text-foreground border-l-2 border-foreground px-4">
          {message.success}
        </div>
      )}
      {"error" in message && (
        <div className="text-destructive-foreground border-l-2 border-destructive-foreground px-4">
          {message.error}
        </div>
      )}
      {"message" in message && (
        <div className="text-foreground border-l-2 px-4">{message.message}</div>
      )}
    </div>
  );
}

================
File: components/ui/auth/header-auth.tsx
================
import { hasEnvVars } from "@/utils/supabase/check-env-vars";
import Link from "next/link";
import { Badge } from "../common/badge";
import { Button } from "../common/button";
import { createClient } from "@/utils/supabase/server";
import { UserProfileDropdown } from "./user-profile-dropdown";

export default async function AuthButton() {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!hasEnvVars) {
    return (
      <>
        <div className="flex gap-4 items-center">
          <div>
            <Badge
              variant={"default"}
              className="font-normal pointer-events-none"
            >
              Please update .env.local file with anon key and url
            </Badge>
          </div>
          <div className="flex gap-2">
            <Button
              size="sm"
              variant={"ghost"}
              disabled
              className="opacity-75 cursor-none pointer-events-none"
            >
              <Link href="/sign-in">Sign in</Link>
            </Button>
            <Button
              size="sm"
              variant={"default"}
              disabled
              className="opacity-75 cursor-none pointer-events-none"
            >
              <Link href="/sign-up">Sign up</Link>
            </Button>
          </div>
        </div>
      </>
    );
  }
  return user ? (
    <UserProfileDropdown user={user} />
  ) : (
    <div className="flex gap-2">
      <Button size="sm" variant={"ghost"}>
        <Link href="/sign-in">Sign in</Link>
      </Button>
      <Button size="sm" variant={"default"}>
        <Link href="/sign-up">Sign up</Link>
      </Button>
    </div>
  );
}

================
File: components/ui/auth/submit-button.tsx
================
"use client";

import { Button } from "@/components/ui/common/button";
import { type ComponentProps } from "react";
import { useFormStatus } from "react-dom";

type Props = ComponentProps<typeof Button> & {
  pendingText?: string;
};

export function SubmitButton({
  children,
  pendingText = "Submitting...",
  ...props
}: Props) {
  const { pending } = useFormStatus();

  return (
    <Button type="submit" aria-disabled={pending} {...props}>
      {pending ? pendingText : children}
    </Button>
  );
}

================
File: components/ui/auth/user-profile-dropdown.tsx
================
'use client'

import { useState, useEffect } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { Bell, LogOut, User as UserIcon, Settings } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/common/avatar";
import { Button } from "@/components/ui/common/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/common/dropdown-menu";
import { cn } from "@/lib/utils";
import { User } from '@supabase/supabase-js';
import { signOutAction } from '@/app/actions/auth';
import { getNotifications, markAllNotificationsAsRead, markNotificationAsRead } from '@/app/actions/notifications';

interface UserProfileDropdownProps {
  user: User;
  initialNotifications?: any[];
}

export function UserProfileDropdown({ user, initialNotifications = [] }: UserProfileDropdownProps) {
  const [unreadCount, setUnreadCount] = useState(0);
  const [isOpen, setIsOpen] = useState(false);
  const [showNotifications, setShowNotifications] = useState(false);
  const [notifications, setNotifications] = useState<any[]>(initialNotifications);

  useEffect(() => {
    if (notifications) {
      const unreadNotifications = notifications.filter(
        (notification) => !notification.is_read
      );
      setUnreadCount(unreadNotifications.length);
    }
  }, [notifications]);
  
  const handleMarkAsRead = async (notificationId: string) => {
    await markNotificationAsRead(notificationId);
    const notificationsResponse = await getNotifications();
    if (notificationsResponse.status === 'success') { 
      setNotifications(notificationsResponse.data || []);
    }
  };

  const handleMarkAllAsRead = async () => {
    await markAllNotificationsAsRead();
    const notificationsResponse = await getNotifications();
    if (notificationsResponse.status === 'success') {
      setNotifications(notificationsResponse.data || []);
    }
  };
  
  const router = useRouter();
  const userInitials = user.email
    ? user.email.substring(0, 2).toUpperCase()
    : '??';

  const handleLogout = async () => {
    router.push('/sign-in');
    await signOutAction();
  };

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="relative h-10 w-10 rounded-full border border-white/[0.05] bg-white/[0.03] hover:bg-white/[0.05] transition-all duration-200"
          aria-label="User profile"
        >
          {unreadCount > 0 && (
            <span className="absolute right-0 top-0 flex h-3 w-3">
              <span className="absolute inline-flex h-full w-full animate-ping rounded-full bg-cyan-400 opacity-75"></span>
              <span className="relative inline-flex h-3 w-3 rounded-full bg-cyan-500"></span>
            </span>
          )}
          <Avatar>
            <AvatarImage src={user.user_metadata.avatar_url} alt={user.email || ''} />
            <AvatarFallback>{userInitials}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1.5">
            <p className="text-sm font-medium leading-none text-white/90 truncate max-w-[200px]">
              {user.user_metadata.full_name || user.email}
            </p>
            <p className="text-xs leading-none text-white/40 truncate max-w-[200px]">
              {user.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuGroup>
          <DropdownMenuItem 
            onClick={(e) => {
              e.preventDefault();
              setShowNotifications(!showNotifications);
            }}
            className="cursor-pointer"
          >
            <Bell className="mr-2 h-4 w-4" />
            <span>Notifications</span>
            {unreadCount > 0 && (
              <div className="ml-auto flex h-5 w-5 items-center justify-center rounded-full bg-cyan-500 text-xs">
                {unreadCount}
              </div>
            )}
          </DropdownMenuItem>
          {showNotifications && (
            <>
              {unreadCount > 0 && (
                <div className="px-3 py-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-auto p-1 text-xs text-white/70 hover:text-white hover:bg-white/[0.05]"
                    onClick={handleMarkAllAsRead}
                  >
                    Mark all as read
                  </Button>
                </div>
              )}
              <div className="max-h-48 overflow-y-auto">
                {notifications.length === 0 ? (
                  <div className="px-3 py-2 text-sm text-white/50">
                    No notifications
                  </div>
                ) : (
                  notifications.map((notification) => (
                    <div
                      key={notification.id}
                      className={cn(
                        'px-3 py-2 text-sm hover:bg-white/[0.05] transition-colors',
                        !notification.is_read && 'bg-white/[0.03]'
                      )}
                    >
                      <div className="flex items-center justify-between gap-2">
                        <div className="font-medium text-white/90">{notification.title}</div>
                        {!notification.is_read && (
                          <Button
                            variant="ghost"
                            size="sm"
                            className="h-auto p-1 text-xs text-white/70 hover:text-white hover:bg-white/[0.05]"
                            onClick={() => handleMarkAsRead(notification.id)}
                          >
                            Mark as read
                          </Button>
                        )}
                      </div>
                      <div className="mt-1 text-white/70 text-xs">{notification.description}</div>
                    </div>
                  ))
                )}
              </div>
            </>
          )}
          <Link href="/protected/profile">
            <DropdownMenuItem>
              <UserIcon className="mr-2 h-4 w-4" />
              <span>Profile</span>
            </DropdownMenuItem>
          </Link>
          <Link href="/protected/settings">
            <DropdownMenuItem>
              <Settings className="mr-2 h-4 w-4" />
              <span>Settings</span>
            </DropdownMenuItem>
          </Link>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />
        <DropdownMenuItem
          className="text-cyan-400 hover:text-cyan-300 focus:text-cyan-300"
          onClick={handleLogout}
        >
          <LogOut className="mr-2 h-4 w-4" />
          <span>Log out</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: components/ui/chat/chat-content-client.tsx
================
"use client";
import { useChat } from "@ai-sdk/react";
import { ServerDrivenSpaceTab } from "@/components/ui/space/space-tab";
import { ServerDrivenConversationTab } from "@/components/ui/conversation/conversation-tab";
import { ServerDrivenQuickActionsTab } from "@/components/ui/quick-actions-tab";
import { ServerDrivenModelTab } from "@/components/ui/chat/model-tab";
import { ChatModeTab } from "@/components/ui/chat/chat-mode-tab";
import { ArrowDown, Search, Sparkles } from "lucide-react";
import { BaseTab } from "@/components/ui/common/base-tab";
import { User } from "@supabase/supabase-js";
import { UnifiedInput } from "@/components/ui/chat/unified-input";
import { ChatMessages } from "@/components/ui/chat/chat-messages";
import { UserProfileDropdown } from "@/components/ui/auth/user-profile-dropdown";
import { useCommandCenter } from "@/hooks/useCommandCenter";
import { useRouter } from "next/navigation";
import { sendMessage, createConversation, switchConversation, deleteConversation } from "@/app/actions/conversations";
import { updateSpace } from "@/app/actions/spaces";
import { useCallback, useRef, useState, useEffect } from "react";
import { useSpaceStore } from "@/stores/space-store";
import { useShallow } from "zustand/react/shallow";

interface ClientChatContentProps {
  user: User;
  initialData: {
    spaces: any[];
    activeSpace: any;
    conversations: any[];
    activeConversation: any;
    messages: any[];
    allMessages: Record<string, any[]>;
    notifications?: any[];
  };
}

export default function ClientChatContent({
  user,
  initialData,
}: ClientChatContentProps) {
  const router = useRouter();
  const { openCommandType } = useCommandCenter();
  
  const [isStickToBottom, setIsStickToBottom] = useState(true);
  const [searchMode, setSearchMode] = useState<"chat" | "search" | "semantic" | "hybrid">("chat");
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  
  const {
    activeSpace: storeActiveSpace,
    conversations: storeConversations,
    activeConversation: storeActiveConversation,
    messages: storeMessages,
  } = useSpaceStore(
    useShallow((state) => state.uiState)
  );
  
  const activeSpace = storeActiveSpace || initialData.activeSpace;
  const conversations = storeConversations || initialData.conversations;
  const activeConversation = storeActiveConversation || initialData.activeConversation;
  const initialMessages = storeMessages || initialData.messages;

  useEffect(() => {
    if (storeActiveConversation && storeActiveConversation !== activeConversation) {
      setMessages(storeMessages || []);
      setData([]);
    }

    router.replace(`/protected/spaces/${activeSpace?.id}/conversations/${activeConversation?.id}`);
  }, [storeActiveConversation?.id]);
  
  const {
    messages,
    setMessages,
    input,
    setInput,
    isLoading: isChatLoading,
    handleInputChange,
    handleSubmit: aiSubmit,
    data,
    setData,
  } = useChat({
    id: activeConversation?.id || 'default',
    api: "/api/chat",
    initialMessages: initialMessages,
    body: {
      spaceId: activeSpace?.id || "",
      conversationId: activeConversation?.id || null,
      provider: activeSpace?.provider || "",
      model: activeSpace?.model || "",
      searchMode,
    },
    onFinish() {
      setData([]);
    },
  });

  const handleStickToBottomChange = useCallback((isAtBottom: boolean) => {
    setIsStickToBottom(isAtBottom);
  }, []);
  
  const scrollToBottomHandler = useRef<() => void>(() => {
    messagesContainerRef.current?.scrollTo({
      top: messagesContainerRef.current.scrollHeight,
      behavior: "smooth",
    });
  });

  const handleScrollToBottom = useCallback((callback: () => void) => {
    scrollToBottomHandler.current = callback;
  }, []);

  const handleSubmit = async () => {
    if (!input.trim() || !activeSpace || !activeConversation) return;
    
    try {
      // First submit through the AI SDK for streaming
      aiSubmit();
      
      // Also send to server action to persist in database
      await sendMessage({
        content: input,
        spaceId: activeSpace.id,
        conversationId: activeConversation.id,
        searchMode,
      });
      
    } catch (error) {
      console.error('Failed to send message:', error);
    }
  };
  
  const handleCreateConversation = async () => {
    if (!activeSpace) return;
    
    try {
      const result = await createConversation(activeSpace.id);
      if (result.status === 'success' && result.data) {
        router.push(`/protected/spaces/${activeSpace.id}/conversations/${result.data.id}`);
      }
    } catch (error) {
      console.error('Failed to create conversation:', error);
    }
  };
  
  return (
    <div className="flex flex-col h-full bg-black text-white relative chat-container">
      <div className="fixed top-4 right-4 z-50">
        {user && <UserProfileDropdown user={user} initialNotifications={initialData.notifications} />}
      </div>
      <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50">
        <div
          className="relative p-1 rounded-full bg-black/20 border border-white/[0.08] backdrop-blur-xl"
          style={{
            background: `color-mix(in srgb, ${activeSpace?.color || "#3ecfff"}10, transparent)`,
            boxShadow: `0 0 20px ${activeSpace?.color || "#3ecfff"}10, inset 0 0 20px ${
              activeSpace?.color || "#3ecfff"
            }05`,
          }}
        >
          <div className="flex items-center divide-x divide-white/[0.08]">
            <div className="px-1 first:pl-1 last:pr-1">
              {/* @ts-ignore */}
              <ServerDrivenSpaceTab 
                spaces={initialData.spaces}
                activeSpace={activeSpace}
              />
            </div>
            <div className="px-1 first:pl-1 last:pr-1">
              {/* @ts-ignore */}
              <ServerDrivenModelTab 
                activeSpace={activeSpace}
                onUpdateSpace={async (spaceId: string, updates: any) => {
                  const success = await updateSpace(spaceId, updates);
                  if (success) {
                    router.refresh();
                  }
                }}
              />
            </div>
            <div className="px-1 first:pl-1 last:pr-1">
              <ChatModeTab 
                mode={searchMode} 
                onModeChange={setSearchMode} 
              />
            </div>
            {!isStickToBottom && messages.length > 0 && (
              <div className="px-1 first:pl-1 last:pr-1">
                <BaseTab
                  icon={<ArrowDown className="w-3 h-3" />}
                  label="Scroll to Bottom"
                  onClick={() => {
                    scrollToBottomHandler.current();
                  }}
                />
              </div>
            )}
          </div>
        </div>
      </div>
      <div className="flex-1 w-full h-full flex flex-col">
        <div className="absolute top-0 left-0 w-full h-screen pointer-events-none">
          <div className="absolute top-0 left-[20%] w-[500px] h-[500px] bg-[#3ecfff]/[0.015] blur-[120px] rounded-full" />
          <div className="absolute top-[20%] right-[20%] w-[400px] h-[400px] bg-[#D4966A]/[0.015] blur-[100px] rounded-full" />
          <div className="absolute bottom-[10%] left-[30%] w-[600px] h-[600px] bg-[#3ecfff]/[0.01] blur-[130px] rounded-full" />
        </div>
        <ChatMessages
          messages={messages}
          onStickToBottomChange={handleStickToBottomChange}
          onScrollToBottom={handleScrollToBottom}
          ref={messagesContainerRef}
          isLoading={isChatLoading}
          streamData={data}
        />
        <div className="fixed left-1/2 bottom-8 -translate-x-1/2 w-[800px] z-50">
          <div className="relative w-full">
            <UnifiedInput
              value={input}
              onChange={handleInputChange}
              onSubmit={handleSubmit}
              disabled={!activeSpace || isChatLoading}
            >
              <div className="flex items-center divide-x divide-white/[0.05] bg-white/[0.03] border-t border-l border-r border-white/[0.05] rounded-t-2xl overflow-hidden backdrop-blur-xl w-full shadow-[0_-4px_20px_rgba(62,207,255,0.03)]">
                <div className="px-1 first:pl-2 last:pr-2 py-1 flex-1">
                  {/* @ts-ignore */}
                  <ServerDrivenQuickActionsTab 
                    onCreateConversation={handleCreateConversation}
                  />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 flex-1">
                  <BaseTab
                    icon={<Search className="w-3 h-3" />}
                    label="Messages"
                    shortcut="F"
                    commandType="conversations"
                    onClick={() => openCommandType("conversations")}
                  />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 flex-1">
                  <BaseTab
                    icon={<Sparkles className="w-3 h-3" />}
                    label="Prompts"
                    shortcut="P"
                    commandType="actions"
                    onClick={() => openCommandType("actions")}
                  />
                </div>
                <div className="flex-shrink min-w-0 flex-1 flex items-center px-1 first:pl-2 last:pr-2 py-1">
                  {/* @ts-ignore */}
                  <ServerDrivenConversationTab
                    conversations={conversations}
                    activeConversation={activeConversation}
                    onCreateConversation={handleCreateConversation}
                  />
                </div>
              </div>
            </UnifiedInput>
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: components/ui/chat/chat-message.tsx
================
import { User, MessageSquareIcon } from 'lucide-react';
import { memo } from 'react';
import { getModelName, type Provider } from '@/config/models';
import { ProviderIcon } from './provider-icon';
import { JSONValue, Message } from 'ai';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/common/avatar';
import { StreamStatus } from './stream-status';
import { Markdown } from './markdown';
import DotSphere from '@/components/ui/space/planet-icon';
import { useSpaceStore } from '@/stores/space-store';

interface ChatMessageProps {
    message: Message;
    userAvatarUrl?: string;
    isLoading?: boolean;
    streamData?: JSONValue[] | undefined;
}

// Define the SimilarMessage type
interface SimilarMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  score: number;
  metadata?: Record<string, any>;
}

const UserAvatar = ({ avatarUrl }: { avatarUrl?: string }) => (
    <Avatar className="h-10 w-10 border bg-white/[0.03] border-white/[0.1]">
        <AvatarImage src={avatarUrl || ""} />
        <AvatarFallback className="bg-white/[0.03]">
            <User className="h-5 w-5 text-white/80" />
        </AvatarFallback>
    </Avatar>
);

const AIAvatar = () => {
    // Use the active space ID from the store as the seed
    // This ensures the AIAvatar looks identical to the active space's DotSphere
    const activeSpace = useSpaceStore(state => state.activeSpace);
    const seed = activeSpace?.id || "default-space"; // Fallback if no active space
    
    return (
        <div className="relative group">
            {/* Refined outer glow */}
            <div className="absolute -inset-2 bg-gradient-to-r from-cyan-500/10 via-indigo-400/10 to-purple-500/10 rounded-full blur-md opacity-0 group-hover:opacity-100 transition-opacity duration-700" />
            
            {/* Elegant halo effect */}
            <div className="absolute -inset-4 opacity-0 group-hover:opacity-70 transition-opacity duration-500">
                <div className="absolute inset-0 rounded-full bg-gradient-to-r from-cyan-500/8 to-indigo-500/8 animate-pulse-slow" />
            </div>
            
            {/* DotSphere component as the avatar - using exact same props as space-tab.tsx except for size */}
            <div className="relative h-12 w-12 flex items-center justify-center">
                <DotSphere 
                    size={40} 
                    seed={seed} 
                    dotCount={80} 
                    dotSize={0.9} 
                    expandFactor={1.15} 
                    transitionSpeed={400}
                    highPerformance={true}
                />
            </div>
        </div>
    );
};

const ModelInfo = ({ provider, modelName, similarMessages }: { 
  provider?: Provider; 
  modelName: string;
  similarMessages?: SimilarMessage[];
}) => {
  const hasSimilarMessages = similarMessages && similarMessages.length > 0;
  
  return (
    <div className="flex items-center gap-1.5 mb-2.5">
      {provider && (
        <div className="px-2 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
          <ProviderIcon provider={provider} size={14} />
        </div>
      )}
      <div className="px-2.5 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <span className="text-white">{modelName}</span>
      </div>
      
      {hasSimilarMessages && (
        <button
          className="px-2.5 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10 hover:bg-white/[0.07] transition-colors"
        >
          <MessageSquareIcon size={11} className="text-cyan-400/80" />
          <span>{similarMessages.length} similar</span>
        </button>
      )}
    </div>
  );
};

export const ChatMessage = memo<ChatMessageProps>(
    ({ message, userAvatarUrl, isLoading, streamData }) => {
        const isUser = message.role === 'user';

        const annotations = message.annotations as Array<{
            model_used?: string;
            provider?: string;
            similarMessages?: SimilarMessage[];
        }> | undefined;

        const modelAnnotation = annotations?.find(a => a.model_used);
        const providerAnnotation = annotations?.find(a => a.provider);
        const similarMessagesAnnotation = annotations?.find(a => a.similarMessages);
        
        const similarMessages = similarMessagesAnnotation?.similarMessages || [];

        const modelName = modelAnnotation?.model_used
            ? getModelName(modelAnnotation.provider as Provider, modelAnnotation.model_used)
            : 'AI';

        const providerName = providerAnnotation?.provider
            ? providerAnnotation.provider.charAt(0).toUpperCase() + providerAnnotation.provider.slice(1)
            : '';

        
        const isStreamingAssistant = !isUser && (
            // Handle regular streaming scenario
            (isLoading && message.content.length <= 0) || 
            // Handle placeholder message scenario
            message.id === 'placeholder-assistant'
        );

        return (
            <div className={`flex items-start gap-5 w-full mx-auto group transition-opacity ${isUser ? 'flex-row-reverse' : ''}`}>
                <div className={`flex-shrink-0 ${isUser ? '' : 'mt-1'}`}>
                    {isUser ? <UserAvatar avatarUrl={userAvatarUrl} /> : <AIAvatar />}
                </div>

                <div className="space-y-2 overflow-hidden max-w-[85%]">
                    <div className="prose prose-invert max-w-none w-full">
                    {message.role === 'assistant' && annotations && !isStreamingAssistant && (
                            <ModelInfo
                                provider={providerAnnotation?.provider as Provider}
                                modelName={modelName}
                                similarMessages={similarMessages}
                            />
                        )}

                        {isUser ? (
                            <div className="text-sm leading-relaxed whitespace-pre-wrap break-words text-white shadow-[0_0_15px_-5px_rgba(255,255,255,0.3)]">
                                {message.content}
                            </div>
                        ) : isStreamingAssistant ? (
                            <div className="transition-all duration-500 ease-in-out will-change-transform">
                            {annotations && (
                                <ModelInfo
                                    provider={providerAnnotation?.provider as Provider}
                                    modelName={modelName}
                                />
                            )}
                                {/* Add a growing animation to the StreamStatus container */}
                                <div 
                                    className="animate-appear transform-gpu transition-all duration-500 ease-out"
                                    style={{ animationFillMode: 'both' }}
                                >
                                    <StreamStatus streamData={streamData} />
                                </div>
                            </div>
                        ) : (
                            <div className="prose prose-invert prose-zinc max-w-none">
                                <Markdown id={message.id}>
                                    {message.content}
                                </Markdown>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        );
    }
);

// Add a display name for easier debugging
ChatMessage.displayName = 'ChatMessage';

================
File: components/ui/chat/chat-messages-skeleton.tsx
================
export function ChatMessagesSkeleton() {
  return (
    <div className="relative flex-1 flex flex-col">
      <div className="messages-container absolute inset-0 overflow-y-auto py-12 px-4 pb-52">
        <div className="max-w-[85%] mx-auto">
          <div className="space-y-12 min-h-full animate-pulse">
            {/* AI Message Skeleton */}
            <div className="flex items-start gap-4">
              <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1]">
                <div className="w-5 h-5 rounded-full bg-white/10" />
              </div>
              <div className="flex-1 space-y-2 overflow-hidden max-w-[85%]">
                <div className="flex items-center gap-1.5 mb-2.5">
                  <div className="w-20 h-4 bg-white/10 rounded" />
                </div>
                <div className="space-y-2">
                  <div className="h-4 bg-white/10 rounded w-full" />
                  <div className="h-4 bg-white/10 rounded w-4/5" />
                  <div className="h-4 bg-white/10 rounded w-2/3" />
                </div>
              </div>
            </div>

            {/* User Message Skeleton */}
            <div className="flex items-start gap-4 justify-end">
              <div className="flex-1 space-y-2 overflow-hidden max-w-[85%] text-right">
                <div className="space-y-2">
                  <div className="h-4 bg-white/10 rounded w-3/4 ml-auto" />
                  <div className="h-4 bg-white/10 rounded w-1/2 ml-auto" />
                </div>
              </div>
              <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1]">
                <div className="w-5 h-5 rounded-full bg-white/10" />
              </div>
            </div>

            {/* Another AI Message Skeleton */}
            <div className="flex items-start gap-4">
              <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1]">
                <div className="w-5 h-5 rounded-full bg-white/10" />
              </div>
              <div className="flex-1 space-y-2 overflow-hidden max-w-[85%]">
                <div className="flex items-center gap-1.5 mb-2.5">
                  <div className="w-20 h-4 bg-white/10 rounded" />
                </div>
                <div className="space-y-2">
                  <div className="h-4 bg-white/10 rounded w-full" />
                  <div className="h-4 bg-white/10 rounded w-3/4" />
                  <div className="h-4 bg-white/10 rounded w-1/2" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

================
File: components/ui/chat/chat-messages.tsx
================
'use client';

import { ChatContainer, useAutoScroll } from '@/components/ui/chat-container';
import { useEffect, forwardRef, useRef, useState, useCallback } from 'react';
import { ChatMessage } from './chat-message';
import { JSONValue, Message } from 'ai';
import { useSearchParams, useRouter } from 'next/navigation';

interface ChatMessagesProps {
  messages: Message[];
  onStickToBottomChange?: (isStickToBottom: boolean) => void;
  onScrollToBottom?: (callback: () => void) => void;
  isLoading?: boolean;
  streamData?: JSONValue[] | undefined;
}

export const ChatMessages = forwardRef<HTMLDivElement, ChatMessagesProps>(
  ({ messages, onStickToBottomChange, onScrollToBottom, isLoading, streamData }, ref) => {
    const [highlightedElement, setHighlightedElement] = useState<HTMLDivElement | null>(null);
    const messageRefs = useRef<Map<string, HTMLDivElement>>(new Map());
    const [hasUserInteracted, setHasUserInteracted] = useState(false);
    const containerRef = useRef<HTMLDivElement>(null);
    const actualRef = (ref as React.RefObject<HTMLDivElement>) || containerRef;
    
    const { 
      autoScrollEnabled, 
      scrollToBottom 
    } = useAutoScroll(actualRef, true);
    
    useEffect(() => {
      if (onStickToBottomChange) {
        onStickToBottomChange(autoScrollEnabled);
      }
    }, [autoScrollEnabled, onStickToBottomChange]);
    
    // Expose scrollToBottom to parent
    useEffect(() => {
      if (onScrollToBottom && scrollToBottom) {
        // Create a function that parent can call
        const handleScrollToBottom = () => scrollToBottom("smooth");
        // Provide the callback to the parent
        onScrollToBottom(handleScrollToBottom);
      }
    }, [onScrollToBottom, scrollToBottom]);

    return (
      <div className="relative flex-1 flex flex-col h-full">
        <ChatContainer
          ref={actualRef}
          className="absolute inset-0 py-12 px-4 pb-52"
          autoScroll={true}
        >
          <div className="max-w-[85%] w-full mx-auto">
            <div className="space-y-12">
              {messages.map((message, index) => (
                <div 
                  key={message.id} 
                  ref={(el) => {
                    if (el && message.id !== 'streaming-message') {
                      messageRefs.current.set(message.id, el);
                    }
                  }}
                  className={`transition-all ${
                    highlightedElement === messageRefs.current.get(message.id) && !hasUserInteracted
                      ? 'bg-cyan-950/20 -mx-6 px-6 py-4 rounded-lg border-2 border-cyan-500/50 animate-highlight-glow relative z-10 shadow-xl' 
                      : ''
                  }`}
                >
                  {highlightedElement === messageRefs.current.get(message.id) && !hasUserInteracted && (
                    <div className="absolute top-2 right-3 text-xs text-cyan-400 animate-pulse-fast">
                      Click anywhere to dismiss
                    </div>
                  )}
                  <ChatMessage 
                    message={message} 
                    isLoading={isLoading}
                    streamData={streamData}
                  />
                  {index < messages.length - 1 && messages[index].role !== messages[index + 1].role && (
                    <div className="w-full flex justify-center my-8">
                      <div className="w-1/3 h-px bg-white/[0.05]" />
                    </div>
                  )}
                </div>
              ))}
              
              {/* Add placeholder assistant message when last message is from user and we're loading */}
              {messages.length > 0 && 
               messages[messages.length - 1].role === 'user' && 
               isLoading && (
                <div key="placeholder-assistant" className="space-y-2">
                  {messages.length > 1 && messages[messages.length - 1].role !== messages[messages.length - 2].role && (
                    <div className="w-full flex justify-center my-8">
                      <div className="w-1/3 h-px bg-white/[0.05]" />
                    </div>
                  )}
                  <ChatMessage 
                    message={{
                      id: 'placeholder-assistant',
                      role: 'assistant',
                      content: '',
                    }}
                    isLoading={true}
                    streamData={[{ status: 'Processing...' }]}
                  />
                </div>
              )}
            </div>
          </div>
        </ChatContainer>
      </div>
    );
  }
);

ChatMessages.displayName = 'ChatMessages';

================
File: components/ui/chat/chat-mode-tab.tsx
================
'use client'

import React from 'react'
import { BaseTab } from '../common/base-tab'
import { Search, MessageSquare, Sparkles, GitCompare } from 'lucide-react'

interface ChatModeTabProps {
mode: 'chat' | 'search' | 'semantic' | 'hybrid'
onModeChange: (mode: 'chat' | 'search' | 'semantic' | 'hybrid') => void
}

const getModeIcon = (mode: string) => {
switch (mode) {
  case 'search':
    return <Search className="w-3.5 h-3.5" />
  case 'semantic':
    return <Sparkles className="w-3.5 h-3.5" />
  case 'hybrid':
    return <GitCompare className="w-3.5 h-3.5" />
  default:
    return <MessageSquare className="w-3.5 h-3.5" />
}
}

const getModeLabel = (mode: string) => {
const label = mode.charAt(0).toUpperCase() + mode.slice(1)
return `Mode: ${label}`
}

export const ChatModeTab: React.FC<ChatModeTabProps> = ({ mode, onModeChange }) => {
// Cycle through modes when tab is clicked
const handleClick = () => {
  // Define the order of modes to cycle through
  const modes: Array<'chat' | 'search' | 'semantic' | 'hybrid'> = [
    'chat', 'search', 'semantic', 'hybrid'
  ];
  
  // Find current mode index
  const currentIndex = modes.indexOf(mode);
  
  // Get next mode (cycling back to beginning if at the end)
  const nextIndex = (currentIndex + 1) % modes.length;
  
  // Call the onModeChange callback with the next mode
  onModeChange(modes[nextIndex]);
}

return (
  <BaseTab
    icon={getModeIcon(mode)}
    label={getModeLabel(mode)}
    shortcut="C"
    isActive={true}
    minWidth="model"
    onClick={handleClick}
  />
)
}

================
File: components/ui/chat/loading-message.tsx
================
import { FC } from 'react'

export const LoadingMessage: FC = () => {
  return (
    <div className="flex items-start gap-4 w-full mx-auto group">
      <div className="flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-md border bg-gradient-to-b from-white/[0.07] to-white/[0.03] border-white/[0.05] relative">
        <div className="absolute inset-0 rounded-md bg-blue-500/20" />
        <div className="w-5 h-5 rounded-full bg-gradient-to-br from-blue-400 to-indigo-500 relative">
          <div className="absolute inset-0 rounded-full bg-gradient-to-t from-transparent to-white/30" />
          <div className="absolute -inset-1 rounded-full bg-blue-500/20 animate-pulse" />
        </div>
      </div>
      <div className="flex-1 space-y-2 overflow-hidden max-w-[85%]">
        <div className="prose prose-invert max-w-none space-y-2">
          <div className="h-[22px] bg-white/10 rounded w-[35%] animate-pulse" />
          <div className="h-[22px] bg-white/10 rounded w-[55%] animate-pulse" />
          <div className="h-[22px] bg-white/10 rounded w-[75%] animate-pulse" />
        </div>
      </div>
    </div>
  )
}

================
File: components/ui/chat/markdown.tsx
================
import { marked } from "marked"
import { memo, useId, useMemo } from "react"
import ReactMarkdown, { Components } from "react-markdown"
import remarkGfm from "remark-gfm"
import { CodeBlock } from "../common/code-block"
import { cn } from "@/lib/utils"

export type MarkdownProps = {
  children: string
  id?: string
  className?: string
  components?: Partial<Components>
}

function parseMarkdownIntoBlocks(markdown: string): string[] {
  const tokens = marked.lexer(markdown)
  return tokens.map((token) => token.raw)
}

function extractLanguage(className?: string): string {
  if (!className) return "plaintext"
  const match = className.match(/language-(\w+)/)
  return match ? match[1] : "plaintext"
}

const INITIAL_COMPONENTS: Partial<Components> = {
  code: function CodeComponent({ className, children, ...props }) {
    const isInline =
      !props.node?.position?.start.line ||
      props.node?.position?.start.line === props.node?.position?.end.line

    if (isInline) {
      return (
        <span
          className={cn(
            "glass-effect px-1.5 py-0.5 text-[13px] font-mono text-zinc-200 rounded-md",
            "backdrop-blur-[4px] bg-white/[0.03] border border-white/[0.05]",
            className
          )}
          {...props}
        >
          {children}
        </span>
      )
    }

    const language = extractLanguage(className)

    return (
      <CodeBlock
        code={children as string}
        language={language}
        className={cn("glass-effect code-block-glow", className)}
      />
    )
  },
  pre: function PreComponent({ children }) {
    return <>{children}</>
  },
  // Enhance link styling
  a: function LinkComponent({ href, children, ...props }) {
    return (
      <a 
        href={href} 
        className="text-cyan-400 hover:text-cyan-300 underline underline-offset-2 transition-colors" 
        target="_blank" 
        rel="noopener noreferrer"
        {...props}
      >
        {children}
      </a>
    )
  },
  // Better list styling
  ul: function UlComponent({ children, ...props }) {
    return (
      <ul className="pl-6 list-disc space-y-1 my-4" {...props}>
        {children}
      </ul>
    )
  },
  ol: function OlComponent({ children, ...props }) {
    return (
      <ol className="pl-6 list-decimal space-y-1 my-4" {...props}>
        {children}
      </ol>
    )
  },
  // Headings with proper margins and styling
  h1: function H1Component({ children, ...props }) {
    return (
      <h1 className="text-2xl font-bold tracking-tight mt-8 mb-4 border-b border-zinc-800 pb-2" {...props}>
        {children}
      </h1>
    )
  },
  h2: function H2Component({ children, ...props }) {
    return (
      <h2 className="text-xl font-bold tracking-tight mt-6 mb-3" {...props}>
        {children}
      </h2>
    )
  },
  h3: function H3Component({ children, ...props }) {
    return (
      <h3 className="text-lg font-bold tracking-tight mt-5 mb-2" {...props}>
        {children}
      </h3>
    )
  },
  // Enhanced paragraph spacing
  p: function PComponent({ children, ...props }) {
    return (
      <p className="leading-7 [&:not(:first-child)]:mt-4" {...props}>
        {children}
      </p>
    )
  },
  // Better blockquote
  blockquote: function BlockquoteComponent({ children, ...props }) {
    return (
      <blockquote className="border-l-4 border-zinc-700 bg-zinc-900/30 pl-4 py-1 my-4 italic" {...props}>
        {children}
      </blockquote>
    )
  },
}

const MemoizedMarkdownBlock = memo(
  function MarkdownBlock({
    content,
    components,
    className,
  }: {
    content: string
    components: Partial<Components>
    className?: string
  }) {
    return (
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        components={components}
        className={cn("prose-zinc max-w-none", className)}
      >
        {content}
      </ReactMarkdown>
    )
  },
  (prevProps, nextProps) => prevProps.content === nextProps.content
)

MemoizedMarkdownBlock.displayName = "MemoizedMarkdownBlock"

function MarkdownComponent({
  children,
  id,
  className,
  components = INITIAL_COMPONENTS,
}: MarkdownProps) {
  const blocks = useMemo(() => {
    try {
      return parseMarkdownIntoBlocks(children)
    } catch (error) {
      console.error(error)
      return [children]
    }
  }, [children])

  // Use a stable ID for the content blocks
  const contentId = useId()
  const uniqueId = id || contentId

  return (
    <div id={uniqueId} className={cn("text-sm text-zinc-100 leading-7", className)}>
      {blocks.map((content, i) => (
        <MemoizedMarkdownBlock
          key={`${uniqueId}-block-${i}`}
          content={content}
          components={components}
        />
      ))}
    </div>
  )
}

const Markdown = memo(MarkdownComponent)
Markdown.displayName = "Markdown"

export { Markdown }

================
File: components/ui/chat/model-tab.tsx
================
import { getModelName, type Provider } from '@/config/models'
import { ProviderIcon } from './provider-icon'
import React from 'react'
import { BaseTab } from '@/components/ui/common/base-tab'
import { useCommandCenter } from '@/hooks/useCommandCenter'

export function ServerDrivenModelTab({ 
  activeSpace,
  onUpdateSpace 
}: { 
  activeSpace: any,
  onUpdateSpace: (spaceId: string, updates: any) => Promise<any>
}) {
  const { openCommandType } = useCommandCenter()
  const hasModel = !!(activeSpace?.provider && activeSpace?.model)
  
  // Get model name safely, handling undefined values
  const modelName = hasModel && activeSpace?.model 
    ? getModelName(activeSpace.provider as Provider, activeSpace.model) 
    : 'No Model Selected';

  return (
    <BaseTab
      icon={hasModel ? (
        <ProviderIcon provider={activeSpace.provider as Provider} size={15} />
      ) : undefined}
      label={modelName}
      shortcut="M"
      commandType="models"
      onClick={() => openCommandType("models")}
    />
  )
}

================
File: components/ui/chat/provider-icon.tsx
================
import { 
  Anthropic, 
  OpenAI, 
  Cohere, 
  Mistral, 
  Google, 
  XAI, 
  Together, 
  DeepSeek, 
  Perplexity, 
  Groq 
} from '@lobehub/icons';
import { Provider } from '@/config/models';

interface ProviderIconProps {
  provider: Provider;
  size?: number;
  className?: string;
}

const PROVIDER_COMPONENTS = {
  groq: Groq,
  anthropic: Anthropic,
  openai: OpenAI,
  cohere: Cohere.Color,
  mistral: Mistral.Color,
  google: Google.Color,
  xai: XAI,
  togetherai: Together.Color,
  deepseek: DeepSeek.Color,
  cerebras: OpenAI,
  perplexity: Perplexity.Color
} as const;

export function ProviderIcon({ provider, size = 24, className = '' }: ProviderIconProps) {
  const IconComponent = PROVIDER_COMPONENTS[provider];
  if (!IconComponent) return null;
  
  return (
    <div className={`relative inline-block ${className}`} style={{ width: size, height: size }}>
      <IconComponent size={size} />
    </div>
  );
}

================
File: components/ui/chat/stream-status.tsx
================
'use client';

import { useEffect, useState, useRef, memo } from 'react';
import { JSONValue } from 'ai';

interface StreamStatusProps {
  streamData?: JSONValue[] | undefined;
}

// Extract the latest status from stream data
function getLatestStatus(streamData?: JSONValue[]): string {
  if (!streamData || !Array.isArray(streamData) || streamData.length === 0) {
    return 'Processing...';
  }
  
  const lastItem = streamData[streamData.length - 1];
  
  // Handle case when we pass a status object directly
  if (typeof lastItem === 'object' && lastItem !== null && 'status' in lastItem) {
    return String(lastItem.status);
  }
  
  return String(lastItem);
}

export const StreamStatus = memo(({ streamData }: StreamStatusProps) => {
  const [statusHistory, setStatusHistory] = useState<string[]>([]);
  const [currentStatus, setCurrentStatus] = useState<string>('Processing...');
  const lastUpdateTimeRef = useRef<number>(Date.now());
  const transitionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const initialProcessingShownRef = useRef<boolean>(false);
  const lastProcessedDataLengthRef = useRef<number>(0);
  
  useEffect(() => {
    // Bail out early if no new data
    if (!streamData || !Array.isArray(streamData) || 
        streamData.length === 0 || 
        streamData.length === lastProcessedDataLengthRef.current) {
      return;
    }
    
    // Update our reference to avoid processing the same data multiple times
    lastProcessedDataLengthRef.current = streamData.length;
    
    const newStatus = getLatestStatus(streamData);
    const currentTime = Date.now();
    
    // Only update if the status has changed to avoid unnecessary renders
    if (newStatus !== currentStatus) {
      // Clear any existing transition timeout
      if (transitionTimeoutRef.current) {
        clearTimeout(transitionTimeoutRef.current);
      }
      
      // Ensure minimum transition time of 600ms between status changes
      const timeSinceLastUpdate = currentTime - lastUpdateTimeRef.current;
      const transitionDelay = Math.max(0, 600 - timeSinceLastUpdate);
      
      transitionTimeoutRef.current = setTimeout(() => {
        // First, add the current status to history (including the initial "Processing...")
        setStatusHistory(prev => {
          // Only add "Processing..." to history once when the first real status arrives
          if (currentStatus === 'Processing...' && !initialProcessingShownRef.current) {
            initialProcessingShownRef.current = true;
            return [currentStatus, ...prev].slice(0, 3); // Keep last 3 statuses
          }
          return [currentStatus, ...prev].slice(0, 3); // Keep last 3 statuses
        });
        
        // Then, update current status to the new status
        setCurrentStatus(newStatus);
        lastUpdateTimeRef.current = Date.now();
      }, transitionDelay);
    }
  }, [streamData, currentStatus]);
  
  return (
    <div className="group rounded-lg backdrop-blur-sm border border-white/[0.05] overflow-hidden transform-gpu transition-all duration-300 ease-out hover:border-white/[0.1]">
      {/* Main status container styled like a tab */}
      <div className="px-3 py-2 relative overflow-hidden bg-white/[0.025] hover:bg-white/[0.035] transition-all duration-300">
        <div className="flex items-center gap-3 relative z-10">
          {/* Status indicator with pulse animation */}
          <div className="relative w-3.5 h-3.5 flex-shrink-0">
            <div className="absolute inset-0 rounded-full bg-cyan-400/20 animate-pulse-slow" />
            <div className="absolute inset-0.5 rounded-full bg-cyan-400 group-hover:bg-[#3ecfff] transition-colors duration-300 animate-pulse-fast" />
          </div>
          
          {/* Current status with tab-like styling */}
          <div className="font-medium text-xs text-white/75 w-full group-hover:text-white/95 transition-colors duration-300">
            {currentStatus}
          </div>
        </div>
      </div>

      {/* Status history with improved transitions in a tab-like container */}
      {statusHistory.length > 0 && (
        <div className="bg-white/[0.015] px-3 py-1.5 space-y-1.5 border-t border-white/[0.025]">
          {statusHistory.map((status, index) => (
            <div 
              key={`status-${index}-${status}`}
              className="text-[10px] text-white/60 transition-all duration-500 flex items-center group-hover:text-white/70"
              style={{ 
                opacity: Math.max(0.7 - index * 0.2, 0.3),
              }}
            >
              <div className="w-1.5 h-1.5 rounded-full bg-white/30 mr-2 group-hover:bg-white/40 transition-colors duration-300" />
              {status}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // Only re-render if streamData has changed in a meaningful way
  if (!prevProps.streamData && !nextProps.streamData) return true;
  if (!prevProps.streamData || !nextProps.streamData) return false;
  
  const prevLength = prevProps.streamData.length;
  const nextLength = nextProps.streamData.length;
  
  // If the lengths are the same, don't re-render
  if (prevLength === nextLength) return true;
  
  // If we have a lot of updates, only re-render every 5 updates
  // to avoid excessive re-renders during fast streaming
  if (prevLength > 10 && nextLength > prevLength && (nextLength - prevLength) < 5) {
    return true;
  }
  
  return false;
});

StreamStatus.displayName = 'StreamStatus';

================
File: components/ui/chat/unified-input.tsx
================
"use client";

import React, { ChangeEvent, useRef, useState, useEffect, useCallback } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { Button } from '@/components/ui/common/button';

interface UnifiedInputProps {
  value: string;
  onChange: (e: ChangeEvent<HTMLInputElement> | ChangeEvent<HTMLTextAreaElement>) => void;
  onSubmit: () => void;
  disabled?: boolean;
  children?: React.ReactNode;
}

export const UnifiedInput: React.FC<UnifiedInputProps> = ({
  value,
  onChange,
  onSubmit,
  disabled = false,
  children
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const focusInput = useCallback(() => {
    textareaRef.current?.focus();
  }, []);

  useHotkeys('meta+/', (e) => {
    e.preventDefault();
    focusInput();
  }, { enableOnFormTags: true });

  useEffect(() => {
    const textarea = textareaRef.current;
    if (!textarea) return;

    const adjustHeight = () => {
      textarea.style.height = 'auto';
      const newHeight = Math.min(textarea.scrollHeight, 200);
      textarea.style.height = `${newHeight}px`;
    };

    adjustHeight();
  }, [value]);

  const handleSubmit = () => {
    if (!value.trim() || disabled) return;
    onSubmit();
  };

  return (
    <div className="relative">
      {children}
      <div 
        className={`
          relative rounded-2xl rounded-t-none
          bg-white/[0.03] border border-white/[0.05]
          transition-all duration-300
          overflow-hidden backdrop-blur-xl
          ${isFocused ? 'bg-white/[0.05] border-white/[0.1]' : ''}
        `}
      >
        <div className="flex items-center gap-2">
          <textarea
            ref={textareaRef}
            value={value}
            onChange={onChange}
            onFocus={() => setIsFocused(true)}
            onBlur={() => setIsFocused(false)}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSubmit();
              }
            }}
            placeholder={"Type your message... (Press ⌘+/ to focus)"}
            className="flex-1 text-sm resize-none min-h-[48px] max-h-[200px] px-4 py-3 focus:bg-transparent bg-transparent focus:outline-none transition-colors duration-200 overflow-y-auto scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent text-white/90 placeholder:text-white/40"
            style={{ overflow: value.split('\n').length > 8 ? 'auto' : 'hidden' }}
            rows={1}
          />

            <Button
              variant="cyan"
              onClick={(e) => {
                e.preventDefault();
                handleSubmit();
              }}
              disabled={disabled}
              className="h-8"
            >
              Send
            </Button>
          </div>
        </div>
        </div>
  );
};

================
File: components/ui/common/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full border border-white/[0.05]",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-white/[0.03] text-white/80 backdrop-blur-sm",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: components/ui/common/badge.tsx
================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

================
File: components/ui/common/base-tab.tsx
================
import { ReactNode, CSSProperties } from 'react'
import { CommandType } from '@/hooks/useCommandCenter'

interface BaseTabProps {
  icon?: ReactNode
  label: string
  shortcut?: string
  onClick?: () => void
  minWidth?: 'space' | 'model' | 'actions'
  roundedBottom?: boolean
  isActive?: boolean
  style?: CSSProperties
  wrapperStyle?: CSSProperties
  className?: string
  color?: string
  rightElement?: ReactNode
  commandType?: CommandType
}

export function BaseTab({
  icon,
  color,
  label,
  shortcut,
  onClick,
  minWidth,
  style,
  wrapperStyle,
  className = '',
  rightElement,
  commandType
}: BaseTabProps) {
  const minWidthClass = {
    space: 'min-w-[100px]',
    model: 'min-w-[120px]',
    actions: ''
  }[minWidth || 'actions']

  return (
    <div
      className={`relative`}
      style={{ 
        ...wrapperStyle 
      }}
    >
      <div
        onClick={onClick}
        className={`px-3 py-1.5 text-white text-xs font-medium flex items-center gap-1.5 relative overflow-hidden cursor-pointer ${minWidthClass}
           transition-all duration-300 group ${className}`}
        style={{ 
          ...style,
        }}
      >
        {icon && (
          <div className="relative z-10 text-white/60 group-hover:text-[#3ecfff]/80 transition-colors duration-300">
            {icon}
          </div>
        )}
        <span className="text-white/75 truncate relative z-10 group-hover:text-white/95 transition-colors duration-300">
          {label}
        </span>
        {shortcut && (
          <span className="text-white/60 text-[10px] ml-auto shrink-0 relative z-10">⌘{shortcut}</span>
        )}
        {rightElement && (
          <div className="ml-auto relative z-10">
            {rightElement}
          </div>
        )}
      </div>
    </div>
  )
}

================
File: components/ui/common/button.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center text-sm font-medium transition-all duration-200 focus-visible:outline-none disabled:opacity-50 disabled:pointer-events-none",
  {
    variants: {
      variant: {
        default: "bg-primary text-white hover:bg-primary/90",
        outline: "border border-white/[0.05] bg-white/[0.02] text-white/90 hover:bg-white/[0.05] hover:text-white backdrop-blur-sm",
        ghost: "text-white/70 hover:bg-white/[0.04] hover:text-white",
        toggle: "text-white/70 hover:bg-white/[0.04] hover:text-white border-t border-white/[0.05] rounded-t-md rounded-b-none",
        cyan: "bg-[#3ecfff]/10 text-[#3ecfff] border border-[#3ecfff]/20 shadow-[0_0_12px_rgba(62,207,255,0.1)] hover:bg-[#3ecfff]/20 rounded-xl",
        destructive: "bg-red-500/10 text-red-500 hover:bg-red-500/20 border border-red-500/20",
      },
      size: {
        default: "h-10 py-2 px-4 rounded-md",
        sm: "h-8 px-3 rounded-md",
        icon: "h-8 w-8 rounded-md",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  active?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, active, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }), active && "bg-white/[0.05] text-white")}
        ref={ref}
        {...props}
      />
    )
  },
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/common/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: components/ui/common/checkbox.tsx
================
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

================
File: components/ui/common/code-block.tsx
================
"use client"

import { cn } from "@/lib/utils"
import React, { useEffect, useState } from "react"
import { codeToHtml } from "shiki"
import { LanguageIcon } from "../chat/language-icon"
import { Copy, CheckIcon } from "lucide-react"

interface CopyButtonProps {
  code: string
}

function CopyButton({ code }: CopyButtonProps) {
  const [copied, setCopied] = useState(false)

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(code)
      setCopied(true)
      setTimeout(() => setCopied(false), 2000)
    } catch (error) {
      console.error('Failed to copy:', error)
    }
  }

  return (
    <button
      onClick={handleCopy}
      className={cn(
        "flex items-center justify-center rounded-md p-1.5",
        "transition-all duration-200 ease-in-out",
        "bg-white/[0.03] hover:bg-white/[0.08] border border-white/[0.05]",
        copied 
          ? "text-green-400 hover:text-green-300 border-green-500/20 bg-green-500/10" 
          : "text-zinc-400 hover:text-zinc-200"
      )}
      title="Copy code"
    >
      {copied ? <CheckIcon size={14} /> : <Copy size={14} />}
    </button>
  )
}

export type CodeBlockProps = {
  children?: React.ReactNode
  className?: string
  code?: string
  language?: string
} & React.HTMLProps<HTMLDivElement>

function CodeBlock({ children, className, code, language, ...props }: CodeBlockProps) {
  // Generate a unique key based on code content or props if available
  const uniqueKey = React.useMemo(() => {
    return code ? `${language}-${code.slice(0, 20)}-${Math.random().toString(36).slice(2, 7)}` : `codeblock-${Math.random().toString(36).slice(2)}`
  }, [code, language])

  if (code && language) {
    return (
      <div
        className={cn(
          "not-prose flex w-full flex-col overflow-hidden my-4 rounded-lg",
          "glass-effect code-block-glow glass-highlight",
          className
        )}
        style={{
          background: 'rgba(255, 255, 255, 0.02)',
          backdropFilter: 'blur(12px)',
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
          border: '1px solid rgba(255, 255, 255, 0.05)'
        }}
        key={uniqueKey} // Add unique key at the top level
        {...props}
      >
        <div className="flex items-center justify-between w-full px-4 py-2 header" style={{background: 'rgba(255, 255, 255, 0.03)', borderBottom: '1px solid rgba(255, 255, 255, 0.05)'}}>
          <div className="flex items-center space-x-2">
            <div className="flex space-x-1.5">
              <div className="w-3 h-3 rounded-full bg-red-500/90 border border-red-600/30 shadow-inner shadow-red-700/20"></div>
              <div className="w-3 h-3 rounded-full bg-yellow-500/90 border border-yellow-600/30 shadow-inner shadow-yellow-700/20"></div>
              <div className="w-3 h-3 rounded-full bg-green-500/90 border border-green-600/30 shadow-inner shadow-green-700/20"></div>
            </div>
            <div className="text-xs text-zinc-400 ml-2">
              {code.split('\n')[0].startsWith('//') ? code.split('\n')[0].substring(2).trim() : ''}
            </div>
          </div>
          <div className="flex items-center gap-2">
          {language && (
                    <div 
                      className="flex items-center gap-1.5 text-xs rounded-md p-1.5 bg-white/[0.03] border border-white/[0.05] text-zinc-400"
                      key={`language-badge-${uniqueKey}`}
                    >
                      <span>{language}</span>
                    </div>
                  )}
            <CopyButton code={code} />
          </div>
        </div>
        <CodeBlockCode code={code} language={language} />
      </div>
    )
  }
  
  return (
    <div
      className={cn(
        "not-prose flex w-full flex-col overflow-hidden my-4 rounded-lg",
        "glass-effect code-block-glow glass-highlight",
        className
      )}
      style={{
        background: 'rgba(255, 255, 255, 0.02)',
        backdropFilter: 'blur(12px)',
        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }}
      key={uniqueKey} // Add unique key here too
      {...props}
    >
      {children}
    </div>
  )
}

export type CodeBlockCodeProps = {
  code: string
  language?: string
  theme?: string
  className?: string
} & React.HTMLProps<HTMLDivElement>

function CodeBlockCode({
  code,
  language = "tsx",
  theme = "github-dark",
  className,
  ...props
}: CodeBlockCodeProps) {
  const [highlightedHtml, setHighlightedHtml] = useState<string | null>(null)
  const [isLargeCode, setIsLargeCode] = useState(false)
  const codeLength = code?.length || 0

  useEffect(() => {
    if (codeLength > 10000) {
      setIsLargeCode(true)
    } else {
      setIsLargeCode(false)
    }

    let isMounted = true
    
    const timer = setTimeout(async () => {
      try {
        const customTheme = {
          name: 'glass-dark',
          type: 'dark',
          fg: '#EEEEEE',
          bg: '#00000000',
          settings: [
            {
              settings: {
                background: '#00000000',
                foreground: '#EEEEEE',
                caret: '#FFFFFF',
                selection: 'rgba(128, 203, 255, 0.2)',
                selectionBorder: 'rgba(128, 203, 255, 0.4)',
                lineHighlight: 'rgba(255, 255, 255, 0.05)',
                gutterForeground: 'rgba(175, 175, 175, 0.5)',
                gutterBorder: 'rgba(255, 255, 255, 0.05)',
              }
            },
            {
              scope: ['comment', 'punctuation.definition.comment', 'string.comment'],
              settings: {
                foreground: 'rgba(106, 153, 85, 0.9)'
              }
            },
            {
              scope: ['string', 'constant.other.symbol'],
              settings: {
                foreground: 'rgba(206, 145, 120, 0.9)'
              }
            },
            {
              scope: ['keyword', 'storage.type', 'storage.modifier'],
              settings: {
                foreground: 'rgba(86, 156, 214, 0.9)'
              }
            },
            {
              scope: ['entity.name.function', 'support.function'],
              settings: {
                foreground: 'rgba(220, 220, 170, 0.9)'
              }
            },
            {
              scope: ['variable', 'support.variable'],
              settings: {
                foreground: 'rgba(156, 220, 254, 0.9)'
              }
            }
          ]
        };

        const html = await codeToHtml(code, { 
          lang: language, 
          theme: "github-dark",
          transformers: [{
            root(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            pre(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            code(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            line(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              if (style.includes('background')) {
                nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              }
              return node;
            },
            tokens(node) {
              return node.map((token: any, index: number) => {
                const tokenAsAny = token as any;
                if (!tokenAsAny.properties) tokenAsAny.properties = {};
                const style = tokenAsAny.properties.style || '';
                if (style.includes('background')) {
                  tokenAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, '');
                }
                tokenAsAny.properties.key = `token-${index}`;
                return token;
              });
            }
          }]
        });

        if (isMounted) {
          const processedHtml = html
            .replace(/background-color: #24292e;/g, 'background-color: transparent !important;')
            .replace(/background-color: #1f2428;/g, 'background-color: transparent !important;')
            .replace(/background: #24292e;/g, 'background: transparent !important;')
            .replace(/background: #1f2428;/g, 'background: transparent !important;');
          
          setHighlightedHtml(processedHtml);
        }
      } catch (error) {
        console.error('Error highlighting code:', error)
      }
    }, isLargeCode ? 100 : 0)

    return () => {
      isMounted = false
      clearTimeout(timer)
    }
  }, [code, language, theme, codeLength, isLargeCode])

  const classNames = cn(
    "w-full overflow-x-auto text-[13px] relative",
    "bg-transparent [&>pre]:bg-transparent [&>pre]:px-4 [&>pre]:py-4 [&>pre]:rounded-b-lg",
    "[&>pre>code]:bg-transparent [&>pre>code]:font-mono [&>pre>code]:text-zinc-200 [&>.shiki]:bg-transparent [&>.shiki]:px-4 [&>.shiki]:py-4 [&>.shiki]:rounded-b-lg",
    "backdrop-blur-[2px]",
    "glass-highlight",
    className
  )

  if (isLargeCode && !highlightedHtml) {
    return (
      <div className={cn(classNames, "glass-code-content")} style={{background: 'transparent'}} {...props}>
        <pre className="bg-transparent text-zinc-200 px-4 py-4 rounded-b-lg font-mono" style={{background: 'transparent'}}>
          <code className={`language-${language} bg-transparent font-mono`} style={{background: 'transparent'}}>
            {code.length > 50000 
              ? code.substring(0, 50000) + '...\n\n(Code truncated for performance - full code will appear shortly)'
              : code}
          </code>
        </pre>
      </div>
    )
  }

  return highlightedHtml ? (
    <div
      className={cn(classNames, "glass-code-content")}
      style={{background: 'transparent'}}
      dangerouslySetInnerHTML={{ __html: highlightedHtml }}
      {...props}
    />
  ) : (
    <div className={cn(classNames, "glass-code-content")} style={{background: 'transparent'}} {...props}>
      <pre className="bg-transparent text-zinc-200 px-4 py-4 rounded-b-lg font-mono" style={{background: 'transparent'}}>
        <code className="font-mono bg-transparent" style={{background: 'transparent'}}>{code}</code>
      </pre>
    </div>
  )
}

export type CodeBlockGroupProps = React.HTMLAttributes<HTMLDivElement>

function CodeBlockGroup({
  children,
  className,
  ...props
}: CodeBlockGroupProps) {
  return (
    <div
      className={cn("flex items-center justify-between", className)}
      {...props}
    >
      {children}
    </div>
  )
}

export { CodeBlockGroup, CodeBlockCode, CodeBlock }

================
File: components/ui/common/command-badge.tsx
================
import { cn } from '@/utils';

interface CommandBadgeProps {
  children: React.ReactNode;
  variant?: 'active' | 'info' | 'count';
  className?: string;
}

export function CommandBadge({ children, variant = 'info', className }: CommandBadgeProps) {
  return (
    <span
      className={cn(
        'px-1.5 py-0.5 rounded-md text-[10px] font-medium',
        variant === 'active' && 'bg-[#3ecfff]/10 text-[#3ecfff] border border-[#3ecfff]/20',
        variant === 'info' && 'text-white/40 border border-white/10',
        variant === 'count' && 'bg-white/5 text-white/60',
        className
      )}
    >
      {children}
    </span>
  );
}

================
File: components/ui/common/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-transparent data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-white/[0.05] bg-white/[0.03] p-6 shadow-none backdrop-blur-xl duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg glass-dialog",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:text-white/70 hover:text-white">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight text-white/90",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-white/70", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: components/ui/common/dropdown-menu.tsx
================
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white/95 focus:bg-white/[0.05]",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4 text-white/60" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border border-white/[0.05] bg-white/[0.03] p-1 text-white/90 shadow-none backdrop-blur-xl data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border border-white/[0.05] bg-white/[0.03] p-1 text-white/90 shadow-none backdrop-blur-xl data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white/95 focus:bg-white/[0.05] focus:text-white/95 data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white/95 focus:bg-white/[0.05] focus:text-white/95 data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white/95 focus:bg-white/[0.05] focus:text-white/95 data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-white/90",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-white/[0.05]", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest text-white/50", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

================
File: components/ui/common/input.tsx
================
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 placeholder:text-white/40 outline-none focus:bg-white/[0.03] focus:border-white/[0.1] transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };

================
File: components/ui/common/label.tsx
================
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none text-white/80 peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

================
File: components/ui/common/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: components/ui/common/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 transition-all duration-200 focus:bg-white/[0.03] focus:border-white/[0.1] focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 text-white/50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border border-white/[0.05] bg-white/[0.03] backdrop-blur-xl text-white/90 shadow-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white data-[state=checked]:bg-white/[0.05] data-[state=checked]:text-white focus:bg-white/[0.08] focus:text-white data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: components/ui/common/switch.tsx
================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

================
File: components/ui/common/tabs.tsx
================
import { ModelTab } from "@/components/ui/chat/model-tab";
import { SpaceTab } from "@/components/ui/space/space-tab";
import QuickActionsTab from "@/components/ui/quick-actions-tab";

export const Tabs = () => {
    return (
            <div className="flex items-center gap-2">
                <SpaceTab />
                <QuickActionsTab />
                <ModelTab />  
            </div>
    );
};

================
File: components/ui/common/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 placeholder:text-white/40 outline-none focus:bg-white/[0.03] focus:border-white/[0.1] transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

================
File: components/ui/common/theme-switcher.tsx
================
"use client";

import { Button } from "@/components/ui/common/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/ui/common/dropdown-menu";
import { Laptop, Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";

const ThemeSwitcher = () => {
  const [mounted, setMounted] = useState(false);
  const { theme, setTheme } = useTheme();

  // useEffect only runs on the client, so now we can safely show the UI
  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  const ICON_SIZE = 16;

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size={"sm"}>
          {theme === "light" ? (
            <Sun
              key="light"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : theme === "dark" ? (
            <Moon
              key="dark"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : (
            <Laptop
              key="system"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-content" align="start">
        <DropdownMenuRadioGroup
          value={theme}
          onValueChange={(e) => setTheme(e)}
        >
          <DropdownMenuRadioItem className="flex gap-2" value="light">
            <Sun size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Light</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="dark">
            <Moon size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Dark</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="system">
            <Laptop size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>System</span>
          </DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

export { ThemeSwitcher };

================
File: components/ui/common/toast.tsx
================
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 right-0 z-[9999] flex max-h-screen w-auto flex-col-reverse items-end gap-2 p-4",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full max-w-[350px] items-center justify-between space-x-2 overflow-hidden rounded-md p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-top-full data-[state=open]:slide-in-from-top-full data-[state=open]:duration-300 data-[state=closed]:duration-200",
  {
    variants: {
      variant: {
        default: 
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
        destructive:
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
        success:
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: components/ui/common/toaster.tsx
================
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/common/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: components/ui/common/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-lg px-3 py-1.5 text-xs animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 bg-black/90 border border-white/10 backdrop-blur-xl shadow-xl shadow-black/20 text-white/90 font-medium",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: components/ui/conversation/conversation-sphere.tsx
================
import React, { useState, useMemo, useCallback } from 'react';

interface DotChatBubbleProps {
  size?: number;
  seed?: string;
  dotCount?: number;
  dotSize?: number;
  className?: string;
  expandFactor?: number;
  transitionSpeed?: number;
  highPerformance?: boolean;
}

interface DotChatBubbleComponent extends React.FC<DotChatBubbleProps> {
  seedCache: Map<string, number>;
  callCount: number;
}

const round = (num: number, precision: number = 6): number => {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
};

const Dot = React.memo(({ 
  dot, 
  isHovering, 
  size, 
  expandFactor, 
  transitionSpeed 
}: { 
  dot: {
    x: number;
    y: number;
    z: number;
    color: string;
    size: number;
    opacity: number;
    zIndex: number;
  };
  isHovering: boolean;
  size: number;
  expandFactor: number;
  transitionSpeed: number;
}) => {
  const expandedX = useMemo(() => 
    round(dot.x + (dot.x - size / 2) * (expandFactor - 1), 6),
    [dot.x, size, expandFactor]
  );
  
  const expandedY = useMemo(() => 
    round(dot.y + (dot.y - size / 2) * (expandFactor - 1), 6),
    [dot.y, size, expandFactor]
  );
  
  const expandedZ = useMemo(() => 
    round(dot.z * expandFactor, 6), 
    [dot.z, expandFactor]
  );

  const currentX = isHovering ? expandedX : dot.x;
  const currentY = isHovering ? expandedY : dot.y;
  const currentZ = isHovering ? expandedZ : dot.z;

  return (
    <div
      className="absolute rounded-full"
      style={{
        backgroundColor: dot.color,
        width: `${round(dot.size, 6)}px`,
        height: `${round(dot.size, 6)}px`,
        opacity: round(dot.opacity, 6),
        transform: `translate3d(${round(currentX, 6)}px, ${round(currentY, 6)}px, ${round(currentZ, 6)}px)`,
        transitionProperty: 'transform',
        transitionDuration: `${transitionSpeed}ms`,
        transitionTimingFunction: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
        transitionDelay: '0s',
        zIndex: dot.zIndex,
        willChange: 'transform'
      }}
    />
  );
});

Dot.displayName = 'Dot';

const DotChatBubble: DotChatBubbleComponent = ({
  size = 120,
  seed,
  dotCount = 150,
  dotSize = 2.5,
  className = '',
  expandFactor = 1.3,
  transitionSpeed = 800,
  highPerformance = false,
}) => {
  const [isHovering, setIsHovering] = useState(false);
  const actualDotCount = highPerformance ? Math.min(dotCount, 60) : dotCount;

  const seedNum = useMemo(() => {
    if (!seed) return Math.floor(Math.random() * 10000);
    if (!DotChatBubble.seedCache.has(seed)) {
      const hash = Array.from(seed).reduce((acc, char) => acc + char.charCodeAt(0), 0);
      DotChatBubble.seedCache.set(seed, hash);
    }
    return DotChatBubble.seedCache.get(seed)!;
  }, [seed]);

  const random = useCallback(() => {
    let x = Math.sin(seedNum + DotChatBubble.callCount++) * 10000;
    return x - Math.floor(x);
  }, [seedNum]);

  const dots = useMemo(() => {
    const points = [];
    const bubbleWidth = size * 0.8; // Main body width
    const bubbleHeight = size * 0.6; // Main body height
    const tailHeight = size * 0.2; // Tail height
    const tailWidth = size * 0.2; // Tail base width
    const cornerRadius = size * 0.1; // Rounded corner radius
    const maxZ = size * 0.2; // Depth for 3D effect

    DotChatBubble.callCount = 1;

    for (let i = 0; i < actualDotCount; i++) {
      let x: number, y: number;

      // Keep generating points until they fall within the chat bubble shape
      while (true) {
        x = (random() - 0.5) * bubbleWidth;
        y = (random() - 0.5) * (bubbleHeight + tailHeight);

        // Check if the point falls within the main body (with rounded corners)
        const isInMainBody = () => {
          const absX = Math.abs(x);
          const absY = Math.abs(y - tailHeight / 2);
          if (absX <= bubbleWidth / 2 - cornerRadius && absY <= bubbleHeight / 2) return true;
          if (absX > bubbleWidth / 2 || absY > bubbleHeight / 2) return false;
          const dx = absX - (bubbleWidth / 2 - cornerRadius);
          const dy = absY - (bubbleHeight / 2 - cornerRadius);
          return dx * dx + dy * dy <= cornerRadius * cornerRadius;
        };

        // Check if the point falls within the triangular tail
        const isInTail = () => {
          if (y > 0 || y < -bubbleHeight / 2 - tailHeight) return false;
          const tailProgress = (y + bubbleHeight / 2 + tailHeight) / tailHeight; // 0 at top, 1 at bottom
          const currentTailWidth = tailWidth * (1 - tailProgress); // Linearly taper the tail
          return Math.abs(x - bubbleWidth / 4) <= currentTailWidth / 2; // Tail is offset to the right
        };

        if (isInMainBody() || isInTail()) break;
      }

      // Adjust coordinates to center the shape
      const posX = round(x + size / 2, 6);
      const posY = round(y + size / 2, 6);
      const posZ = round((random() - 0.5) * maxZ, 6); // Small depth for 3D effect

      const hue = round((seedNum % 360) + (i * 137.5) % 360, 2);
      const saturation = round(70 + random() * 30, 2);
      const lightness = round(45 + random() * 30, 2);
      const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

      const sizeVariation = round(0.8 + random() * 0.6, 6);
      const finalDotSize = round(dotSize * sizeVariation, 6);

      const zIndex = Math.floor(posZ);
      const opacity = round(0.6 + (posZ / maxZ) * 0.4, 6);

      points.push({
        x: posX,
        y: posY,
        z: posZ,
        color,
        size: finalDotSize,
        opacity,
        zIndex,
      });
    }

    return points.sort((a, b) => a.zIndex - b.zIndex);
  }, [actualDotCount, dotSize, random, seedNum, size]);

  const handleMouseEnter = useCallback(() => setIsHovering(true), []);
  const handleMouseLeave = useCallback(() => setIsHovering(false), []);

  return (
    <div
      className={`relative ${className}`}
      style={{
        width: size,
        height: size,
        perspective: size * 3,
      }}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <div
        className="relative w-full h-full"
        style={{ transformStyle: 'preserve-3d' }}
      >
        {dots.map((dot, index) => (
          <Dot 
            key={index}
            dot={dot}
            isHovering={isHovering}
            size={size}
            expandFactor={expandFactor}
            transitionSpeed={transitionSpeed}
          />
        ))}
      </div>
    </div>
  );
};

DotChatBubble.seedCache = new Map<string, number>();
DotChatBubble.callCount = 1;

export default DotChatBubble;

================
File: components/ui/conversation/conversation-tab.tsx
================
import { MessageSquare, Plus, Check, Loader2 } from 'lucide-react'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/common/tooltip"
import { BaseTab } from '@/components/ui/common/base-tab'
import { cn } from '@/lib/utils'
import { useCommandCenter } from '@/hooks/useCommandCenter'
import { useState } from 'react'

export function ServerDrivenConversationTab({
  conversations,
  activeConversation,
  onCreateConversation,
}: {
  conversations: any[];
  activeConversation: any;
  onCreateConversation: (title: string) => Promise<void>;
}) {
  const { openCommandType } = useCommandCenter();
  const [isCreating, setIsCreating] = useState(false);

  const hasActiveConversation = !!activeConversation;
  const hasMultipleConversations = conversations && conversations.length > 1;

  const handleNewConversation = async () => {
    if (!activeConversation?.space_id) return;
    
    try {
      setIsCreating(true);
      await onCreateConversation("New Conversation");
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <div className="flex items-center space-x-1">
      <BaseTab 
        icon={<MessageSquare className="w-3 h-3" />}
        label={activeConversation?.title || "No Conversation Selected"}
        shortcut="C"
        commandType="conversations"
        onClick={() => openCommandType("conversations")}
      />
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <button
              onClick={handleNewConversation}
              disabled={isCreating || !activeConversation?.space_id}
              className={cn(
                "inline-flex items-center justify-center rounded-full w-4 h-4",
                "text-white/80 bg-white/5 hover:bg-white/10",
                "border border-white/10 transition-colors",
                "focus:outline-none focus:ring-2 focus:ring-white/20",
                (isCreating || !activeConversation?.space_id) && "opacity-50 cursor-not-allowed"
              )}
            >
              {isCreating ? (
                <Check className="w-2 h-2" />
              ) : (
                <Plus className="w-2 h-2" />
              )}
            </button>
          </TooltipTrigger>
          <TooltipContent>
            <p>New Conversation</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </div>
  );
}

================
File: components/ui/conversation/create-conversation-button.tsx
================
import React, { useCallback } from 'react';
import { useLoadingOperation } from '@/hooks/useLoadingOperation';
import { createConversation } from '@/app/actions/conversations';
import { useOperationToast } from '@/hooks/useOperationToast';

const CreateConversationButton: React.FC = () => {
  const conversationCreation = useLoadingOperation(
    async (conversationData: { name: string; description: string; spaceId: string }) => {
      const { name, spaceId } = conversationData;
      return await createConversation(spaceId, name);
    },
    {
      onSuccess: (result) => {
        if (result && result.status === 'success') {
          showToastFromResult(result);      
          setIsOpen(false);
          resetForm();
        }
      },
      onError: (error) => {
        console.error('Failed to create conversation:', error);
      }
    }
  );

  const handleSubmit = useCallback(async (event: React.FormEvent) => {
    event.preventDefault();
    // Implement the form submission logic here
  }, []);

  return (
    <button onClick={handleSubmit}>Create Conversation</button>
  );
};

export default CreateConversationButton;

================
File: components/ui/space/create-space-button.tsx
================
import { useState } from 'react';
import { Plus, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/common/button';
import { createSpace } from '@/app/actions/spaces';
import { useLoadingOperation } from '@/hooks/useLoadingOperation';
import { useRouteTransition } from '@/hooks/useRouteTransition';
import { useOperationToast } from '@/hooks/useOperationToast';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/common/dialog';
import { Input } from '@/components/ui/common/input';
import { Label } from '@/components/ui/common/label';
import { Textarea } from '@/components/ui/common/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/common/select';

// Default options
const DEFAULT_MODEL = 'claude-3-sonnet-20240229';
const DEFAULT_PROVIDER = 'anthropic';
const PROVIDER_NAMES: Record<string, string> = {
  'anthropic': 'Anthropic',
  'openai': 'OpenAI',
};

export function CreateSpaceButton() {
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('New Space');
  const [description, setDescription] = useState('');
  const [provider, setProvider] = useState(DEFAULT_PROVIDER);
  
  const { showToastFromResult } = useOperationToast();
  const { navigateWhenReady, isTransitioning } = useRouteTransition();
  
  // Use our enhanced loading operation hook
  const spaceCreation = useLoadingOperation(
    async (spaceData: { name: string; description: string; model: string; provider: string }) => {
      const { name, description, model, provider } = spaceData;
      return await createSpace(name, description, model, provider, true);
    }, 
    {
      onSuccess: (result) => {
        if (result && result.status === 'success') {
          showToastFromResult(result);
          setIsOpen(false);
          resetForm();
        }
      },
      onError: (error) => {
        console.error('Failed to create space:', error);
      }
    }
  );
  
  // Combined loading state
  const isLoading = spaceCreation.isLoading || isTransitioning;
  
  const resetForm = () => {
    setName('New Space');
    setDescription('');
    setProvider(DEFAULT_PROVIDER);
  };
  
  const handleCreateSpace = async (e: React.FormEvent) => {
    e.preventDefault();
    
    await navigateWhenReady(async () => {
      const result = await spaceCreation.execute({
        name,
        description,
        model: DEFAULT_MODEL,
        provider,
      });
      
      return result || {};
    });
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        <Button variant="outline" size="sm">
          <Plus className="mr-2 h-4 w-4" />
          New Space
        </Button>
      </DialogTrigger>
      <DialogContent>
        <form onSubmit={handleCreateSpace}>
          <DialogHeader>
            <DialogTitle>Create New Space</DialogTitle>
            <DialogDescription>
              Create a new workspace for your conversations.
            </DialogDescription>
          </DialogHeader>
          
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="name" className="text-right">
                Name
              </Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="col-span-3"
                required
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="description" className="text-right">
                Description
              </Label>
              <Textarea
                id="description"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                className="col-span-3"
                placeholder="Optional"
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="provider" className="text-right">
                Provider
              </Label>
              <Select value={provider} onValueChange={(value) => setProvider(value)}>
                <SelectTrigger id="provider" className="col-span-3">
                  <SelectValue placeholder="Select provider" />
                </SelectTrigger>
                <SelectContent>
                  {Object.entries(PROVIDER_NAMES).map(([key, name]) => (
                    <SelectItem key={key} value={key}>
                      {name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>
          
          <DialogFooter>
            <Button 
              type="submit" 
              disabled={isLoading || !name.trim()}
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Creating...
                </>
              ) : (
                'Create Space'
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================
File: components/ui/space/planet-icon.tsx
================
import React, { useState, useMemo, useCallback } from 'react';

interface DotSphereProps {
  size?: number;
  seed?: string;
  dotCount?: number;
  dotSize?: number;
  className?: string;
  expandFactor?: number;
  transitionSpeed?: number;
  highPerformance?: boolean; // New prop for performance mode
}

// Add static properties to the component type
interface DotSphereComponent extends React.FC<DotSphereProps> {
  seedCache: Map<string, number>;
  callCount: number;
}

const round = (num: number, precision: number = 6): number => {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
};

// Create a separate component for individual dots to optimize rendering
const Dot = React.memo(({ 
  dot, 
  isHovering, 
  size, 
  expandFactor, 
  transitionSpeed 
}: { 
  dot: {
    x: number;
    y: number;
    z: number;
    color: string;
    size: number;
    opacity: number;
    zIndex: number;
  };
  isHovering: boolean;
  size: number;
  expandFactor: number;
  transitionSpeed: number;
}) => {
  // Calculate expanded position when hovering - memoized within the component
  const expandedX = useMemo(() => 
    round(dot.x + (dot.x - size / 2) * (expandFactor - 1), 6),
    [dot.x, size, expandFactor]
  );
  
  const expandedY = useMemo(() => 
    round(dot.y + (dot.y - size / 2) * (expandFactor - 1), 6),
    [dot.y, size, expandFactor]
  );
  
  const expandedZ = useMemo(() => 
    round(dot.z * expandFactor, 6), 
    [dot.z, expandFactor]
  );

  // Use original or expanded position based on hover state
  const currentX = isHovering ? expandedX : dot.x;
  const currentY = isHovering ? expandedY : dot.y;
  const currentZ = isHovering ? expandedZ : dot.z;

  return (
    <div
      className="absolute rounded-full"
      style={{
        backgroundColor: dot.color,
        width: `${round(dot.size, 6)}px`,
        height: `${round(dot.size, 6)}px`,
        opacity: round(dot.opacity, 6),
        transform: `translate3d(${round(currentX, 6)}px, ${round(currentY, 6)}px, ${round(currentZ, 6)}px)`,
        transitionProperty: 'transform',
        transitionDuration: `${transitionSpeed}ms`,
        transitionTimingFunction: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
        transitionDelay: '0s',
        zIndex: dot.zIndex,
        willChange: 'transform' // Hint to browser for hardware acceleration
      }}
    />
  );
});

Dot.displayName = 'Dot'; // For debugging in React DevTools

// Create the component as a properly typed FC
const DotSphere: DotSphereComponent = ({
  size = 120,
  seed,
  dotCount = 150,
  dotSize = 2.5,
  className = '',
  expandFactor = 1.3,
  transitionSpeed = 800,
  highPerformance = false, // Default to false for backward compatibility
}) => {
  const [isHovering, setIsHovering] = useState(false);

  // Adjust dot count for performance mode
  const actualDotCount = highPerformance ? Math.min(dotCount, 60) : dotCount;

  // Compute a stable number from the seed for consistent randomization
  const seedNum = useMemo(() => {
    if (!seed) return Math.floor(Math.random() * 10000);
    
    // Cache seed hash computation in a Map for improved performance
    if (!DotSphere.seedCache.has(seed)) {
      const hash = Array.from(seed).reduce((acc, char) => acc + char.charCodeAt(0), 0);
      DotSphere.seedCache.set(seed, hash);
    }
    
    return DotSphere.seedCache.get(seed)!;
  }, [seed]);

  // Seeded random number generator for reproducibility
  const random = useCallback(() => {
    let x = Math.sin(seedNum + DotSphere.callCount++) * 10000;
    return x - Math.floor(x);
  }, [seedNum]);

  // Generate dots distributed on a sphere (Fibonacci spiral algorithm)
  const dots = useMemo(() => {
    const sphereRadius = round((size / 2 - dotSize) * 0.8, 6);
    const points = [];
    const goldenRatio = (1 + Math.sqrt(5)) / 2;
    
    // Reset call count before generating dots to ensure consistent random sequence
    DotSphere.callCount = 1;

    for (let i = 0; i < actualDotCount; i++) {
      const y = round(1 - (i / (actualDotCount - 1)) * 2, 6);
      const radius = round(Math.sqrt(1 - y * y), 6);
      const theta = round(2 * Math.PI * i / goldenRatio, 6);
      const x = round(Math.cos(theta) * radius, 6);
      const z = round(Math.sin(theta) * radius, 6);

      // Generate color with rounded values
      const hue = round((seedNum % 360) + (i * 137.5) % 360, 2);
      const saturation = round(70 + random() * 30, 2);
      const lightness = round(45 + random() * 30, 2);
      const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

      const sizeVariation = round(0.8 + random() * 0.6, 6);
      const finalDotSize = round(dotSize * sizeVariation, 6);

      const posX = round(x * sphereRadius + size / 2, 6);
      const posY = round(y * sphereRadius + size / 2, 6);
      const posZ = round(z * sphereRadius, 6);

      const zIndex = Math.floor(posZ);
      const opacity = round(0.6 + (posZ / sphereRadius) * 0.4, 6);

      points.push({
        x: posX,
        y: posY,
        z: posZ,
        color,
        size: finalDotSize,
        opacity,
        zIndex,
      });
    }

    return points.sort((a, b) => a.zIndex - b.zIndex);
  }, [actualDotCount, dotSize, random, seedNum, size]);

  // Event handlers for hover
  const handleMouseEnter = useCallback(() => setIsHovering(true), []);
  const handleMouseLeave = useCallback(() => setIsHovering(false), []);

  return (
    <div
      className={`relative ${className}`}
      style={{
        width: size,
        height: size,
        perspective: size * 3, // 3D perspective
      }}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <div
        className="relative w-full h-full"
        style={{ transformStyle: 'preserve-3d' }}
      >
        {dots.map((dot, index) => (
          <Dot 
            key={index}
            dot={dot}
            isHovering={isHovering}
            size={size}
            expandFactor={expandFactor}
            transitionSpeed={transitionSpeed}
          />
        ))}
      </div>
    </div>
  );
};

// Initialize static properties
DotSphere.seedCache = new Map<string, number>();
DotSphere.callCount = 1;

export default DotSphere;

================
File: components/ui/space/space-tab.tsx
================
'use client'

import { BaseTab } from '@/components/ui/common/base-tab'
import { useCommandCenter } from '@/hooks/useCommandCenter'
import DotSphere from './planet-icon'

export function ServerDrivenSpaceTab({ 
  activeSpace,
  isLoading = false
}: { 
  spaces: any[],
  activeSpace: any,
  isLoading?: boolean
}) {
  const { openCommandType } = useCommandCenter()

  const spaceColor = activeSpace?.color || '#3ecfff'

  return (
    <div className="relative flex items-center">
      {activeSpace && (
        <div className="mr-2">
          <DotSphere 
            size={24} 
            seed={activeSpace.id} 
            dotCount={80} 
            dotSize={0.8} 
            expandFactor={1.15} 
            transitionSpeed={400}
            className={isLoading ? "animate-pulse" : ""}
            highPerformance={true}
          />
        </div>
      )}
      <BaseTab
        icon={<span style={{ color: spaceColor }}>●</span>}
        label={isLoading ? `Loading${activeSpace?.name ? ' ' + activeSpace.name : ''}...` : (activeSpace?.name || "No Space Selected")}
        shortcut="E"
        commandType="spaces"
        onClick={() => openCommandType("spaces")}
        rightElement={isLoading ? <span className="loading-dots text-[10px] text-cyan-400"></span> : undefined}
      />
    </div>
  )
}

================
File: components/ui/chat-container.tsx
================
"use client"

import { cn } from "@/lib/utils"
import { useEffect, useRef, useState, useCallback } from "react"
import React from "react"

const useAutoScroll = (
  containerRef: React.RefObject<HTMLDivElement | null>,
  enabled: boolean
) => {
  const [autoScrollEnabled, setAutoScrollEnabled] = useState(true)
  const lastScrollTopRef = useRef(0)
  const autoScrollingRef = useRef(false)
  const [newMessageAdded, setNewMessageAdded] = useState(false)
  const prevChildrenCountRef = useRef(0)
  const scrollTriggeredRef = useRef(false)

  const isAtBottom = useCallback((element: HTMLDivElement) => {
    const { scrollTop, scrollHeight, clientHeight } = element
    return scrollHeight - scrollTop - clientHeight <= 50
  }, [])

  const scrollToBottom = useCallback((behavior: ScrollBehavior = "smooth") => {
    const container = containerRef.current
    if (!container) return

    autoScrollingRef.current = true
    scrollTriggeredRef.current = true
    
    const targetScrollTop = container.scrollHeight - container.clientHeight

    container.scrollTo({
      top: targetScrollTop,
      behavior: behavior
    })

    const checkScrollEnd = () => {
      if (Math.abs(container.scrollTop - targetScrollTop) < 5) {
        autoScrollingRef.current = false
        scrollTriggeredRef.current = false
        return
      }

      requestAnimationFrame(checkScrollEnd)
    }

    requestAnimationFrame(checkScrollEnd)

    const safetyTimeout = setTimeout(() => {
      autoScrollingRef.current = false
      scrollTriggeredRef.current = false
    }, 500)

    try {
      const handleScrollEnd = () => {
        autoScrollingRef.current = false
        scrollTriggeredRef.current = false
        clearTimeout(safetyTimeout)
        container.removeEventListener("scrollend", handleScrollEnd)
      }

      container.addEventListener("scrollend", handleScrollEnd, {
        once: true,
      })
    } catch (e) {
      // scrollend event not supported in this browser, fallback to requestAnimationFrame
    }
  }, [containerRef])

  useEffect(() => {
    if (!enabled) return

    const container = containerRef?.current
    if (!container) return

    lastScrollTopRef.current = container.scrollTop

    const handleScroll = () => {
      if (autoScrollingRef.current) return

      const currentScrollTop = container.scrollTop
      
      if (currentScrollTop < lastScrollTopRef.current && autoScrollEnabled) {
        setAutoScrollEnabled(false)
      }

      if (isAtBottom(container) && !autoScrollEnabled) {
        setAutoScrollEnabled(true)
      }

      lastScrollTopRef.current = currentScrollTop
    }

    const handleWheel = (e: WheelEvent) => {
      if (e.deltaY < 0 && autoScrollEnabled) {
        setAutoScrollEnabled(false)
      }
    }

    const handleTouchStart = () => {
      lastScrollTopRef.current = container.scrollTop
    }

    const handleTouchMove = () => {
      if (container.scrollTop < lastScrollTopRef.current && autoScrollEnabled) {
        setAutoScrollEnabled(false)
      }

      lastScrollTopRef.current = container.scrollTop
    }

    const handleTouchEnd = () => {
      if (isAtBottom(container) && !autoScrollEnabled) {
        setAutoScrollEnabled(true)
      }
    }

    container.addEventListener("scroll", handleScroll, { passive: true })
    container.addEventListener("wheel", handleWheel, { passive: true })
    container.addEventListener("touchstart", handleTouchStart, {
      passive: true,
    })
    container.addEventListener("touchmove", handleTouchMove, { passive: true })
    container.addEventListener("touchend", handleTouchEnd, { passive: true })

    return () => {
      container.removeEventListener("scroll", handleScroll)
      container.removeEventListener("wheel", handleWheel)
      container.removeEventListener("touchstart", handleTouchStart)
      container.removeEventListener("touchmove", handleTouchMove)
      container.removeEventListener("touchend", handleTouchEnd)
    }
  }, [containerRef, enabled, autoScrollEnabled, isAtBottom])

  return {
    autoScrollEnabled,
    scrollToBottom,
    isScrolling: autoScrollingRef.current,
    scrollTriggered: scrollTriggeredRef.current,
    newMessageAdded,
    setNewMessageAdded,
    prevChildrenCountRef,
  }
}

export type ChatContainerProps = {
  children: React.ReactNode
  className?: string
  autoScroll?: boolean
  scrollToRef?: React.RefObject<HTMLDivElement | null>
  ref?: React.RefObject<HTMLDivElement | null>
} & React.HTMLAttributes<HTMLDivElement>

function ChatContainer({
  className,
  children,
  autoScroll = true,
  scrollToRef,
  ref,
  ...props
}: ChatContainerProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const localBottomRef = useRef<HTMLDivElement>(null)
  const bottomRef = scrollToRef || localBottomRef
  const chatContainerRef = ref || containerRef
  const prevChildrenRef = useRef<React.ReactNode>(null)
  const contentChangedWithoutNewMessageRef = useRef(false)

  const { 
    autoScrollEnabled, 
    scrollToBottom, 
    isScrolling,
    scrollTriggered,
    newMessageAdded,
    setNewMessageAdded,
    prevChildrenCountRef
  } = useAutoScroll(
    chatContainerRef,
    autoScroll
  )

  useEffect(() => {
    const childrenArray = React.Children.toArray(children)
    const currentChildrenCount = childrenArray.length
    
    if (currentChildrenCount > prevChildrenCountRef.current) {
      setNewMessageAdded(true)
    } 
    else if (prevChildrenRef.current !== children) {
      contentChangedWithoutNewMessageRef.current = true
    }
    
    prevChildrenCountRef.current = currentChildrenCount
    prevChildrenRef.current = children
  }, [children, setNewMessageAdded])

  useEffect(() => {
    if (!autoScroll) return
    
    const scrollHandler = () => {
      if (newMessageAdded) {
        scrollToBottom("smooth")
        setNewMessageAdded(false)
        contentChangedWithoutNewMessageRef.current = false
      } 
      else if (
        contentChangedWithoutNewMessageRef.current && 
        autoScrollEnabled && 
        !isScrolling && 
        !scrollTriggered
      ) {
        scrollToBottom("smooth")
        contentChangedWithoutNewMessageRef.current = false
      }
    }
    
    requestAnimationFrame(scrollHandler)
    
  }, [
    children, 
    autoScroll, 
    autoScrollEnabled, 
    isScrolling,
    scrollTriggered,
    scrollToBottom, 
    newMessageAdded, 
    setNewMessageAdded
  ])

  return (
    <div
      className={cn("flex flex-col overflow-y-auto", className)}
      role="log"
      ref={chatContainerRef}
      {...props}
    >
      {children}
      <div
        ref={bottomRef}
        className="h-[1px] w-full flex-shrink-0 scroll-mt-4"
        aria-hidden="true"
      />
    </div>
  )
}

export { ChatContainer, useAutoScroll }

================
File: components/ui/command.tsx
================
import * as React from "react";
import { DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";
import { cn } from "@/lib/utils";
import { Dialog, DialogContent, DialogTitle, DialogDescription } from "@/components/ui/common/dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-lg bg-transparent text-white",
      className
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent 
        className="overflow-hidden p-0 max-w-2xl w-full mx-auto rounded-xl border border-white/[0.05] bg-white/[0.03] shadow-none backdrop-blur-xl pointer-events-auto"
      >
        <DialogTitle className="sr-only">Command Menu</DialogTitle>
        <DialogDescription className="sr-only">
          Search commands, actions, and navigate through your workspace.
        </DialogDescription>
        
        <Command className="
          [&_[cmdk-group-heading]]:px-4 
          [&_[cmdk-group-heading]]:font-semibold 
          [&_[cmdk-group-heading]]:text-white/70
          [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 
          [&_[cmdk-group]]:px-2 
          [&_[cmdk-input-wrapper]_svg]:h-5 
          [&_[cmdk-input-wrapper]_svg]:w-5 
          [&_[cmdk-input]]:h-12 
          [&_[cmdk-item]]:px-3 
          [&_[cmdk-item]]:py-3 
          [&_[cmdk-item]_svg]:h-5 
          [&_[cmdk-item]_svg]:w-5
          transition-all duration-200
          bg-transparent
        ">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div 
    className="flex items-center border-b border-white/[0.05] px-4"
    cmdk-input-wrapper=""
  >
    <Search className="mr-2 h-5 w-5 shrink-0 text-white/70" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-12 w-full bg-transparent py-3 text-sm text-white/90 outline-none placeholder:text-white/50 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
));
CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[400px] overflow-y-auto overflow-x-hidden py-2", className)}
    {...props}
  />
));
CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm text-white/70"
    {...props}
  />
));
CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-white [&_[cmdk-group-heading]]:px-3 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-semibold [&_[cmdk-group-heading]]:text-white/70",
      className
    )}
    {...props}
  />
));
CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-white/[0.05]", className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-pointer select-none items-center rounded-md px-3 py-2.5 text-sm text-white/80 outline-none transition-all duration-200",
      "aria-selected:bg-white/[0.05] aria-selected:text-white",
      "data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      "hover:bg-white/[0.05] hover:backdrop-blur-sm active:bg-white/[0.06]",
      "border border-transparent hover:border-white/[0.06]",
      "group pointer-events-auto",
      className
    )}
    {...props}
  />
));
CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto flex items-center gap-1 text-xs tracking-widest text-white/60 group-hover:text-white/80",
        className
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};

================
File: components/ui/quick-actions-tab.tsx
================
import { Sparkles } from "lucide-react";
import { BaseTab } from "./common/base-tab";
import { useCommandCenter } from "@/hooks/useCommandCenter";

// Original component that uses hooks
export default function QuickActionsTab() {
    const { toggleCommandCenter } = useCommandCenter();
    
    return (
        <BaseTab
            icon={<Sparkles className="w-3 h-3" />}
            label="Quick Actions"
            shortcut="K"
            minWidth="actions"
            commandType="application"
            onClick={() => {
                toggleCommandCenter();
            }}
        />
    );
}

// Server-driven version that accepts props
export function ServerDrivenQuickActionsTab({ 
    onCreateConversation 
}: { 
    onCreateConversation: (title: string) => Promise<void> 
}) {
    const { toggleCommandCenter } = useCommandCenter();
    
    return (
        <BaseTab
            icon={<Sparkles className="w-3 h-3" />}
            label="Quick Actions"
            shortcut="K"
            minWidth="actions"
            commandType="application"
            onClick={() => {
                toggleCommandCenter();
            }}
        />
    );
}

================
File: components/ui/scroll-button.tsx
================
"use client"

import * as React from "react"
import { ArrowDown } from "lucide-react"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/common/button"

export type ScrollButtonProps = {
  containerRef: React.RefObject<HTMLElement | null>
  scrollRef?: React.RefObject<HTMLElement | null>
  className?: string
  onClick?: () => void
}

export function ScrollButton({
  containerRef,
  scrollRef,
  className,
  onClick,
}: ScrollButtonProps) {
  const [visible, setVisible] = React.useState(false)

  const handleClick = React.useCallback(() => {
    if (onClick) {
      onClick()
      return
    }

    if (scrollRef?.current) {
      scrollRef.current.scrollIntoView({
        behavior: "smooth",
        block: "end",
      })
      return
    }

    if (containerRef?.current) {
      containerRef.current.scrollTo({
        top: containerRef.current.scrollHeight,
        behavior: "smooth",
      })
    }
  }, [containerRef, scrollRef, onClick])

  React.useEffect(() => {
    const container = containerRef.current
    if (!container) return

    const handleScroll = () => {
      const { scrollTop, scrollHeight, clientHeight } = container
      // Show button when not at the bottom
      setVisible(scrollHeight - scrollTop - clientHeight > 10)
    }

    container.addEventListener("scroll", handleScroll, { passive: true })
    // Initial check
    handleScroll()

    return () => {
      container.removeEventListener("scroll", handleScroll)
    }
  }, [containerRef])

  if (!visible) return null

  return (
    <Button
      size="icon"
      variant="outline"
      className={cn(
        "size-8 rounded-full bg-background/80 backdrop-blur transition-opacity hover:bg-background",
        className
      )}
      onClick={handleClick}
    >
      <ArrowDown className="size-4" />
      <span className="sr-only">Scroll to bottom</span>
    </Button>
  )
}

================
File: components/ui/tab-skeleton.tsx
================
export function TabSkeleton() {
  return (
    <div className="flex items-center gap-2 animate-pulse">
      {/* Space Tab Skeleton */}
      <div className="px-3 py-1 rounded-t-lg backdrop-blur-2xl border border-white/[0.05] min-w-[100px]
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <div className="flex items-center gap-1.5">
          <div className="w-2 h-2 rounded-full bg-white/10" />
          <div className="h-3 w-16 bg-white/10 rounded" />
        </div>
      </div>

      {/* Quick Actions Tab Skeleton */}
      <div className="px-3 py-1 rounded-t-lg backdrop-blur-2xl border border-white/[0.05]
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <div className="flex items-center gap-1.5">
          <div className="w-3 h-3 rounded bg-white/10" />
          <div className="h-3 w-20 bg-white/10 rounded" />
        </div>
      </div>

      {/* Model Tab Skeleton */}
      <div className="px-3 py-1 rounded-t-lg backdrop-blur-2xl border border-white/[0.05] min-w-[120px]
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <div className="flex items-center gap-1.5">
          <div className="w-3.5 h-3.5 rounded-full bg-white/10" />
          <div className="h-3 w-24 bg-white/10 rounded" />
        </div>
      </div>
    </div>
  )
}

================
File: components/CommandButton.tsx
================
import React from 'react';
import { Button } from '@/components/ui/common/button';
import { useCommandCenter } from '@/hooks/useCommandCenter';
import { Command } from 'lucide-react';
import { CommandType } from '@/hooks/useCommandCenter';

interface CommandButtonProps {
  className?: string;
  label?: string;
  showIcon?: boolean;
  showShortcut?: boolean;
  type?: CommandType;
}

export function CommandButton({
  className,
  label = 'Command Menu',
  showIcon = true,
  showShortcut = true,
  type,
}: CommandButtonProps) {
  const { openCommandCenter, openCommandType } = useCommandCenter();

  const handleClick = () => {
    if (type) {
      openCommandType(type);
    } else {
      openCommandCenter();
    }
  };

  return (
    <Button
      variant="ghost"
      className={className}
      onClick={handleClick}
    >
      {showIcon && <Command className="mr-2 h-4 w-4" />}
      {label}
      {showShortcut && (
        <kbd className="pointer-events-none ml-auto inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground">
          <span className="text-xs">⌘</span>K
        </kbd>
      )}
    </Button>
  );
}

/**
 * A button that opens the command center with a specific command type pre-selected
 */
export function TypedCommandButton({
  className,
  label,
  type,
  icon,
  shortcutKeys,
}: {
  className?: string;
  label: string;
  type: CommandType;
  icon?: React.ReactNode;
  shortcutKeys?: string[];
}) {
  const { openCommandType } = useCommandCenter();

  return (
    <Button
      variant="ghost"
      className={className}
      onClick={() => openCommandType(type)}
    >
      {icon && <span className="mr-2">{icon}</span>}
      {label}
      {shortcutKeys && (
        <kbd className="pointer-events-none ml-auto inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground">
          {shortcutKeys.map((key, i) => (
            <React.Fragment key={i}>
              {i > 0 && <span className="mx-0.5">+</span>}
              <span className="text-xs">{key}</span>
            </React.Fragment>
          ))}
        </kbd>
      )}
    </Button>
  );
}

export default CommandButton;

================
File: components/CommandCenter.tsx
================
"use client"

import React, { useEffect } from 'react';
import { Command, CommandDialog, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList, CommandSeparator, CommandShortcut } from '@/components/ui/command';
import { CommandOption, CommandType, useCommandCenter } from '@/hooks/useCommandCenter';

/**
 * Main CommandCenter component that integrates with the CMDK library
 * and uses the CommandContext to show available commands
 */
export function CommandCenter() {
  const {
    isOpen,
    closeCommandCenter,
    filteredCommands,
    setSearchQuery,
    activeCommandType,
  } = useCommandCenter();

  // Group commands by type for organized display
  const groupedCommands = React.useMemo(() => {
    const grouped: Record<CommandType, CommandOption[]> = {
      application: [],
      spaces: [],
      conversations: [],
      models: [],
      actions: [],
    };

    filteredCommands.forEach((command) => {
      grouped[command.type].push(command);
    });

    return grouped;
  }, [filteredCommands]);

  // Get all available command types that have commands
  const availableTypes = React.useMemo(() => {
    return Object.entries(groupedCommands)
      .filter(([_, commands]) => commands.length > 0)
      .map(([type]) => type as CommandType);
  }, [groupedCommands]);

  const handleSelect = async (commandId: string) => {
    const command = filteredCommands.find(cmd => cmd.id === commandId);
    if (command) {
      command?.action();
      closeCommandCenter();
    }
  };

  const renderCommandGroups = () => {
    if (activeCommandType) {
      // Render only the active type
      const commands = groupedCommands[activeCommandType];
      if (commands.length === 0) {
        // Add a message when no commands are found for the active type
        return (
          <CommandEmpty>No {activeCommandType} found.</CommandEmpty>
        );
      }

      return (
        <CommandGroup heading={activeCommandType.charAt(0).toUpperCase() + activeCommandType.slice(1)}>
          {commands.map((command) => (
            <CommandItem
              key={command.id}
              onSelect={() => handleSelect(command.id)}
              value={command.id}
              className="group cursor-pointer relative overflow-hidden"
            >
              <div className="flex items-center w-full pointer-events-auto">
                {command.icon && (
                  <span className="mr-3 text-white/70 group-hover:text-white/90 transition-colors duration-200">
                    {command.icon}
                  </span>
                )}
                <div className="flex flex-col justify-center flex-1 overflow-hidden">
                  <span className="truncate text-white/90 font-medium group-hover:text-white transition-colors duration-200">{command.name}</span>
                  {command.description && (
                    <span className="text-xs text-white/60 truncate mt-0.5 group-hover:text-white/80 transition-colors duration-200">
                      {command.description}
                    </span>
                  )}
                </div>
                {command.shortcut && !command.rightElement && (
                  <CommandShortcut>
                    {command.shortcut.map((key, i) => (
                      <React.Fragment key={i}>
                        {i > 0 && <span className="mx-0.5">+</span>}
                        <kbd className="px-1.5 py-0.5 text-[10px] bg-white/[0.02] border border-white/[0.05] rounded group-hover:border-white/[0.1] transition-all duration-200">
                          {key}
                        </kbd>
                      </React.Fragment>
                    ))}
                  </CommandShortcut>
                )}
                {command.rightElement && (
                  <div className="flex items-center ml-auto pointer-events-auto">
                    {command.rightElement}
                  </div>
                )}
              </div>
            </CommandItem>
          ))}
        </CommandGroup>
      );
    }

    // Render all groups
    return availableTypes.map((type, index) => {
      const commands = groupedCommands[type];
      if (commands.length === 0) return null;

      return (
        <React.Fragment key={type}>
          <CommandGroup heading={type.charAt(0).toUpperCase() + type.slice(1)}>
            {commands.map((command) => (
              <CommandItem
                key={command.id}
                onSelect={() => handleSelect(command.id)}
                value={command.id}
                className="group cursor-pointer relative overflow-hidden"
              >
                <div className="flex items-center w-full pointer-events-auto">
                  {command.icon && (
                    <span className="mr-3 text-white/70 group-hover:text-white/90 transition-colors duration-200">
                      {command.icon}
                    </span>
                  )}
                  <div className="flex flex-col justify-center flex-1 overflow-hidden">
                    <span className="truncate text-white/90 font-medium group-hover:text-white transition-colors duration-200">{command.name}</span>
                    {command.description && (
                      <span className="text-xs text-white/60 truncate mt-0.5 group-hover:text-white/80 transition-colors duration-200">
                        {command.description}
                      </span>
                    )}
                  </div>
                  {command.shortcut && !command.rightElement && (
                    <CommandShortcut>
                      {command.shortcut.map((key, i) => (
                        <React.Fragment key={i}>
                          {i > 0 && <span className="mx-0.5">+</span>}
                          <kbd className="px-1.5 py-0.5 text-[10px] bg-white/[0.02] border border-white/[0.05] rounded group-hover:border-white/[0.1] transition-all duration-200">
                            {key}
                          </kbd>
                        </React.Fragment>
                      ))}
                    </CommandShortcut>
                  )}
                  {command.rightElement && (
                    <div className="flex items-center ml-auto pointer-events-auto">
                      {command.rightElement}
                    </div>
                  )}
                </div>
              </CommandItem>
            ))}
          </CommandGroup>
          {index < availableTypes.length - 1 && <CommandSeparator />}
        </React.Fragment>
      );
    });
  };

  return (
    <CommandDialog open={isOpen} onOpenChange={closeCommandCenter}>
      <CommandInput
        placeholder="Type a command or search..."
        onValueChange={setSearchQuery}
      />
      <CommandList className="scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent">
        <CommandEmpty className="py-6 text-center text-sm">
          <div className="flex flex-col items-center justify-center space-y-1">
            <div className="text-white/60">No commands found.</div>
            <div className="text-xs text-white/40">Try a different search term</div>
          </div>
        </CommandEmpty>
        {renderCommandGroups()}
      </CommandList>
    </CommandDialog>
  );
}

export default CommandCenter;

================
File: components/CommandProviders.tsx
================
"use client";

import React, { ReactNode, useEffect, useState, useRef, useCallback, useMemo } from "react";
import { CommandOption, useCommandRegistration, CommandType } from "@/hooks/useCommandCenter";
import { 
  Settings, 
  Search, 
  Plus, 
  MessageSquare, 
  Brain, 
  Command, 
  Trash, 
  PencilLine,
  Pencil
} from "lucide-react";
import { AVAILABLE_MODELS, PROVIDER_NAMES, Provider } from "@/config/models";
import { toast } from 'sonner'
import DotSphere from "@/components/ui/space/planet-icon";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/common/dialog";
import { Button } from "@/components/ui/common/button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/common/select";
import { Textarea } from "@/components/ui/common/textarea";
import { useCommandCenter } from "@/hooks/useCommandCenter";
import { useRouter } from "next/navigation";
import { getMostRecentConversation } from "@/app/actions/conversations";
import { cn } from "@/lib/utils";
import { useSpaceStore, Space as SpaceType, Conversation as ConversationType } from '@/stores/space-store';

/**
 * Dialog for creating or editing a space
 */
export function SpaceDialogForm({
  open,
  onOpenChange,
  onCreateSuccess,
  onEditSuccess,
  editSpace = null,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onCreateSuccess: () => void;
  onEditSuccess: () => void;
  editSpace?: any; // The space to edit, null when creating a new space
}) {
  const [name, setName] = useState(editSpace?.name || "New Space");
  const [description, setDescription] = useState(editSpace?.description || "");
  const [provider, setProvider] = useState<Provider>(editSpace?.provider || "anthropic");
  const [model, setModel] = useState(editSpace?.model || "");
  const initialRenderRef = useRef(true);
  const router = useRouter();

  const { 
    createSpace, 
    updateSpace, 
    isLoading, 
    loadingSpaceId 
  } = useSpaceStore();

  useEffect(() => {
    if (open) {
      if (editSpace) {
        setName(editSpace.name || "Untitled Space");
        setDescription(editSpace.description || "");
        setProvider(editSpace.provider || "anthropic");
        setModel(editSpace.model || AVAILABLE_MODELS["anthropic"][0].id);
      } else {
        setName("New Space");
        setDescription("");
        setProvider("anthropic");
        setModel(AVAILABLE_MODELS["anthropic"][0].id);
      }
      initialRenderRef.current = false;
    }
  }, [open, editSpace]);

  useEffect(() => {
    if (!editSpace && provider && AVAILABLE_MODELS[provider]?.length > 0) {
      setModel(AVAILABLE_MODELS[provider][0].id);
    }
  }, [provider, editSpace]);

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();
      
      let success = false;
      
      if (editSpace) {
        success = await updateSpace(editSpace.id, {
          name,
          description,
          model,
          provider
        });

        onEditSuccess();
      } else {
        const result = await createSpace(name, description, model, provider);
        success = !!result;
        
        if (success && result) {
          const newSpaceId = result.id;
          const conversation = await getMostRecentConversation(newSpaceId);

          router.replace(`/protected/spaces/${newSpaceId}/conversations/${conversation.data?.id}`);
          
          onCreateSuccess();
          return;
        }
      }
    },
    [name, description, model, provider, createSpace, updateSpace, onCreateSuccess, onEditSuccess, editSpace, router]
  );

  const isSubmitting = editSpace 
    ? loadingSpaceId === editSpace.id 
    : isLoading;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>{editSpace ? "Edit Space" : "Create New Space"}</DialogTitle>
            <DialogDescription>
              {editSpace 
                ? "Update the settings for this workspace." 
                : "Create a new workspace for your conversations."}
            </DialogDescription>
          </DialogHeader>

          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Space name"
                required
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="description">Description (optional)</Label>
              <Textarea
                id="description"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Describe the purpose of this space"
                rows={3}
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="provider">Provider</Label>
              <Select value={provider} onValueChange={(value) => setProvider(value as Provider)}>
                <SelectTrigger id="provider">
                  <SelectValue placeholder="Select provider" />
                </SelectTrigger>
                <SelectContent>
                  {Object.entries(PROVIDER_NAMES).map(([key, name]) => (
                    <SelectItem key={key} value={key}>
                      {name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="grid gap-2">
              <Label htmlFor="model">Model</Label>
              <Select value={model} onValueChange={setModel}>
                <SelectTrigger id="model">
                  <SelectValue placeholder="Select model" />
                </SelectTrigger>
                <SelectContent>
                  {provider &&
                    AVAILABLE_MODELS[provider]?.map((modelOption) => (
                      <SelectItem key={modelOption.id} value={modelOption.id}>
                        {modelOption.name}
                      </SelectItem>
                    ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          <DialogFooter>
            <Button type="submit" disabled={isSubmitting || !name || !model || !provider}>
              {isSubmitting ? (
                <div className="flex items-center gap-2">
                  <div className="animate-spin h-4 w-4 border-2 border-white/20 border-t-white/80 rounded-full" />
                  <span>{editSpace ? "Updating..." : "Creating..."}</span>
                </div>
              ) : (
                editSpace ? "Update Space" : "Create Space"
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Dialog for confirming space deletion
 */
export function DeleteSpaceDialog({
  open,
  onOpenChange,
  space,
  onConfirm,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  space: any | null;
  onConfirm: () => void;
}) {
  // Use the space store
  const { loadingSpaceId } = useSpaceStore();

  const isSubmitting = space ? loadingSpaceId === space.id : false;

  const handleDelete = useCallback(async () => {
    if (isSubmitting) return;
    
    try {
      await onConfirm();
    } catch (error) {
      console.error("Error deleting space:", error);
    } finally {
      onOpenChange(false);
    }
  }, [isSubmitting, onConfirm, onOpenChange]);

  if (!space) return null;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Delete Space</DialogTitle>
          <DialogDescription>
            Are you sure you want to delete "{space.name}"? This action cannot be undone.
          </DialogDescription>
        </DialogHeader>

        <DialogFooter className="mt-4 flex justify-between">
          <Button 
            variant="outline" 
            onClick={() => onOpenChange(false)}
            className="border-white/10 bg-white/5 hover:bg-white/10 text-white backdrop-blur-sm"
          >
            Cancel
          </Button>
          <Button 
            variant="destructive" 
            onClick={handleDelete} 
            disabled={isSubmitting}
            className="bg-red-500/20 hover:bg-red-500/30 border border-red-500/20 text-red-400 backdrop-blur-sm"
          >
            {isSubmitting ? (
              <div className="flex items-center gap-2">
                <div className="animate-spin h-4 w-4 border-2 border-red-400/20 border-t-red-400/80 rounded-full" />
                <span>Deleting...</span>
              </div>
            ) : (
              "Delete Space"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Provider for application-wide commands
 */
export function ApplicationCommandProvider({ children }: { children: ReactNode }) {
  const applicationCommands = useCallback(
    (): CommandOption[] => [
      {
        id: "settings",
        name: "Open Settings",
        description: "Open application settings",
        icon: <Settings className="h-4 w-4" />,
        shortcut: ["⌘", ","],
        type: "application",
        keywords: ["settings", "preferences", "config", "configuration"],
        action: () => {
          console.log("Opening settings");
        },
      },
      {
        id: "search",
        name: "Search Everything",
        description: "Search across all content",
        icon: <Search className="h-4 w-4" />,
        shortcut: ["⌘", "F"],
        type: "application",
        keywords: ["search", "find", "filter", "query"],
        action: () => {
          console.log("Opening global search");
        },
      },
    ],
    []
  );

  useCommandRegistration(applicationCommands());

  return <>{children}</>;
}

/**
 * Provider for space-related commands
 */
export function SpacesCommandProvider({ 
  children, 
}: { 
  children: ReactNode, 
}) {
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [spaceToEdit, setSpaceToEdit] = useState<any>(null);
  const [spaceToDelete, setSpaceToDelete] = useState<any>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const { closeCommandCenter, openCommandType } = useCommandCenter();
  
  const storeSpaces = useSpaceStore(state => state.spaces);
  const storeActiveSpace = useSpaceStore(state => state.activeSpace);
  
  const { 
    deleteSpace,
    activeConversation,
    loadSpaceFullData
  } = useSpaceStore();

  const reopenSpacesCommandCenter = useCallback(() => {
    openCommandType('spaces');
  }, [openCommandType]);

  const baseCommands = useCallback(
    (): CommandOption[] => [
      {
        id: "create-space",
        name: "Create New Space",
        description: "Create a new workspace",
        icon: <Plus className="h-4 w-4" />,
        shortcut: ["⌘", "N"],
        type: "spaces",
        keywords: ["create", "new", "space", "workspace", "add"],
        action: () => {
          closeCommandCenter();
          setSpaceToEdit(null);
          setShowCreateDialog(true);
        },
      },
    ],
    [closeCommandCenter]
  );

  const handleSelectSpace = useCallback(async (spaceId: string) => {
    await loadSpaceFullData(spaceId);
  }, [activeConversation]);

  const handleEditSpace = useCallback((space: any) => {
    closeCommandCenter();
    setSpaceToEdit(space);
    setShowCreateDialog(true);
  }, [closeCommandCenter]);

  const handleDeleteSpace = useCallback((space: any) => {
    closeCommandCenter();
    setSpaceToDelete(space);
    setShowDeleteDialog(true);
  }, [closeCommandCenter]);

  const confirmDeleteSpace = useCallback(async () => {
    if (spaceToDelete) {
      try {
        // Check if this is the active space before deletion
        const isActiveSpace = spaceToDelete.id === storeActiveSpace?.id;
        
        // Use the store's deleteSpace function directly
        const success = await deleteSpace(spaceToDelete.id);
        
        if (success) {
          // If we successfully deleted the active space, navigate to the new active space
          if (isActiveSpace) {
            // Check if there are any spaces left
            const remainingSpaces = storeSpaces?.filter(space => !space.is_deleted) || [];
            
            // After a short delay to ensure store updates are complete
            setTimeout(() => {
              if (remainingSpaces.length > 0) {
                // Use the navigation helper to go to the right space/conversation
                useSpaceStore.getState().navigateToActiveConversation(router);
              } else {
                // No spaces left, navigate to home page
                router.push('/protected');
              }
            }, 200);
          }
        } else {
          // Handle failure case explicitly
          console.error('Failed to delete space');
          toast.error('Deletion Failed', {
            description: 'Could not delete the space. Please try again.'
          });
        }
      } catch (error) {
        console.error('Error in space deletion process:', error);
        toast.error('Deletion Failed', {
          description: 'An error occurred while deleting the space.'
        });
      } finally {
        // Always close the dialog
        setShowDeleteDialog(false);
        setSpaceToDelete(null);
        
        // Reopen command center
        setTimeout(() => {
          reopenSpacesCommandCenter();
        }, 150);
      }
    }
  }, [router, reopenSpacesCommandCenter, spaceToDelete, storeActiveSpace?.id, storeSpaces, deleteSpace]);

  const handleDeleteDialogClose = useCallback((open: boolean) => {
    setShowDeleteDialog(open);
    if (!open) {
      setTimeout(() => {
        reopenSpacesCommandCenter();
      }, 150);
    }
  }, [reopenSpacesCommandCenter]);

  const handleCreateDialogClose = useCallback((open: boolean) => {
    setShowCreateDialog(open);
    if (!open) {
      setTimeout(() => {
        reopenSpacesCommandCenter();
      }, 150);
    }
  }, [reopenSpacesCommandCenter]);

  const spaceOptionsList = useMemo(() => {
    console.log('SpacesCommandProvider - storeSpaces:', storeSpaces);

    return storeSpaces
      ?.filter(space => !space.is_deleted)
      ?.sort((a: SpaceType, b: SpaceType) => new Date(b.updated_at || '').getTime() - new Date(a.updated_at || '').getTime())
      .map((space) => ({
        id: `space-${space.id}`,
        name: space.name,
        description: space.description || "Switch to this workspace",
        icon: (
          <div className="flex items-center gap-2">
              <DotSphere 
                size={22} 
                seed={space.id} 
                dotCount={60} 
                dotSize={0.7} 
                expandFactor={1.15} 
                transitionSpeed={400}
                highPerformance={true}
              />
          </div>
        ),
        type: "spaces" as CommandType,
        keywords: ["space", "workspace", "switch", space.name],
        action: async () => {
          await handleSelectSpace(space.id);
        },
        closeCommandOnSelect: false,
        rightElement: (
          <div className="flex items-center">
            <div
              onClick={(e) => { 
                e.stopPropagation();
                e.preventDefault();
                handleEditSpace(space);
              }}
              className={cn(
                "flex items-center h-7 w-7 justify-center rounded-md p-1.5 mr-1",
                "transition-all duration-200 ease-in-out",
                "bg-white/[0.03] hover:bg-white/[0.08] border border-white/[0.05]",
                "text-zinc-400 hover:text-zinc-200",
                "cursor-pointer"
              )}
              title="Edit Space"
            >
              <Pencil size={11} strokeWidth={1.5} />
            </div>
            <div
              onClick={(e) => { 
                e.stopPropagation();
                e.preventDefault();
                handleDeleteSpace(space);
              }}
              className={cn(
                "flex items-center h-7 w-7 justify-center rounded-md p-1.5",
                "transition-all duration-200 ease-in-out",
                "bg-white/[0.03] hover:bg-red-400/20 border border-white/[0.05]",
                "text-red-400 hover:text-red-200",
                "cursor-pointer"
              )}
              title="Delete Space"
            >
              <Trash className="text-red-400" size={11} strokeWidth={1.5} />
            </div>
          </div>
        )
      })) ?? [];
  }, [storeSpaces]);

  const spaceCommands = useCallback((): CommandOption[] => {
    const commands = [] as CommandOption[];
    return [...commands, ...spaceOptionsList];
  }, [spaceOptionsList]);

  useCommandRegistration([...baseCommands(), ...spaceCommands()]);

  const onCreateSuccess = useCallback(() => {
    setShowCreateDialog(false);
    closeCommandCenter();
  }, [closeCommandCenter]);

  const onEditSuccess = useCallback(() => {
    handleCreateDialogClose(false);
    reopenSpacesCommandCenter();
  }, [handleCreateDialogClose, reopenSpacesCommandCenter]);

  return (
    <>
      <SpaceDialogForm
        open={showCreateDialog}
        onOpenChange={handleCreateDialogClose}
        onCreateSuccess={onCreateSuccess}
        onEditSuccess={onEditSuccess}
        editSpace={spaceToEdit}
      />
      <DeleteSpaceDialog 
        open={showDeleteDialog}
        onOpenChange={handleDeleteDialogClose}
        space={spaceToDelete}
        onConfirm={confirmDeleteSpace}
      />
      {children}
    </>
  );
}

/**
 * Dialog for creating or editing a conversation
 */
export function ConversationDialogForm({
  open,
  onOpenChange,
  onEditSuccess,
  editConversation = null,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onEditSuccess: () => void;
  editConversation?: any; // The conversation to edit
}) {
  const [title, setTitle] = useState(editConversation?.title || "");
  const initialRenderRef = useRef(true);
  const router = useRouter();

  const { 
    updateConversation, 
    isLoading, 
    loadingConversationId 
  } = useSpaceStore();

  useEffect(() => {
    if (open) {
      if (editConversation) {
        setTitle(editConversation.title || "");
      } else {
        setTitle("");
      }
      initialRenderRef.current = false;
    }
  }, [open, editConversation]);

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();
      
      if (editConversation) {
        const success = await updateConversation(editConversation.id, title);

        if (success) {
          onEditSuccess();
        }
      }
    },
    [title, updateConversation, onEditSuccess, editConversation]
  );

  const isSubmitting = editConversation 
    ? loadingConversationId === editConversation.id 
    : isLoading;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Edit Conversation</DialogTitle>
            <DialogDescription>
              Update the title for this conversation.
            </DialogDescription>
          </DialogHeader>

          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="title">Title</Label>
              <Input
                id="title"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder="Conversation title"
                required
              />
            </div>
          </div>

          <DialogFooter>
            <Button type="submit" disabled={isSubmitting || !title}>
              {isSubmitting ? (
                <div className="flex items-center gap-2">
                  <div className="animate-spin h-4 w-4 border-2 border-white/20 border-t-white/80 rounded-full" />
                  <span>Updating...</span>
                </div>
              ) : (
                "Update Conversation"
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Dialog for confirming conversation deletion
 */
export function DeleteConversationDialog({
  open,
  onOpenChange,
  conversation,
  onConfirm,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  conversation: any | null;
  onConfirm: () => void;
}) {
  // Use the space store
  const { loadingConversationId } = useSpaceStore();

  const isSubmitting = conversation ? loadingConversationId === conversation.id : false;

  const handleDelete = useCallback(async () => {
    if (isSubmitting) return;
    
    try {
      await onConfirm();
    } catch (error) {
      console.error("Error deleting conversation:", error);
    } finally {
      onOpenChange(false);
    }
  }, [isSubmitting, onConfirm, onOpenChange]);

  if (!conversation) return null;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Delete Conversation</DialogTitle>
          <DialogDescription>
            Are you sure you want to delete "{conversation.title || 'Untitled Conversation'}"? This action cannot be undone.
          </DialogDescription>
        </DialogHeader>

        <DialogFooter className="mt-4 flex justify-between">
          <Button 
            variant="outline" 
            onClick={() => onOpenChange(false)}
            className="border-white/10 bg-white/5 hover:bg-white/10 text-white backdrop-blur-sm"
          >
            Cancel
          </Button>
          <Button 
            variant="destructive" 
            onClick={handleDelete} 
            disabled={isSubmitting}
            className="bg-red-500/20 hover:bg-red-500/30 border border-red-500/20 text-red-400 backdrop-blur-sm"
          >
            {isSubmitting ? (
              <div className="flex items-center gap-2">
                <div className="animate-spin h-4 w-4 border-2 border-red-400/20 border-t-red-400/80 rounded-full" />
                <span>Deleting...</span>
              </div>
            ) : (
              "Delete Conversation"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Provider for conversation-related commands
 */
export function ConversationsCommandProvider({ 
  children, 
}: { 
  children: ReactNode, 
}) {
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [conversationToEdit, setConversationToEdit] = useState<any>(null);
  const [conversationToDelete, setConversationToDelete] = useState<any>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const { closeCommandCenter, openCommandType } = useCommandCenter();
  
  const storeConversations = useSpaceStore(state => state.conversations);
  const storeActiveConversation = useSpaceStore(state => state.activeConversation);
  const storeActiveSpace = useSpaceStore(state => state.activeSpace);
  
  const { 
    createConversation, 
    selectConversation, 
    deleteConversation 
  } = useSpaceStore();

  const reopenConversationsCommandCenter = useCallback(() => {
    openCommandType('conversations');
  }, [openCommandType]);

  type Conversation = {
    id: string;
    title?: string;
    is_deleted?: boolean;
    updated_at?: string;
    [key: string]: any;
  };

  const handleEditConversation = useCallback((conversation: any) => {
    closeCommandCenter();
    setConversationToEdit(conversation);
    setShowEditDialog(true);
  }, [closeCommandCenter]);

  const handleDeleteConversation = useCallback((conversation: any) => {
    closeCommandCenter();
    setConversationToDelete(conversation);
    setShowDeleteDialog(true);
  }, [closeCommandCenter]);

  const confirmDeleteConversation = useCallback(async () => {
    if (conversationToDelete) {
      try {
        const success = await deleteConversation(conversationToDelete.id);
        
        if (success) {
          if (conversationToDelete.id === storeActiveConversation?.id) {
            const remainingConversations = storeConversations?.filter(
              conv => !conv.is_deleted && conv.id !== conversationToDelete.id
            ) || [];
            
            if (remainingConversations.length > 0) {
              await selectConversation(remainingConversations[0].id);
            } else {
              await createConversation();
            }
          }
        } else {
          toast.error('Deletion Failed', {
            description: 'Could not delete the conversation. Please try again.'
          });
        }
      } catch (error) {
        console.error('Error in conversation deletion process:', error);
        toast.error('Deletion Failed', {
          description: 'An error occurred while deleting the conversation.'
        });
      } finally {
        setShowDeleteDialog(false);
        setConversationToDelete(null);
        
        setTimeout(() => {
          reopenConversationsCommandCenter();
        }, 150);
      }
    }
  }, [
    conversationToDelete, 
    storeActiveConversation?.id, 
    storeConversations, 
    deleteConversation, 
    selectConversation, 
    createConversation,
    reopenConversationsCommandCenter
  ]);

  const handleEditDialogClose = useCallback((open: boolean) => {
    setShowEditDialog(open);
    if (!open) {
      setTimeout(() => {
        reopenConversationsCommandCenter();
      }, 150);
    }
  }, [reopenConversationsCommandCenter]);

  const handleDeleteDialogClose = useCallback((open: boolean) => {
    setShowDeleteDialog(open);
    if (!open) {
      setTimeout(() => {
        reopenConversationsCommandCenter();
      }, 150);
    }
  }, [reopenConversationsCommandCenter]);

  const onEditSuccess = useCallback(() => {
    handleEditDialogClose(false);
    reopenConversationsCommandCenter();
  }, [handleEditDialogClose, reopenConversationsCommandCenter]);

  const conversationOptionsList = useMemo(() => {
    const conversationsToUse = storeConversations;
    const activeConversationToUse = storeActiveConversation;
    
    console.log('Building conversation options with conversations:', conversationsToUse?.length || 0);
    
    return conversationsToUse
      ?.filter((conv) => !conv.is_deleted)
      .sort((a, b) => {
        const dateA = a.updated_at ? new Date(a.updated_at).getTime() : 0;
        const dateB = b.updated_at ? new Date(b.updated_at).getTime() : 0;
        return dateB - dateA;
      })
      .map((conversation: Conversation) => ({
        id: `conversation-${conversation.id}`,
        name: conversation.title || "Untitled Conversation",
        description: storeActiveSpace
          ? `Open conversation in ${storeActiveSpace.name}: ${conversation.title || "Untitled"}`
          : `Open conversation: ${conversation.title || "Untitled"}`,
        icon: (
          <div className="flex items-center gap-2">
            <MessageSquare className="h-4 w-4" />
            {conversation.id === storeActiveConversation?.id && (
              <span className="text-[10px] font-medium bg-cyan-500/20 text-cyan-500 rounded-full px-2 py-0.5">
                Active
              </span>
            )}
          </div>
        ),
        type: "conversations" as CommandType,
        keywords: ["conversation", "chat", "open", conversation.title || ""],
        action: async () => {
          await selectConversation(conversation.id);
          closeCommandCenter();
        },
        closeCommandOnSelect: false,
        rightElement: (
          <div className="flex items-center">
            <div
              onClick={(e) => { 
                e.stopPropagation();
                e.preventDefault();
                handleEditConversation(conversation);
              }}
              className={cn(
                "flex items-center h-7 w-7 justify-center rounded-md p-1.5 mr-1",
                "transition-all duration-200 ease-in-out",
                "bg-white/[0.03] hover:bg-white/[0.08] border border-white/[0.05]",
                "text-zinc-400 hover:text-zinc-200",
                "cursor-pointer"
              )}
              title="Edit Conversation"
            >
              <Pencil size={11} strokeWidth={1.5} />
            </div>
            <div
              onClick={(e) => { 
                e.stopPropagation();
                e.preventDefault();
                handleDeleteConversation(conversation);
              }}
              className={cn(
                "flex items-center h-7 w-7 justify-center rounded-md p-1.5",
                "transition-all duration-200 ease-in-out",
                "bg-white/[0.03] hover:bg-red-400/20 border border-white/[0.05]",
                "text-red-400 hover:text-red-200",
                "cursor-pointer"
              )}
              title="Delete Conversation"
            >
              <Trash className="text-red-400" size={11} strokeWidth={1.5} />
            </div>
          </div>
        )
      })) ?? [];
  }, [
    storeConversations, 
    storeActiveConversation, 
    storeActiveSpace, 
    selectConversation, 
    closeCommandCenter,
    handleEditConversation,
    handleDeleteConversation
  ]);

  const conversationCommands = useCallback((): CommandOption[] => {
    return [
      {
        id: "new-conversation",
        name: "Start New Conversation",
        description: storeActiveSpace
          ? `Begin a new chat in ${storeActiveSpace.name}`
          : "Begin a new chat conversation",
        icon: <MessageSquare className="h-4 w-4" />,
        shortcut: ["⌘", "T"],
        type: "conversations",
        keywords: ["conversation", "chat", "new", "start", "begin"],
        action: async () => {
          await createConversation();
          closeCommandCenter();
        },
      },
      ...conversationOptionsList,
    ];
  }, [storeActiveSpace, conversationOptionsList, createConversation, closeCommandCenter]);

  useCommandRegistration(conversationCommands());

  // Debug log for monitoring state changes
  useEffect(() => {
    console.log('ConversationsCommandProvider - Conversation commands updated');
  }, [conversationCommands]);

  return (
    <>
      <ConversationDialogForm
        open={showEditDialog}
        onOpenChange={handleEditDialogClose}
        onEditSuccess={onEditSuccess}
        editConversation={conversationToEdit}
      />
      <DeleteConversationDialog 
        open={showDeleteDialog}
        onOpenChange={handleDeleteDialogClose}
        conversation={conversationToDelete}
        onConfirm={confirmDeleteConversation}
      />
      {children}
    </>
  );
}

/**
 * Provider for model-related commands
 */
export function ModelsCommandProvider({ children, activeSpace = null }: { children: ReactNode, activeSpace?: any }) {
  const baseModelCommands = useCallback(
    (): CommandOption[] => [
      {
        id: "select-model",
        name: "Select AI Model",
        description: "Choose a different AI model",
        icon: <Brain className="h-4 w-4" />,
        type: "models",
        keywords: ["model", "ai", "select", "change", "choose"],
        action: () => {
          console.log("Opening model selection");
        },
      },
    ],
    []
  );

  const modelCommands = useCallback((): CommandOption[] => {
    const commands: CommandOption[] = [];

    Object.entries(AVAILABLE_MODELS).forEach(([providerKey, models]) => {
      const provider = providerKey as Provider;
      const providerName = PROVIDER_NAMES[provider];

      commands.push({
        id: `provider-${provider}`,
        name: providerName,
        description: `Select a model from ${providerName}`,
        icon: <Brain className="h-4 w-4" />,
        type: "models",
        keywords: ["provider", providerName.toLowerCase(), "model"],
        action: () => {
          console.log(`Selecting provider: ${providerName}`);
        },
      });

      models.forEach((model) => {
        commands.push({
          id: `model-${provider}-${model.id}`,
          name: model.name,
          description: model.description || `${providerName} model`,
          icon: <Brain className="h-4 w-4" />,
          type: "models",
          keywords: ["model", model.name.toLowerCase(), providerName.toLowerCase()],
          action: () => {
            console.log(`Selecting model: ${model.name} from ${providerName}`);
          },
        });
      });
    });

    return commands;
  }, []);

  useCommandRegistration([...baseModelCommands(), ...modelCommands()]);

  return <>{children}</>;
}

/**
 * Provider for general actions commands
 */
export function ActionsCommandProvider({ children }: { children: ReactNode }) {
  const actionCommands = useCallback(
    (): CommandOption[] => [
      {
        id: "keyboard-shortcuts",
        name: "View Keyboard Shortcuts",
        description: "Show all available keyboard shortcuts",
        icon: <Command className="h-4 w-4" />,
        type: "actions",
        keywords: ["keyboard", "shortcuts", "keys", "bindings", "help"],
        action: () => {
          console.log("Viewing keyboard shortcuts");
        },
      },
    ],
    []
  );

  useCommandRegistration(actionCommands());

  return <>{children}</>;
}

/**
 * Combined provider for all command types
 */
export function AllCommandProviders({ 
  children,
  spaces = [],
  activeSpace = null,
  conversations = [],
  activeConversation = null,
  user = null,
  messages = [],
}: { 
  children: ReactNode;
  spaces?: any[];
  activeSpace?: any;
  conversations?: any[];
  activeConversation?: any;
  user?: any;
  messages?: any[];
}) {
  const { initializeState } = useSpaceStore();
  
  useEffect(() => {
    initializeState({
      spaces,
      activeSpace,
      conversations,
      activeConversation,
      messages,
      isLoading: false,
      loadingType: null
    });
  }, []);
  
  return (
    <ApplicationCommandProvider>
      <SpacesCommandProvider>
        <ConversationsCommandProvider>
          <ModelsCommandProvider>
            <ActionsCommandProvider>{children}</ActionsCommandProvider>
          </ModelsCommandProvider>
        </ConversationsCommandProvider>
      </SpacesCommandProvider>
    </ApplicationCommandProvider>
  );
}

================
File: components/CommandRoot.tsx
================
"use client"

import React from 'react';
import CommandCenter from "@/components/CommandCenter";
import CommandShortcuts from "@/components/CommandShortcuts";

export default function CommandRoot() {
  return (
    <>
      <CommandCenter />
      <CommandShortcuts />
    </>
  );
}

================
File: components/CommandShortcuts.tsx
================
import { useModalHotkey, useCommandCenter } from "@/hooks/useCommandCenter";
import { useHotkeys } from "react-hotkeys-hook";

/**
 * Component that registers keyboard shortcuts for specific command types
 * This can be placed anywhere in your component tree, typically near the root
 */
export function CommandShortcuts() {
  const { toggleCommandCenter } = useCommandCenter();

  useHotkeys('meta+k', (event) => {
    event.preventDefault();
    toggleCommandCenter();
  }, {
    enableOnFormTags: true,
    enableOnContentEditable: true
  }); 

  useModalHotkey("spaces", "meta+s");
  useModalHotkey("conversations", "meta+b");
  useModalHotkey("models", "meta+m");
  useModalHotkey("actions", "meta+a");

  return null;
}

export default CommandShortcuts;

================
File: config/models.ts
================
export const PROVIDER_DESCRIPTIONS: Record<Provider, string> = {
  groq: 'Ultra-fast inference optimized for real-time applications',
  anthropic: 'Advanced language models with strong reasoning capabilities',
  openai: 'State-of-the-art models with broad capabilities',
  cohere: 'Specialized models for enterprise and business use cases',
  mistral: 'Open-source foundation models with various specializations',
  google: 'Cutting-edge multimodal models from Google DeepMind',
  xai: 'Advanced models focused on reasoning and transparency',
  togetherai: 'Curated collection of top open-source models',
  perplexity: 'Research-focused models optimized for reasoning tasks'
};

export const AVAILABLE_MODELS = {
  groq: [
    { id: 'deepseek-r1-distill-llama-70b', name: 'Deepseek R1 70B', description: 'Powerful general-purpose model with fast inference', contextWindow: 32768 },
    { id: 'mixtral-8x7b-instruct', name: 'Mixtral 8x7B', description: 'Efficient model balancing speed and capability', contextWindow: 32768 },
    { id: 'deepseek-r1-distill-llama-70b-specdec', name: 'Deepseek R1 70B SpecDec', description: 'Specialized for technical documentation', contextWindow: 32768 },
    { id: 'gemma2-9b-it', name: 'Gemma 2 9B', description: 'Compact model optimized for quick responses', contextWindow: 8192 },
    { id: 'llama-3.3-70b-versatile', name: 'LLaMA 3.3 70B Versatile', description: 'Latest LLaMA optimized for versatility', contextWindow: 128000 },
  ],
  anthropic: [
    { id: 'claude-3-opus-latest', name: 'Claude 3 Opus', description: 'Most capable model for complex tasks', contextWindow: 128000 },
    { id: 'claude-3-5-sonnet-latest', name: 'Claude 3.5 Sonnet', description: 'Balanced performance and speed', contextWindow: 128000 },
    { id: 'claude-3-5-haiku-latest', name: 'Claude 3.5 Haiku', description: 'Fast, efficient for simple tasks', contextWindow: 128000 },
  ],
  openai: [
    { id: 'gpt-4o', name: 'GPT-4o', description: 'Most powerful model for complex reasoning', contextWindow: 128000, multimodal: true },
    { id: 'gpt-4o-mini', name: 'GPT-4o Mini', description: 'Efficient version of GPT-4', contextWindow: 128000, multimodal: true },
    { id: 'o1', name: 'O1', description: 'Fast, general-purpose assistant', contextWindow: 128000 },
    { id: 'o3-mini', name: 'O3 Mini', description: 'Quick responses for simple tasks', contextWindow: 128000 },
  ],
  cohere: [
    { id: 'command', name: 'Command', description: 'Enterprise-grade general model', contextWindow: 128000 },
    { id: 'command-light', name: 'Command Light', description: 'Faster, lighter version of Command', contextWindow: 32768 },
    { id: 'command-nightly', name: 'Command Nightly', description: 'Latest experimental features', contextWindow: 128000 },
    { id: 'command-light-nightly', name: 'Command Light Nightly', description: 'Fast experimental version', contextWindow: 32768 }
  ],
  mistral: [
    { id: 'mistral-large-latest', name: 'Mistral Large', description: 'Most capable open model', contextWindow: 32000 },
    { id: 'codestral-latest', name: 'Codestral', description: 'Specialized for code generation', contextWindow: 32000 },
    { id: 'pixtral-large-latest', name: 'Pixtral Large', description: 'Vision and image understanding', contextWindow: 128000, multimodal: true },
    { id: 'ministral-3b-latest', name: 'Ministral 3B', description: 'Ultra-compact, fast responses', contextWindow: 4096 },
    { id: 'ministral-8b-latest', name: 'Ministral 8B', description: 'Balanced size and capability', contextWindow: 8192 },
    { id: 'mistral-small-latest', name: 'Mistral Small', description: 'Efficient for simple tasks', contextWindow: 4096 },
  ],
  google: [
    { id: 'gemini-2.0-flash-001', name: 'Gemini 2.0 Flash', description: 'Ultra-fast responses, latest version', contextWindow: 1000000, multimodal: true },
    { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro', description: 'Balanced performance model', contextWindow: 1000000, multimodal: true },
  ],
  xai: [
    { id: 'grok-2-1212', name: 'Grok 2', description: 'Advanced reasoning capabilities', contextWindow: 128000 },
    { id: 'grok-2-vision-1212', name: 'Grok 2 Vision', description: 'Multimodal understanding', contextWindow: 128000, multimodal: true },
  ],
  togetherai: [
    { id: 'deepseek-ai/DeepSeek-R1', name: 'DeepSeek R1', description: 'General purpose reasoning', contextWindow: 128000 },
    { id: 'deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free', name: 'DeepSeek R1 Distill Llama 70B', description: 'Efficient large model', contextWindow: 32768 },
    { id: 'deepseek-ai/DeepSeek-V3', name: 'DeepSeek V3', description: 'Latest architecture improvements', contextWindow: 128000 },
    { id: 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free', name: 'Llama 3.3 70B Instruct Turbo', description: 'Fast instruction following', contextWindow: 128000 },
    { id: 'meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo', name: 'Llama 3.1 405B Instruct Turbo', description: 'Massive model, best quality', contextWindow: 128000 },
  ],
  perplexity: [
    { id: 'sonar-reasoning-pro', name: 'Sonar Reasoning Pro', description: 'Advanced reasoning capabilities', contextWindow: 200000 },
    { id: 'sonar-reasoning', name: 'Sonar Reasoning', description: 'Efficient reasoning model', contextWindow: 200000 },
    { id: 'sonar-pro', name: 'Sonar Pro', description: 'Professional general use', contextWindow: 200000 },
    { id: 'sonar', name: 'Sonar', description: 'Fast, reliable model', contextWindow: 200000 }
  ]
} as const;

export type Provider = keyof typeof AVAILABLE_MODELS;
export type ModelsByProvider = {
  [P in Provider]: typeof AVAILABLE_MODELS[P][number]['id'];
};

export const PROVIDER_NAMES: Record<Provider, string> = {
  groq: 'Groq',
  anthropic: 'Anthropic',
  openai: 'OpenAI',
  cohere: 'Cohere',
  mistral: 'Mistral',
  google: 'Google',
  xai: 'xAI',
  togetherai: 'Together AI',
  perplexity: 'Perplexity'
};

export function isValidModelForProvider(provider: Provider, model: string): boolean {
  return AVAILABLE_MODELS[provider].some(m => m.id === model);
}

export function getModelName(provider: Provider | undefined, modelId: string): string {
  if (!provider || !modelId) return 'Select Model';
  
  const models = AVAILABLE_MODELS[provider];
  if (!models) return modelId;

  const model = models.find(m => m.id === modelId);
  return model?.name || modelId;
}

================
File: docs/COMMAND_SYSTEM.md
================
# Command System Architecture

This document outlines the architecture of the Spatial Command System, a unified modal interface for accessing all functionality within the application.

## Overview

The Command System follows the Raycast pattern, providing a single entry point to all application functionalities. It is designed to be:

- **Extensible**: New commands can be easily added to any part of the application
- **Modular**: Commands are organized into logical categories
- **Accessible**: Available via keyboard shortcuts (⌘K) or UI buttons
- **Scalable**: Built to handle an unlimited number of commands
- **Fast**: Quick access to any feature within the application

## Architecture

The Command System architecture follows SOLID principles:

### Single Responsibility Principle
- Each component has a single responsibility
- `CommandCenter` - Displays the command UI
- `CommandProvider` - Manages command state
- Section-specific providers - Register commands for their domains

### Open/Closed Principle
- The system is open for extension but closed for modification
- New command categories can be added without changing existing code
- New commands can be registered without modifying the core framework

### Liskov Substitution Principle
- Command types follow a consistent interface
- All commands have the same structure regardless of their category

### Interface Segregation Principle
- The API is minimal and focused
- Command registration hooks provide just what's needed
- Command rendering is separated from command behavior

### Dependency Inversion Principle
- High-level modules don't depend on low-level modules
- Commands are registered through abstraction (context)
- Components consume the command API through hooks

## Core Components

### 1. Command UI Components (`components/ui/command.tsx`)
- Reusable UI components built on top of CMDK
- Includes dialog, input, list, and item components
- Styled with Tailwind CSS for a consistent look and feel

### 2. Command Context (`hooks/useCommandCenter.tsx`)
- Central state management for the command system
- Handles command registration and filtering
- Manages dialog open/close state and keyboard shortcuts
- Provides functions to open specific command types directly

### 3. Command Providers (`components/CommandProviders.tsx`)
- Section-specific providers that register commands for their domains
- Organized into logical categories (application, spaces, conversations, etc.)
- Each provider registers its commands on mount and unregisters on unmount

### 4. Command Center (`components/CommandCenter.tsx`)
- Main component that displays the command UI
- Handles rendering of command groups and items
- Manages navigation between command categories

### 5. Command Button (`components/CommandButton.tsx`)
- UI component to trigger the command center
- Can be customized and placed anywhere in the application
- Includes TypedCommandButton for direct access to specific command types

### 6. Command Shortcuts (`components/CommandShortcuts.tsx`)
- Registers global keyboard shortcuts for specific command types
- Makes specific categories directly accessible via keyboard

## Command Structure

Each command follows this structure:

```typescript
interface CommandOption {
  id: string;                   // Unique identifier
  name: string;                 // Display name
  description?: string;         // Optional description
  icon?: ReactNode;             // Optional icon
  shortcut?: string[];          // Optional keyboard shortcut
  type: CommandType;            // Category (application, spaces, etc.)
  keywords?: string[];          // Optional keywords for search
  action: () => void;           // Function to execute when selected
}
```

## Extension Points

To add new commands:

1. Create a new command provider or extend an existing one
2. Define your commands following the `CommandOption` interface
3. Register them using the `useCommandRegistration` hook

For a new command category:

1. Add the new type to the `CommandType` union type
2. Create a new provider for that category
3. Add your commands following the structure above
4. Add a modal-specific shortcut if needed

## Keyboard Shortcuts

The system supports two levels of keyboard shortcuts:

1. **Global Command Center Shortcut**: `⌘K` (or `Ctrl+K` on Windows) opens the main command center.
2. **Type-Specific Shortcuts**:
   - `⌘S` - Open Spaces commands
   - `⌘T` - Open Conversations commands
   - `⌘M` - Open Models commands
   - `⌘A` - Open Actions commands

To add a new type-specific shortcut:

```typescript
// In CommandShortcuts.tsx or any component
useModalHotkey("your-command-type", "meta+letter");
```

## Design Decisions

1. **Context-based State Management**
   - Using React Context for global command state
   - Allows any component to register commands from anywhere in the app

2. **Component Composition**
   - Command UI components are composable
   - Allows for customization and future extension

3. **Keyboard Accessibility**
   - All commands are accessible via keyboard shortcuts
   - The command center itself is triggered via ⌘K (or Ctrl+K)
   - Type-specific shortcuts for direct access to specific categories

4. **Search-based Navigation**
   - Commands are searchable by name, description, and keywords
   - Enables quick access to any functionality

5. **Category-based Organization**
   - Commands are organized into logical categories
   - Provides structure to potentially hundreds of commands

6. **Direct Modal Access**
   - Each command category can be accessed directly
   - Supports both keyboard shortcuts and UI buttons

## Future Improvements

1. **Command History**
   - Track recently used commands
   - Allow quick access to frequently used actions

2. **Dynamic Command Loading**
   - Lazy-load commands based on application state
   - Register commands only when needed

3. **Sub-commands and Nested Navigation**
   - Add support for commands that open sub-menus
   - Enable more complex command hierarchies

4. **Command Permissions**
   - Control command visibility based on user permissions
   - Show/hide commands based on application state

5. **Command Palettes**
   - Create context-specific command palettes
   - Show different sets of commands based on the current view

================
File: electron/main.ts
================
import { app, BrowserWindow } from "electron";
import { join } from "path";

const createWindow = () => {
  const mainWindow = new BrowserWindow({
    width: 900,
    height: 670,
    webPreferences: {
      preload: join(__dirname, "preload.js"),
      nodeIntegration: true,
    },
  });
  
  mainWindow.loadURL("http://localhost:3000");
};

app.whenReady().then(createWindow);

================
File: hooks/use-stick-to-bottom.ts
================
import { useCallback, useEffect, useRef, useState } from 'react';

export function useStickToBottom(threshold = 150) {
  const [isStickToBottom, setIsStickToBottom] = useState(true);
  const containerRef = useRef<HTMLDivElement>(null);
  const prevScrollHeightRef = useRef<number>(0);

  const checkIsStickToBottom = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    const { scrollHeight, scrollTop, clientHeight } = container;
    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
    
    setIsStickToBottom(distanceFromBottom <= threshold);
  }, [threshold]);

  const scrollToBottom = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    // Ensure we scroll all the way to the bottom
    container.scrollTop = container.scrollHeight;
  }, []);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = () => {
      checkIsStickToBottom();
    };

    container.addEventListener('scroll', handleScroll);
    return () => container.removeEventListener('scroll', handleScroll);
  }, [checkIsStickToBottom]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleResize = () => {
      if (isStickToBottom) {
        scrollToBottom();
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [isStickToBottom, scrollToBottom]);

  // Auto-scroll when content changes if we're sticking to bottom
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const { scrollHeight } = container;
    
    if (scrollHeight !== prevScrollHeightRef.current) {
      if (isStickToBottom) {
        scrollToBottom();
      }
      prevScrollHeightRef.current = scrollHeight;
    }
  });

  // Always scroll to bottom on initial render
  useEffect(() => {
    scrollToBottom();
  }, []);

  return {
    containerRef,
    isStickToBottom,
    scrollToBottom
  };
}

================
File: hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/common/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: hooks/useCommandCenter.tsx
================
'use client'
import { ReactNode, createContext, useCallback, useContext, useEffect, useMemo, useState, useRef } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';

// Command types
export type CommandType = 'application' | 'spaces' | 'conversations' | 'models' | 'actions';

export interface CommandOption {
  id: string;
  name: string;
  description?: string;
  icon?: ReactNode;
  rightElement?: ReactNode;
  shortcut?: string[];
  type: CommandType;
  keywords?: string[];
  action: () => void;
}

interface CommandContextType {
  isOpen: boolean;
  openCommandCenter: () => void;
  closeCommandCenter: () => void;
  toggleCommandCenter: () => void;
  openCommandType: (type: CommandType) => void;
  closeCommandType: (type: CommandType) => void;
  registerCommand: (command: CommandOption) => void;
  unregisterCommand: (commandId: string) => void;
  commands: CommandOption[];
  filteredCommands: CommandOption[];
  setSearchQuery: (query: string) => void;
  searchQuery: string;
  activeCommandType: CommandType | null;
  setActiveCommandType: (type: CommandType | null) => void;
}

const CommandContext = createContext<CommandContextType | undefined>(undefined);

export function CommandProvider({ children }: { children: ReactNode }) {
  const [isOpen, setIsOpen] = useState(false);
  const [commands, setCommands] = useState<CommandOption[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [activeCommandType, setActiveCommandType] = useState<CommandType | null>(null);
  
  // Use a ref to track mounted state to avoid state updates after unmount
  const isMounted = useRef(true);
  
  useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);

  // Command center controls
  const openCommandCenter = useCallback(() => setIsOpen(true), []);
  const closeCommandCenter = useCallback(() => {
    console.log('closeCommandCenter called');
    setIsOpen(false);
    setSearchQuery('');
    setActiveCommandType(null);
  }, []);
  
  const toggleCommandCenter = useCallback(() => {
    console.log('toggleCommandCenter called');
    console.log('Current state:', { isOpen, activeCommandType });
    
    if (isOpen) {
      if (activeCommandType !== null) {
        console.log('Switching from specific command type to main command center');
        setActiveCommandType(null);
      } else {
        console.log('Closing main command center');
        setIsOpen(false);
        setSearchQuery('');
        setActiveCommandType(null);
      }
    } else {
      console.log('Opening main command center');
      setIsOpen(true);
      setActiveCommandType(null);
    }
  }, [isOpen, activeCommandType]);
  
  // Function to close a specific command type
  const closeCommandType = useCallback((type: CommandType) => {
    console.log('closeCommandType called with:', type);
    if (isOpen && activeCommandType === type) {
      setIsOpen(false);
      setSearchQuery('');
    }
  }, [isOpen, activeCommandType]);
  
  // New function to open command center with a specific type
  const openCommandType = useCallback((type: CommandType) => {
    console.log('openCommandType called with:', type);
    if (isOpen && activeCommandType === type) {
      console.log('Closing the currently open type');
      closeCommandType(type);
    } else {
      console.log('Switching to command type:', type);
      setActiveCommandType(type);
      if (!isOpen) {
        setIsOpen(true);
        console.log('Opening command center');
      }
    }
  }, [isOpen, activeCommandType, closeCommandType]);

  // Register keyboard shortcuts
  // meta+k is now handled in CommandShortcuts component
  useHotkeys('esc', () => {
    if (isOpen) {
      closeCommandCenter();
    }
  });

  // Command registration - properly memoized to prevent infinite loops
  const registerCommand = useCallback((command: CommandOption) => {
    console.log('registerCommand called with:', command);

    if (!isMounted.current) return;
    
    setCommands(prev => {
      // Check if this exact command already exists to avoid unnecessary updates
      const exists = prev.some(cmd => cmd.id === command.id);
      if (exists) {
        // Only update if there are actual changes
        const isEqual = prev.some(cmd => 
          cmd.id === command.id && 
          cmd.name === command.name && 
          cmd.description === command.description
        );
        if (isEqual) return prev; // No change needed
        
        // Replace the existing command
        return prev.map(cmd => cmd.id === command.id ? command : cmd);
      }
      // Add new command
      return [...prev, command];
    });
  }, []);

  const unregisterCommand = useCallback((commandId: string) => {
    console.log('unregisterCommand called with:', commandId);

    if (!isMounted.current) return;
    
    setCommands(prev => {
      // Only update if the command exists
      const commandExists = prev.some(cmd => cmd.id === commandId);
      if (!commandExists) return prev;
      return prev.filter(cmd => cmd.id !== commandId);
    });
  }, []);

  // Filter commands based on search query and active type - memoize to avoid recalculation
  const filteredCommands = useMemo(() => {
    return commands.filter(command => {
      // Filter by type if active type is set
      if (activeCommandType && command.type !== activeCommandType) {
        return false;
      }

      // If no search query, return all commands of the active type (or all commands if no active type)
      if (!searchQuery) return true;

      const query = searchQuery.toLowerCase();
      
      // Search in name, description, and keywords
      return (
        command.name.toLowerCase().includes(query) ||
        (command.description?.toLowerCase().includes(query)) ||
        command.keywords?.some(keyword => keyword.toLowerCase().includes(query))
      );
    });
  }, [commands, searchQuery, activeCommandType]);

  // Context value - memoize to prevent unnecessary re-renders
  const value = useMemo(() => ({
    isOpen,
    openCommandCenter,
    closeCommandCenter,
    toggleCommandCenter,
    openCommandType,
    closeCommandType,
    registerCommand,
    unregisterCommand,
    commands,
    filteredCommands,
    searchQuery,
    setSearchQuery,
    activeCommandType,
    setActiveCommandType,
  }), [
    isOpen, 
    openCommandCenter, 
    closeCommandCenter, 
    toggleCommandCenter, 
    openCommandType,
    closeCommandType,
    registerCommand, 
    unregisterCommand, 
    commands, 
    filteredCommands, 
    searchQuery, 
    activeCommandType
  ]);

  return (
    <CommandContext.Provider value={value}>
      {children}
    </CommandContext.Provider>
  );
}

export function useCommandCenter() {
  const context = useContext(CommandContext);
  if (context === undefined) {
    throw new Error('useCommandCenter must be used within a CommandProvider');
  }
  return context;
}

export function useCommandRegistration(commands: CommandOption[]) {
  const { registerCommand, unregisterCommand } = useCommandCenter();
  
  const commandsRef = useRef<CommandOption[]>([]);
  
  useEffect(() => {
    console.log(`useCommandRegistration - commands changed, count: ${commands.length}`);
    
    // Make a deep copy of incoming commands to prevent reference issues
    const currentCommands = [...commands];
    
    // Find commands that were previously registered but are no longer in the current list
    const removedCommands = commandsRef.current.filter(
      prevCmd => !currentCommands.some(cmd => cmd.id === prevCmd.id)
    );
    
    // Unregister removed commands
    removedCommands.forEach(command => {
      console.log(`Unregistering command: ${command.id}`);
      unregisterCommand(command.id);
    });
    
    // Find new commands that weren't previously registered
    const newCommands = currentCommands.filter(
      cmd => !commandsRef.current.some(prevCmd => prevCmd.id === cmd.id)
    );
    
    // Register new commands
    newCommands.forEach(command => {
      console.log(`Registering new command: ${command.id}`);
      registerCommand(command);
    });
    
    // Also update any commands that might have changed but kept the same ID
    const updatedCommands = currentCommands.filter(
      cmd => commandsRef.current.some(prevCmd => 
        prevCmd.id === cmd.id && 
        (prevCmd.name !== cmd.name || 
         prevCmd.description !== cmd.description ||
         JSON.stringify(prevCmd.keywords) !== JSON.stringify(cmd.keywords))
      )
    );
    
    // Re-register updated commands
    updatedCommands.forEach(command => {
      console.log(`Updating command: ${command.id}`);
      registerCommand(command);
    });
    
    // Update our ref to the current commands array
    commandsRef.current = currentCommands;
    
  }, [commands, registerCommand, unregisterCommand]);
}

export function useModalHotkey(type: CommandType, hotkey: string) {
  const { openCommandType } = useCommandCenter();
  
  useHotkeys(hotkey, (event) => {
    event.preventDefault();
    console.log('Hotkey pressed:', hotkey);
    openCommandType(type);
  }, { 
    enableOnFormTags: true,
    enableOnContentEditable: true
  });
}

================
File: hooks/useLoadingOperation.ts
================
import { useState, useCallback } from 'react';

interface OperationCallbacks<T> {
  onSuccess?: (result: T) => void | Promise<void>;
  onError?: (error: any) => void | Promise<void>;
}

/**
 * Hook for managing loading states during async operations
 * Ensures loading state persists until the entire operation completes
 */
export function useLoadingOperation<T>(
  operationFn: (...args: any[]) => Promise<T>,
  callbacks: OperationCallbacks<T> = {}
) {
  const [isLoading, setIsLoading] = useState(false);
  const [result, setResult] = useState<T | null>(null);
  const [error, setError] = useState<any>(null);
  
  const execute = useCallback(async (...args: any[]) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const operationResult = await operationFn(...args);
      setResult(operationResult);
      
      if (callbacks.onSuccess) {
        await callbacks.onSuccess(operationResult);
      }
      
      return operationResult;
    } catch (err) {
      setError(err);
      
      if (callbacks.onError) {
        await callbacks.onError(err);
      }
      
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [operationFn, callbacks]);
  
  return { 
    execute, 
    isLoading, 
    result, 
    error,
    reset: useCallback(() => {
      setResult(null);
      setError(null);
    }, [])
  };
}

================
File: hooks/useOperationToast.ts
================
import { useCallback } from 'react';
import { useToast } from './use-toast';
import { ActionResponse } from '@/app/actions/utils/responses';

/**
 * Hook for handling toast notifications from operation results
 * Provides a consistent way to show toast messages when operations complete
 */
export function useOperationToast() {
  const { toast } = useToast();
  
  const showToastFromResult = useCallback(<T>(result: ActionResponse<T>) => {
    if (result.toast) {
      const { title, description, variant } = result.toast;
      toast({
        title, 
        description,
        variant,
        // Use a longer duration to ensure user sees it
        duration: 3000
      });
    } else if (result.status === 'error' && result.error) {
      // Show error toast if we have an error but no toast defined
      toast({
        title: 'Error',
        description: result.error,
        variant: 'destructive',
        duration: 3000
      });
    }
  }, [toast]);
  
  // Helper for showing custom toast
  const showCustomToast = useCallback((
    title: string,
    description: string,
    variant: 'default' | 'success' | 'destructive' = 'default'
  ) => {
    toast({ 
      title, 
      description, 
      variant, 
      duration: 3000 
    });
  }, [toast]);
  
  return { 
    showToastFromResult,
    showCustomToast
  };
}

================
File: hooks/useRouteTransition.ts
================
import { useState, useCallback } from 'react';
import { useRouter } from 'next/navigation';

type OperationResult = {
  redirectTo?: string;
  [key: string]: any;
};

/**
 * Hook for managing loading states during routing transitions
 * Ensures the UI stays in loading state until navigation completes
 */
export function useRouteTransition() {
  const router = useRouter();
  const [isTransitioning, setIsTransitioning] = useState(false);
  
  const navigateWhenReady = useCallback(async (
    operation: () => Promise<OperationResult>,
    fallbackPath?: string
  ) => {
    setIsTransitioning(true);
    
    try {
      const result = await operation();
      
      if (result?.redirectTo) {
        await router.push(result.redirectTo);
      } else if (fallbackPath) {
        await router.push(fallbackPath);
      }
      
      return result;
    } catch (error) {
      console.error('Navigation error:', error);
      return null;
    } finally {
      // Use a small delay to ensure the UI doesn't flash
      setTimeout(() => setIsTransitioning(false), 300);
    }
  }, [router]);
  
  return { 
    navigateWhenReady, 
    isTransitioning 
  };
}

================
File: lib/utils.ts
================
import { redirect } from "next/navigation";
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Redirects to a specified path with an encoded message as a query parameter.
 * @param {('error' | 'success')} type - The type of message, either 'error' or 'success'.
 * @param {string} path - The path to redirect to.
 * @param {string} message - The message to be encoded and added as a query parameter.
 * @returns {never} This function doesn't return as it triggers a redirect.
 */
export function encodedRedirect(
  type: "error" | "success",
  path: string,
  message: string,
) {
  return redirect(`${path}?${type}=${encodeURIComponent(message)}`);
}

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: public/icons/providers/default.svg
================
<?xml version="1.0" encoding="UTF-8"?>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M12 2L2 7L12 12L22 7L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M2 17L12 22L22 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M2 12L12 17L22 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: public/icons/providers/groq.svg
================
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="152px" height="55.5px" viewBox="0 32.25 152 55.5" enable-background="new 0 32.25 152 55.5" xml:space="preserve">
 <title>
  groq_logo
 </title>
 <g id="Layer_2">
  <g id="Layer_1-2">
   <path d="M84.848,34.137c-9.798,0-17.769,7.971-17.769,17.77s7.971,17.769,17.769,17.769s17.77-7.971,17.77-17.769
			S94.645,34.137,84.848,34.137z M84.848,63.013c-6.124,0-11.106-4.983-11.106-11.106s4.982-11.106,11.106-11.106
			c6.124,0,11.106,4.982,11.106,11.106S90.973,63.013,84.848,63.013z">
   </path>
   <path d="M60.315,34.206c-0.607-0.068-1.217-0.104-1.827-0.108c-0.304,0-0.595,0.009-0.893,0.014s-0.594,0.033-0.891,0.051
			c-1.197,0.094-2.382,0.299-3.541,0.611c-2.329,0.629-4.574,1.723-6.515,3.277c-1.97,1.57-3.548,3.575-4.611,5.859
			c-0.53,1.138-0.921,2.336-1.165,3.567c-0.121,0.608-0.21,1.222-0.266,1.84c-0.02,0.307-0.055,0.615-0.059,0.921l-0.011,0.459
			l-0.005,0.23v0.19l0.015,5.951l0.015,5.951l0.041,5.95h6.664l0.042-5.95l0.015-5.952l0.015-5.951v-0.182l0.005-0.142l0.008-0.285
			c0-0.191,0.028-0.375,0.039-0.564c0.036-0.37,0.091-0.738,0.165-1.102c0.146-0.716,0.374-1.413,0.678-2.077
			c0.613-1.332,1.528-2.502,2.673-3.419c1.156-0.932,2.541-1.628,4.038-2.042c0.757-0.207,1.532-0.344,2.314-0.408
			c0.198-0.011,0.395-0.03,0.594-0.037c0.199-0.007,0.402-0.013,0.595-0.012c0.383,0,0.76,0.025,1.142,0.06
			c1.518,0.153,2.989,0.619,4.318,1.368l3.326-5.776C65.108,35.263,62.753,34.484,60.315,34.206z">
   </path>
   <path d="M17.77,34.048C7.971,34.048,0,42.019,0,51.817s7.971,17.77,17.77,17.77h5.844v-6.664H17.77
			c-6.124,0-11.106-4.982-11.106-11.106s4.982-11.106,11.106-11.106s11.132,4.982,11.132,11.106l0,0v16.365l0,0
			c0,6.084-4.954,11.039-11.023,11.103c-2.904-0.024-5.681-1.191-7.729-3.25l-4.712,4.712c3.266,3.283,7.691,5.151,12.321,5.201
			v0.003c0.04,0,0.08,0,0.119,0h0.125v-0.003c9.659-0.131,17.48-8.005,17.525-17.686l0.006-16.881
			C35.302,41.785,27.422,34.048,17.77,34.048z">
   </path>
   <path d="M124.083,34.137c-9.798,0-17.769,7.971-17.769,17.77s7.971,17.769,17.769,17.769h6.08v-6.663h-6.08
			c-6.124,0-11.106-4.983-11.106-11.106s4.982-11.106,11.106-11.106c5.799,0,10.572,4.468,11.062,10.143h-0.01v34.12h6.664V51.907
			l0,0C141.797,42.108,133.881,34.137,124.083,34.137z">
   </path>
   <polygon points="151.983,35.04 151.033,35.04 149.737,37.053 148.399,35.04 147.44,35.04 147.44,38.624 148.511,38.624 
			148.511,36.88 149.461,38.288 149.979,38.288 150.912,36.836 150.929,38.624 152,38.624 		">
   </polygon>
   <polygon points="143.519,35.896 144.685,35.896 144.685,38.624 145.86,38.624 145.86,35.896 147.034,35.896 147.034,35.04 
			143.519,35.04 		">
   </polygon>
  </g>
 </g>
</svg>

================
File: stores/space-store.ts
================
import { create } from 'zustand';
import { toast } from 'sonner';
import { 
  createSpace as createSpaceAction,
  updateSpace as updateSpaceAction,
  deleteSpace as deleteSpaceAction,
  getSpaces as getSpacesAction,
  getSpace as getSpaceAction,
  getSpaceData as getSpaceDataAction,
  setActiveSpace as setActiveSpaceAction,
  createConversation as createConversationAction,
  updateConversationTitle as updateConversationTitleAction,
  deleteConversation as deleteConversationAction
} from '@/app/actions';

export interface UIState {
  activeSpace: Space | null;
  conversations: Conversation[] | null;
  activeConversation: Conversation | null;
  messages: any[] | null;
  isLoading: boolean;
  loadingType: 'space' | 'conversation' | 'messages' | null;
}

export interface Space {
  id: string;
  name: string;
  description?: string;
  user_id: string;
  model: string;
  provider: string;
  color?: string;
  created_at?: string;
  updated_at?: string;
  is_deleted?: boolean;
  [key: string]: any;
}

export interface Conversation {
  id: string;
  title?: string;
  space_id: string;
  created_at?: string;
  updated_at?: string;
  is_deleted?: boolean;
  [key: string]: any;
}

export interface SpaceData {
  space: Space | null;
  conversations: Conversation[] | null;
  messages: any[] | null;
  activeConversation: Conversation | null;
}

export interface InitialState {
  spaces?: Space[] | null;
  activeSpace?: Space | null;
  conversations?: Conversation[] | null;
  activeConversation?: Conversation | null;
  messages?: any[] | null;
  isLoading?: boolean;
  loadingType?: 'space' | 'conversation' | 'messages' | null;
}

export interface SpaceStore {
  // State
  spaces: Space[] | null;
  activeSpace: Space | null;
  conversations: Conversation[] | null;
  activeConversation: Conversation | null;
  isLoading: boolean;
  loadingSpaceId: string | null;
  loadingConversationId: string | null;
  
  // UI State for rendering components without navigation
  uiState: UIState;
  
  // Single initialization function
  initializeState: (initialState: InitialState) => void;
  
  // UI State update methods
  updateUIState: (updates: Partial<UIState>) => void;
  
  // Space fetch operations
  fetchSpaces: () => Promise<Space[] | null>;
  fetchSpace: (id: string) => Promise<Space | null>;
  fetchSpaceData: (id: string) => Promise<SpaceData | null>;
  loadSpaceFullData: (spaceId: string) => Promise<SpaceData | null>;
  
  // Space local state operations
  setSpaces: (spaces: Space[] | null) => void;
  setActiveSpace: (space: Space | null) => void;
  updateLocalSpace: (id: string, updates: Partial<Space>) => void;
  addLocalSpace: (space: Space) => void;
  removeLocalSpace: (id: string) => void;
  
  // Space server operations with optimistic updates
  createSpace: (name: string, description: string, model: string, provider: string, color?: string) => Promise<Space | null>;
  updateSpace: (id: string, updates: Partial<Space>) => Promise<boolean>;
  deleteSpace: (id: string) => Promise<boolean>;
  setActiveSpaceOnServer: (id: string) => Promise<boolean>;
  
  // Conversation state operations
  setConversations: (conversations: Conversation[] | null) => void;
  setActiveConversation: (conversation: Conversation | null) => void;
  updateLocalConversation: (id: string, updates: Partial<Conversation>) => void;
  addLocalConversation: (conversation: Conversation) => void;
  removeLocalConversation: (id: string) => void;
  
  // Conversation server operations
  createConversation: (title?: string) => Promise<Conversation | null>;
  selectConversation: (conversationId: string) => Promise<boolean>;
  updateConversation: (conversationId: string, title: string) => Promise<boolean>;
  deleteConversation: (conversationId: string) => Promise<boolean>;
  
  // Loading state
  setLoading: (isLoading: boolean) => void;
  setLoadingSpaceId: (id: string | null) => void;
  setLoadingConversationId: (id: string | null) => void;
  
  // Navigation helper (keeping for backward compatibility)
  navigateToActiveConversation: (router: any) => void;
}

export const useSpaceStore = create<SpaceStore>((set, get) => ({
  // State
  spaces: null,
  activeSpace: null,
  conversations: null,
  activeConversation: null,
  isLoading: false,
  loadingSpaceId: null,
  loadingConversationId: null,
  
  // Initialize UI state
  uiState: {
    activeSpace: null,
    conversations: null,
    activeConversation: null,
    messages: null,
    isLoading: false,
    loadingType: null
  },
  
  // Single consolidated initialization function
  initializeState: (initialState) => {
    console.log('Initializing space store state with:', initialState);
    
    set({
      // Set main state
      spaces: initialState.spaces || null,
      activeSpace: initialState.activeSpace || null,
      conversations: initialState.conversations || null,
      activeConversation: initialState.activeConversation || null,
      isLoading: initialState.isLoading || false,
      
      // Also update UI state to match
      uiState: {
        activeSpace: initialState.activeSpace || null,
        conversations: initialState.conversations || null,
        activeConversation: initialState.activeConversation || null,
        messages: initialState.messages || null,
        isLoading: initialState.isLoading || false,
        loadingType: initialState.loadingType || null
      }
    });
  },
  
  // Update UI state method
  updateUIState: (updates) => {
    set((state) => ({
      uiState: {
        ...state.uiState,
        ...updates
      }
    }));
  },
  
  // Fetch operations
  fetchSpaces: async () => {
    set({ isLoading: true });
    try {
      const response: any = await getSpacesAction();
      if (response && response.status === 'success' && response.data) {
        set({ spaces: response.data });
        return response.data;
      }
      return null;
    } catch (error) {
      console.error('Error fetching spaces:', error);
      return null;
    } finally {
      set({ isLoading: false });
    }
  },
  
  fetchSpace: async (id) => {
    set({ loadingSpaceId: id });
    try {
      const response: any = await getSpaceAction(id);
      if (response && response.status === 'success' && response.data) {
        // Update this space in our local spaces array
        set((state) => ({
          spaces: state.spaces?.map(space => 
            space.id === id ? response.data : space
          ) || [response.data]
        }));
        return response.data;
      }
      return null;
    } catch (error) {
      console.error('Error fetching space:', error);
      return null;
    } finally {
      set({ loadingSpaceId: null });
    }
  },
  
  fetchSpaceData: async (id) => {
    set({ 
      loadingSpaceId: id,
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'space'
      }
    });
    
    try {
      const response: any = await getSpaceDataAction(id);
      if (response && response.status === 'success' && response.data) {
        // If we get space data, also update the space in our store
        if (response.data.space) {
          set((state) => ({
            spaces: state.spaces?.map(space => 
              space.id === id ? response.data.space : space
            ) || [response.data.space]
          }));
        }
        
        // Update both standard and UI state
        set((state) => ({
          conversations: response.data.conversations,
          activeConversation: response.data.activeConversation,
          uiState: {
            ...state.uiState,
            activeSpace: response.data.space,
            conversations: response.data.conversations,
            activeConversation: response.data.activeConversation,
            messages: response.data.messages,
            isLoading: false,
            loadingType: null
          }
        }));
        
        return response.data;
      }
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      return null;
    } catch (error) {
      console.error('Error fetching space data:', error);
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      return null;
    } finally {
      set({ loadingSpaceId: null });
    }
  },
  
  loadSpaceFullData: async (spaceId) => {
    set((state) => ({
      uiState: {
        ...state.uiState,
        isLoading: true,
        loadingType: 'space'
      }
    }));
    
    try {
      const spaceDataResponse: any = await getSpaceDataAction(spaceId);
      
      if (spaceDataResponse) {
        const { space, conversations, activeConversation, messages } = spaceDataResponse;
        
        set((state) => ({
          activeSpace: space,
          spaces: state.spaces?.map(s => s.id === spaceId ? space : s) || [space],
          conversations: conversations,
          activeConversation: activeConversation,
          
          uiState: {
            activeSpace: space,
            conversations: conversations,
            activeConversation: activeConversation,
            messages: messages,
            isLoading: false,
            loadingType: null
          }
        }));
        
        await setActiveSpaceAction(spaceId);

        return spaceDataResponse;
      } else {
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));

        return null;
      }
    } catch (error) {
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
    }
  },
  
  // Space local state operations
  setSpaces: (spaces) => set({ spaces }),
  
  setActiveSpace: (space) => set({ 
    activeSpace: space,
    uiState: {
      ...get().uiState,
      activeSpace: space
    } 
  }),
  
  updateLocalSpace: (id, updates) => set((state) => {
    const updatedSpaces = state.spaces?.map(space => 
      space.id === id ? { ...space, ...updates } : space
    ) || null;
    
    const updatedActiveSpace = state.activeSpace?.id === id 
      ? { ...state.activeSpace, ...updates } 
      : state.activeSpace;
    
    const updatedUIState = {
      ...state.uiState,
      activeSpace: state.uiState.activeSpace?.id === id 
        ? { ...state.uiState.activeSpace, ...updates }
        : state.uiState.activeSpace
    };
    
    return {
      spaces: updatedSpaces,
      activeSpace: updatedActiveSpace,
      uiState: updatedUIState
    };
  }),
  
  addLocalSpace: (space) => set((state) => {
    console.log('Adding local space:', space.id);
    const newSpaces = state.spaces 
      ? [space, ...state.spaces] 
      : [space];
      
    return {
      spaces: newSpaces
    };
  }),
  
  removeLocalSpace: (id) => set((state) => ({
    spaces: state.spaces?.filter(space => space.id !== id) || null,
    activeSpace: state.activeSpace?.id === id 
      ? null 
      : state.activeSpace,
    uiState: {
      ...state.uiState,
      activeSpace: state.uiState.activeSpace?.id === id 
        ? null
        : state.uiState.activeSpace
    }
  })),
  
  createSpace: async (name, description, model, provider, color) => {
    set({ 
      isLoading: true,
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'space'
      }
    });
    
    try {
      const space: any = await createSpaceAction(name, description, model, provider, true, color);

      set((state) => ({
        spaces: state.spaces ? [space, ...state.spaces] : [space],
        activeSpace: space,
        uiState: {
          ...state.uiState,
          activeSpace: space,
          isLoading: false,
          loadingType: null
        }
      }));

      await get().loadSpaceFullData(space.id);

      return space;
    } catch (error) {
      console.error('Error creating space:', error);
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      toast.error('Creation Failed', {
        description: 'Could not create space'
      });
      return null;
    } finally {
      set({ isLoading: false });
    }
  },
  
  updateSpace: async (id, updates) => {
    set({ 
      loadingSpaceId: id,
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'space'
      }
    });
    
    try {
      // Update local state optimistically
      get().updateLocalSpace(id, updates);
      
      // Call server action
      const response: any = await updateSpaceAction(id, updates);
      
      if (response && response.status === 'success') {
        // Update with server data to ensure consistency
        if (response.data) {
          get().updateLocalSpace(id, response.data);
        }
        
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));
        
        toast.success('Space Updated', {
          description: 'Changes saved successfully'
        });
        
        return true;
      } else {
        // Fetch the original space to rollback on failure
        const originalSpace = await get().fetchSpace(id);
        if (originalSpace) {
          get().updateLocalSpace(id, originalSpace);
        }
        
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));
        
        toast.error('Update Failed', {
          description: response?.message || 'Could not update space'
        });
        return false;
      }
    } catch (error) {
      console.error('Error updating space:', error);
      
      // Try to fetch the original space to rollback
      const originalSpace = await get().fetchSpace(id);
      if (originalSpace) {
        get().updateLocalSpace(id, originalSpace);
      }
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      toast.error('Update Failed', {
        description: 'Could not update space'
      });
      return false;
    } finally {
      set({ loadingSpaceId: null });
    }
  },
  
  deleteSpace: async (id) => {
    set({ 
      loadingSpaceId: id,
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'space'
      }
    });
    
    try {
      // Check if this is the active space
      const isActiveSpace = get().activeSpace?.id === id;
      const isUIActiveSpace = get().uiState.activeSpace?.id === id;
      
      // Get space before deletion for potential rollback
      const spaceToDelete = get().spaces?.find(space => space.id === id);
      
      // Update local state optimistically
      get().updateLocalSpace(id, { is_deleted: true });
      
      // Remove from UI immediately (optimistic)
      get().removeLocalSpace(id);
      
      try {
        // Call deleteSpaceAction which returns void or throws an error
        await deleteSpaceAction(id);
        
        // If we reach here, deletion was successful
        toast.success('Space Deleted', {
          description: 'Space has been removed'
        });
        
        // If this was the active space, find the next most recently updated space and set it as active
        if (isActiveSpace || isUIActiveSpace) {
          // Get all spaces, sorted by updated_at
          const remainingSpaces = get().spaces?.filter(space => !space.is_deleted) || [];
          
          if (remainingSpaces.length > 0) {
            // Sort spaces by updated_at (most recent first)
            const sortedSpaces = [...remainingSpaces].sort((a, b) => 
              new Date(b.updated_at || '').getTime() - new Date(a.updated_at || '').getTime()
            );
            
            // Get the most recently updated space
            const nextActiveSpace = sortedSpaces[0];
            
            if (nextActiveSpace) {
              // Load the full space data for the new active space
              await get().loadSpaceFullData(nextActiveSpace.id);
            } else {
              // No spaces left, clear UI state
              set({
                activeSpace: null,
                conversations: null,
                activeConversation: null,
                uiState: {
                  activeSpace: null,
                  conversations: [],
                  activeConversation: null,
                  messages: [],
                  isLoading: false,
                  loadingType: null
                }
              });
            }
          } else {
            // No spaces left, clear UI state
            set({
              activeSpace: null,
              conversations: null,
              activeConversation: null,
              uiState: {
                activeSpace: null,
                conversations: [],
                activeConversation: null,
                messages: [],
                isLoading: false,
                loadingType: null
              }
            });
          }
        } else {
          // Not the active space, just reset loading
          set((state) => ({
            uiState: {
              ...state.uiState,
              isLoading: false,
              loadingType: null
            }
          }));
        }
        
        return true;
      } catch (actionError) {
        // Handle error from the deleteSpaceAction
        console.error('Error deleting space:', actionError);
        
        // Restore the space on failure
        if (spaceToDelete) {
          get().addLocalSpace(spaceToDelete);
        }
        
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));
        
        toast.error('Deletion Failed', {
          description: 'Could not delete space'
        });
        return false;
      }
    } catch (error) {
      console.error('Error deleting space:', error);
      
      // Try to restore the space
      const spaceToRestore = get().spaces?.find(space => space.id === id);
      if (spaceToRestore) {
        get().addLocalSpace(spaceToRestore);
      }
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      toast.error('Deletion Failed', {
        description: 'Could not delete space'
      });
      return false;
    } finally {
      set({ loadingSpaceId: null });
    }
  },
  
  setActiveSpaceOnServer: async (id) => {
    set({ 
      loadingSpaceId: id,
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'space'
      }
    });
    
    try {
      // Load the full space data for UI rendering
      await get().loadSpaceFullData(id);
      
      return true;
    } catch (error) {
      console.error('Error setting active space:', error);
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      toast.error('Activation Failed', {
        description: 'Could not set active space'
      });
      return false;
    } finally {
      set({ loadingSpaceId: null });
    }
  },
  
  // Conversation state operations
  setConversations: (conversations) => set({ 
    conversations,
    uiState: {
      ...get().uiState,
      conversations
    }
  }),
  
  setActiveConversation: (conversation) => set({ 
    activeConversation: conversation,
    uiState: {
      ...get().uiState,
      activeConversation: conversation
    }
  }),
  
  updateLocalConversation: (id, updates) => set((state) => {
    const updatedConversations = state.conversations?.map(conversation => 
      conversation.id === id ? { ...conversation, ...updates } : conversation
    ) || null;
    
    const updatedActiveConversation = state.activeConversation?.id === id 
      ? { ...state.activeConversation, ...updates } 
      : state.activeConversation;
    
    return {
      conversations: updatedConversations,
      activeConversation: updatedActiveConversation,
      uiState: {
        ...state.uiState,
        conversations: updatedConversations,
        activeConversation: updatedActiveConversation
      }
    };
  }),
  
  addLocalConversation: (conversation) => set((state) => {
    const newConversations = state.conversations 
      ? [conversation, ...state.conversations] 
      : [conversation];
      
    return {
      conversations: newConversations,
      uiState: {
        ...state.uiState,
        conversations: newConversations
      }
    };
  }),
  
  removeLocalConversation: (id) => set((state) => {
    const filteredConversations = state.conversations?.filter(conv => conv.id !== id) || null;
    const updatedActiveConversation = state.activeConversation?.id === id 
      ? null 
      : state.activeConversation;
      
    return {
      conversations: filteredConversations,
      activeConversation: updatedActiveConversation,
      uiState: {
        ...state.uiState,
        conversations: filteredConversations,
        activeConversation: updatedActiveConversation
      }
    };
  }),
  
  // Conversation server operations with optimistic updates
  createConversation: async (title) => {
    const activeSpace = get().activeSpace;
    
    if (!activeSpace?.id) {
      toast.error('Cannot Create Conversation', {
        description: 'No active space selected'
      });
      return null;
    }
    
    set({ 
      loadingConversationId: 'creating',
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'conversation'
      }
    });
    
    try {
      // Call server action
      const newConversation = await createConversationAction(activeSpace.id, title);
      
      if (!newConversation) {
        toast.error('Creation Failed', {
          description: 'Could not create conversation'
        });
        
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));
        
        return null;
      }
      
      // Update state with new conversation
      get().setActiveConversation(newConversation);
      get().addLocalConversation(newConversation);
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      toast.success('Conversation Created', {
        description: 'Start chatting now!'
      });
      
      return newConversation;
    } catch (error) {
      console.error('Failed to create conversation:', error);
      
      toast.error('Creation Failed', {
        description: 'Could not create conversation'
      });
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      return null;
    } finally {
      set({ loadingConversationId: null });
    }
  },
  
  selectConversation: async (conversationId) => {
    const activeSpace = get().activeSpace;
    
    if (!activeSpace?.id) {
      toast.error('Cannot Select Conversation', {
        description: 'No active space selected'
      });
      return false;
    }
    
    try {
      const conversation = get().conversations?.find(c => c.id === conversationId);
      
      if (!conversation) {
        console.warn('Conversation not found:', conversationId);
        return false;
      }
      
      get().setActiveConversation(conversation);
      return true;
    } catch (error) {
      console.error('Failed to select conversation:', error);
      toast.error('Selection Failed', {
        description: 'Could not select conversation'
      });
      return false;
    }
  },
  
  updateConversation: async (conversationId, title) => {
    const activeSpace = get().activeSpace;
    
    if (!activeSpace?.id) {
      toast.error('Cannot Update Conversation', {
        description: 'No active space selected'
      });
      return false;
    }
    
    set({ loadingConversationId: conversationId });
    
    try {
      // Update locally first (optimistic)
      get().updateLocalConversation(conversationId, { title });
      
      // Call server action
      await updateConversationTitleAction(conversationId, title);
      
      toast.success('Conversation Updated', {
        description: 'Title updated successfully'
      });
      
      return true;
    } catch (error) {
      console.error('Failed to update conversation:', error);
      
      toast.error('Update Failed', {
        description: 'Could not update conversation'
      });
      
      return false;
    } finally {
      set({ loadingConversationId: null });
    }
  },
  
  deleteConversation: async (conversationId) => {
    const activeSpace = get().activeSpace;
    
    if (!activeSpace?.id) {
      toast.error('Cannot Delete Conversation', {
        description: 'No active space selected'
      });
      return false;
    }
    
    set({ loadingConversationId: conversationId });
    
    try {
      get().updateLocalConversation(conversationId, { is_deleted: true });
      
      if (get().activeConversation?.id === conversationId) {
        get().setActiveConversation(null);
      }
      
      await deleteConversationAction(conversationId);
      
      get().removeLocalConversation(conversationId);
      
      toast.success('Conversation Deleted', {
        description: 'Deletion successful'
      });
      
      return true;
    } catch (error) {
      console.error('Failed to delete conversation:', error);
      
      get().updateLocalConversation(conversationId, { is_deleted: false });
      
      toast.error('Deletion Failed', {
        description: 'Could not delete conversation'
      });
      
      return false;
    } finally {
      set({ loadingConversationId: null });
    }
  },
  
  // Loading state
  setLoading: (isLoading) => set({ 
    isLoading,
    uiState: {
      ...get().uiState,
      isLoading
    }
  }),
  
  setLoadingSpaceId: (id) => set({ loadingSpaceId: id }),
  
  setLoadingConversationId: (id) => set({ loadingConversationId: id }),
  
  // Navigation helper (keeping for backward compatibility)
  navigateToActiveConversation: (router) => {
    const activeSpace = get().activeSpace;
    
    if (!activeSpace) {
      // If no active space, go to the home page
      router.push('/protected');
      return;
    }
    
    // Check if we have an active conversation in the space
    const activeConversation = get().activeConversation;
    const conversations = get().conversations;
    
    if (activeConversation && activeConversation.id) {
      // Navigate to the active conversation
      router.push(`/protected/spaces/${activeSpace.id}/conversations/${activeConversation.id}`);
    } else if (conversations && conversations.length > 0 && conversations[0] && conversations[0].id) {
      // Navigate to the first conversation
      router.push(`/protected/spaces/${activeSpace.id}/conversations/${conversations[0].id}`);
    } else {
      // No conversations, just go to the space
      router.push(`/protected/spaces/${activeSpace.id}/conversations`);
    }
  },
}));

// Helper functions
export const getCurrentSpaces = () => useSpaceStore.getState().spaces || []; 
export const getActiveSpace = () => useSpaceStore.getState().activeSpace;
export const getCurrentConversations = () => useSpaceStore.getState().conversations || [];
export const getActiveConversation = () => useSpaceStore.getState().activeConversation;

================
File: supabase/migrations/20250204124800_create_complete_schema.sql
================
-- Create complete schema for Vinci app
-- Timestamp: 2025-02-04T12:48:00-07:00

-- USERS TABLE: Supabase Auth will manage user accounts.
-- No changes needed; we'll use `auth.users`.

-- SPACES TABLE: Metadata for spaces.
CREATE TABLE spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    -- Removed color column
    is_archived BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on spaces
ALTER TABLE spaces ENABLE ROW LEVEL SECURITY;

-- RLS policies for spaces
CREATE POLICY "Users can view their own spaces"
    ON spaces FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own spaces"
    ON spaces FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own spaces"
    ON spaces FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own spaces"
    ON spaces FOR DELETE
    USING (user_id = auth.uid());

-- CONVERSATIONS TABLE: Each conversation is part of a space.
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    title TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on conversations
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for conversations
CREATE POLICY "Users can view conversations in their spaces"
    ON conversations FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create conversations in their spaces"
    ON conversations FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    annotations JSONB DEFAULT '[]'::jsonb,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT valid_annotations CHECK (
        jsonb_typeof(annotations) = 'array'
    )
);

-- Enable RLS on messages
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- RLS policies for messages
CREATE POLICY "Users can view messages in their spaces"
    ON messages FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can insert messages in their spaces"
    ON messages FOR INSERT
    WITH CHECK (
        messages.user_id = auth.uid() AND
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

-- SPACE_USER_RELATIONS (Optional for shared spaces).
CREATE TABLE space_user_relations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces (id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    role TEXT CHECK (role IN ('owner', 'editor', 'viewer')) DEFAULT 'viewer',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space_user_relations
ALTER TABLE space_user_relations ENABLE ROW LEVEL SECURITY;

-- Add indexes for better query performance
CREATE INDEX idx_spaces_user_id ON spaces(user_id);
CREATE INDEX idx_conversations_space_id ON conversations(space_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_space_user_relations_space_id ON space_user_relations(space_id);
CREATE INDEX idx_space_user_relations_user_id ON space_user_relations(user_id);

-- Create a function to get the latest messages in a conversation
CREATE OR REPLACE FUNCTION get_conversation_messages(conversation_uuid UUID)
RETURNS TABLE (
    id UUID,
    user_id UUID,
    role TEXT,
    content TEXT,
    annotations JSONB,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        m.id,
        m.user_id,
        m.role,
        m.content,
        m.annotations,
        m.created_at,
        m.updated_at
    FROM messages m
    WHERE m.conversation_id = conversation_uuid
    AND m.is_deleted = FALSE
    ORDER BY m.created_at ASC;
END;
$$;

================
File: supabase/migrations/20250204124900_alter_space_table.sql
================
ALTER TABLE "spaces" ADD COLUMN model TEXT NOT NULL DEFAULT 'deepseek-r1-distill-llama-70b';
ALTER TABLE "spaces" ADD COLUMN provider text NOT NULL DEFAULT 'groq';

================
File: supabase/migrations/20250204125000_create_active_space_table.sql
================
CREATE TABLE active_spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id) 
);

================
File: supabase/migrations/20250204125100_update_rls_policies.sql
================


================
File: supabase/migrations/20250221221400_add_active_conversations.sql
================
-- Create active_conversations table
CREATE TABLE active_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id)
);

-- Enable RLS on active_conversations
ALTER TABLE active_conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for active_conversations
CREATE POLICY "Users can view their own active conversation"
    ON active_conversations FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can update their own active conversation"
    ON active_conversations FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own active conversation"
    ON active_conversations FOR DELETE
    USING (user_id = auth.uid());

================
File: supabase/migrations/20250223171800_add_notifications.sql
================
-- Create notifications schema
-- Timestamp: 2025-02-23T17:18:00-07:00

-- Create notification types enum
CREATE TYPE notification_type AS ENUM (
    'space_created',
    'space_deleted',
    'model_changed',
    'conversation_created',
    'conversation_deleted'
);

-- Create notifications table
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type notification_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on notifications
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- RLS policies for notifications
CREATE POLICY "Users can view their own notifications"
    ON notifications FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own notifications"
    ON notifications FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own notifications"
    ON notifications FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- Create index for faster notification lookups
CREATE INDEX notifications_user_id_idx ON notifications(user_id);
CREATE INDEX notifications_created_at_idx ON notifications(created_at DESC);

================
File: supabase/migrations/20250223171900_add_realtime_notifications.sql
================
-- Enable realtime for notifications
ALTER PUBLICATION supabase_realtime ADD TABLE notifications;

================
File: supabase/migrations/20250223175200_add_space_history.sql
================
-- Create space history schema
-- Timestamp: 2025-02-23T17:52:00-07:00

-- Create space action types enum
CREATE TYPE space_action_type AS ENUM (
    'created',
    'deleted',
    'updated',
    'model_changed',
    'conversation_added',
    'conversation_deleted'
);

-- Create space history table
CREATE TABLE space_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    action_type space_action_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space history
ALTER TABLE space_history ENABLE ROW LEVEL SECURITY;

-- RLS policies for space history
CREATE POLICY "Users can view history for spaces they have access to"
    ON space_history FOR SELECT
    USING (
        user_id = auth.uid() OR 
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create history entries for their spaces"
    ON space_history FOR INSERT
    WITH CHECK (
        user_id = auth.uid() AND
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

-- Create indexes for faster lookups
CREATE INDEX space_history_space_id_idx ON space_history(space_id);
CREATE INDEX space_history_user_id_idx ON space_history(user_id);
CREATE INDEX space_history_created_at_idx ON space_history(created_at DESC);

================
File: supabase/migrations/20250223175201_migration_add_is_deleted_to_conversations.sql
================
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS is_deleted BOOLEAN DEFAULT FALSE;
UPDATE conversations SET is_deleted = FALSE WHERE is_deleted IS NULL;

================
File: supabase/migrations/20250223175202_migration_add_performance_indexes.sql
================
-- Indexes to improve overall database performance

-- Index for spaces table by user_id
CREATE INDEX IF NOT EXISTS idx_spaces_user_id 
ON spaces (user_id);

-- Index for active_spaces table by user_id
CREATE INDEX IF NOT EXISTS idx_active_spaces_user_id 
ON active_spaces (user_id);

-- Composite index for conversations with multiple conditions
CREATE INDEX IF NOT EXISTS idx_conversations_space_id_is_deleted_updated_at 
ON conversations (space_id, is_deleted, updated_at DESC);

-- Index for messages by conversation_id
-- This will speed up the getMessages queries
CREATE INDEX IF NOT EXISTS idx_messages_conversation_id_created_at 
ON messages (conversation_id, created_at DESC);

-- Index for notifications by user_id and read status
-- This will optimize the getNotifications query
CREATE INDEX IF NOT EXISTS idx_notifications_user_id_read_created_at 
ON notifications (user_id, is_read, created_at DESC);

-- Index to optimize space data lookup
CREATE INDEX IF NOT EXISTS idx_spaces_id_updated_at 
ON spaces (id, updated_at DESC);

-- Index to optimize conversation lookup by id
CREATE INDEX IF NOT EXISTS idx_conversations_id 
ON conversations (id);

-- If you have message search functionality
CREATE INDEX IF NOT EXISTS idx_messages_content_gin 
ON messages USING gin(to_tsvector('english', content));

-- Partial index for active conversations only, reducing index size
CREATE INDEX IF NOT EXISTS idx_active_conversations 
ON conversations (space_id, updated_at DESC) 
WHERE is_deleted = false;

-- Index for faster joins between spaces and conversations
CREATE INDEX IF NOT EXISTS idx_conversations_space_id
ON conversations (space_id);

-- If you frequently query by user_id and conversation_id together
CREATE INDEX IF NOT EXISTS idx_messages_user_id_conversation_id
ON messages (user_id, conversation_id);

-- Purpose: Add performance indexes for spaces, conversations, messages, and other tables to optimize query performance

================
File: supabase/migrations/20250225012800_add_conversations_update_policy.sql
================
CREATE POLICY "Users can update conversations in their spaces"
    ON conversations FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

================
File: supabase/.gitignore
================
# Supabase
.branches
.temp
.env

================
File: supabase/config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "ui"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: supabase/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-25T01:28:27.566Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
migrations/
  20250204124800_create_complete_schema.sql
  20250204124900_alter_space_table.sql
  20250204125000_create_active_space_table.sql
  20250204125100_update_rls_policies.sql
  20250221221400_add_active_conversations.sql
  20250223171800_add_notifications.sql
  20250223171900_add_realtime_notifications.sql
  20250223175200_add_space_history.sql
  20250223175201_migration_add_is_deleted_to_conversations.sql
.gitignore
config.toml

================================================================
Files
================================================================

================
File: migrations/20250204124800_create_complete_schema.sql
================
-- Create complete schema for Vinci app
-- Timestamp: 2025-02-04T12:48:00-07:00

-- USERS TABLE: Supabase Auth will manage user accounts.
-- No changes needed; we'll use `auth.users`.

-- SPACES TABLE: Metadata for spaces.
CREATE TABLE spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    -- Removed color column
    is_archived BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on spaces
ALTER TABLE spaces ENABLE ROW LEVEL SECURITY;

-- RLS policies for spaces
CREATE POLICY "Users can view their own spaces"
    ON spaces FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own spaces"
    ON spaces FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own spaces"
    ON spaces FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own spaces"
    ON spaces FOR DELETE
    USING (user_id = auth.uid());

-- CONVERSATIONS TABLE: Each conversation is part of a space.
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    title TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on conversations
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for conversations
CREATE POLICY "Users can view conversations in their spaces"
    ON conversations FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create conversations in their spaces"
    ON conversations FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    annotations JSONB DEFAULT '[]'::jsonb,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT valid_annotations CHECK (
        jsonb_typeof(annotations) = 'array'
    )
);

-- Enable RLS on messages
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- RLS policies for messages
CREATE POLICY "Users can view messages in their spaces"
    ON messages FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can insert messages in their spaces"
    ON messages FOR INSERT
    WITH CHECK (
        messages.user_id = auth.uid() AND
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

-- SPACE_USER_RELATIONS (Optional for shared spaces).
CREATE TABLE space_user_relations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces (id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    role TEXT CHECK (role IN ('owner', 'editor', 'viewer')) DEFAULT 'viewer',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space_user_relations
ALTER TABLE space_user_relations ENABLE ROW LEVEL SECURITY;

-- Add indexes for better query performance
CREATE INDEX idx_spaces_user_id ON spaces(user_id);
CREATE INDEX idx_conversations_space_id ON conversations(space_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_space_user_relations_space_id ON space_user_relations(space_id);
CREATE INDEX idx_space_user_relations_user_id ON space_user_relations(user_id);

-- Create a function to get the latest messages in a conversation
CREATE OR REPLACE FUNCTION get_conversation_messages(conversation_uuid UUID)
RETURNS TABLE (
    id UUID,
    user_id UUID,
    role TEXT,
    content TEXT,
    annotations JSONB,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        m.id,
        m.user_id,
        m.role,
        m.content,
        m.annotations,
        m.created_at,
        m.updated_at
    FROM messages m
    WHERE m.conversation_id = conversation_uuid
    AND m.is_deleted = FALSE
    ORDER BY m.created_at ASC;
END;
$$;

================
File: migrations/20250204124900_alter_space_table.sql
================
ALTER TABLE "spaces" ADD COLUMN model TEXT NOT NULL DEFAULT 'deepseek-r1-distill-llama-70b';
ALTER TABLE "spaces" ADD COLUMN provider text NOT NULL DEFAULT 'groq';

================
File: migrations/20250204125000_create_active_space_table.sql
================
CREATE TABLE active_spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id) 
);

================
File: migrations/20250204125100_update_rls_policies.sql
================


================
File: migrations/20250221221400_add_active_conversations.sql
================
-- Create active_conversations table
CREATE TABLE active_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id)
);

-- Enable RLS on active_conversations
ALTER TABLE active_conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for active_conversations
CREATE POLICY "Users can view their own active conversation"
    ON active_conversations FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can update their own active conversation"
    ON active_conversations FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own active conversation"
    ON active_conversations FOR DELETE
    USING (user_id = auth.uid());

================
File: migrations/20250223171800_add_notifications.sql
================
-- Create notifications schema
-- Timestamp: 2025-02-23T17:18:00-07:00

-- Create notification types enum
CREATE TYPE notification_type AS ENUM (
    'space_created',
    'space_deleted',
    'model_changed',
    'conversation_created',
    'conversation_deleted'
);

-- Create notifications table
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type notification_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on notifications
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- RLS policies for notifications
CREATE POLICY "Users can view their own notifications"
    ON notifications FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own notifications"
    ON notifications FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own notifications"
    ON notifications FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- Create index for faster notification lookups
CREATE INDEX notifications_user_id_idx ON notifications(user_id);
CREATE INDEX notifications_created_at_idx ON notifications(created_at DESC);

================
File: migrations/20250223171900_add_realtime_notifications.sql
================
-- Enable realtime for notifications
ALTER PUBLICATION supabase_realtime ADD TABLE notifications;

================
File: migrations/20250223175200_add_space_history.sql
================
-- Create space history schema
-- Timestamp: 2025-02-23T17:52:00-07:00

-- Create space action types enum
CREATE TYPE space_action_type AS ENUM (
    'created',
    'deleted',
    'updated',
    'model_changed',
    'conversation_added',
    'conversation_deleted'
);

-- Create space history table
CREATE TABLE space_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    action_type space_action_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space history
ALTER TABLE space_history ENABLE ROW LEVEL SECURITY;

-- RLS policies for space history
CREATE POLICY "Users can view history for spaces they have access to"
    ON space_history FOR SELECT
    USING (
        user_id = auth.uid() OR 
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create history entries for their spaces"
    ON space_history FOR INSERT
    WITH CHECK (
        user_id = auth.uid() AND
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

-- Create indexes for faster lookups
CREATE INDEX space_history_space_id_idx ON space_history(space_id);
CREATE INDEX space_history_user_id_idx ON space_history(user_id);
CREATE INDEX space_history_created_at_idx ON space_history(created_at DESC);

================
File: migrations/20250223175201_migration_add_is_deleted_to_conversations.sql
================
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS is_deleted BOOLEAN DEFAULT FALSE;
UPDATE conversations SET is_deleted = FALSE WHERE is_deleted IS NULL;

================
File: .gitignore
================
# Supabase
.branches
.temp
.env

================
File: config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "ui"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: types/index.ts
================
export interface Space {
  id: string;
  name: string;
  description?: string;
  model?: string;
  provider?: string;
  is_archived: boolean;
  is_deleted: boolean;
  created_at: string;
  updated_at: string;
  user_id: string;
  color?: string;
  isActive?: boolean;
}

export interface Conversation {
  id: string;
  space_id: string;
  title?: string;
  created_at?: string;
  updated_at?: string;
  is_deleted?: boolean;
  messageCount?: number;
  lastMessage?: string;
}

================
File: utils/supabase/check-env-vars.ts
================
// This check can be removed
// it is just for tutorial purposes

export const hasEnvVars =
  process.env.NEXT_PUBLIC_SUPABASE_URL &&
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

================
File: utils/supabase/client.ts
================
import { createBrowserClient } from "@supabase/ssr";

export const createClient = () =>
  createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );

================
File: utils/supabase/middleware.ts
================
import { createServerClient } from "@supabase/ssr";
import { type NextRequest, NextResponse } from "next/server";

export const updateSession = async (request: NextRequest) => {
  // This `try/catch` block is only here for the interactive tutorial.
  // Feel free to remove once you have Supabase connected.
  try {
    // Create an unmodified response
    let response = NextResponse.next({
      request: {
        headers: request.headers,
      },
    });

    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return request.cookies.getAll();
          },
          setAll(cookiesToSet) {
            cookiesToSet.forEach(({ name, value }) =>
              request.cookies.set(name, value),
            );
            response = NextResponse.next({
              request,
            });
            cookiesToSet.forEach(({ name, value, options }) =>
              response.cookies.set(name, value, options),
            );
          },
        },
      },
    );

    // This will refresh session if expired - required for Server Components
    // https://supabase.com/docs/guides/auth/server-side/nextjs
    const user = await supabase.auth.getUser();

    // protected routes
    if (request.nextUrl.pathname.startsWith("/protected") && user.error) {
      return NextResponse.redirect(new URL("/sign-in", request.url));
    }

    if (request.nextUrl.pathname === "/" && !user.error) {
      return NextResponse.redirect(new URL("/protected", request.url));
    }

    return response;
  } catch (e) {
    // If you are here, a Supabase client could not be created!
    // This is likely because you have not set up environment variables.
    // Check out http://localhost:3000 for Next Steps.
    return NextResponse.next({
      request: {
        headers: request.headers,
      },
    });
  }
};

================
File: utils/supabase/server.ts
================
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export const createClient = async () => {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => {
              cookieStore.set(name, value, options);
            });
          } catch (error) {
            // The `set` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    },
  );
};

================
File: utils/pinecone.ts
================
import { Pinecone } from '@pinecone-database/pinecone';
import { OpenAIEmbeddings } from '@langchain/openai';
import { RecordMetadata } from '@pinecone-database/pinecone';
import { createClient } from './supabase/server';

if (!process.env.PINECONE_API_KEY) {
  throw new Error('Missing PINECONE_API_KEY environment variable');
}

if (!process.env.PINECONE_ENVIRONMENT) {
  throw new Error('Missing PINECONE_ENVIRONMENT environment variable');
}

if (!process.env.PINECONE_INDEX) {
  throw new Error('Missing PINECONE_INDEX environment variable');
}

if (!process.env.OPENAI_API_KEY) {
  throw new Error('Missing OPENAI_API_KEY environment variable');
}

const pinecone = new Pinecone();

const index = pinecone.Index(process.env.PINECONE_INDEX!);

const embeddings = new OpenAIEmbeddings({
  openAIApiKey: process.env.OPENAI_API_KEY,
  modelName: 'text-embedding-3-large',
});

export interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  spaceId: string;
  conversationId: string;
  parentId?: string;
  childId?: string;
  metadata?: Record<string, any>;
}

interface PineconeMetadata extends RecordMetadata {
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  spaceId: string;
  conversationId: string;
  parentId?: string;
  childId?: string;
  tags?: string[];
  similarMessagesStr?: string;
  similarMessagesCount?: number;
  [key: string]: any;
}

export async function upsertChatMessage(message: ChatMessage) {
  try {
    if (!message.id) {
      throw new Error('Message ID is required for Pinecone upsert');
    }

    const vector = await embeddings.embedQuery(message.content);

    const metadata: PineconeMetadata = {
      content: message.content,
      role: message.role,
      createdAt: message.createdAt,
      spaceId: message.spaceId,
      conversationId: message.conversationId,
      ...(message.parentId && { parentId: message.parentId }),
      ...(message.childId && { childId: message.childId }),
    };
    
    if (message.metadata) {
      Object.entries(message.metadata).forEach(([key, value]) => {
        if (key === 'similarMessages' && value) {
          metadata.similarMessagesStr = JSON.stringify(value);
          metadata.similarMessagesCount = Array.isArray(value) ? value.length : 0;
        } else if (key === 'tags' && Array.isArray(value)) {
          metadata.tags = value;
        } else if (
          typeof value === 'string' || 
          typeof value === 'number' || 
          typeof value === 'boolean' ||
          (Array.isArray(value) && value.every(item => typeof item === 'string'))
        ) {
          metadata[key] = value;
        }
      });
    }

    await index.upsert([
      {
        id: message.id,
        values: vector,
        metadata,
      },
    ]);

    if (message.role === 'assistant' && message.parentId) {
      const parentVector = await index.fetch([message.parentId]);
      const parentRecord = parentVector.records[message.parentId];
      if (parentRecord && parentRecord.metadata) {
        const parentMetadata = parentRecord.metadata as PineconeMetadata;
        await index.upsert([
          {
            id: message.parentId,
            values: parentRecord.values,
            metadata: {
              ...parentMetadata,
              childId: message.id,
            },
          },
        ]);
      }
    }
  } catch (error) {
    console.error('Error upserting chat message to Pinecone:', error);
    throw error;
  }
}

export async function searchSimilarMessages(query: string, limit = 5, tags: string[] = []) {
  try {
    const queryEmbedding = await embeddings.embedQuery(query);

    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      throw new Error('Unauthorized');
    }
    
    const filter: any = {};
    
    // Add tag filter if tags are provided
    if (tags.length > 0) {
      filter.tags = { $in: tags };
    }
    
    // Get deleted conversations and spaces to exclude them from results
    const [conversationsResult, spacesResult] = await Promise.all([
      supabase
        .from('conversations')
        .select('id')
        .eq('is_deleted', true),
      supabase
        .from('spaces')
        .select('id')
        .eq('is_deleted', true)
    ]);
    
    const deletedConversationIds = conversationsResult.data?.map(c => c.id) || [];
    const deletedSpaceIds = spacesResult.data?.map(s => s.id) || [];
    
    // Build filter for Pinecone query
    // Use $and only if we have multiple conditions
    if ((deletedConversationIds.length > 0 || deletedSpaceIds.length > 0) || tags.length > 0) {
      // Initialize $and array if we need it
      filter.$and = [];
      
      // Add tag filter to $and if tags are provided
      if (tags.length > 0) {
        filter.$and.push({ tags: { $in: tags } });
        // Remove the top-level tags filter since we're using it in $and
        delete filter.tags;
      }
      
      // Add filters to exclude deleted conversations and spaces
      if (deletedConversationIds.length > 0) {
        filter.$and.push({ conversationId: { $nin: deletedConversationIds } });
      }
      
      if (deletedSpaceIds.length > 0) {
        filter.$and.push({ spaceId: { $nin: deletedSpaceIds } });
      }
      
      // If $and has only one condition, simplify the filter
      if (filter.$and.length === 1) {
        const condition = filter.$and[0];
        delete filter.$and;
        Object.assign(filter, condition);
      } else if (filter.$and.length === 0) {
        delete filter.$and;
      }
    }

    const results = await index.query({
      vector: queryEmbedding,
      topK: limit,
      includeMetadata: true,
      ...(Object.keys(filter).length > 0 ? { filter } : {}),
    });

    return results.matches.map((match) => ({
      score: match.score,
      message: reconstructChatMessage(match.metadata as PineconeMetadata, match.id),
    }));
  } catch (error) {
    console.error('Error searching similar messages in Pinecone:', error);
    throw error;
  }
}

function reconstructChatMessage(metadata: PineconeMetadata, id: string): ChatMessage {
  const { 
    content, 
    role, 
    createdAt, 
    spaceId, 
    conversationId, 
    parentId, 
    childId, 
    similarMessagesStr, 
    similarMessagesCount,
    ...rest 
  } = metadata;
  
  // Prepare the message metadata
  const messageMetadata: Record<string, any> = { 
    ...rest
    // Don't duplicate conversationId in metadata since it's already at the top level
  };
  
  // Parse the stringified similarMessages back to an object if it exists
  if (similarMessagesStr) {
    try {
      const parsedMessages = JSON.parse(similarMessagesStr);
      // Make sure each similar message has conversationId as a direct property
      messageMetadata.similarMessages = parsedMessages.map((msg: any) => ({
        ...msg,
        // Put conversationId directly on the message object
        conversationId: msg.conversationId || msg.metadata?.conversationId
      }));
    } catch (error) {
      console.error('Error parsing similarMessages from Pinecone:', error);
      // If parsing fails, provide an empty array as fallback
      messageMetadata.similarMessages = [];
    }
  }

  return {
    id,
    content,
    role,
    createdAt,
    spaceId,
    conversationId, // This stays at the top level where it belongs
    ...(parentId && { parentId }),
    ...(childId && { childId }),
    metadata: messageMetadata,
  };
}

export async function getMessageThread(messageId: string): Promise<ChatMessage[]> {
  try {
    if (!messageId) {
      throw new Error('Message ID is required to get message thread');
    }

    const messages: ChatMessage[] = [];
    let currentId: string | undefined = messageId;

    while (currentId) {
      const result = await index.fetch([currentId]);
      const record = result.records[currentId];
      if (!record || !record.metadata) break;

      const metadata = record.metadata as PineconeMetadata;
      messages.unshift(reconstructChatMessage(metadata, currentId));
      currentId = metadata.parentId;
    }

    currentId = messageId;
    while (currentId) {
      const result = await index.fetch([currentId]);
      const record = result.records[currentId];
      if (!record || !record.metadata) break;

      const metadata = record.metadata as PineconeMetadata;
      if (!metadata.childId) break;

      const childResult = await index.fetch([metadata.childId]);
      const childRecord = childResult.records[metadata.childId];
      if (!childRecord || !childRecord.metadata) break;

      const childMetadata = childRecord.metadata as PineconeMetadata;
      messages.push(reconstructChatMessage(childMetadata, metadata.childId));
      currentId = metadata.childId;
    }

    return messages;
  } catch (error) {
    console.error('Error getting message thread:', error);
    throw error;
  }
}

export async function deleteMessagesByConversationId(conversationId: string): Promise<void> {
  try {
    if (!conversationId) {
      throw new Error('Conversation ID is required to delete messages');
    }

    console.log(`Deleting messages for conversation: ${conversationId}`);

    // Use query to find all vectors by conversationId
    const queryEmbedding = await embeddings.embedQuery(''); // Empty query to match all vectors
    const queryResponse = await index.query({
      vector: queryEmbedding,
      filter: {
        conversationId: conversationId
      },
      topK: 10000, // Set a high limit to get all messages
      includeMetadata: true,
    });

    // If we found messages to delete
    if (queryResponse.matches && queryResponse.matches.length > 0) {
      console.log(`Found ${queryResponse.matches.length} messages to delete`);
      
      // Extract the IDs from the response
      const messageIds = queryResponse.matches.map(match => match.id);
      
      if (messageIds.length > 0) {
        console.log(`Deleting ${messageIds.length} message records from Pinecone`);
        
        // Delete the vectors by their IDs
        await index.deleteMany(messageIds);
        console.log(`Successfully deleted ${messageIds.length} messages from Pinecone`);
      }
    } else {
      console.log(`No messages found for conversation ${conversationId}`);
    }
  } catch (error) {
    console.error('Error deleting messages by conversation ID:', error);
    throw error;
  }
}

export async function deleteMessagesBySpaceId(spaceId: string): Promise<void> {
  try {
    if (!spaceId) {
      throw new Error('Space ID is required to delete messages');
    }

    console.log(`Deleting messages for space: ${spaceId}`);

    // Use query to find all vectors by spaceId
    const queryEmbedding = await embeddings.embedQuery(''); // Empty query to match all vectors
    const queryResponse = await index.query({
      vector: queryEmbedding,
      filter: {
        spaceId: spaceId
      },
      topK: 10000, // Set a high limit to get all messages
      includeMetadata: true,
    });

    // If we found messages to delete
    if (queryResponse.matches && queryResponse.matches.length > 0) {
      console.log(`Found ${queryResponse.matches.length} messages to delete`);
      
      // Extract the IDs from the response
      const messageIds = queryResponse.matches.map(match => match.id);
      
      if (messageIds.length > 0) {
        console.log(`Deleting ${messageIds.length} message records from Pinecone`);
        
        // Delete the vectors by their IDs
        await index.deleteMany(messageIds);
        console.log(`Successfully deleted ${messageIds.length} messages from Pinecone`);
      }
    } else {
      console.log(`No messages found for space ${spaceId}`);
    }
  } catch (error) {
    console.error('Error deleting messages by space ID:', error);
    throw error;
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: constants.ts
================
import { Provider } from "@/config/models";

export interface AIModel {
  id: string;
  name: string;
  contextLength: number;
  provider: Provider;
}

export interface AIProvider {
  id: Provider;
  name: string;
  models: AIModel[];
}

export const API_ROUTES = {
  CHAT: '/api/chat',
  CONVERSATIONS: (spaceId: string) => `/api/conversations/${spaceId}`,
  MESSAGES: (conversationId: string) => `/api/messages/${conversationId}`,
  SPACES: '/api/spaces',
  SPACE: (id: string) => `/api/spaces/${id}`,
};


// Database Tables
export const DB_TABLES = {
  NOTIFICATIONS: 'notifications',
  SPACES: 'spaces',
  CONVERSATIONS: 'conversations',
  MESSAGES: 'messages',
  ACTIVE_SPACES: 'active_spaces',
  ACTIVE_CONVERSATIONS: 'active_conversations'
} as const

// Common Table Columns
export const COLUMNS = {
  // Common columns
  ID: 'id',
  USER_ID: 'user_id',
  CREATED_AT: 'created_at',
  UPDATED_AT: 'updated_at',
  IS_DELETED: 'is_deleted',

  // Space columns
  NAME: 'name',
  DESCRIPTION: 'description',
  MODEL: 'model',
  PROVIDER: 'provider',
  IS_ACTIVE: 'isActive',

  // Conversation columns
  SPACE_ID: 'space_id',
  TITLE: 'title',

  // Message columns
  CONVERSATION_ID: 'conversation_id',
  ROLE: 'role',
  CONTENT: 'content',
  MODEL_USED: 'model_used',
  PARENT_MESSAGE_ID: 'parent_message_id',
  ANNOTATIONS: 'annotations',
  COLOR: 'color',
} as const

// Message Roles
export const MESSAGE_ROLES = {
  USER: 'user',
  ASSISTANT: 'assistant'
} as const

// Common Error Messages
export const ERROR_MESSAGES = {
  UNAUTHORIZED: { error: 'Unauthorized', status: 401 },
  MISSING_FIELDS: { error: 'Missing required fields', status: 400 },
  INVALID_PROVIDER: { error: 'Invalid provider', status: 400 },
  INVALID_MODEL: { error: 'Invalid model for the selected provider', status: 400 },
  MISSING_SPACE_ID: { error: 'Space ID is required', status: 400 },
  MISSING_CONVERSATION_ID: { error: 'Conversation ID is required', status: 400 },
  INVALID_ROLE: { error: 'Invalid role: must be either "user" or "assistant"', status: 400 },
  MISSING_ASSISTANT_FIELDS: { error: 'Assistant messages require model_used and provider fields', status: 400 },
  SPACE_NOT_FOUND: { error: 'Space not found or access denied', status: 404 },
  CONVERSATION_NOT_FOUND: { error: 'Conversation not found', status: 404 },
  SERVER_ERROR: (message: string) => ({ error: message, status: 500 })
} as const

export const DEFAULTS = {
  CONVERSATION_TITLE: 'New Conversation',
  SPACE_NAME: 'My Space',
  SPACE_DESCRIPTION: 'My first space',
  WELCOME_MESSAGE: 'Welcome to Vinci! I\'m here to help you explore and create. What would you like to do?'
} as const

================
File: middleware.ts
================
import { type NextRequest } from "next/server";
import { updateSession } from "@/utils/supabase/middleware";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - images - .svg, .png, .jpg, .jpeg, .gif, .webp
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};

================
File: next.config.ts
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: "standalone",
  reactStrictMode: true,
  env: {
    NEXT_PUBLIC_SUPPORTED_MODELS: process.env.SUPPORTED_MODELS,
    NEXT_PUBLIC_MODEL_PROVIDERS: process.env.MODEL_PROVIDERS,
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'unpkg.com',
        pathname: '/@lobehub/**',
      },
      {
        protocol: 'https',
        hostname: 'registry.npmmirror.com',
        pathname: '/@lobehub/**',
      }
    ],
  },
  transpilePackages: ['@lobehub/icons'],
};

export default nextConfig;

================
File: nodemon.json
================
{
    "$schema": "https://json.schemastore.org/nodemon.json",
    "exec": "electron .",
    "watch": ["build"],
    "ignore": ["build", "public/build"]
  }

================
File: package.json
================
{
  "private": true,
  "main": "build/main.js",
  "scripts": {
    "next:dev": "next dev --turbopack",
    "next:build": "next build",
    "electron:build": "tsup",
    "electron:build_watch": "tsup --watch",
    "electron:watch": "cross-env NODE_ENV='development' nodemon",
    "electron:dev": "npm-run-all --parallel electron:build_watch electron:watch",
    "dev": "npm-run-all --parallel electron:dev next:dev"
  },
  "dependencies": {
    "@agentic/ai-sdk": "^7.3.1",
    "@ai-sdk/anthropic": "^1.1.6",
    "@ai-sdk/cerebras": "^0.1.8",
    "@ai-sdk/cohere": "^1.1.7",
    "@ai-sdk/deepseek": "^0.1.8",
    "@ai-sdk/fireworks": "^0.1.8",
    "@ai-sdk/google": "^1.1.10",
    "@ai-sdk/groq": "^1.1.7",
    "@ai-sdk/mistral": "^1.1.6",
    "@ai-sdk/openai": "^1.1.9",
    "@ai-sdk/perplexity": "^0.0.7",
    "@ai-sdk/togetherai": "^0.1.9",
    "@ai-sdk/xai": "^1.1.8",
    "@electron-toolkit/utils": "^3.0.0",
    "@icons-pack/react-simple-icons": "^12.0.0",
    "@langchain/openai": "^0.4.4",
    "@lobehub/icons": "^1.68.0",
    "@openrouter/ai-sdk-provider": "^0.2.0",
    "@pinecone-database/pinecone": "^5.0.0",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "latest",
    "@supabase/supabase-js": "latest",
    "@types/highlight.js": "^10.1.0",
    "@types/markdown-it": "^14.1.2",
    "@types/marked": "^6.0.0",
    "@types/prismjs": "^1.26.5",
    "@upstash/qstash": "^2.7.22",
    "@upstash/redis": "^1.34.4",
    "ai": "^4.1.34",
    "autoprefixer": "10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.4",
    "developer-icons": "^5.2.9",
    "emoji-picker-react": "^4.12.0",
    "framer-motion": "^12.0.6",
    "get-port-please": "^3.1.2",
    "highlight.js": "^11.11.1",
    "isomorphic-dompurify": "^2.21.0",
    "lodash": "^4.17.21",
    "lucide-react": "^0.468.0",
    "markdown-it": "^14.1.0",
    "markdown-it-jsx": "^1.1.0",
    "marked": "^15.0.7",
    "marked-base-url": "^1.1.6",
    "marked-gfm-heading-id": "^4.1.1",
    "marked-highlight": "^2.2.1",
    "marked-mangle": "^1.1.10",
    "next": "15.2.0",
    "next-themes": "^0.4.3",
    "prettier": "^3.3.3",
    "prismjs": "^1.29.0",
    "react": "19.0.0",
    "react-colorful": "^5.6.1",
    "react-dom": "19.0.0",
    "react-hotkeys-hook": "^4.6.1",
    "react-icons": "^5.5.0",
    "react-intersection-observer": "^9.15.1",
    "react-markdown": "^9.1.0",
    "react-syntax-highlighter": "^15.6.1",
    "react-textarea-autosize": "^8.5.7",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.1",
    "shiki": "^2.5.0",
    "sonner": "^2.0.1",
    "use-stick-to-bottom": "^1.0.46",
    "zod": "^3.24.1",
    "zod-to-json-schema": "^3.24.1",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@swc/core": "^1.10.12",
    "@swc/helpers": "^0.5.15",
    "@types/lodash": "^4.17.15",
    "@types/node": "22.10.2",
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4",
    "@types/react-syntax-highlighter": "^15.5.13",
    "cross-env": "^7.0.3",
    "electron": "^34.0.2",
    "electron-builder": "^25.1.8",
    "nodemon": "^3.1.9",
    "npm-run-all": "^4.1.5",
    "postcss": "8.4.49",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "tsup": "^8.3.6",
    "typescript": "5.7.2"
  },
  "overrides": {
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4"
  }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: README.md
================
<a href="https://demo-nextjs-with-supabase.vercel.app/">
  <img alt="Next.js and Supabase Starter Kit - the fastest way to build apps with Next.js and Supabase" src="https://demo-nextjs-with-supabase.vercel.app/opengraph-image.png">
  <h1 align="center">Next.js and Supabase Starter Kit</h1>
</a>

<p align="center">
 The fastest way to build apps with Next.js and Supabase
</p>

<p align="center">
  <a href="#features"><strong>Features</strong></a> ·
  <a href="#demo"><strong>Demo</strong></a> ·
  <a href="#deploy-to-vercel"><strong>Deploy to Vercel</strong></a> ·
  <a href="#clone-and-run-locally"><strong>Clone and run locally</strong></a> ·
  <a href="#feedback-and-issues"><strong>Feedback and issues</strong></a>
  <a href="#more-supabase-examples"><strong>More Examples</strong></a>
</p>
<br/>

## Features

- Works across the entire [Next.js](https://nextjs.org) stack
  - App Router
  - Pages Router
  - Middleware
  - Client
  - Server
  - It just works!
- supabase-ssr. A package to configure Supabase Auth to use cookies
- Styling with [Tailwind CSS](https://tailwindcss.com)
- Components with [shadcn/ui](https://ui.shadcn.com/)
- Optional deployment with [Supabase Vercel Integration and Vercel deploy](#deploy-your-own)
  - Environment variables automatically assigned to Vercel project

## Demo

You can view a fully working demo at [demo-nextjs-with-supabase.vercel.app](https://demo-nextjs-with-supabase.vercel.app/).

## Deploy to Vercel

Vercel deployment will guide you through creating a Supabase account and project.

After installation of the Supabase integration, all relevant environment variables will be assigned to the project so the deployment is fully functioning.

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&project-name=nextjs-with-supabase&repository-name=nextjs-with-supabase&demo-title=nextjs-with-supabase&demo-description=This+starter+configures+Supabase+Auth+to+use+cookies%2C+making+the+user%27s+session+available+throughout+the+entire+Next.js+app+-+Client+Components%2C+Server+Components%2C+Route+Handlers%2C+Server+Actions+and+Middleware.&demo-url=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2F&external-id=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&demo-image=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2Fopengraph-image.png)

The above will also clone the Starter kit to your GitHub, you can clone that locally and develop locally.

If you wish to just develop locally and not deploy to Vercel, [follow the steps below](#clone-and-run-locally).

## Clone and run locally

1. You'll first need a Supabase project which can be made [via the Supabase dashboard](https://database.new)

2. Create a Next.js app using the Supabase Starter template npx command

   ```bash
   npx create-next-app --example with-supabase with-supabase-app
   ```

   ```bash
   yarn create next-app --example with-supabase with-supabase-app
   ```

   ```bash
   pnpm create next-app --example with-supabase with-supabase-app
   ```

3. Use `cd` to change into the app's directory

   ```bash
   cd with-supabase-app
   ```

4. Rename `.env.example` to `.env.local` and update the following:

   ```
   NEXT_PUBLIC_SUPABASE_URL=[INSERT SUPABASE PROJECT URL]
   NEXT_PUBLIC_SUPABASE_ANON_KEY=[INSERT SUPABASE PROJECT API ANON KEY]
   ```

   Both `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` can be found in [your Supabase project's API settings](https://app.supabase.com/project/_/settings/api)

5. You can now run the Next.js local development server:

   ```bash
   npm run dev
   ```

   The starter kit should now be running on [localhost:3000](http://localhost:3000/).

6. This template comes with the default shadcn/ui style initialized. If you instead want other ui.shadcn styles, delete `components.json` and [re-install shadcn/ui](https://ui.shadcn.com/docs/installation/next)

> Check out [the docs for Local Development](https://supabase.com/docs/guides/getting-started/local-development) to also run Supabase locally.

## Feedback and issues

Please file feedback and issues over on the [Supabase GitHub org](https://github.com/supabase/supabase/issues/new/choose).

## More Supabase examples

- [Next.js Subscription Payments Starter](https://github.com/vercel/nextjs-subscription-payments)
- [Cookie-based Auth and the Next.js 13 App Router (free course)](https://youtube.com/playlist?list=PL5S4mPUpp4OtMhpnp93EFSo42iQ40XjbF)
- [Supabase Auth and the Next.js App Router](https://github.com/supabase/supabase/tree/master/examples/auth/nextjs)
# spatial-application

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			},
        'pulse-fast': {
          '0%, 100%': { opacity: '1' },
          '50%': { opacity: '0.4' }
        },
        'pulse-slow': {
          '0%, 100%': { opacity: '0.9' },
          '50%': { opacity: '0.4' }
        },
        'shimmer': {
          '0%': { backgroundPosition: '-100% 0' },
          '100%': { backgroundPosition: '200% 0' }
        },
        'glow': {
          '0%, 100%': { opacity: '0.8' },
          '50%': { opacity: '0.5' }
        },
        'highlight-glow': {
          '0%': { boxShadow: '0 0 5px rgba(62,207,255,0.3)', borderColor: 'rgba(62,207,255,0.3)' },
          '50%': { boxShadow: '0 0 20px rgba(62,207,255,0.8)', borderColor: 'rgba(62,207,255,0.8)' },
          '100%': { boxShadow: '0 0 5px rgba(62,207,255,0.3)', borderColor: 'rgba(62,207,255,0.3)' }
        },
        'rotate-slow': {
          '0%': { transform: 'rotate(0deg)' },
          '100%': { transform: 'rotate(360deg)' }
        },
        'halo-pulse': {
          '0%, 100%': { transform: 'scale(1)', opacity: '0.6' },
          '50%': { transform: 'scale(1.1)', opacity: '0.2' }
        },
        'float': {
          '0%, 100%': { transform: 'translateY(0px)' },
          '50%': { transform: 'translateY(-3px)' }
        },
        'appear': {
          '0%': { opacity: '0', transform: 'scale(0.97)' },
          '100%': { opacity: '1', transform: 'scale(1)' }
        }
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out',
        'pulse-fast': 'pulse-fast 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
        'pulse-slow': 'pulse-slow 3s ease-in-out infinite',
        'shimmer': 'shimmer 3s linear infinite',
        'glow': 'glow 2s ease-in-out infinite',
        'highlight-glow': 'highlight-glow 3s ease-in-out infinite',
        'rotate-slow': 'rotate-slow 10s linear infinite',
        'halo-pulse': 'halo-pulse 3s ease-in-out infinite',
        'float': 'float 3s ease-in-out infinite',
        'appear': 'appear 0.5s cubic-bezier(0.26, 0.53, 0.74, 1.48)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: tsup.config.ts
================
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["./electron/main.ts", "./electron/preload.ts"],
  splitting: false,
  sourcemap: false,
  clean: true,
  outDir: "build",
  external: ["electron"],
  format: ["cjs"]
});
