This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/
  component-data-flow.md
  data-flow-architecture.md
  electron-preload-modularization.md
  ipc-event-system.md
  state-management.md
electron/
  preload/
    api/
      app-state.ts
      auth.ts
      command-center.ts
      conversations.ts
      messages.ts
      notifications.ts
      space.ts
      user.ts
    utils/
      ipc.ts
  main.ts
  preload.ts
  tsconfig.json
src/
  components/
    auth/
      form-message.tsx
      index.ts
      submit-button.tsx
      user-profile-dropdown.tsx
    chat/
      ui/
        actions-tab.tsx
        chat-mode-tab.tsx
        conversation-tab.tsx
        messages-tab.tsx
        model-tab.tsx
        space-tab.tsx
        suggestions-tab.tsx
        tasks-tab.tsx
        user-profile-dropdown.tsx
      chat-container.tsx
      chat-content-client.tsx
      chat-message.tsx
      chat-messages.tsx
      file-mention-input.tsx
      markdown.tsx
      provider-icon.tsx
      stream-status.tsx
      unified-input.tsx
    dialogs/
      CreateSpaceDialog.tsx
      DeleteConversationDialog.tsx
      DeleteSpaceDialog.tsx
      EditConversationDialog.tsx
      EditSpaceDialog.tsx
    providers/
      ActionsProvider.tsx
      BackgroundTasksProvider.tsx
      ChatModesProvider.tsx
      ConversationsProvider.tsx
      MessageSearchProvider.tsx
      ModelsProvider.tsx
      SimilarMessagesProvider.tsx
      SpacesProvider.tsx
      SuggestionsProvider.tsx
    shared/
      dropdown-list.tsx
      model-display.tsx
    space/
      planet-icon.tsx
    ui/
      accordion.tsx
      alert-dialog.tsx
      alert.tsx
      aspect-ratio.tsx
      avatar.tsx
      badge.tsx
      base-tab.tsx
      breadcrumb.tsx
      button.tsx
      calendar.tsx
      card.tsx
      carousel.tsx
      chart.tsx
      checkbox.tsx
      code-block.tsx
      collapsible.tsx
      command-badge.tsx
      context-menu.tsx
      dialog.tsx
      drawer.tsx
      dropdown-menu.tsx
      form.tsx
      glass-container.tsx
      gradient-text.tsx
      hover-card.tsx
      index.ts
      input-otp.tsx
      input.tsx
      label.tsx
      menubar.tsx
      navigation-menu.tsx
      pagination.tsx
      popover.tsx
      progress.tsx
      radio-group.tsx
      resizable.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      sidebar.tsx
      skeleton.tsx
      slider.tsx
      sonner.tsx
      switch.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      theme-switcher.tsx
      toast.tsx
      toaster.tsx
      toggle-group.tsx
      toggle.tsx
      tooltip.tsx
    ErrorBoundary.tsx
  config/
    api.ts
    chat-modes.ts
  core/
    auth/
      auth-service.ts
    ipc/
      handlers/
        app-state-handlers.ts
        auth-handlers.ts
        command-center-handlers.ts
        conversation-handlers.ts
        message-handlers.ts
        notification-handlers.ts
        profile-handlers.ts
        space-handlers.ts
        user-handlers.ts
      constants.ts
      ipc-handlers.ts
    utils/
      state-utils.ts
    window/
      shortcuts.ts
      window-service.ts
  errors/
    index.ts
  hooks/
    use-app-state.ts
    use-auth.ts
    use-command-center.ts
    use-command-window.ts
    use-conversations.ts
    use-messages.ts
    use-notifications.ts
    use-spaces.ts
    use-toast.ts
    use-user.ts
  layouts/
    AuthLayout.tsx
    ProtectedLayout.tsx
  lib/
    utils/
      env-utils.ts
      utils.ts
  pages/
    CommandCenter.tsx
    ForgotPassword.tsx
    Profile.tsx
    Protected.tsx
    ResetPassword.tsx
    SignIn.tsx
  registry/
    dialogs.tsx
    providers.tsx
  schemas/
    auth.ts
    conversations.ts
    spaces.ts
  services/
    api/
      api-service.ts
    app-data/
      app-data-service.ts
    conversations/
      conversation-service.ts
    messages/
      message-service.ts
    notification/
      notification-service.ts
    search/
      search-service.ts
    spaces/
      space-service.ts
    user/
      user-service.ts
  store/
    main/
      index.ts
    renderer/
      index.ts
    actions.ts
  styles/
    cmdk.css
    globals.css
  types/
    api.ts
    app.ts
    auth.ts
    chat.ts
    command.ts
    conversation.ts
    electron.d.ts
    ipc.ts
    message.ts
    notification.ts
    provider.ts
    space.ts
    user.ts
    utils.ts
  utils/
    auth.ts
    index.ts
    logger.ts
    model-utils.ts
    responseHelper.ts
    validation.ts
  App.tsx
  main.tsx
.gitignore
components.json
electron.vite.config.ts
index.html
package.json
postcss.config.js
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: docs/component-data-flow.md
================
# Component Data Flow Guide

## Overview

This guide explains how React components in our Electron application should handle data flow between the renderer process (React components) and the main process (Electron backend) using our centralized IPC event system and state management.

## Data Flow Architecture

### 1. Main Process → Renderer Process Flow


Using our centralized IPC events from `src/core/ipc/constants.ts`:

```mermaid
graph TD
    A[Main Process State] -->|State Change| B[IPC Event Emitter]
    B -->|AppStateEvents.STATE_UPDATED| C[Preload Script]
    C -->|window.electron.on| D[React Component]
    D -->|setState| E[Component State]
```

#### Example Implementation
```typescript
// In your React component
import { useEffect, useState } from 'react';
import { User } from '@/src/types';
import { AppStateEvents } from '@/src/core/ipc/constants';

export function UserProfile() {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    // 1. Set up listener for state updates
    const cleanup = window.electron.on('state-updated', (event, response) => {
      if (response.success && response.data.user) {
        setUser(response.data.user);
      }
    });

    // 2. Request initial state
    window.electron.invoke(AppStateEvents.GET_STATE)
      .then((response) => {
        if (response.success && response.data.user) {
          setUser(response.data.user);
        }
      });

    // 3. Clean up listener on unmount
    return cleanup;
  }, []);

  if (!user) return <div>Loading...</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      {/* ... */}
    </div>
  );
}
```

### 2. Renderer Process → Main Process Flow

```mermaid
graph TD
    A[User Action] -->|Click/Input| B[React Component]
    B -->|window.electron.invoke| C[Preload Script]
    C -->|IPC Invoke| D[Main Process Handler]
    D -->|Process Data| E[Main Process State]
    E -->|State Updated| F[IPC Event Emitter]
    F -->|AppStateEvents.STATE_UPDATED| G[All Listening Components]
```

#### Example Implementation
```typescript
// In your React component
import { useState } from 'react';

export function UpdateProfile() {
  const [isUpdating, setIsUpdating] = useState(false);

  const handleUpdateProfile = async (newData: any) => {
    try {
      setIsUpdating(true);
      
      // 1. Send update request to main process
      const response = await window.electron.invoke('update-profile', newData);
      
      if (!response.success) {
        throw new Error(response.error);
      }

      // 2. Main process will emit state update
      // 3. Components listening for state updates will receive new data
      
    } catch (error) {
      console.error('Failed to update profile:', error);
    } finally {
      setIsUpdating(false);
    }
  };

  return (
    <button 
      onClick={() => handleUpdateProfile({ name: 'New Name' })}
      disabled={isUpdating}
    >
      {isUpdating ? 'Updating...' : 'Update Profile'}
    </button>
  );
}
```

## Best Practices

### 1. Component Setup

```typescript
import { AppStateEvents, AuthEvents, SpaceEvents, MessageEvents } from '@/src/core/ipc/constants';
import { IpcEventType } from '@/src/types';

// Custom hook for handling IPC communication
function useIpcState<T>(eventType: IpcEventType, initialValue: T) {
  const [state, setState] = useState<T>(initialValue);

  useEffect(() => {
    // Set up listener
    const cleanup = window.electron.on(eventType, (event, response) => {
      if (response.success) {
        setState(response.data);
      }
    });

    // Get initial state
    window.electron.invoke(eventType)
      .then((response) => {
        if (response.success) {
          setState(response.data);
        }
      });

    return cleanup;
  }, [eventType]);

  return state;
}

// Using the hook in a component
function ConversationList() {
  const conversations = useIpcState(MessageEvents.GET_CONVERSATION_MESSAGES, []);
  
  return (
    <div>
      {conversations.map(conversation => (
        <ConversationItem key={conversation.id} {...conversation} />
      ))}
    </div>
  );
}
```

### 2. Error Handling

```typescript
function useIpcAction(actionType: IpcEventType) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const execute = async (...args: any[]) => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await window.electron.invoke(actionType, ...args);
      
      if (!response.success) {
        throw new Error(response.error);
      }

      return response.data;
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  };

  return { execute, isLoading, error };
}

// Using the hook
function MessageSender() {
  const { execute, isLoading, error } = useIpcAction(MessageEvents.SEND_MESSAGE);

  const handleSend = async (message: string) => {
    try {
      await execute({ content: message });
      // Success! Main process will emit state update
    } catch (err) {
      // Handle error (already set in hook)
    }
  };

  return (
    <div>
      {error && <div className="error">{error}</div>}
      <button disabled={isLoading}>
        {isLoading ? 'Sending...' : 'Send'}
      </button>
    </div>
  );
}
```

### 3. State Synchronization

```typescript
// Custom hook for synced state
function useSyncedState<T>(eventType: IpcEventType, initialState: T) {
  const [state, setState] = useState<T>(initialState);

  useEffect(() => {
    // Listen for state updates
    const cleanup = window.electron.on(eventType, (event, response) => {
      if (response.success) {
        setState(response.data);
      }
    });

    // Get initial state
    window.electron.invoke(eventType)
      .then((response) => {
        if (response.success) {
          setState(response.data);
        }
      });

    return cleanup;
  }, [eventType]);

  // Function to update state
  const updateState = async (newState: T) => {
    const response = await window.electron.invoke(eventType, newState);
    return response.success;
  };

  return [state, updateState] as const;
}

// Using synced state
function UserSettings() {
  const [settings, updateSettings] = useSyncedState(AppStateEvents.GET_STATE, {});

  const handleThemeChange = async (theme: string) => {
    await updateSettings({ ...settings, theme });
  };

  return (
    <div>
      <select 
        value={settings.theme} 
        onChange={e => handleThemeChange(e.target.value)}
      >
        <option value="light">Light</option>
        <option value="dark">Dark</option>
      </select>
    </div>
  );
}
```

## Common Patterns

### 1. Loading States

- Always show loading states during IPC communication
- Handle initial data loading
- Provide feedback during updates

### 2. Error Handling
- Handle both network and IPC errors
- Show user-friendly error messages
- Provide retry mechanisms

### 3. State Updates

- Listen for global state changes
- Update local state accordingly
- Handle race conditions

### 4. Cleanup

- Always remove IPC listeners on component unmount
- Cancel pending operations when appropriate
- Clear local state when needed

## Anti-Patterns to Avoid

1. **Direct Store Access**

❌ Don't try to access the main process store directly
✅ Use IPC communication for all data access

2. **Multiple Listeners**
❌ Don't set up multiple listeners for the same event
✅ Use a single listener and share state through props or context

3. **Missing Error Handling**
❌ Don't assume IPC calls will always succeed
✅ Always handle potential errors

4. **Skipping Cleanup**
❌ Don't forget to remove listeners on unmount
✅ Always return cleanup function in useEffect

## Performance Considerations

1. **Debouncing/Throttling**

```typescript
function useDebounceIpc(delay: number) {
  const timeoutRef = useRef<NodeJS.Timeout>();

  const debounce = (fn: () => void) => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    timeoutRef.current = setTimeout(fn, delay);
  };

  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return debounce;
}
```

2. **Selective Updates**
```typescript
function useSelectiveSync<T>(selector: (data: any) => T) {
  const [state, setState] = useState<T | null>(null);
  const prevValue = useRef<T | null>(null);

  useEffect(() => {
    const cleanup = window.electron.on('state-updated', (event, response) => {
      if (response.success) {
        const newValue = selector(response.data);
        if (JSON.stringify(newValue) !== JSON.stringify(prevValue.current)) {
          prevValue.current = newValue;
          setState(newValue);
        }
      }
    });

    return cleanup;
  }, [selector]);

  return state;
}
```

## Testing Components

```typescript
// Example test for a component using IPC
import { render, fireEvent, waitFor } from '@testing-library/react';
import { UserProfile } from './UserProfile';

// Mock window.electron
const mockElectron = {
  on: jest.fn(),
  invoke: jest.fn(),
  off: jest.fn(),
};

window.electron = mockElectron;

describe('UserProfile', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should load and display user data', async () => {
    // Mock successful response
    mockElectron.invoke.mockResolvedValueOnce({
      success: true,
      data: { name: 'Test User' }
    });

    const { getByText } = render(<UserProfile />);

    // Should show loading initially
    expect(getByText('Loading...')).toBeInTheDocument();

    // Should show user data after loading
    await waitFor(() => {
      expect(getByText('Test User')).toBeInTheDocument();
    });
  });
});
```

================
File: docs/data-flow-architecture.md
================
# Data Flow Architecture

## Overview

This document outlines the complete data flow architecture of our Electron application, from startup to API interactions and state updates.

## Application Startup Flow

```mermaid
sequenceDiagram
    participant Main as Main Process
    participant Preload as Preload Script
    participant Renderer as Renderer Process
    participant API as External API

    Main->>Main: Initialize app
    Main->>Main: Set up IPC handlers
    Main->>Preload: Load preload script
    Preload->>Preload: Initialize API modules
    Main->>Renderer: Load renderer process
    Renderer->>Renderer: Initialize React app
    Renderer->>Renderer: Set up state stores
    Renderer->>Main: Request initial data
    Main->>API: Fetch initial data
    API->>Main: Return data
    Main->>Renderer: Send data via IPC
    Renderer->>Renderer: Update state stores
```

## Core Components

### 1. Main Process (`main.ts`)

- Entry point of the application
- Event Constants (`src/core/ipc/constants.ts`):
  ```typescript
  // Authentication events
  export const AuthEvents = {
    GET_SESSION: 'get-session',
    GET_AUTH_TOKEN: 'get-auth-token',
    SIGN_UP: 'sign-up',
    SIGN_OUT: 'sign-out'
  };

  // Command center events
  export const CommandCenterEvents = {
    OPEN_DIALOG: 'open-dialog',
    DIALOG_OPENED: 'dialog-opened',
    DIALOG_CLOSED: 'dialog-closed'
  };

  // Space events
  export const SpaceEvents = {
    GET_SPACES: 'get-spaces',
    CREATE_SPACE: 'create-space',
    UPDATE_SPACE: 'update-space'
  };
  ```

- Entry point of the application
- Responsibilities:
  - Window management
  - IPC handler setup
  - System API interactions
  - External API communication
  - File system operations

### 2. Preload Script (`preload.ts`)

- Bridge between main and renderer processes
- Modules:
  - Authentication API
  - Command Center API
  - App State API
  - Space Management API
  - Message Handling API
  - IPC Utilities

### 3. Renderer Process (React Application)

- User interface and state management
- Components:
  - State stores
  - React components
  - Custom hooks for IPC
  - Event handlers

## Data Flow Patterns

### 1. API Data Fetching

```mermaid
sequenceDiagram
    participant Component as React Component
    participant Store as State Store
    participant IPC as IPC Bridge
    participant Main as Main Process
    participant API as External API

    Component->>IPC: Request data
    IPC->>Main: Forward request
    Main->>API: API request
    API->>Main: Response
    Main->>IPC: Send response
    IPC->>Store: Update state
    Store->>Component: Notify changes
```

### 2. State Updates

1. **Local State Updates with Custom Hooks**
   ```typescript
   // Custom hook for IPC communication
   const useIpcEffect = (channel: string, callback: (data: any) => void) => {
     useEffect(() => {
       ipcRenderer.on(channel, (_, data) => callback(data));
       return () => {
         ipcRenderer.removeListener(channel, callback);
       };
     }, [channel, callback]);
   };

   // Usage in component
   const MyComponent = () => {
     const [data, setData] = useState<Data>();
     
     useIpcEffect(SpaceEvents.GET_SPACES, (spaces) => {
       setData(spaces);
     });
   };
   ```
   ```typescript
   // Component level
   const [localState, setLocalState] = useState<Data>();
   
   // Update through IPC
   useEffect(() => {
     ipcRenderer.on('data-update', (event, data) => {
       setLocalState(data);
     });
   }, []);
   ```

2. **Global State Updates with State Management**
   ```typescript
   // Store definition
   interface AppState {
     spaces: Space[];
     messages: Message[];
     loading: boolean;
     setSpaces: (spaces: Space[]) => void;
     setMessages: (messages: Message[]) => void;
   }

   const useStore = create<AppState>((set) => ({
     spaces: [],
     messages: [],
     loading: false,
     setSpaces: (spaces) => set({ spaces }),
     setMessages: (messages) => set({ messages })
   }));

   // IPC listener setup
   ipcRenderer.on(SpaceEvents.GET_SPACES, (_, spaces) => {
     useStore.getState().setSpaces(spaces);
   });
   ```
   ```typescript
   // Store level
   const useStore = create<AppState>((set) => ({
     data: null,
     setData: (data) => set({ data }),
   }));
   
   // Update through IPC
   ipcRenderer.on('global-update', (event, data) => {
     useStore.getState().setData(data);
   });
   ```

## State Synchronization

### 1. Main Process → Renderer

```typescript
// Main process handler
ipcMain.handle(SpaceEvents.GET_SPACES, async () => {
  try {
    const spaces = await api.getSpaces();
    // Broadcast to all windows
    BrowserWindow.getAllWindows().forEach((window) => {
      window.webContents.send(SpaceEvents.GET_SPACES, spaces);
    });
    return spaces;
  } catch (error) {
    console.error('Failed to fetch spaces:', error);
    throw error;
  }
});

// Renderer process listener
const { spaces } = useStore();
useIpcEffect(SpaceEvents.GET_SPACES, (newSpaces) => {
  useStore.getState().setSpaces(newSpaces);
});

- IPC events trigger state updates
- State changes propagate through stores
- Components react to store updates

### 2. Renderer → Main Process

- User actions trigger IPC events
- Main process handles requests
- Results flow back to renderer

## Error Handling

1. **API Errors**
   ```typescript
   try {
     const response = await api.getData();
     sendToRenderer('data-success', response);
   } catch (error) {
     sendToRenderer('data-error', error);
     logError(error);
   }
   ```

2. **IPC Errors**
   ```typescript
   ipcMain.handle('request-data', async (event, args) => {
     try {
       return await processRequest(args);
     } catch (error) {
       return { error: error.message };
     }
   });
   ```

## Performance Considerations

1. **Data Caching**
   - Cache API responses
   - Implement local storage
   - Use memory cache for frequent data

2. **State Updates**
   - Batch updates when possible
   - Debounce frequent changes
   - Use selective updates

3. **IPC Communication**
   - Minimize payload size
   - Use typed events
   - Implement request queuing

## Best Practices

1. **Data Fetching**
   - Use centralized API clients
   - Implement retry mechanisms
   - Handle offline scenarios

2. **State Management**
   - Follow single source of truth
   - Use atomic updates
   - Implement proper cleanup

3. **Error Handling**
   - Consistent error formats
   - Proper error propagation
   - User-friendly error messages

## Monitoring and Debugging

1. **IPC Monitoring**
   - Log IPC events
   - Track payload sizes
   - Monitor event frequency

2. **State Tracking**
   - Debug state changes
   - Track update sources
   - Monitor performance

3. **Error Tracking**
   - Log error details
   - Track error patterns
   - Monitor API health

================
File: docs/electron-preload-modularization.md
================
# Electron Preload Script Modularization

## Overview

This document outlines the modularization of the Electron preload script in the Vinci application. The main goal was to improve code organization, maintainability, and readability by breaking down the preload script into distinct modules based on functionality.

## Directory Structure

```typescript
electron/
├── preload/
│   ├── api/
│   │   ├── auth.ts         # Authentication-related IPC calls
│   │   ├── command-center.ts # Command center operations
│   │   ├── app-state.ts    # Application state management
│   │   ├── space.ts        # Space-related operations
│   │   └── messages.ts     # Message handling
│   └── utils/
│       └── ipc.ts          # Common IPC utilities
└── preload.ts              # Main preload script
```

## Key Components


### 1. IPC Utilities (`ipc.ts`)

- Centralized IPC communication utilities
- Provides type-safe wrappers for IPC operations
- Functions:
  - `on`: Register event listeners
  - `off`: Remove specific event listeners
  - `removeAllListeners`: Clean up all listeners
  - `invoke`: Make IPC calls with promises
  - `send`: Send one-way IPC messages


### 2. API Modules

#### Authentication (`auth.ts`)

- Handles user authentication operations
- Manages auth tokens and sessions
- Operations:
  - Sign in/out
  - Token management
  - Session handling
  - Password reset


#### Command Center (`command-center.ts`)

- Manages command center window operations
- Handles dialog interactions
- Features:
  - Window state management
  - Command type handling
  - Dialog operations
  - File search and read operations


#### App State (`app-state.ts`)

- Manages global application state
- Handles state synchronization
- Features:
  - State retrieval
  - Data refresh operations
  - State update notifications


#### Space Management (`space.ts`)

- Handles workspace and conversation spaces
- Operations:
  - Space retrieval
  - Space updates
  - Conversation management


#### Message Handling (`messages.ts`)

- Manages message operations
- Features:
  - Message sending
  - Message retrieval
  - Message updates
  - Message deletion


## State Management

- Using state management for global application state
- Simplified state synchronization between main and renderer processes
- Direct state updates without complex middleware


## Type Safety

- Leverages TypeScript for type safety
- Centralized IPC event types in `src/core/ipc/constants.ts`
- Shared types between main and renderer processes
- Type-safe IPC communication


## Benefits

1. **Improved Maintainability**

   - Clear separation of concerns
   - Modular code structure
   - Easier to update and debug


2. **Better Organization**

   - Domain-specific modules
   - Centralized utilities
   - Clear file structure


3. **Enhanced Type Safety**

   - TypeScript integration
   - Consistent type definitions
   - Reduced runtime errors


4. **Simplified Testing**

   - Isolated modules
   - Clear dependencies
   - Easier to mock and test


## Future Improvements

1. **Testing**

   - Add unit tests for each module
   - Implement integration tests
   - Add end-to-end tests


2. **Documentation**

   - Add JSDoc comments
   - Generate API documentation
   - Add usage examples


3. **Error Handling**

   - Implement consistent error handling
   - Add error logging
   - Improve error messages


4. **Performance**

   - Optimize IPC communication
   - Implement caching where appropriate
   - Add performance monitoring

================
File: docs/ipc-event-system.md
================
# IPC Event System Documentation

## Overview
This document outlines the Inter-Process Communication (IPC) event system used in the Vinci application. The system is designed to provide type-safe, maintainable, and centralized event handling between the main and renderer processes.

## Event Constants
Located in `src/core/ipc/constants.ts`, our IPC events are organized into distinct categories:

### Authentication Events
```typescript
export const AuthEvents = {
  GET_SESSION: 'get-session',
  GET_AUTH_TOKEN: 'get-auth-token',
  REFRESH_AUTH_TOKENS: 'refresh-auth-tokens',
  SIGN_UP: 'sign-up',
  SIGN_OUT: 'sign-out',
  RESET_PASSWORD: 'reset-password',
  SET_AUTH_TOKENS: 'set-auth-tokens',
  CLEAR_AUTH_DATA: 'clear-auth-data'
}
```

### Command Center Events
```typescript
export const CommandCenterEvents = {
  OPEN_DIALOG: 'open-dialog',
  DIALOG_OPENED: 'dialog-opened',
  DIALOG_CLOSED: 'dialog-closed',
  TOGGLE: 'toggle-command-center',
  SHOW: 'show-command-center',
  CLOSE: 'close-command-center',
  SET_TYPE: 'set-command-type',
  SYNC_STATE: 'sync-command-center-state',
  REFRESH: 'refresh-command-center',
  CHECK_TYPE: 'check-command-type'
}
```

### Space Events
```typescript
export const SpaceEvents = {
  GET_SPACE_CONVERSATIONS: 'get-space-conversations',
  UPDATE_SPACE: 'update-space',
  UPDATE_SPACE_MODEL: 'update-space-model',
  SET_ACTIVE_SPACE: 'set-active-space'
}
```

### Message Events
```typescript
export const MessageEvents = {
  GET_CONVERSATION_MESSAGES: 'get-conversation-messages',
  SEND_MESSAGE: 'send-message',
  DELETE_MESSAGE: 'delete-message',
  UPDATE_MESSAGE: 'update-message'
}
```

### App State Events
```typescript
export const AppStateEvents = {
  SYNC_STATE: 'sync-app-state',
  GET_STATE: 'get-app-state',
  REFRESH_DATA: 'refresh-app-data',
  STATE_UPDATED: 'state-updated'
}
```

## IPC Utilities
Located in `electron/preload/utils/ipc.ts`, these utilities provide a consistent interface for IPC communication:

```typescript
export const ipcUtils = {
  // Register event listener
  on: (channel: IpcEventType, callback: EventCallback) => {...},
  
  // Remove specific event listener
  off: (channel: IpcEventType, callback: EventCallback) => {...},
  
  // Remove all listeners for a channel
  removeAllListeners: (channel: IpcEventType) => {...},
  
  // Make IPC calls with promise support
  invoke: <T>(channel: IpcEventType, ...args: any[]) => Promise<...>,
  
  // Send one-way IPC messages
  send: (channel: IpcEventType, data: IpcResponse) => {...}
}
```

## State Management
- Using Zustand for state management
- State synchronization between main and renderer processes via IPC events
- Centralized state updates through AppStateEvents

## Type Safety
- All IPC events are typed using TypeScript
- Event types are defined in `src/types/index.ts`
- Type checking for both event names and payload data
- Autocomplete support in IDE

## Best Practices

### 1. Event Naming
- Use consistent naming conventions
- Group related events together
- Use descriptive names that indicate purpose

### 2. Error Handling
- Always include success/error status in responses
- Provide meaningful error messages
- Handle errors appropriately in both processes

### 3. Event Usage
- Use `invoke` for request-response patterns
- Use `send` for one-way notifications
- Clean up listeners when components unmount

### 4. State Updates
- Use AppStateEvents for global state changes
- Keep state updates atomic
- Validate state changes before applying

## Security Considerations
- Validate all IPC inputs
- Use encryption for sensitive data
- Implement proper access controls
- Handle errors securely

## Testing
- Unit test each event handler
- Test error scenarios
- Validate event payloads
- Test state synchronization

## Examples

### Component Usage
```typescript
// Using IPC in a React component
useEffect(() => {
  const handleStateUpdate = (event: any, data: any) => {
    // Handle state update
  };

  // Register listener
  const cleanup = window.electron.on('state-updated', handleStateUpdate);

  // Clean up on unmount
  return cleanup;
}, []);
```

### Making IPC Calls
```typescript
// Invoking IPC methods
const response = await window.electron.invoke('get-app-state');
if (response.success) {
  // Handle success
} else {
  // Handle error
}
```

================
File: docs/state-management.md
================
# State Management in Vinci Application

## Migration from Redux to Zustand

### Overview
We've migrated from Redux to Zustand for state management to achieve:
- Simpler, more lightweight state management
- Reduced boilerplate code
- Better TypeScript integration
- Easier integration with Electron's IPC system

### Key Changes

1. **Removal of Redux Dependencies**
- Removed Redux and related packages
- Eliminated Redux middleware
- Removed Redux DevTools integration
- Cleaned up Redux action creators and reducers

2. **Zustand Implementation**
- Using Zustand for global state management
- Direct state updates without action creators
- TypeScript-first approach with better type inference
- Simplified state selectors

### State Architecture

#### Store Structure
```typescript
interface AppState {
  user: User | null;
  spaces: Space[];
  activeSpace: Space | null;
  conversations: Conversation[];
  messages: Message[];
  commandCenter: {
    isOpen: boolean;
    type: string | null;
  };
}
```

#### IPC Integration
- State updates are synchronized between main and renderer processes
- Using AppStateEvents for state synchronization
- Atomic state updates to maintain consistency

### Benefits

1. **Simplified Code**
- Less boilerplate
- More intuitive state updates
- Easier to maintain and understand

2. **Better Performance**
- Reduced bundle size
- More efficient updates
- Less memory usage

3. **Improved Developer Experience**
- Better TypeScript integration
- Simpler debugging
- Faster development cycles

### Best Practices

1. **State Updates**
```typescript
// Creating a store
const useStore = create<AppState>((set) => ({
  user: null,
  setUser: (user: User | null) => set({ user }),
  // ... other state and actions
}));

// Using the store in components
const user = useStore((state) => state.user);
```

2. **Electron Integration**
```typescript
// Syncing state with main process
useEffect(() => {
  const unsubscribe = useStore.subscribe(
    (state) => state,
    (state) => {
      window.electron.invoke('sync-app-state', state);
    }
  );
  return unsubscribe;
}, []);
```

3. **State Persistence**
- Using Electron's file system for state persistence
- Encrypted storage for sensitive data
- State rehydration on app startup

### Testing

1. **Unit Tests**
- Test individual store slices
- Verify state updates
- Check computed values

2. **Integration Tests**
- Test store interactions
- Verify IPC synchronization
- Check state persistence

### Future Improvements

1. **State Optimization**
- Implement selective state updates
- Add state compression for large datasets
- Optimize state synchronization

2. **Developer Tools**
- Add state debugging tools
- Implement state logging
- Create state visualization tools

3. **Performance**
- Add state caching
- Implement state preloading
- Optimize state serialization

### Migration Guide

1. **Remove Redux**
```bash
npm remove redux react-redux @reduxjs/toolkit
```

2. **Install Zustand**
```bash
npm install zustand
```

3. **Update Components**
- Replace useSelector with useStore
- Update dispatch calls to use store actions
- Remove Redux Provider components

4. **Update IPC Communication**
- Remove Redux action dispatching
- Implement direct state updates
- Update state synchronization

================
File: electron/preload/api/app-state.ts
================
import { ipcRenderer } from 'electron';
import { AppStateEvents } from '@/core/ipc/constants';

export const appStateApi = {
  getAppState: async () => {
    try {
      const response = await ipcRenderer.invoke(AppStateEvents.GET_STATE);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("Error getting app state:", error);
      return null;
    }
  },
  
  refreshAppData: async () => {
    try {
      const response = await ipcRenderer.invoke(AppStateEvents.REFRESH_DATA);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("Error refreshing app data:", error);
      return null;
    }
  },

  syncAppState: (newState: any) => {
    ipcRenderer.send(AppStateEvents.SYNC_STATE, { success: true, data: newState });
  },
};

================
File: electron/preload/api/auth.ts
================
import { ipcRenderer } from 'electron';
import { AuthEvents } from '@/core/ipc/constants';
import { IpcResponse } from '@/src/types/ipc';

export const authApi = {
  setAuthTokens: (accessToken: string, refreshToken: string) => 
    ipcRenderer.invoke(AuthEvents.SET_AUTH_TOKENS, accessToken, refreshToken),
  
  getAuthToken: () => 
    ipcRenderer.invoke(AuthEvents.GET_AUTH_TOKEN) as Promise<IpcResponse>,
  
  refreshAuthTokens: () => 
    ipcRenderer.invoke(AuthEvents.REFRESH_AUTH_TOKENS),
  
  signOut: () => 
    ipcRenderer.invoke(AuthEvents.SIGN_OUT),
  
  resetPassword: (email: string) =>
    ipcRenderer.invoke(AuthEvents.RESET_PASSWORD, email),
  
  signUp: (email: string, password: string) =>
    ipcRenderer.invoke(AuthEvents.SIGN_UP, email, password),
  
  verifyToken: () =>
    ipcRenderer.invoke(AuthEvents.VERIFY_TOKEN) as Promise<IpcResponse>,
};

================
File: electron/preload/api/command-center.ts
================
import { ipcRenderer } from 'electron';
import { CommandCenterEvents, AppStateEvents } from '@/core/ipc/constants';
import { CommandType } from '@/types/command';

export const commandCenterApi = {
  searchFiles: async (searchTerm: string) => {
    try {
      const response = await ipcRenderer.invoke(CommandCenterEvents.SEARCH_FILES, searchTerm);
      return response.success ? response.data : [];
    } catch (error) {
      console.error("Error searching files:", error);
      return [];
    }
  },

  readFile: async (filePath: string) => {
    try {
      const response = await ipcRenderer.invoke(CommandCenterEvents.READ_FILE, filePath);
      if (!response.success) throw new Error(response.error);
      return response.data;
    } catch (error) {
      console.error("Error reading file:", error);
      throw error;
    }
  },

  ping: () => ({ success: true, data: "pong" }),
  
  closeCommandCenterFromUnauthenticated: async () => {
    try {
      return await ipcRenderer.invoke('close-command-center');
    } catch (error) {
      console.error("Error closing command center:", error);
      return { success: false, error };
    }
  },

  toggleCommandCenter: async (commandType: CommandType = 'unified') => {
    try {
      return await ipcRenderer.invoke(CommandCenterEvents.TOGGLE, commandType);
    } catch (error) {
      console.error("Error toggling command center:", error);
      return { success: false, error };
    }
  },

  closeCommandCenter: async (commandType: CommandType = 'unified') => {
    try {
      return await ipcRenderer.invoke(CommandCenterEvents.CLOSE, commandType);
    } catch (error) {
      console.error("Error closing command center:", error);
      return { success: false, error };
    }
  },

  openCommandType: async (commandType: CommandType) => {
    try {
      await ipcRenderer.invoke(AppStateEvents.REFRESH_DATA);
      return await ipcRenderer.invoke(CommandCenterEvents.SHOW, commandType);
    } catch (error) {
      console.error("Error opening command type:", error);
      return { success: false, error };
    }
  },

  refreshCommandCenter: async (commandType: CommandType = 'unified') => {
    try {
      return await ipcRenderer.invoke(CommandCenterEvents.REFRESH, commandType);
    } catch (error) {
      console.error("Error refreshing command center:", error);
      return { success: false, error };
    }
  },

  checkCommandType: async (commandType: CommandType) => {
    try {
      return await ipcRenderer.invoke(CommandCenterEvents.CHECK_TYPE, commandType);
    } catch (error) {
      console.error("Error checking command type:", error);
      return { success: false, error };
    }
  },

  openDialog: async (dialogType: string, data: any) => {
    try {
      return await ipcRenderer.invoke(CommandCenterEvents.OPEN_DIALOG, dialogType, data);
    } catch (error) {
      console.error("Error opening dialog:", error);
      return { success: false, error };
    }
  },
  
  notifyDialogOpened: () => 
    ipcRenderer.send(CommandCenterEvents.DIALOG_OPENED, { success: true }),
  
  notifyDialogClosed: () => 
    ipcRenderer.send(CommandCenterEvents.DIALOG_CLOSED, { success: true }),

  closeDialog: async () => {
    try {
      return await ipcRenderer.invoke(CommandCenterEvents.DIALOG_CLOSED);
    } catch (error) {
      console.error("Error closing dialog:", error);
      return { success: false, error };
    }
  }
};

================
File: electron/preload/api/conversations.ts
================
import { ipcRenderer } from 'electron';
import { ConversationEvents } from '@/core/ipc/constants';

export const conversationApi = {
  getConversations: async () => {
    try {
      const response = await ipcRenderer.invoke(ConversationEvents.GET_CONVERSATIONS);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] getConversations error:", error);
      return null;
    }
  },

  createConversation: async (spaceId: string, conversationData: any) => {
    try {
      const response = await ipcRenderer.invoke(ConversationEvents.CREATE_CONVERSATION, { 
        spaceId, 
        ...conversationData 
      });
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] createConversation error:", error);
      return null;
    }
  },

  updateConversation: async (conversationId: string, conversationData: any) => {
    try {
      const response = await ipcRenderer.invoke(ConversationEvents.UPDATE_CONVERSATION, { 
        id: conversationId, 
        ...conversationData 
      });
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] updateConversation error:", error);
      return null;
    }
  },

  deleteConversation: async (conversationId: string) => {
    try {
      const response = await ipcRenderer.invoke(ConversationEvents.DELETE_CONVERSATION, { 
        conversationId 
      });
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] deleteConversation error:", error);
      return null;
    }
  },

  setActiveConversation: async (conversationId: string) => {
    try {
      const response = await ipcRenderer.invoke(ConversationEvents.SET_ACTIVE_CONVERSATION, conversationId);
      return response;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] setActiveConversation error:", error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  },

  onConversationsUpdated: (callback: (conversations: any[]) => void) => {
    const handler = (_event: any, response: any) => {
      if (response.success && response.data) {
        callback(response.data);
      }
    };

    ipcRenderer.on(ConversationEvents.CONVERSATIONS_UPDATED, handler);
    return () => ipcRenderer.removeListener(ConversationEvents.CONVERSATIONS_UPDATED, handler);
  },
};

================
File: electron/preload/api/messages.ts
================
import { ipcRenderer } from 'electron';
import { MessageEvents, SearchEvents } from '@/core/ipc/constants';

export const messageApi = {
  getConversationMessages: async (conversationId: string) => {
    const response = await ipcRenderer.invoke(MessageEvents.GET_CONVERSATION_MESSAGES, { conversationId });
    return response.success ? response.data : null;
  },

  searchMessages: async (query: string) => {
    const response = await ipcRenderer.invoke(SearchEvents.SEARCH_MESSAGES, { query });
    return response.success ? response.data : [];
  },

  sendChatMessage: async (conversationId: string, message: string) => {
    const response = await ipcRenderer.invoke(MessageEvents.SEND_MESSAGE, { conversationId, message });
    return response.success ? response.data : null;
  },

  deleteMessage: async (conversationId: string, messageId: string) => {
    const response = await ipcRenderer.invoke(MessageEvents.DELETE_MESSAGE, { conversationId, messageId });
    return response.success ? response.data : null;
  },

  updateMessage: async (conversationId: string, messageId: string, content: string) => {
    const response = await ipcRenderer.invoke(MessageEvents.UPDATE_MESSAGE, { conversationId, messageId, content });
    return response.success ? response.data : null;
  },
};

================
File: electron/preload/api/notifications.ts
================
import { ipcRenderer } from 'electron';
import { NotificationEvents } from '@/core/ipc/constants';

export const notificationApi = {
  getNotifications: async () => {
    try {
      const response = await ipcRenderer.invoke(NotificationEvents.GET_NOTIFICATIONS);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] getNotifications error:", error);
      return null;
    }
  },

  markNotificationAsRead: async (notificationId: string) => {
    try {
      const response = await ipcRenderer.invoke(NotificationEvents.MARK_AS_READ, notificationId);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] markNotificationAsRead error:", error);
      return null;
    }
  },

  markAllNotificationsAsRead: async () => {
    try {
      const response = await ipcRenderer.invoke(NotificationEvents.MARK_ALL_AS_READ);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] markAllNotificationsAsRead error:", error);
      return null;
    }
  },

  onNotificationReceived: (callback: (notification: any) => void) => {
    const handler = (_event: any, response: any) => {
      if (response.success && response.data) {
        callback(response.data);
      }
    };

    ipcRenderer.on(NotificationEvents.NOTIFICATION_RECEIVED, handler);
    return () => ipcRenderer.removeListener(NotificationEvents.NOTIFICATION_RECEIVED, handler);
  },
};

================
File: electron/preload/api/space.ts
================
import { ipcRenderer } from 'electron';
import { SpaceEvents } from '@/core/ipc/constants';

export const spaceApi = {
  getSpaces: async () => {
    try {
      const response = await ipcRenderer.invoke(SpaceEvents.GET_SPACES);
      return response.success ? response.data : null;
    } catch (error) {
      console.error('[ELECTRON PRELOAD] getSpaces error:', error);
      return null;
    }
  },

  getSpaceConversations: async (spaceId: string) => {
    const response = await ipcRenderer.invoke(SpaceEvents.GET_SPACE_CONVERSATIONS, { spaceId });
    return response.success ? response.data : null;
  },

  updateSpace: async (spaceId: string, spaceData: any) => {
    const response = await ipcRenderer.invoke(SpaceEvents.UPDATE_SPACE, { spaceId, ...spaceData });
    return response.success ? response.data : null;
  },

  updateSpaceModel: async (spaceId: string, model: string, provider: string) => {
    console.log('[ELECTRON PRELOAD] Calling updateSpaceModel:', spaceId, model, provider);
    try {
      const response = await ipcRenderer.invoke(SpaceEvents.UPDATE_SPACE_MODEL, { spaceId, model, provider });
      console.log('[ELECTRON PRELOAD] updateSpaceModel result:', response);
      return response.success ? response.data : null;
    } catch (error) {
      console.error('[ELECTRON PRELOAD] updateSpaceModel error:', error);
      throw error;
    }
  },

  setActiveSpace: async (spaceId: string) => {
    try {
      console.log('[ELECTRON PRELOAD] setActiveSpace called with:', spaceId);
      const response = await ipcRenderer.invoke(SpaceEvents.SET_ACTIVE_SPACE, { spaceId });
      console.log('[ELECTRON PRELOAD] setActiveSpace result:', response);
      return response;
    } catch (error) {
      console.error('[ELECTRON PRELOAD] setActiveSpace error:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  },

  getActiveSpace: async () => {
    try {
      return await ipcRenderer.invoke(SpaceEvents.GET_ACTIVE_SPACE);
    } catch (error) {
      console.error('[ELECTRON PRELOAD] getActiveSpace error:', error);
      throw error;
    }
  },

  createSpace: async (spaceData: any) => {
    try {
      const response = await ipcRenderer.invoke(SpaceEvents.CREATE_SPACE, spaceData);
      return response;
    } catch (error) {
      console.error('[ELECTRON PRELOAD] createSpace error:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  },

  deleteSpace: async (spaceId: string) => {
    try {
      const response = await ipcRenderer.invoke(SpaceEvents.DELETE_SPACE, spaceId);
      return response;
    } catch (error) {
      console.error('[ELECTRON PRELOAD] deleteSpace error:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  },
};

================
File: electron/preload/api/user.ts
================
import { ipcRenderer } from 'electron';
import { UserEvents } from '@/core/ipc/constants';
import { IpcResponse } from '@/types';

export const userApi = {
  getProfile: async () => {
    try {
      const response = await ipcRenderer.invoke(UserEvents.GET_PROFILE);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] getProfile error:", error);
      return null;
    }
  },

  updateProfile: async (profileData: any) => {
    try {
      const response = await ipcRenderer.invoke(UserEvents.UPDATE_PROFILE, profileData);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] updateProfile error:", error);
      return null;
    }
  },

  updatePassword: async (currentPassword: string, newPassword: string) => {
    try {
      const response = await ipcRenderer.invoke(UserEvents.UPDATE_PASSWORD, { 
        currentPassword, 
        newPassword 
      });
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] updatePassword error:", error);
      return null;
    }
  },

  updateEmailPreferences: async (preferences: any) => {
    try {
      const response = await ipcRenderer.invoke(UserEvents.UPDATE_EMAIL_PREFERENCES, preferences);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] updateEmailPreferences error:", error);
      return null;
    }
  },

  getSettings: async () => {
    try {
      const response = await ipcRenderer.invoke(UserEvents.GET_SETTINGS);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] getSettings error:", error);
      return null;
    }
  },

  updateSettings: async (settings: any) => {
    try {
      const response = await ipcRenderer.invoke(UserEvents.UPDATE_SETTINGS, settings);
      return response.success ? response.data : null;
    } catch (error) {
      console.error("[ELECTRON PRELOAD] updateSettings error:", error);
      return null;
    }
  },
};

================
File: electron/preload/utils/ipc.ts
================
import { ipcRenderer, IpcRendererEvent } from 'electron';
import { 
  IpcResponse,
  AuthEventType,
  AppStateEventType,
  CommandCenterEventType,
  SpaceEventType,
  MessageEventType,
  UserEventType,
  NotificationEventType,
  ConversationEventType
} from '../../../src/types';

export type IpcEventType = 
  | AuthEventType 
  | AppStateEventType 
  | CommandCenterEventType 
  | SpaceEventType 
  | MessageEventType
  | UserEventType
  | NotificationEventType
  | ConversationEventType;

export type EventCallback = (event: IpcRendererEvent, response: IpcResponse) => void;

export const ipcUtils = {
  on: (channel: IpcEventType, callback: EventCallback): () => void => {
    ipcRenderer.on(channel, callback);
    return () => ipcRenderer.removeListener(channel, callback);
  },

  off: (channel: IpcEventType, callback: EventCallback): void => {
    ipcRenderer.removeListener(channel, callback);
  },

  removeAllListeners: (channel: IpcEventType): void => {
    ipcRenderer.removeAllListeners(channel);
  },

  invoke: <T = any>(channel: IpcEventType, ...args: any[]): Promise<IpcResponse & { data?: T }> => {
    return ipcRenderer.invoke(channel, ...args);
  },

  send: (channel: IpcEventType, data: IpcResponse): void => {
    ipcRenderer.send(channel, data);
  },
};

================
File: electron/main.ts
================
import { app, safeStorage, BrowserWindow } from 'electron';
import { join } from 'path';
import { isMac } from '@/lib/utils/env-utils';
import { registerIpcHandlers } from '@/core/ipc/ipc-handlers';
import { registerGlobalShortcuts } from '@/core/window/shortcuts';
import { loadAuthData, refreshTokens } from '@/core/auth/auth-service';
import { createMainWindow, preloadCommandWindows } from '@/core/window/window-service';
import { fetchInitialAppData } from '@/services/app-data/app-data-service';
import { useMainStore } from '@/store/main';

const ROUTES = {
  SIGN_IN: '/sign-in',
  PROTECTED: '/protected'
} as const;

const APP_CONFIG = {
  DEV_SERVER: 'http://localhost:5173',
  IS_DEV: process.env.NODE_ENV === 'development'
} as const;

if (isMac()) app.dock.show();

function getAppUrl(route: string): string {
  const baseUrl = APP_CONFIG.IS_DEV 
    ? APP_CONFIG.DEV_SERVER 
    : `file://${join(__dirname, '../renderer/index.html')}`;
  return `${baseUrl}#${route}`;
}

async function handleAuth(): Promise<boolean> {
  const store = useMainStore.getState();
  const { accessToken, refreshToken, tokenExpiryTime } = await loadAuthData(safeStorage);
  
  if (tokenExpiryTime) store.setTokenExpiryTime(tokenExpiryTime);
  if (!accessToken && !refreshToken) return false;
  if (!accessToken && refreshToken) return await refreshTokens(safeStorage);
  
  return true;
}

async function handleAppData(): Promise<boolean> {
  try {
    const data = await fetchInitialAppData();
    if (data.error) return false;
    
    useMainStore.getState().setAppState(data);
    return true;
  } catch {
    return false;
  }
}

async function startApp() {
  registerIpcHandlers();
  registerGlobalShortcuts();

  const isAuthenticated = await handleAuth();
  if (!isAuthenticated) {
    const mainWindow = await createMainWindow();
    if (!mainWindow) {
      console.error('Failed to create main window');
      app.quit();
      return;
    }
    mainWindow.webContents.on('did-fail-load', console.error);
    if (APP_CONFIG.IS_DEV) mainWindow.webContents.openDevTools();
    mainWindow.loadURL(getAppUrl(ROUTES.SIGN_IN));
    return;
  }

  const hasData = await handleAppData();
  if (!hasData) {
    const mainWindow = await createMainWindow();
    if (!mainWindow) {
      console.error('Failed to create main window');
      app.quit();
      return;
    }
    mainWindow.webContents.on('did-fail-load', console.error);
    if (APP_CONFIG.IS_DEV) mainWindow.webContents.openDevTools();
    mainWindow.loadURL(getAppUrl(ROUTES.SIGN_IN));
    return;
  }

  const [mainWindow] = await Promise.all([
    createMainWindow(),
    preloadCommandWindows()
  ]);

  if (!mainWindow) {
    console.error('Failed to create main window');
    app.quit();
    return;
  }
  mainWindow.webContents.on('did-fail-load', console.error);
  if (APP_CONFIG.IS_DEV) {
    mainWindow.webContents.openDevTools();
  }
  mainWindow.loadURL(getAppUrl(ROUTES.PROTECTED));
}

function shutdown() {
  BrowserWindow.getAllWindows()
    .filter(window => window && !window.isDestroyed())
    .forEach(window => window?.destroy());
  app.quit();
}

app.whenReady().then(startApp);
app.on('window-all-closed', () => !isMac() && shutdown());
app.on('activate', () => BrowserWindow.getAllWindows().length === 0 && createMainWindow());
app.on('before-quit', shutdown);
if (isMac()) app.on('quit', shutdown);

================
File: electron/preload.ts
================
import { contextBridge, ipcRenderer } from "electron";
import { authApi } from './preload/api/auth';
import { commandCenterApi } from './preload/api/command-center';
import { appStateApi } from './preload/api/app-state';
import { spaceApi } from './preload/api/space';
import { messageApi } from './preload/api/messages';
import { userApi } from './preload/api/user';
import { notificationApi } from './preload/api/notifications';
import { conversationApi } from './preload/api/conversations';
import { ipcUtils } from './preload/utils/ipc';

const updatedAuthApi = {
  ...authApi,
};

contextBridge.exposeInMainWorld("electron", {
  ...updatedAuthApi,
  ...commandCenterApi,
  ...ipcUtils,
  ...appStateApi,
  ...spaceApi,
  ...messageApi,
  ...userApi,
  ...notificationApi,
  ...conversationApi,
});

================
File: electron/tsconfig.json
================
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "outDir": "../build",
    "rootDir": "../",
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": false,
    "baseUrl": "../",
    "paths": {
      "@/*": ["*"],
      "@/src/*": ["src/*"],
      "@/lib/*": ["src/lib/*"],
      "@/store/*": ["src/store/*"],
      "@/core/*": ["src/core/*"],
      "@/services/*": ["src/services/*"]
    }
  },
  "include": [
    "./**/*", 
    "../src/types/electron.d.ts", 
    "../src/lib/**/*.ts",
    "../src/core",
    "../src/services",
    "../src/store",
    "../src/lib/utils"
  ],
  "exclude": ["../src/lib/**/*.tsx"]
}

================
File: src/components/auth/form-message.tsx
================
export type Message =
  | { success: string }
  | { error: string }
  | { message: string };

export function FormMessage({ message }: { message: Message }) {
  return (
    <div className="flex flex-col gap-2 w-full max-w-md text-sm">
      {"success" in message && (
        <div className="text-foreground border-l-2 border-foreground px-4">
          {message.success}
        </div>
      )}
      {"error" in message && (
        <div className="text-destructive-foreground border-l-2 border-destructive-foreground px-4">
          {message.error}
        </div>
      )}
      {"message" in message && (
        <div className="text-foreground border-l-2 px-4">{message.message}</div>
      )}
    </div>
  );
}

================
File: src/components/auth/index.ts
================
export * from './form-message';
export * from './submit-button';

================
File: src/components/auth/submit-button.tsx
================
import { type ComponentProps } from "react";
import { useFormStatus } from "react-dom";
import { Button } from "@/components/ui/button";
type Props = ComponentProps<typeof Button> & {
  pendingText?: string;
};

export function SubmitButton({
  children,
  pendingText = "Submitting...",
  ...props
}: Props) {
  const { pending } = useFormStatus();

  return (
    <Button type="submit" aria-disabled={pending} {...props}>
      {pending ? pendingText : children}
    </Button>
  );
}

================
File: src/components/auth/user-profile-dropdown.tsx
================
import React, { useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { Bell, LogOut, User as UserIcon, Settings } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils/utils";
import { User } from '@supabase/supabase-js';
import { useUser } from '@/hooks/use-user';
import { useNotifications } from '@/hooks/use-notifications';
import { UserProfile } from '@/services/user/user-service';

interface UserProfileDropdownProps {
  user: User | UserProfile;
}

export function UserProfileDropdown({ user }: UserProfileDropdownProps) {
  const navigate = useNavigate();
  const { signOut } = useUser();
  const { notifications, unreadCount, markAsRead, markAllAsRead } = useNotifications();
  const [isOpen, setIsOpen] = useState(false);
  const [showNotifications, setShowNotifications] = useState(false);
  
  const userInitials = user.email
    ? user.email.substring(0, 2).toUpperCase()
    : '??';

  const handleLogout = async () => {
    try {
      await signOut();
      navigate('/sign-in');
    } catch (error) {
      console.error('Error signing out:', error);
    }
  };
  
  const handleMarkAsRead = async (notificationId: string) => {
    await markAsRead(notificationId);
  };

  const handleMarkAllAsRead = async () => {
    await markAllAsRead();
  };
  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="relative h-10 w-10 rounded-full border border-white/[0.05] bg-white/[0.03] hover:bg-white/[0.05] transition-all duration-200"
          aria-label="User profile"
        >
          {unreadCount > 0 && (
            <span className="absolute right-0 top-0 flex h-3 w-3">
              <span className="absolute inline-flex h-full w-full animate-ping rounded-full bg-cyan-400 opacity-75"></span>
              <span className="relative inline-flex h-3 w-3 rounded-full bg-cyan-500"></span>
            </span>
          )}
          <Avatar>
            <AvatarImage src={('user_metadata' in user) ? user.user_metadata?.avatar_url : undefined} alt={user.email || ''} />
            <AvatarFallback>{userInitials}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1.5">
            <p className="text-sm font-medium leading-none text-white/90 truncate max-w-[200px]">
              {('user_metadata' in user) ? user.user_metadata?.full_name || user.email : user.email}
            </p>
            <p className="text-xs leading-none text-white/40 truncate max-w-[200px]">
              {user.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuGroup>
          <DropdownMenuItem 
            onClick={(e: React.MouseEvent) => {
              e.preventDefault();
              setShowNotifications(!showNotifications);
            }}
            className="cursor-pointer"
          >
            <Bell className="mr-2 h-4 w-4" />
            <span>Notifications</span>
            {unreadCount > 0 && (
              <div className="ml-auto flex h-5 w-5 items-center justify-center rounded-full bg-cyan-500 text-xs">
                {unreadCount}
              </div>
            )}
          </DropdownMenuItem>
          {showNotifications && (
            <>
              {unreadCount > 0 && (
                <div className="px-3 py-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-auto p-1 text-xs text-white/70 hover:text-white hover:bg-white/[0.05]"
                    onClick={handleMarkAllAsRead}
                  >
                    Mark all as read
                  </Button>
                </div>
              )}
              <div className="max-h-48 overflow-y-auto">
                {notifications.length === 0 ? (
                  <div className="px-3 py-2 text-sm text-white/50">
                    No notifications
                  </div>
                ) : (
                  notifications.map((notification) => (
                    <div
                      key={notification.id}
                      className={cn(
                        'px-3 py-2 text-sm hover:bg-white/[0.05] transition-colors',
                        !notification.is_read && 'bg-white/[0.03]'
                      )}
                    >
                      <div className="flex items-center justify-between gap-2">
                        <div className="font-medium text-white/90">{notification.title}</div>
                        {!notification.is_read && (
                          <Button
                            variant="ghost"
                            size="sm"
                            className="h-auto p-1 text-xs text-white/70 hover:text-white hover:bg-white/[0.05]"
                            onClick={() => handleMarkAsRead(notification.id)}
                          >
                            Mark as read
                          </Button>
                        )}
                      </div>
                      <div className="mt-1 text-white/70 text-xs">{notification.description}</div>
                    </div>
                  ))
                )}
              </div>
            </>
          )}
          <Link to="/protected/profile">
            <DropdownMenuItem>
              <UserIcon className="mr-2 h-4 w-4" />
              <span>Profile</span>
            </DropdownMenuItem>
          </Link>
          <Link to="/protected/settings">
            <DropdownMenuItem>
              <Settings className="mr-2 h-4 w-4" />
              <span>Settings</span>
            </DropdownMenuItem>
          </Link>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />
        <DropdownMenuItem
          className="text-cyan-400 hover:text-cyan-300 focus:text-cyan-300"
          onClick={handleLogout}
        >
          <LogOut className="mr-2 h-4 w-4" />
          <span>Log out</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: src/components/chat/ui/actions-tab.tsx
================
import { useState } from 'react';
import { 
  Plus, RefreshCw, FileText, List, Download, 
  Clock, ArrowUpRight, Tag, FileCode, CheckSquare, 
  CalendarIcon, Mail, Share2, BookmarkIcon
} from 'lucide-react';
import { BaseTab } from '@/components/ui/base-tab';
import {
  DropdownMenu,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { toast } from '@/hooks/use-toast';
import { DropdownList, DropdownSection, DropdownItem, DropdownFooterAction } from '@/components/shared/dropdown-list';

export interface ActionsTabProps {
  onCreateConversation?: (title: string) => Promise<void>;
  onClick?: () => void;
}

export function ActionsTab({ onCreateConversation, onClick }: ActionsTabProps) {
  const [isCreating, setIsCreating] = useState(false);
  const [lastCreated, setLastCreated] = useState<string | null>(null);

  const handleClick = async () => {
    if (onClick) {
      onClick();
    } else if (onCreateConversation) {
      await onCreateConversation('Quick Action');
    }
  };

  const handleQuickAction = async (actionId: string) => {
    if (!onCreateConversation) return;
    
    const action = quickActions.find(a => a.id === actionId);
    if (!action) return;
    
    setIsCreating(true);
    try {
      await onCreateConversation(action.name);
      setLastCreated(action.id);
      
      toast({
        title: "Action Created",
        description: `Created "${action.name}" action`,
        variant: "default",
      });
    } catch (error) {
      toast({
        title: "Creation Failed",
        description: "Unable to create action. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsCreating(false);
    }
  };

  const quickActions = [
    {
      id: 'summarize',
      name: 'Summarize Conversation',
      description: 'Generate a concise summary of the current conversation',
      category: 'conversation'
    },
    {
      id: 'extract-action-items',
      name: 'Extract Action Items',
      description: 'Identify and list all action items discussed in the conversation',
      category: 'conversation'
    },
    {
      id: 'meeting-notes',
      name: 'Generate Meeting Notes',
      description: 'Create structured meeting notes from this conversation',
      category: 'conversation'
    },
    {
      id: 'export',
      name: 'Export Conversation',
      description: 'Export this conversation as Markdown, PDF, or text file',
      category: 'utility'
    },
    {
      id: 'bookmark',
      name: 'Add Bookmark',
      description: 'Bookmark this conversation at the current point',
      category: 'utility'
    },
    {
      id: 'generate-code',
      name: 'Generate Code',
      description: 'Create code based on the requirements in this conversation',
      category: 'content'
    },
    {
      id: 'create-draft',
      name: 'Draft Email',
      description: 'Create an email draft based on points discussed',
      category: 'content'
    },
    {
      id: 'create-event',
      name: 'Schedule Event',
      description: 'Create calendar event from details in conversation',
      category: 'content'
    },
    {
      id: 'share-conversation',
      name: 'Share Conversation',
      description: 'Generate a shareable link to this conversation',
      category: 'utility'
    }
  ];

  // Group actions by category
  const conversationActions = quickActions.filter(action => action.category === 'conversation');
  const contentActions = quickActions.filter(action => action.category === 'content');
  const utilityActions = quickActions.filter(action => action.category === 'utility');

  // Get icon based on action id
  const getActionIcon = (actionId: string) => {
    switch (actionId) {
      case 'summarize':
        return <FileText className="w-4 h-4 text-blue-400" />;
      case 'extract-action-items':
        return <CheckSquare className="w-4 h-4 text-green-400" />;
      case 'meeting-notes':
        return <List className="w-4 h-4 text-purple-400" />;
      case 'export':
        return <Download className="w-4 h-4 text-teal-400" />;
      case 'bookmark':
        return <BookmarkIcon className="w-4 h-4 text-orange-400" />;
      case 'generate-code':
        return <FileCode className="w-4 h-4 text-cyan-400" />;
      case 'create-draft':
        return <Mail className="w-4 h-4 text-indigo-400" />;
      case 'create-event':
        return <CalendarIcon className="w-4 h-4 text-rose-400" />;
      case 'share-conversation':
        return <Share2 className="w-4 h-4 text-amber-400" />;
      default:
        return <Plus className="w-4 h-4 text-white/60" />;
    }
  };

  // Build sections for dropdown
  const buildSections = () => {
    const sections: DropdownSection[] = [];

    if (conversationActions.length > 0) {
      sections.push({
        title: "Conversation Actions",
        items: conversationActions.map(action => createActionItem(action))
      });
    }

    if (contentActions.length > 0) {
      sections.push({
        title: "Content Generation",
        items: contentActions.map(action => createActionItem(action))
      });
    }

    if (utilityActions.length > 0) {
      sections.push({
        title: "Utilities",
        items: utilityActions.map(action => createActionItem(action))
      });
    }

    return sections;
  };

  const createActionItem = (action: any): DropdownItem => ({
    id: action.id,
    isActive: lastCreated === action.id,
    isDisabled: isCreating,
    onSelect: () => handleQuickAction(action.id),
    content: (
      <div className="flex w-full">
        <div className="flex-shrink-0 mr-2.5 mt-0.5">
          {getActionIcon(action.id)}
        </div>
        <div className="flex-1 min-w-0">
          <div className="flex items-center justify-between mb-0.5">
            <span className="text-sm font-medium text-white/90 truncate">{action.name}</span>
            {isCreating && lastCreated === action.id && (
              <span className="text-xs bg-white/10 text-white/80 px-1.5 py-0.5 rounded-full">
                Processing...
              </span>
            )}
          </div>
          <span className="text-xs text-white/60 line-clamp-2 w-full">
            {action.description}
          </span>
        </div>
      </div>
    )
  });

  const actionSections = buildSections();

  // Get footer actions based on selected action
  const getFooterActions = (): DropdownFooterAction[] => {
    // If an action is selected, show action-specific options
    if (lastCreated) {
      const selectedAction = quickActions.find(a => a.id === lastCreated);
      if (selectedAction) {
        return [
          {
            icon: <ArrowUpRight className="w-3.5 h-3.5" />,
            label: `Execute "${selectedAction.name}"`,
            onClick: () => handleQuickAction(lastCreated)
          },
          {
            icon: <Tag className="w-3.5 h-3.5" />,
            label: "Save as template",
            onClick: () => {
              toast({
                title: "Template Saved",
                description: `Saved "${selectedAction.name}" as template`,
                variant: "default",
              });
            }
          }
        ];
      }
    }
    
    // Default action when no action is selected
    return [
      {
        icon: <Plus className="w-3.5 h-3.5" />,
        label: "Create custom action",
        onClick: () => handleClick()
      }
    ];
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="transparent" 
          className="p-0 h-auto rounded-sm transition-all duration-200 group w-full"
          aria-label="Actions menu"
        >
          <BaseTab
            icon={
              <div className="flex items-center justify-center w-5 h-5 group-hover:scale-110 transition-transform duration-300">
                {isCreating ? 
                  <RefreshCw className="w-3 h-3 animate-spin" /> : 
                  <Plus className="w-3 h-3" />
                }
              </div>
            }
            label="Actions"
            shortcut="A"
            className="w-full"
          />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownList 
        sections={actionSections}
        footerActions={getFooterActions()}
        emptyState={<div className="text-sm text-white/50">No actions available</div>}
      />
    </DropdownMenu>
  );
}

================
File: src/components/chat/ui/chat-mode-tab.tsx
================
import React, { useState } from 'react';
import {
  DropdownMenu,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { BaseTab } from '@/components/ui/base-tab';
import { getChatModeConfig, getAllChatModes } from '@/config/chat-modes';
import { Space } from '@/types/space';
import { useSpaces } from '@/hooks/use-spaces';
import { toast } from '@/hooks/use-toast';
import { Settings, RefreshCw } from 'lucide-react';
import { DropdownList, DropdownSection, DropdownItem, DropdownFooterAction } from '@/components/shared/dropdown-list';

export interface ChatModeTabProps {
  space?: Space | null;
}

export function ChatModeTab({ space }: ChatModeTabProps) {
  const { updateSpace } = useSpaces();
  const [isUpdating, setIsUpdating] = useState(false);
  const chatMode = space?.chat_mode || 'ask';
  const modeConfig = getChatModeConfig(chatMode);
  const Icon = modeConfig.icon;
  const chatModes = getAllChatModes();

  const handleModeSelect = async (modeId: string) => {
    if (!space?.id) {
      toast({
        title: "No Active Space",
        description: "Please select a space first",
        variant: "destructive",
      });
      return;
    }

    if (modeId === chatMode) {
      return; // Don't update if it's the same mode
    }

    setIsUpdating(true);
    try {
      await updateSpace(space.id, {
        chat_mode: modeId,
        chat_mode_config: {}
      });
      
      toast({
        title: "Mode Updated",
        description: `Now using ${getChatModeConfig(modeId).name}`,
        variant: "default",
      });
    } catch (error) {
      console.error('Error updating chat mode:', error);
      toast({
        title: "Update Failed",
        description: error instanceof Error ? error.message : "Please try again",
        variant: "destructive",
      });
    } finally {
      setIsUpdating(false);
    }
  };
  
  const handleModeSettings = (modeId: string) => {
    const mode = getChatModeConfig(modeId);
    
    toast({
      title: "Coming Soon",
      description: `${mode.name} settings will be available soon!`,
      variant: "default",
    });
  };

  // Build sections for dropdown
  const chatModeSections: DropdownSection[] = [
    {
      title: "Chat Modes",
      items: chatModes.map((mode): DropdownItem => ({
        id: mode.id,
        isActive: mode.id === chatMode,
        isDisabled: isUpdating,
        onSelect: () => handleModeSelect(mode.id),
        content: (
          <div className="flex w-full">
            <div className="flex-shrink-0 mr-2.5">
              <mode.icon className="w-4 h-4 text-white/60" />
            </div>
            <div className="flex-1 min-w-0">
              <div className="flex items-center justify-between mb-0.5">
                <span className="text-sm font-medium text-white/90 truncate">{mode.name}</span>
                {mode.id === chatMode && (
                  <span className="text-xs bg-white/10 text-white/80 px-1.5 py-0.5 rounded-full">
                    {isUpdating ? 'Updating...' : 'Current'}
                  </span>
                )}
              </div>
              <span className="text-xs text-white/60 line-clamp-1 w-full">
                {mode.description}
              </span>
            </div>
          </div>
        )
      }))
    }
  ];

  // Define footer actions
  const footerActions: DropdownFooterAction[] = [
    {
      icon: <Settings className="w-3.5 h-3.5" />,
      label: "Configure mode",
      onClick: (modeId) => handleModeSettings(modeId),
    }
  ];
  
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="transparent" 
          className="p-0 h-auto rounded-sm transition-all duration-200 group"
          aria-label={`Current chat mode: ${modeConfig.name}`}
        >
          <BaseTab
            icon={
              <div className="flex items-center justify-center w-5 h-5 group-hover:scale-110 transition-transform duration-300">
                <Icon className="w-3.5 h-3.5" />
              </div>
            }
            label={modeConfig.name}
            isActive={!!chatMode}
          />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownList 
        sections={chatModeSections}
        footerActions={footerActions}
        emptyState={<div className="text-sm text-white/50">No chat modes available</div>}
      />
    </DropdownMenu>
  );
}

================
File: src/components/chat/ui/conversation-tab.tsx
================
import { useState } from 'react';
import { BaseTab } from '@/components/ui/base-tab';
import { MessageSquare, Edit, Trash, Share2, Plus, RefreshCw, Search } from 'lucide-react';
import { Conversation } from '@/types/conversation';
import { useRendererStore } from '@/store/renderer';
import { formatDistanceToNow } from 'date-fns';
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { toast } from '@/hooks/use-toast';
import { DropdownList, DropdownSection, DropdownItem, DropdownFooterAction } from '@/components/shared/dropdown-list';

export interface ConversationTabProps {
  activeConversation: Conversation | null;
  onCreateConversation?: (title: string) => Promise<void>;
  onSelectConversation?: (conversation: Conversation) => void;
  onClick?: () => void;
}

export function ConversationTab({ 
  activeConversation, 
  onCreateConversation, 
  onSelectConversation,
  onClick 
}: ConversationTabProps) {
  const [isCreating, setIsCreating] = useState(false);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const { conversations } = useRendererStore();

  const handleClick = async () => {
    if (onClick) {
      onClick();
    } else if (onCreateConversation && !activeConversation) {
      setIsCreating(true);
      try {
        await onCreateConversation('New Conversation');
      } catch (error) {
        console.error('Error creating conversation:', error);
        toast({
          title: 'Error',
          description: 'Failed to create conversation',
          variant: 'destructive',
        });
      } finally {
        setIsCreating(false);
      }
    }
  };

  const handleConversationAction = async (action: string, conversationId?: string) => {
    // Find the conversation if an ID is provided
    const targetConversation = conversationId 
      ? conversations.find(c => c.id === conversationId) 
      : activeConversation;
      
    if (!targetConversation) return;
    
    try {
      // Here you would implement the actual action logic
      console.log(`${action} conversation: ${targetConversation.title} (${targetConversation.id})`);
      
      toast({
        title: 'Success',
        description: `Conversation "${targetConversation.title}" ${action.toLowerCase()}`,
        variant: 'default',
      });
    } catch (error) {
      toast({
        title: 'Error',
        description: `Failed to ${action.toLowerCase()} conversation`,
        variant: 'destructive',
      });
    }
  };

  const handleSelectConversation = (conversation: Conversation) => {
    if (onSelectConversation) {
      onSelectConversation(conversation);
    }
  };

  // Filter conversations based on search query
  const filterConversations = () => {
    let filtered = [...conversations];
    
    // Apply text search filter
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase().trim();
      filtered = filtered.filter(conversation => 
        (conversation.title?.toLowerCase().includes(query)) || 
        (conversation.lastMessage && conversation.lastMessage.toLowerCase().includes(query))
      );
    }
    
    return filtered;
  };

  // Sort conversations by update time
  const sortedConversations = filterConversations().sort((a, b) => {
    return new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime();
  });

  // Build sections for dropdown
  const conversationSections: DropdownSection[] = [
    {
      title: `Conversations ${sortedConversations.length > 0 ? `(${sortedConversations.length})` : ''}`,
      items: sortedConversations.map((conversation): DropdownItem => ({
        id: conversation.id,
        isActive: activeConversation?.id === conversation.id,
        onSelect: () => handleSelectConversation(conversation),
        content: (
          <div className="flex w-full">
            <div className="flex-shrink-0 mr-2.5">
              <MessageSquare className="w-3.5 h-3.5 text-white/60" />
            </div>
            <div className="flex-1 min-w-0">
              <div className="flex items-center justify-between mb-0.5">
                <span className="text-sm font-medium text-white/90 truncate">{conversation.title}</span>
                {activeConversation?.id === conversation.id && (
                  <span className="text-xs bg-white/10 text-white/80 px-1.5 py-0.5 rounded-full">
                    Current
                  </span>
                )}
              </div>
              {conversation.lastMessage && (
                <span className="text-xs text-white/60 line-clamp-1 w-full">
                  {conversation.lastMessage}
                </span>
              )}
              <div className="flex items-center mt-1">
                <span className="text-xs text-white/40">
                  {formatDistanceToNow(new Date(conversation.updated_at), { addSuffix: true })}
                </span>
              </div>
            </div>
          </div>
        )
      })),
      actionButton: {
        icon: isCreating ? 
          <RefreshCw className="w-3.5 h-3.5 text-white/70 animate-spin" /> : 
          <Plus className="w-3.5 h-3.5 text-white/70" />,
        onClick: handleClick,
        isLoading: isCreating,
        ariaLabel: "Create new conversation"
      }
    }
  ];

  // Dynamic footer actions 
  const footerActions: DropdownFooterAction[] = [
    {
      icon: <Edit className="w-3.5 h-3.5" />,
      label: "Rename",
      onClick: (conversationId) => handleConversationAction("Renamed", conversationId)
    },
    {
      icon: <Trash className="w-3.5 h-3.5" />,
      label: "Delete",
      onClick: (conversationId) => handleConversationAction("Deleted", conversationId),
      variant: "destructive"
    }
  ];

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="p-0 h-auto hover:bg-white/[0.05] rounded-sm transition-all duration-200 group w-full"
          aria-label={activeConversation ? `Current conversation: ${activeConversation.title}` : "New conversation"}
        >
          <BaseTab
            icon={<MessageSquare className="w-3 h-3 group-hover:text-[#3ecfff]/80" />}
            label={activeConversation?.title || 'New Conversation'}
            isActive={!!activeConversation}
            className="w-full"
          />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownList 
        headerContent={
          <div className="px-2 pt-1.5 pb-2">
            {/* Search input */}
            <div className="relative">
              <div className="absolute inset-y-0 left-2.5 flex items-center pointer-events-none">
                <Search className="h-3.5 w-3.5 text-white/40" />
              </div>
              <input
                type="text"
                placeholder="Search conversations..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full bg-white/[0.05] rounded-md py-1.5 pl-8 pr-3 text-sm text-white/80 placeholder:text-white/40 focus:outline-none focus:ring-1 focus:ring-white/20 focus:bg-white/[0.07]"
                aria-label="Search conversations"
                autoFocus
              />
              {searchQuery && (
                <button
                  onClick={() => setSearchQuery('')}
                  className="absolute inset-y-0 right-2 flex items-center text-white/40 hover:text-white/60"
                >
                  <span className="sr-only">Clear search</span>
                  <svg className="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              )}
            </div>
            
            {/* Search feedback */}
            {searchQuery && (
              <div className="flex justify-between items-center text-xs text-white/50 mt-1.5 px-1">
                <span>
                  {sortedConversations.length === 0 
                    ? 'No matches found' 
                    : `Found ${sortedConversations.length} match${sortedConversations.length === 1 ? '' : 'es'}`}
                </span>
                <button 
                  className="hover:text-white/70 transition-colors text-xs"
                  onClick={() => setSearchQuery('')}
                >
                  Clear search
                </button>
              </div>
            )}
          </div>
        }
        sections={conversationSections}
        footerActions={footerActions}
        emptyState={
          <div className="text-sm text-white/50 flex flex-col items-center py-4">
            <MessageSquare className="w-10 h-10 text-white/20 mb-2" />
            {searchQuery ? (
              <>
                <p>No conversations match your search</p>
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="mt-3 text-xs" 
                  onClick={() => setSearchQuery('')}
                >
                  Clear search
                </Button>
              </>
            ) : (
              <>
                <p>No conversations yet</p>
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="mt-3 text-xs" 
                  onClick={handleClick}
                >
                  Start a new conversation
                </Button>
              </>
            )}
          </div>
        }
      />
    </DropdownMenu>
  );
}

================
File: src/components/chat/ui/messages-tab.tsx
================
import { useState, useMemo } from 'react';
import { Search, MessageSquare, Code, FileText, SlidersHorizontal, Globe, Sparkles, Filter, XCircle, Copy, ExternalLink, Pencil } from 'lucide-react';
import { BaseTab } from '@/components/ui/base-tab';
import {
  DropdownMenu,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { toast } from '@/hooks/use-toast';
import { DropdownList, DropdownSection, DropdownItem, DropdownFooterAction } from '@/components/shared/dropdown-list';
import { formatDistanceToNow } from 'date-fns';

export interface MessagesTabProps {
  messages?: Array<{
    id: string;
    content: string;
    role: 'user' | 'assistant';
    timestamp?: Date;
    annotations?: any[];
  }>;
  spaceId?: string;
  spaceName?: string;
  conversationId?: string;
  conversationName?: string;
  onMessageSearch?: (query: string, searchScope: 'conversation' | 'space') => void;
  onCommandWindowToggle?: (mode: string) => void;
  onClick?: () => void;
}

export function MessagesTab({ 
  messages = [], 
  spaceId,
  spaceName,
  conversationId,
  conversationName,
  onMessageSearch, 
  onCommandWindowToggle,
  onClick 
}: MessagesTabProps) {
  const [selectedMessageId, setSelectedMessageId] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [searchScope, setSearchScope] = useState<'conversation' | 'space'>('conversation');
  const [filterType, setFilterType] = useState<'all' | 'code' | 'user' | 'ai'>('all');
  
  // Filter messages based on search query and filter type
  const filteredMessages = useMemo(() => {
    if (searchScope !== 'conversation') return [];
    
    let filtered = messages;
    
    // Apply text search if query exists
    if (searchQuery.trim()) {
      filtered = filtered.filter(msg => 
        msg.content.toLowerCase().includes(searchQuery.toLowerCase().trim())
      );
    }
    
    // Apply type filter
    switch (filterType) {
      case 'code':
        filtered = filtered.filter(msg => msg.content.includes('```'));
        break;
      case 'user':
        filtered = filtered.filter(msg => msg.role === 'user');
        break;
      case 'ai':
        filtered = filtered.filter(msg => msg.role === 'assistant');
        break;
      default:
        // 'all' - no filtering
        break;
    }
    
    return filtered;
  }, [messages, searchQuery, searchScope, filterType]);
  
  // Handle search across space
  const handleSearch = () => {
    if (searchQuery.trim() && onMessageSearch) {
      onMessageSearch(searchQuery, searchScope);
      
      toast({
        title: `Searching ${searchScope === 'space' ? spaceName || 'Entire Space' : conversationName || 'Conversation'}`,
        description: `Searching for "${searchQuery}"`,
        variant: "default",
      });
      
      // Close the dropdown if searching in space
      if (searchScope === 'space' && onClick) {
        onClick();
      }
    }
  };
  
  // Handle message selection
  const handleMessageSelect = (messageId: string) => {
    setSelectedMessageId(messageId);
    
    toast({
      title: "Message Selected",
      description: "Scrolled to selected message",
      variant: "default",
    });
    
    // Close dropdown after selection
    if (onClick) {
      onClick();
    }
  };
  
  // Format message content preview
  const getMessagePreview = (content: string) => {
    // Remove code blocks
    let preview = content.replace(/```[\s\S]*?```/g, '[Code Block]');
    // Remove markdown
    preview = preview.replace(/\*\*(.*?)\*\*/g, '$1');
    preview = preview.replace(/\*(.*?)\*/g, '$1');
    // Truncate
    return preview.length > 100 ? preview.substring(0, 100) + '...' : preview;
  };
  
  // Get message icon based on content and role
  const getMessageIcon = (message: any) => {
    if (message.role === 'user') {
      return <MessageSquare className="w-4 h-4 text-blue-400" />;
    }
    
    if (message.content.includes('```')) {
      return <Code className="w-4 h-4 text-green-400" />;
    }
    
    if (message.annotations?.some((a: any) => a.type === 'file_reference')) {
      return <FileText className="w-4 h-4 text-orange-400" />; 
    }
    
    return <Sparkles className="w-4 h-4 text-purple-400" />;
  };
  
  // Dropdown section for messages
  const messageSection: DropdownSection = {
    title: `Messages ${filteredMessages.length > 0 ? `(${filteredMessages.length})` : ''}`,
    items: filteredMessages.map(message => ({
      id: message.id,
      isActive: selectedMessageId === message.id,
      onSelect: () => handleMessageSelect(message.id),
      content: (
        <div className="flex w-full">
          <div className="flex-shrink-0 mr-2.5 mt-0.5">
            {getMessageIcon(message)}
          </div>
          <div className="flex-1 min-w-0">
            <div className="flex items-center justify-between mb-0.5">
              <span className="text-sm font-medium text-white/90 truncate">
                {message.role === 'user' ? 'You' : 'AI'}
              </span>
              {message.timestamp && (
                <span className="text-xs text-white/50">
                  {formatDistanceToNow(message.timestamp, { addSuffix: true })}
                </span>
              )}
            </div>
            <span className="text-xs text-white/60 line-clamp-2 w-full">
              {getMessagePreview(message.content)}
            </span>
          </div>
        </div>
      )
    }))
  };
  
  // Get footer actions based on selected message
  const getFooterActions = (): DropdownFooterAction[] => {
    // If in space scope, show space search action
    if (searchScope === 'space') {
      return [
        {
          icon: <Search className="w-3.5 h-3.5" />,
          label: `Search ${spaceName || 'All Chats'}`,
          onClick: () => handleSearch(),
          isDisabled: !searchQuery.trim()
        }
      ];
    }
    
    // Return message-specific actions for conversation scope
    return [
      {
        icon: <Copy className="w-3.5 h-3.5" />,
        label: "Copy message",
        onClick: (messageId) => {
          const selectedMessage = messages.find(msg => msg.id === messageId);
          if (selectedMessage) {
            const hasCode = selectedMessage.content.includes('```');
            const content = hasCode 
              ? selectedMessage.content.match(/```(?:\w*\n)?([\s\S]*?)```/)?.[1] || selectedMessage.content
              : selectedMessage.content;
              
            navigator.clipboard.writeText(content);
            toast({
              title: "Copied to clipboard",
              description: hasCode ? "Code copied to clipboard" : "Message copied to clipboard",
              variant: "default",
            });
          }
        }
      },
      {
        icon: <MessageSquare className="w-3.5 h-3.5" />,
        label: "Add to conversation",
        onClick: (messageId) => {
          const selectedMessage = messages.find(msg => msg.id === messageId);
          if (selectedMessage) {
            toast({
              title: "Message added",
              description: "Message added to current conversation",
              variant: "default",
            });
            // Here you would implement the actual add to conversation logic
          }
        }
      }
    ];
  };
  
  // Calculate filter summary for display
  const getFilterSummary = () => {
    if (filterType === 'all' && !searchQuery) return null;
    
    const parts = [];
    if (filterType !== 'all') {
      parts.push(filterType === 'code' ? 'Code blocks' : 
                filterType === 'user' ? 'Your messages' : 'AI messages');
    }
    
    if (searchQuery) {
      parts.push(`"${searchQuery}"`);
    }
    
    return parts.join(' with ');
  };
  
  const filterSummary = getFilterSummary();
  
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="transparent" 
          className="p-0 h-auto rounded-sm transition-all duration-200 group w-full"
          aria-label="Search messages"
        >
          <BaseTab
            icon={
              <div className="flex items-center justify-center w-5 h-5 group-hover:scale-110 transition-transform duration-300">
                <Search className="w-3 h-3" />
              </div>
            }
            label="Messages"
            shortcut="F"
            className="w-full"
          />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownList 
        headerContent={
          <div className="px-2 pt-2 pb-2">
            {/* Scope toggle */}
            <div className="flex mb-2.5 bg-white/[0.03] rounded-md p-0.5">
              <button
                className={`flex-1 flex items-center justify-center gap-1.5 px-2 py-1.5 text-xs rounded-md transition-all duration-200 ${
                  searchScope === 'conversation' 
                    ? 'bg-white/10 text-white/90 font-medium shadow-sm' 
                    : 'text-white/60 hover:text-white/80 hover:bg-white/[0.05]'
                }`}
                onClick={() => setSearchScope('conversation')}
                aria-label={`Search in ${conversationName || 'current conversation'}`}
              >
                <MessageSquare className="w-3 h-3" />
                <span className="truncate">{conversationName || 'This Chat'}</span>
              </button>
              <button
                className={`flex-1 flex items-center justify-center gap-1.5 px-2 py-1.5 text-xs rounded-md transition-all duration-200 ${
                  searchScope === 'space' 
                    ? 'bg-white/10 text-white/90 font-medium shadow-sm' 
                    : 'text-white/60 hover:text-white/80 hover:bg-white/[0.05]'
                }`}
                onClick={() => setSearchScope('space')}
                aria-label={`Search in ${spaceName || 'entire space'}`}
              >
                <Globe className="w-3 h-3" />
                <span className="truncate">{spaceName || 'All Chats'}</span>
              </button>
            </div>
            
            {/* Search input */}
            <div className="relative">
              <div className="absolute inset-y-0 left-2.5 flex items-center pointer-events-none">
                <Search className="h-3.5 w-3.5 text-white/40" />
              </div>
              <input
                type="text"
                placeholder={`Search ${searchScope === 'conversation' ? (conversationName || 'this chat') : (spaceName || 'all chats')}...`}
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    if (searchScope === 'space') {
                      handleSearch();
                    } else if (filteredMessages.length > 0) {
                      handleMessageSelect(filteredMessages[0].id);
                    }
                  }
                }}
                className="w-full bg-white/[0.05] rounded-md py-1.5 pl-8 pr-3 text-sm text-white/80 placeholder:text-white/40 focus:outline-none focus:ring-1 focus:ring-white/20 focus:bg-white/[0.07]"
                aria-label={`Search ${searchScope === 'conversation' ? 'this chat' : 'all chats'}`}
                autoFocus
              />
              {searchQuery && (
                <button
                  onClick={() => setSearchQuery('')}
                  className="absolute inset-y-0 right-2 flex items-center text-white/40 hover:text-white/60"
                >
                  <span className="sr-only">Clear search</span>
                  <XCircle className="h-3.5 w-3.5" />
                </button>
              )}
            </div>
            
            {/* Filters - only show in conversation scope */}
            {searchScope === 'conversation' && (
              <div className="mt-2.5 flex space-x-1.5">
                <button
                  onClick={() => setFilterType('all')}
                  className={`px-2 py-1 text-xs rounded-md flex items-center gap-1 flex-1 justify-center transition-all ${
                    filterType === 'all' 
                      ? 'bg-white/10 text-white/90' 
                      : 'bg-white/[0.03] hover:bg-white/[0.05] text-white/60'
                  }`}
                >
                  <MessageSquare className="w-2.5 h-2.5" />
                  All
                </button>
                <button
                  onClick={() => setFilterType('code')}
                  className={`px-2 py-1 text-xs rounded-md flex items-center gap-1 flex-1 justify-center transition-all ${
                    filterType === 'code' 
                      ? 'bg-white/10 text-white/90' 
                      : 'bg-white/[0.03] hover:bg-white/[0.05] text-white/60'
                  }`}
                >
                  <Code className="w-2.5 h-2.5" />
                  Code
                </button>
                <button
                  onClick={() => setFilterType('user')}
                  className={`px-2 py-1 text-xs rounded-md flex items-center gap-1 flex-1 justify-center transition-all ${
                    filterType === 'user' 
                      ? 'bg-white/10 text-white/90' 
                      : 'bg-white/[0.03] hover:bg-white/[0.05] text-white/60'
                  }`}
                >
                  <MessageSquare className="w-2.5 h-2.5" />
                  You
                </button>
                <button
                  onClick={() => setFilterType('ai')}
                  className={`px-2 py-1 text-xs rounded-md flex items-center gap-1 flex-1 justify-center transition-all ${
                    filterType === 'ai' 
                      ? 'bg-white/10 text-white/90' 
                      : 'bg-white/[0.03] hover:bg-white/[0.05] text-white/60'
                  }`}
                >
                  <Sparkles className="w-2.5 h-2.5" />
                  AI
                </button>
              </div>
            )}
            
            {/* Search results summary */}
            {(searchScope === 'conversation' && (searchQuery || filterType !== 'all')) && (
              <div className="flex justify-between items-center text-xs text-white/50 mt-2 px-1">
                {filterSummary && (
                  <div className="flex items-center">
                    <Filter className="w-3 h-3 mr-1" />
                    <span>Filtering: {filterSummary}</span>
                  </div>
                )}
                <span className="ml-auto">
                  {filteredMessages.length === 0 
                    ? 'No matches' 
                    : `${filteredMessages.length} match${filteredMessages.length === 1 ? '' : 'es'}`}
                </span>
              </div>
            )}
            
            {/* Space search instruction */}
            {searchScope === 'space' && (
              <div className="flex items-center text-xs text-white/50 mt-2 px-1">
                <Globe className="w-3 h-3 mr-1" />
                <span>Press Enter to search across all chats</span>
              </div>
            )}
          </div>
        }
        sections={searchScope === 'conversation' && filteredMessages.length > 0 ? [messageSection] : []}
        footerActions={getFooterActions()}
        emptyState={
          <div className="text-sm text-white/50 flex flex-col items-center justify-center py-8">
            {searchScope === 'space' ? (
              <>
                <Globe className="w-8 h-8 text-white/20 mb-3" />
                <p className="mb-1">Search across all chats</p>
                <p className="text-xs text-white/40 max-w-[220px] text-center">
                  Type your search and press Enter to find messages in this space
                </p>
                {searchQuery && (
                  <Button 
                    variant="outline" 
                    size="sm" 
                    className="mt-4 text-xs" 
                    onClick={() => handleSearch()}
                  >
                    <Search className="w-3 h-3 mr-1.5" />
                    Search "{searchQuery}"
                  </Button>
                )}
              </>
            ) : searchQuery || filterType !== 'all' ? (
              <>
                <Filter className="w-8 h-8 text-white/20 mb-3" />
                <p className="mb-1">No messages match your filters</p>
                <div className="flex space-x-2 mt-4">
                  {searchQuery && (
                    <Button 
                      variant="outline" 
                      size="sm" 
                      className="text-xs" 
                      onClick={() => setSearchQuery('')}
                    >
                      Clear search
                    </Button>
                  )}
                  {filterType !== 'all' && (
                    <Button 
                      variant="outline" 
                      size="sm" 
                      className="text-xs" 
                      onClick={() => setFilterType('all')}
                    >
                      Clear filters
                    </Button>
                  )}
                </div>
              </>
            ) : messages.length === 0 ? (
              <>
                <MessageSquare className="w-8 h-8 text-white/20 mb-3" />
                <p>No messages in this conversation</p>
              </>
            ) : (
              <>
                <Search className="w-8 h-8 text-white/20 mb-3" />
                <p className="mb-1">Search this conversation</p>
                <p className="text-xs text-white/40 max-w-[220px] text-center">
                  Type to search or select a filter to find specific messages
                </p>
              </>
            )}
          </div>
        }
      />
    </DropdownMenu>
  );
}

================
File: src/components/chat/ui/model-tab.tsx
================
import { useState } from 'react';
import { Space } from '@/types/space';
import { BaseTab } from '@/components/ui/base-tab';
import { ProviderIcon } from '@lobehub/icons';
import { getModelDisplayInfo } from '@/utils/model-utils';
import {
  DropdownMenu,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { AVAILABLE_MODELS, Model, Provider } from '@/types/provider';
import { useSpaces } from '@/hooks/use-spaces';
import { toast } from '@/hooks/use-toast';
import { Plus, RefreshCw, Settings, Info, Search } from 'lucide-react';
import { DropdownList, DropdownSection, DropdownItem, DropdownFooterAction } from '@/components/shared/dropdown-list';

export interface ModelTabProps {
  space: Space | null;
}

export function ModelTab({ space }: ModelTabProps) {
  const { updateSpaceModel } = useSpaces();
  const modelInfo = space ? getModelDisplayInfo(space.model) : null;
  const [isUpdating, setIsUpdating] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState<string>('');

  const handleModelSelect = async (model: Model, provider: Provider) => {
    if (!space?.id) {
      toast({
        title: "No Active Space",
        description: "Please select a space first",
        variant: "destructive",
      });
      return;
    }

    if (model.id === space.model) {
      return; // Don't update if it's the same model
    }

    setIsUpdating(model.id);
    try {
      const success = await updateSpaceModel(space.id, model.id, provider);
      if (success) {
        toast({
          title: "Model Updated",
          description: `Now using ${model.name}`,
          variant: "default",
        });
      } else {
        throw new Error("Failed to update model");
      }
    } catch (error) {
      console.error('Error updating model:', error);
      toast({
        title: "Update Failed",
        description: error instanceof Error ? error.message : "Please try again",
        variant: "destructive",
      });
    } finally {
      setIsUpdating(null);
    }
  };

  const handleModelAction = (action: string, modelId?: string) => {
    // Extract the provider and model id from the combined id
    if (!modelId) return;
    
    const [provider, id] = modelId.split('-');
    
    if (!provider || !id) return;
    
    toast({
      title: "Model Action",
      description: `${action} model ${id} from ${provider}`,
      variant: "default",
    });
  };

  // Filter models based on search query
  const filterModels = (models: any[]) => {
    if (!searchQuery.trim()) return models;
    
    const query = searchQuery.toLowerCase().trim();
    return models.filter(model => 
      model.name.toLowerCase().includes(query) || 
      (model.description && model.description.toLowerCase().includes(query))
    );
  };

  // Build model sections for dropdown
  const modelSections: DropdownSection[] = [];
  let totalModelsShown = 0;

  Object.entries(AVAILABLE_MODELS).forEach(([provider, modelList]) => {
    // Ensure modelList is an array
    const models = Array.isArray(modelList) ? modelList : [];
    
    // Filter models based on search query
    const filteredModels = filterModels(models);
    totalModelsShown += filteredModels.length;
    
    if (filteredModels.length > 0) {
      modelSections.push({
        title: `${provider.charAt(0).toUpperCase() + provider.slice(1)} Models (${filteredModels.length})`,
        items: filteredModels.map((model: any) => ({
          id: `${provider}-${model.id}`,
          isActive: space?.model === model.id,
          isDisabled: isUpdating !== null,
          onSelect: () => handleModelSelect(model, provider as Provider),
          content: (
            <div className="flex w-full">
              <div className="flex-shrink-0 mr-2.5">
                <ProviderIcon 
                  type="color" 
                  provider={provider as Provider} 
                  size={16} 
                  className={`${isUpdating === model.id ? 'opacity-50' : ''}`}
                />
              </div>
              <div className="flex-1 min-w-0">
                <div className="flex items-center justify-between mb-0.5">
                  <span className="text-sm font-medium text-white/90 truncate">{model.name}</span>
                  {space?.model === model.id && (
                    <span className="text-xs bg-white/10 text-white/80 px-1.5 py-0.5 rounded-full">
                      {isUpdating === model.id ? 'Updating...' : 'Current'}
                    </span>
                  )}
                </div>
                {model.description && (
                  <span className="text-xs text-white/60 line-clamp-1 w-full">
                    {model.description}
                  </span>
                )}
              </div>
            </div>
          )
        }))
      });
    }
  });

  // Define footer actions
  const footerActions: DropdownFooterAction[] = [
    {
      icon: <Info className="w-3.5 h-3.5" />,
      label: "Model details",
      onClick: (modelId) => handleModelAction("Viewing details for", modelId)
    },
    {
      icon: <Settings className="w-3.5 h-3.5" />,
      label: "Configure",
      onClick: (modelId) => handleModelAction("Configuring", modelId)
    }
  ];

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="p-0 h-auto hover:bg-white/[0.05] rounded-sm transition-all duration-200 group"
          aria-label={modelInfo ? `Current model: ${modelInfo.displayName}` : "Select model"}
        >
          <BaseTab
            icon={modelInfo ? (
              <div className="flex items-center justify-center w-5 h-5 group-hover:scale-110 transition-transform duration-300">
                <ProviderIcon type="color" provider={modelInfo.provider} size={18} />
              </div>
            ) : (
              <div className="w-5 h-5 rounded-full bg-white/[0.03] border border-white/[0.1] group-hover:border-white/20 transition-all duration-200" />
            )}
            label={modelInfo?.displayName || 'Select Model'}
            isActive={!!modelInfo}
          />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownList 
        headerContent={
          <div className="px-2 pt-1.5 pb-2">
            {/* Search input */}
            <div className="relative">
              <div className="absolute inset-y-0 left-2.5 flex items-center pointer-events-none">
                <Search className="h-3.5 w-3.5 text-white/40" />
              </div>
              <input
                type="text"
                placeholder="Search models..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full bg-white/[0.05] rounded-md py-1.5 pl-8 pr-3 text-sm text-white/80 placeholder:text-white/40 focus:outline-none focus:ring-1 focus:ring-white/20 focus:bg-white/[0.07]"
                aria-label="Search models"
                autoFocus
              />
              {searchQuery && (
                <button
                  onClick={() => setSearchQuery('')}
                  className="absolute inset-y-0 right-2 flex items-center text-white/40 hover:text-white/60"
                >
                  <span className="sr-only">Clear search</span>
                  <svg className="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              )}
            </div>
            
            {/* Search feedback */}
            {searchQuery && (
              <div className="flex justify-between items-center text-xs text-white/50 mt-1.5 px-1">
                <span>
                  {totalModelsShown === 0 
                    ? 'No matches found' 
                    : `Found ${totalModelsShown} match${totalModelsShown === 1 ? '' : 'es'}`}
                </span>
                <button 
                  className="hover:text-white/70 transition-colors text-xs"
                  onClick={() => setSearchQuery('')}
                >
                  Clear search
                </button>
              </div>
            )}
          </div>
        }
        sections={modelSections}
        footerActions={footerActions}
        emptyState={
          <div className="text-sm text-white/50 flex flex-col items-center py-4">
            {searchQuery ? (
              <>
                <Search className="w-8 h-8 text-white/20 mb-2" />
                <p>No models match your search</p>
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="mt-3 text-xs" 
                  onClick={() => setSearchQuery('')}
                >
                  Clear search
                </Button>
              </>
            ) : (
              <div>No models available. Please check your configuration.</div>
            )}
          </div>
        }
      />
    </DropdownMenu>
  );
}

================
File: src/components/chat/ui/space-tab.tsx
================
import { useState, useMemo } from 'react';
import { BaseTab } from '@/components/ui/base-tab';
import { Space } from '@/types/space';
import DotSphere from '@/components/space/planet-icon';
import { Plus, Settings, RefreshCw, Users, Clock, Edit, Trash, Search } from 'lucide-react';
import {
  DropdownMenu,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { useSpaces } from '@/hooks/use-spaces';
import { Button } from '@/components/ui/button';
import { toast } from '@/hooks/use-toast';
import { formatDistanceToNow } from 'date-fns';
import { DropdownList, DropdownSection, DropdownItem, DropdownFooterAction } from '@/components/shared/dropdown-list';

// Utility function to generate consistent space colors based on ID
const getSpaceColor = (id: string) => {
  // Simple hash function for the ID to get consistent colors
  const hash = Array.from(id).reduce((acc, char, i) => acc + char.charCodeAt(0) * (i + 1), 0);
  const hue = hash % 360;
  return {
    primary: `hsl(${hue}, 70%, 60%)`,
    secondary: `hsl(${(hue + 40) % 360}, 80%, 40%)`,
    gradient: `linear-gradient(135deg, hsl(${hue}, 70%, 60%), hsl(${(hue + 40) % 360}, 80%, 40%))`,
  };
};

export interface SpaceTabProps {
  activeSpace: Space | null;
}

export function SpaceTab({ activeSpace }: SpaceTabProps) {
  const { spaces, setActiveSpaceById } = useSpaces();
  const [isCreating, setIsCreating] = useState(false);
  const [searchQuery, setSearchQuery] = useState<string>('');
  
  // Pre-compute colors for all spaces to avoid recalculation
  const spaceColors = useMemo(() => {
    const colors = new Map();
    spaces.forEach(space => {
      colors.set(space.id, getSpaceColor(space.id));
    });
    return colors;
  }, [spaces]);

  const handleSpaceSelect = async (space: Space) => {
    try {
      await setActiveSpaceById(space.id);
      toast({
        title: "Success",
        description: `Switched to ${space.name}`,
        variant: "default",
      });
    } catch (error) {
      console.error('Error switching space:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive",
      });
    }
  };

  const handleCreateSpace = () => {
    setIsCreating(true);
    // Add actual creation logic or navigation here
    toast({
      title: "Coming Soon",
      description: "Space creation feature will be available soon!",
      variant: "default",
    });
    setIsCreating(false);
  };

  const handleManageSpace = () => {
    toast({
      title: "Coming Soon",
      description: "Space management feature will be available soon!",
      variant: "default",
    });
  };

  const handleSpaceAction = async (action: string, spaceId?: string) => {
    // Find the space if an ID is provided
    const targetSpace = spaceId 
      ? spaces.find(s => s.id === spaceId) 
      : activeSpace;
      
    if (!targetSpace) return;
    
    try {
      // Here you would implement the actual action logic
      console.log(`${action} space: ${targetSpace.name} (${targetSpace.id})`);
      
      toast({
        title: 'Success',
        description: `Space "${targetSpace.name}" ${action.toLowerCase()}`,
        variant: 'default',
      });
    } catch (error) {
      toast({
        title: 'Error',
        description: `Failed to ${action.toLowerCase()} space`,
        variant: 'destructive',
      });
    }
  };

  // Filter spaces based on search query
  const filterSpaces = () => {
    if (!searchQuery.trim()) return spaces;
    
    const query = searchQuery.toLowerCase().trim();
    return spaces.filter(space => 
      space.name.toLowerCase().includes(query) || 
      (space.description && space.description.toLowerCase().includes(query))
    );
  };

  // Sort spaces by most recently updated
  const sortedSpaces = [...filterSpaces()].sort((a, b) => {
    return new Date(b.updated_at || b.created_at).getTime() - 
           new Date(a.updated_at || a.created_at).getTime();
  });

  // Build sections for dropdown
  const spaceSections: DropdownSection[] = [
    {
      title: `Your Spaces ${sortedSpaces.length > 0 ? `(${sortedSpaces.length})` : ''}`,
      items: sortedSpaces.map((space): DropdownItem => ({
        id: space.id,
        isActive: activeSpace?.id === space.id,
        onSelect: () => activeSpace?.id !== space.id && handleSpaceSelect(space),
        content: (
          <div className="flex w-full">
            <div className="flex-shrink-0 mr-2.5">
              {activeSpace?.id === space.id ? (
                <div className="w-4 h-4">
                  <DotSphere 
                    size={16} 
                    seed={space.id} 
                    dotCount={60} 
                    dotSize={0.7} 
                    expandFactor={1.15} 
                    transitionSpeed={400}
                    highPerformance={true}
                  />
                </div>
              ) : (
                <div 
                  className="w-4 h-4 rounded-full border border-white/10"
                  style={{ 
                    background: spaceColors.get(space.id)?.gradient || 'linear-gradient(135deg, #3f87a6, #2a5674)',
                    boxShadow: 'inset 0 0 4px rgba(0, 0, 0, 0.3)' 
                  }}
                />
              )}
            </div>
            <div className="flex-1 min-w-0">
              <div className="flex items-center justify-between mb-0.5">
                <span className="text-sm font-medium text-white/90 truncate">{space.name}</span>
                {activeSpace?.id === space.id && (
                  <span className="text-xs bg-white/10 text-white/80 px-1.5 py-0.5 rounded-full">Current</span>
                )}
              </div>
              {space.description && (
                <span className="text-xs text-white/60 line-clamp-1 w-full">
                  {space.description}
                </span>
              )}
            </div>
          </div>
        )
      })),
      actionButton: {
        icon: isCreating ? 
          <RefreshCw className="w-3.5 h-3.5 text-white/70 animate-spin" /> : 
          <Plus className="w-3.5 h-3.5 text-white/70" />,
        onClick: handleCreateSpace,
        isLoading: isCreating,
        ariaLabel: "Create new space"
      }
    }
  ];

  // Define footer actions
  const footerActions: DropdownFooterAction[] = [
    {
      icon: <Edit className="w-3.5 h-3.5" />,
      label: "Edit space",
      onClick: (spaceId) => handleSpaceAction("Edited", spaceId)
    },
    {
      icon: <Trash className="w-3.5 h-3.5" />,
      label: "Delete space",
      onClick: (spaceId) => handleSpaceAction("Deleted", spaceId),
      variant: "destructive"
    }
  ];

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="p-0 h-auto hover:bg-white/[0.05] rounded-sm transition-all duration-200 group"
          aria-label={activeSpace ? `Current space: ${activeSpace.name}` : "Select space"}
        >
          <BaseTab
            icon={
              activeSpace ? (
                <div className="flex items-center justify-center w-5 h-5 group-hover:scale-110 transition-transform duration-300">
                  <DotSphere 
                    size={20} 
                    seed={activeSpace.id} 
                    dotCount={80} 
                    dotSize={0.8} 
                    expandFactor={1.15} 
                    transitionSpeed={400}
                    highPerformance={true}
                  />
                </div>
              ) : (
                <div className="w-5 h-5 rounded-full bg-gradient-to-tr from-blue-500/20 to-purple-500/20 flex items-center justify-center border border-white/10 group-hover:border-white/20 transition-all duration-200">
                  <Plus size={12} className="text-white/60 group-hover:text-white/80 transition-colors duration-200" />
                </div>
              )
            }
            label={activeSpace?.name || 'Select Space'}
            isActive={!!activeSpace}
          />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownList 
        headerContent={
          <div className="px-2 pt-1.5 pb-2">
            {/* Search input */}
            <div className="relative">
              <div className="absolute inset-y-0 left-2.5 flex items-center pointer-events-none">
                <Search className="h-3.5 w-3.5 text-white/40" />
              </div>
              <input
                type="text"
                placeholder="Search spaces..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full bg-white/[0.05] rounded-md py-1.5 pl-8 pr-3 text-sm text-white/80 placeholder:text-white/40 focus:outline-none focus:ring-1 focus:ring-white/20 focus:bg-white/[0.07]"
                aria-label="Search spaces"
                autoFocus
              />
              {searchQuery && (
                <button
                  onClick={() => setSearchQuery('')}
                  className="absolute inset-y-0 right-2 flex items-center text-white/40 hover:text-white/60"
                >
                  <span className="sr-only">Clear search</span>
                  <svg className="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>
              )}
            </div>
            
            {/* Search feedback */}
            {searchQuery && (
              <div className="flex justify-between items-center text-xs text-white/50 mt-1.5 px-1">
                <span>
                  {sortedSpaces.length === 0 
                    ? 'No matches found' 
                    : `Found ${sortedSpaces.length} match${sortedSpaces.length === 1 ? '' : 'es'}`}
                </span>
                <button 
                  className="hover:text-white/70 transition-colors text-xs"
                  onClick={() => setSearchQuery('')}
                >
                  Clear search
                </button>
              </div>
            )}
          </div>
        }
        sections={spaceSections}
        footerActions={footerActions}
        emptyState={
          <div className="text-sm text-white/50 flex flex-col items-center py-4">
            {searchQuery ? (
              <>
                <Search className="w-8 h-8 text-white/20 mb-2" />
                <p>No spaces match your search</p>
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="mt-3 text-xs" 
                  onClick={() => setSearchQuery('')}
                >
                  Clear search
                </Button>
              </>
            ) : (
              <>
                <div className="w-12 h-12 rounded-full mb-2 bg-gradient-to-r from-blue-400/20 to-purple-400/20 flex items-center justify-center">
                  <Plus className="w-6 h-6 text-white/40" />
                </div>
                <p>No spaces available</p>
                <Button 
                  variant="outline" 
                  size="sm" 
                  className="mt-3 text-xs" 
                  onClick={handleCreateSpace}
                >
                  Create your first space
                </Button>
              </>
            )}
          </div>
        }
      />
    </DropdownMenu>
  );
}

================
File: src/components/chat/ui/suggestions-tab.tsx
================
import { useState, useMemo } from 'react';
import { Brain, Check, Clock, Calendar, Info, Search, XCircle, FileText, Code, Globe, MessageSquare, Lightbulb, ShoppingCart } from 'lucide-react';
import { BaseTab } from '@/components/ui/base-tab';
import {
  DropdownMenu,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { toast } from '@/hooks/use-toast';
import { DropdownList, DropdownSection, DropdownItem, DropdownFooterAction } from '@/components/shared/dropdown-list';

export interface SuggestionsTabProps {
  onClick?: () => void;
}

type SuggestionType = 
  | 'calendar'
  | 'research'
  | 'tasks'
  | 'development'
  | 'meeting'
  | 'travel'
  | 'document'
  | 'shopping'
  | 'communication'
  | 'learning';

interface Suggestion {
  id: string;
  title: string;
  description: string;
  type: SuggestionType;
  timestamp: string;
}

export function SuggestionsTab({ onClick }: SuggestionsTabProps) {
  const [searchQuery, setSearchQuery] = useState<string>('');
  
  const handleSuggestionAction = async (suggestionId: string, action: 'accept' | 'dismiss') => {
    try {
      const suggestion = suggestions.find(s => s.id === suggestionId);
      if (!suggestion) return;
      
      switch (action) {
        case 'accept':
          toast({
            title: 'Suggestion Accepted',
            description: `"${suggestion.title}" accepted`,
            variant: 'default',
          });
          break;
        case 'dismiss':
          toast({
            title: 'Suggestion Dismissed',
            description: `"${suggestion.title}" dismissed`,
            variant: 'default',
          });
          break;
      }
    } catch (error) {
      toast({
        title: 'Operation Failed',
        description: `Failed to ${action} suggestion. Please try again.`,
        variant: 'destructive',
      });
    }
  };

  const suggestions: Suggestion[] = [
    {
      id: 'suggestion-1',
      title: 'Schedule 1-on-1 with Dallen',
      description: 'Based on your conversation, would you like to schedule a 1-on-1 meeting with Dallen for 2:30pm today?',
      type: 'calendar',
      timestamp: new Date(Date.now() - 300000).toISOString()
    },
    {
      id: 'suggestion-2',
      title: 'Research Tesla Models',
      description: 'I noticed you mentioned buying a Tesla. Would you like me to research current models and pricing?',
      type: 'research',
      timestamp: new Date(Date.now() - 600000).toISOString()
    },
    {
      id: 'suggestion-3',
      title: 'Set Up Project Reminders',
      description: 'You mentioned deadlines for the frontend tasks. Should I create reminders for these deadlines?',
      type: 'tasks',
      timestamp: new Date(Date.now() - 900000).toISOString()
    },
    {
      id: 'suggestion-4',
      title: 'Create API Integration',
      description: 'Would you like me to generate boilerplate code for integrating with the payment API you discussed?',
      type: 'development',
      timestamp: new Date(Date.now() - 1200000).toISOString()
    },
    {
      id: 'suggestion-5',
      title: 'Book Team Meeting Room',
      description: 'Should I reserve a conference room for your team standup mentioned in the conversation?',
      type: 'meeting',
      timestamp: new Date(Date.now() - 1500000).toISOString()
    },
    {
      id: 'suggestion-6',
      title: 'Check Flight Prices',
      description: 'I noticed you mentioned traveling to San Francisco. Would you like me to check flight options?',
      type: 'travel',
      timestamp: new Date(Date.now() - 1800000).toISOString()
    },
    {
      id: 'suggestion-7',
      title: 'Draft Project Proposal',
      description: 'Based on your ideas, would you like me to create a draft proposal document for your client?',
      type: 'document',
      timestamp: new Date(Date.now() - 2100000).toISOString()
    },
    {
      id: 'suggestion-8',
      title: 'Compare Laptop Models',
      description: 'You mentioned needing a new laptop. Would you like me to research and compare options?',
      type: 'shopping',
      timestamp: new Date(Date.now() - 2400000).toISOString()
    },
    {
      id: 'suggestion-9',
      title: 'Draft Email Response',
      description: 'Would you like me to help draft a response to the client email you mentioned?',
      type: 'communication',
      timestamp: new Date(Date.now() - 2700000).toISOString()
    },
    {
      id: 'suggestion-10',
      title: 'Find TypeScript Tutorials',
      description: 'I noticed you had questions about TypeScript. Would you like me to find relevant learning resources?',
      type: 'learning',
      timestamp: new Date(Date.now() - 3000000).toISOString()
    }
  ];
  
  const filterSuggestions = () => {
    if (!searchQuery.trim()) {
      return [...suggestions];
    }
    
    const query = searchQuery.toLowerCase().trim();
    return suggestions.filter(suggestion => 
      suggestion.title.toLowerCase().includes(query) ||
      suggestion.description.toLowerCase().includes(query)
    );
  };
  
  const filteredSuggestions = filterSuggestions();
  
  // Group suggestions by type
  const groupedSuggestions = useMemo(() => {
    const groups: Record<string, Suggestion[]> = {};
    
    filteredSuggestions.forEach(suggestion => {
      if (!groups[suggestion.type]) {
        groups[suggestion.type] = [];
      }
      groups[suggestion.type].push(suggestion);
    });
    
    return groups;
  }, [filteredSuggestions]);
  
  // Get appropriate icon for each suggestion type
  const getTypeIcon = (type: SuggestionType) => {
    switch (type) {
      case 'calendar':
        return <Calendar className="w-4 h-4 text-blue-400" />;
      case 'research':
        return <Info className="w-4 h-4 text-purple-400" />;
      case 'tasks':
        return <Check className="w-4 h-4 text-green-400" />;
      case 'development':
        return <Code className="w-4 h-4 text-cyan-400" />;
      case 'meeting':
        return <MessageSquare className="w-4 h-4 text-yellow-400" />;
      case 'travel':
        return <Globe className="w-4 h-4 text-blue-500" />;
      case 'document':
        return <FileText className="w-4 h-4 text-orange-400" />;
      case 'shopping':
        return <ShoppingCart className="w-4 h-4 text-pink-400" />;
      case 'communication':
        return <MessageSquare className="w-4 h-4 text-indigo-400" />;
      case 'learning':
        return <Lightbulb className="w-4 h-4 text-yellow-400" />;
      default:
        return <Brain className="w-4 h-4 text-gray-400" />;
    }
  };

  // Get appropriate label for each type (capitalize first letter)
  const getTypeLabel = (type: SuggestionType) => {
    return type.charAt(0).toUpperCase() + type.slice(1);
  };
  
  const getSuggestionSections = (): DropdownSection[] => {
    return Object.entries(groupedSuggestions).map(([type, suggestions]) => ({
      title: `${getTypeLabel(type as SuggestionType)} (${suggestions.length})`,
      items: suggestions.map((suggestion): DropdownItem => ({
        id: suggestion.id,
        onSelect: () => {}, 
        content: (
          <div className="flex w-full">
            <div className="flex-shrink-0 mr-2.5 mt-0.5">
              {getTypeIcon(suggestion.type)}
            </div>
            <div className="flex-1 min-w-0">
              <div className="mb-0.5">
                <span className="text-sm font-medium text-white/90 block">{suggestion.title}</span>
              </div>
              <p className="text-xs text-white/70 leading-relaxed">{suggestion.description}</p>
              <div className="flex mt-1.5">
                <span className="text-xs text-white/50">
                  <Clock className="w-3 h-3 inline mr-1 align-text-bottom" />
                  {new Date(suggestion.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                </span>
              </div>
            </div>
          </div>
        )
      }))
    }));
  };

  const getFooterActions = (): DropdownFooterAction[] => {
    return [
      {
        icon: <Check className="w-3.5 h-3.5" />,
        label: "Execute this",
        onClick: (suggestionId: string) => {
          handleSuggestionAction(suggestionId, 'accept');
        },
        variant: 'default'
      },
      {
        icon: <XCircle className="w-3.5 h-3.5" />,
        label: "Dismiss",
        onClick: (suggestionId: string) => {
          handleSuggestionAction(suggestionId, 'dismiss');
        },
        variant: 'destructive'
      }
    ];
  };
  
  const suggestionSections = getSuggestionSections();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="p-0 h-auto hover:bg-white/[0.05] rounded-sm transition-all duration-200 group w-full"
          aria-label="Suggestions menu"
        >
          <BaseTab
            icon={
              <div className="flex items-center justify-center w-5 h-5 group-hover:scale-110 transition-transform duration-300">
                <Brain className="w-3 h-3 text-purple-400" />
              </div>
            }
            label="Suggestions"
            shortcut="S"
            className="w-full"
          />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownList 
        headerContent={
          <div className="px-2 pt-1.5 pb-2">
            <div className="relative">
              <div className="absolute inset-y-0 left-2.5 flex items-center pointer-events-none">
                <Search className="h-3.5 w-3.5 text-white/40" />
              </div>
              <input
                type="text"
                placeholder="Search suggestions..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full bg-white/[0.05] rounded-md py-1.5 pl-8 pr-3 text-sm text-white/80 placeholder:text-white/40 focus:outline-none focus:ring-1 focus:ring-white/20 focus:bg-white/[0.07]"
                aria-label="Search suggestions"
                autoFocus
              />
              {searchQuery && (
                <button
                  onClick={() => setSearchQuery('')}
                  className="absolute inset-y-0 right-2 flex items-center text-white/40 hover:text-white/60"
                >
                  <span className="sr-only">Clear search</span>
                  <XCircle className="h-3.5 w-3.5" />
                </button>
              )}
            </div>
            
            {searchQuery && (
              <div className="flex justify-between items-center text-xs text-white/50 mt-2 px-1">
                <div className="flex items-center">
                  <Search className="w-3 h-3 mr-1" />
                  <span>Searching: "{searchQuery}"</span>
                </div>
                <span className="ml-auto">
                  {filteredSuggestions.length === 0 
                    ? 'No matches' 
                    : `${filteredSuggestions.length} match${filteredSuggestions.length === 1 ? '' : 'es'}`}
                </span>
              </div>
            )}
          </div>
        }
        sections={suggestionSections}
        footerActions={getFooterActions()}
        emptyState={
          <div className="text-sm text-white/50 flex flex-col items-center py-4">
            {searchQuery ? (
              <>
                <Search className="w-8 h-8 text-white/20 mb-2" />
                <p>No suggestions match your search</p>
                <div className="flex space-x-2 mt-4">
                  <Button 
                    variant="outline" 
                    size="sm" 
                    className="text-xs" 
                    onClick={() => setSearchQuery('')}
                  >
                    Clear search
                  </Button>
                </div>
              </>
            ) : (
              <>
                <Brain className="w-8 h-8 text-white/20 mb-2" />
                <p>No suggestions available</p>
              </>
            )}
          </div>
        }
      />
    </DropdownMenu>
  );
}

================
File: src/components/chat/ui/tasks-tab.tsx
================
import { useState } from 'react';
import { Loader2, CheckCircle, XCircle, FolderOpen, Clock, ArrowRight, Search } from 'lucide-react';
import { BaseTab } from '@/components/ui/base-tab';
import {
  DropdownMenu,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';
import { toast } from '@/hooks/use-toast';
import { DropdownList, DropdownSection, DropdownItem, DropdownFooterAction } from '@/components/shared/dropdown-list';

export interface TasksTabProps {
  onClick?: () => void;
}

export function TasksTab({ onClick }: TasksTabProps) {
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [filterStatus, setFilterStatus] = useState<'all' | 'running' | 'completed' | 'failed'>('all');
  
  const handleTaskAction = async (taskId: string, action: 'cancel' | 'retry') => {
    try {
      // Find the task
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      
      switch (action) {
        case 'cancel':
          toast({
            title: 'Task Cancelled',
            description: `"${task.name}" cancelled successfully`,
            variant: 'default',
          });
          break;
        case 'retry':
          toast({
            title: 'Task Retried',
            description: `"${task.name}" retried successfully`,
            variant: 'default',
          });
          break;
      }
    } catch (error) {
      toast({
        title: 'Operation Failed',
        description: `Failed to ${action} task. Please try again.`,
        variant: 'destructive',
      });
    }
  };

  const tasks = [
    {
      id: 'task-1',
      name: 'Code Generation',
      status: 'running',
      progress: 45,
      startTime: new Date(Date.now() - 300000).toISOString()
    },
    {
      id: 'task-2',
      name: 'File Indexing',
      status: 'completed',
      progress: 100,
      startTime: new Date(Date.now() - 600000).toISOString()
    },
    {
      id: 'task-3',
      name: 'Model Download',
      status: 'failed',
      progress: 30,
      startTime: new Date(Date.now() - 900000).toISOString()
    }
  ];
  
  // Filter tasks based on search query and status filter
  const filterTasks = () => {
    let filtered = [...tasks];
    
    // Apply text search filter
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase().trim();
      filtered = filtered.filter(task => 
        task.name.toLowerCase().includes(query) ||
        task.status.toLowerCase().includes(query)
      );
    }
    
    // Apply status filter
    if (filterStatus !== 'all') {
      filtered = filtered.filter(task => task.status === filterStatus);
    }
    
    return filtered;
  };
  
  const filteredTasks = filterTasks();
  
  // Group tasks by status
  const runningTasks = filteredTasks.filter(task => task.status === 'running');
  const completedTasks = filteredTasks.filter(task => task.status === 'completed');
  const failedTasks = filteredTasks.filter(task => task.status === 'failed');
  
  // Build sections for dropdown
  const taskSections: DropdownSection[] = [];
  
  if (runningTasks.length > 0) {
    taskSections.push({
      title: `Running Tasks (${runningTasks.length})`,
      items: runningTasks.map((task): DropdownItem => ({
        id: task.id,
        onSelect: () => {}, // No need to track selection, handled by footer actions
        content: (
          <div className="flex w-full">
            <div className="flex-shrink-0 mr-2.5 mt-0.5">
              <Loader2 className="w-4 h-4 animate-spin text-white/60" />
            </div>
            <div className="flex-1 min-w-0">
              <div className="flex items-center justify-between mb-0.5">
                <span className="text-sm font-medium text-white/90 truncate">{task.name}</span>
                <span className="text-xs bg-blue-500/20 text-blue-300 px-1.5 py-0.5 rounded-full">
                  Running
                </span>
              </div>
              <div className="flex justify-between items-center mt-1.5">
                <div className="w-full max-w-[140px] h-1.5 bg-white/10 rounded-full overflow-hidden">
                  <div 
                    className="h-full rounded-full bg-blue-500"
                    style={{ width: `${task.progress}%` }}
                  />
                </div>
                <span className="text-xs text-white/60 ml-2">{task.progress}%</span>
              </div>
              <div className="flex mt-1.5">
                <span className="text-xs text-white/50">
                  <Clock className="w-3 h-3 inline mr-1 align-text-bottom" />
                  Started {new Date(task.startTime).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                </span>
              </div>
            </div>
          </div>
        )
      }))
    });
  }
  
  if (completedTasks.length > 0) {
    taskSections.push({
      title: `Completed Tasks (${completedTasks.length})`,
      items: completedTasks.map((task): DropdownItem => ({
        id: task.id,
        onSelect: () => {}, // No need to track selection, handled by footer actions
        content: (
          <div className="flex w-full">
            <div className="flex-shrink-0 mr-2.5 mt-0.5">
              <CheckCircle className="w-4 h-4 text-green-500" />
            </div>
            <div className="flex-1 min-w-0">
              <div className="flex items-center justify-between mb-0.5">
                <span className="text-sm font-medium text-white/90 truncate">{task.name}</span>
                <span className="text-xs bg-green-500/20 text-green-300 px-1.5 py-0.5 rounded-full">
                  Completed
                </span>
              </div>
              <div className="flex justify-between items-center mt-1.5">
                <div className="w-full max-w-[140px] h-1.5 bg-white/10 rounded-full overflow-hidden">
                  <div 
                    className="h-full rounded-full bg-green-500"
                    style={{ width: `${task.progress}%` }}
                  />
                </div>
                <span className="text-xs text-white/60 ml-2">{task.progress}%</span>
              </div>
              <div className="flex mt-1.5">
                <span className="text-xs text-white/50">
                  <Clock className="w-3 h-3 inline mr-1 align-text-bottom" />
                  Finished {new Date(task.startTime).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                </span>
              </div>
            </div>
          </div>
        )
      }))
    });
  }
  
  if (failedTasks.length > 0) {
    taskSections.push({
      title: `Failed Tasks (${failedTasks.length})`,
      items: failedTasks.map((task): DropdownItem => ({
        id: task.id,
        onSelect: () => {}, // No need to track selection, handled by footer actions
        content: (
          <div className="flex w-full">
            <div className="flex-shrink-0 mr-2.5 mt-0.5">
              <XCircle className="w-4 h-4 text-red-500" />
            </div>
            <div className="flex-1 min-w-0">
              <div className="flex items-center justify-between mb-0.5">
                <span className="text-sm font-medium text-white/90 truncate">{task.name}</span>
                <span className="text-xs bg-red-500/20 text-red-300 px-1.5 py-0.5 rounded-full">
                  Failed
                </span>
              </div>
              <div className="flex justify-between items-center mt-1.5">
                <div className="w-full max-w-[140px] h-1.5 bg-white/10 rounded-full overflow-hidden">
                  <div 
                    className="h-full rounded-full bg-red-500"
                    style={{ width: `${task.progress}%` }}
                  />
                </div>
                <span className="text-xs text-white/60 ml-2">{task.progress}%</span>
              </div>
              <div className="flex mt-1.5">
                <span className="text-xs text-white/50">
                  <Clock className="w-3 h-3 inline mr-1 align-text-bottom" />
                  Failed at {new Date(task.startTime).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                </span>
              </div>
            </div>
          </div>
        )
      }))
    });
  }

  // Define footer actions based on task status
  const getFooterActions = (): DropdownFooterAction[] => {
    return [
      {
        icon: <XCircle className="w-3.5 h-3.5" />,
        label: "Cancel task",
        onClick: (taskId: string) => {
          handleTaskAction(taskId, 'cancel');
        },
        variant: 'destructive',
        shouldShow: (taskId: string) => {
          const task = tasks.find(t => t.id === taskId);
          return task?.status === 'running';
        }
      },
      {
        icon: <ArrowRight className="w-3.5 h-3.5" />,
        label: "Retry task",
        onClick: (taskId: string) => {
          handleTaskAction(taskId, 'retry');
        },
        shouldShow: (taskId: string) => {
          const task = tasks.find(t => t.id === taskId);
          return task?.status === 'failed';
        }
      }
    ];
  };
  
  // Calculate filter summary for display
  const getFilterSummary = () => {
    if (filterStatus === 'all' && !searchQuery) return null;
    
    const parts = [];
    if (filterStatus !== 'all') {
      parts.push(filterStatus === 'running' ? 'Running tasks' : 
                filterStatus === 'completed' ? 'Completed tasks' : 'Failed tasks');
    }
    
    if (searchQuery) {
      parts.push(`"${searchQuery}"`);
    }
    
    return parts.join(' with ');
  };
  
  const filterSummary = getFilterSummary();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="p-0 h-auto hover:bg-white/[0.05] rounded-sm transition-all duration-200 group w-full"
          aria-label="Tasks menu"
        >
          <BaseTab
            icon={
              <div className="flex items-center justify-center w-5 h-5 group-hover:scale-110 transition-transform duration-300">
                <Loader2 className={`w-3 h-3 ${runningTasks.length > 0 ? 'animate-spin text-blue-400' : 'text-white/60'}`} />
              </div>
            }
            label="Tasks"
            shortcut="T"
            className="w-full"
          />
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownList 
        headerContent={
          <div className="px-2 pt-1.5 pb-2">
            {/* Search input */}
            <div className="relative">
              <div className="absolute inset-y-0 left-2.5 flex items-center pointer-events-none">
                <Search className="h-3.5 w-3.5 text-white/40" />
              </div>
              <input
                type="text"
                placeholder="Search tasks..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full bg-white/[0.05] rounded-md py-1.5 pl-8 pr-3 text-sm text-white/80 placeholder:text-white/40 focus:outline-none focus:ring-1 focus:ring-white/20 focus:bg-white/[0.07]"
                aria-label="Search tasks"
                autoFocus
              />
              {searchQuery && (
                <button
                  onClick={() => setSearchQuery('')}
                  className="absolute inset-y-0 right-2 flex items-center text-white/40 hover:text-white/60"
                >
                  <span className="sr-only">Clear search</span>
                  <XCircle className="h-3.5 w-3.5" />
                </button>
              )}
            </div>
            
            {/* Filters */}
            <div className="mt-2.5 flex space-x-1.5">
              <button
                onClick={() => setFilterStatus('all')}
                className={`px-2 py-1 text-xs rounded-md flex items-center gap-1 flex-1 justify-center transition-all ${
                  filterStatus === 'all' 
                    ? 'bg-white/10 text-white/90' 
                    : 'bg-white/[0.03] hover:bg-white/[0.05] text-white/60'
                }`}
              >
                <Loader2 className="w-2.5 h-2.5" />
                All
              </button>
              <button
                onClick={() => setFilterStatus('running')}
                className={`px-2 py-1 text-xs rounded-md flex items-center gap-1 flex-1 justify-center transition-all ${
                  filterStatus === 'running' 
                    ? 'bg-white/10 text-white/90' 
                    : 'bg-white/[0.03] hover:bg-white/[0.05] text-white/60'
                }`}
              >
                <Loader2 className="w-2.5 h-2.5 text-blue-400" />
                Running
              </button>
              <button
                onClick={() => setFilterStatus('completed')}
                className={`px-2 py-1 text-xs rounded-md flex items-center gap-1 flex-1 justify-center transition-all ${
                  filterStatus === 'completed' 
                    ? 'bg-white/10 text-white/90' 
                    : 'bg-white/[0.03] hover:bg-white/[0.05] text-white/60'
                }`}
              >
                <CheckCircle className="w-2.5 h-2.5 text-green-400" />
                Done
              </button>
              <button
                onClick={() => setFilterStatus('failed')}
                className={`px-2 py-1 text-xs rounded-md flex items-center gap-1 flex-1 justify-center transition-all ${
                  filterStatus === 'failed' 
                    ? 'bg-white/10 text-white/90' 
                    : 'bg-white/[0.03] hover:bg-white/[0.05] text-white/60'
                }`}
              >
                <XCircle className="w-2.5 h-2.5 text-red-400" />
                Failed
              </button>
            </div>
            
            {/* Filter summary */}
            {(filterStatus !== 'all' || searchQuery) && (
              <div className="flex justify-between items-center text-xs text-white/50 mt-2 px-1">
                {filterSummary && (
                  <div className="flex items-center">
                    <Search className="w-3 h-3 mr-1" />
                    <span>Filtering: {filterSummary}</span>
                  </div>
                )}
                <span className="ml-auto">
                  {filteredTasks.length === 0 
                    ? 'No matches' 
                    : `${filteredTasks.length} match${filteredTasks.length === 1 ? '' : 'es'}`}
                </span>
              </div>
            )}
          </div>
        }
        sections={taskSections}
        footerActions={getFooterActions()}
        emptyState={
          <div className="text-sm text-white/50 flex flex-col items-center py-4">
            {searchQuery || filterStatus !== 'all' ? (
              <>
                <Search className="w-8 h-8 text-white/20 mb-2" />
                <p>No tasks match your filters</p>
                <div className="flex space-x-2 mt-4">
                  {searchQuery && (
                    <Button 
                      variant="outline" 
                      size="sm" 
                      className="text-xs" 
                      onClick={() => setSearchQuery('')}
                    >
                      Clear search
                    </Button>
                  )}
                  {filterStatus !== 'all' && (
                    <Button 
                      variant="outline" 
                      size="sm" 
                      className="text-xs" 
                      onClick={() => setFilterStatus('all')}
                    >
                      Clear filters
                    </Button>
                  )}
                </div>
              </>
            ) : (
              <>
                <CheckCircle className="w-8 h-8 text-white/20 mb-2" />
                <p>No active tasks</p>
              </>
            )}
          </div>
        }
      />
    </DropdownMenu>
  );
}

================
File: src/components/chat/ui/user-profile-dropdown.tsx
================
import { User } from '@supabase/supabase-js';
import { useAuth } from '@/hooks/use-auth';
import { Button } from '@/components/ui/button';
import { useState, useRef, useEffect } from 'react';

interface UserProfileDropdownProps {
  user: User;
}

export function UserProfileDropdown({ user }: UserProfileDropdownProps) {
  const { signOut } = useAuth();
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const initials = user.user_metadata.full_name
    ?.split(' ')
    .map((name: string) => name[0])
    .join('') || user.email?.[0] || '?';

  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    }

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <div className="relative" ref={dropdownRef}>
      <Button
        variant="ghost"
        className="h-8 w-8 rounded-full p-0 overflow-hidden"
        onClick={() => setIsOpen(!isOpen)}
      >
        <div className="w-full h-full bg-white/5">
          {user.user_metadata.avatar_url ? (
            <img
              src={user.user_metadata.avatar_url}
              alt={initials}
              className="w-full h-full object-cover"
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center text-sm font-medium">
              {initials}
            </div>
          )}
        </div>
      </Button>
      {isOpen && (
        <div className="absolute right-0 mt-2 w-56 bg-white/5 backdrop-blur-xl border border-white/[0.08] rounded-lg shadow-lg">
          <div className="px-4 py-3">
            <p className="text-sm font-medium">{user.user_metadata.full_name}</p>
            <p className="text-xs text-gray-400">{user.email}</p>
          </div>
          <div className="border-t border-white/[0.08]">
            <Button
              variant="ghost"
              className="w-full justify-start rounded-none px-4 py-2 text-sm text-red-500 hover:text-red-400"
              onClick={() => {
                signOut();
                setIsOpen(false);
              }}
            >
              Sign out
            </Button>
          </div>
        </div>
      )}
    </div>
  );
}

================
File: src/components/chat/chat-container.tsx
================
import { cn } from "@/lib/utils/utils"
import { useEffect, useRef, useState, useCallback } from "react"
import React from "react"

const useAutoScroll = (
  containerRef: React.RefObject<HTMLDivElement | null>,
  enabled: boolean
) => {
  const [autoScrollEnabled, setAutoScrollEnabled] = useState(true)
  const lastScrollTopRef = useRef(0)
  const autoScrollingRef = useRef(false)
  const userScrollingRef = useRef(false)
  const [newMessageAdded, setNewMessageAdded] = useState(false)
  const prevChildrenCountRef = useRef(0)
  const scrollTriggeredRef = useRef(false)
  const scrollTimeout = useRef<NodeJS.Timeout | null>(null)

  // Increased the threshold to prevent flickering when content expands
  const isAtBottom = useCallback((element: HTMLDivElement) => {
    const { scrollTop, scrollHeight, clientHeight } = element
    return scrollHeight - scrollTop - clientHeight <= 100
  }, [])

  const scrollToBottom = useCallback((behavior: ScrollBehavior = "smooth") => {
    const container = containerRef.current
    if (!container) return
    
    // If user is actively scrolling up, don't interrupt
    if (userScrollingRef.current && !isAtBottom(container)) {
      return
    }

    autoScrollingRef.current = true
    scrollTriggeredRef.current = true
    
    const targetScrollTop = container.scrollHeight - container.clientHeight

    container.scrollTo({
      top: targetScrollTop,
      behavior: behavior
    })

    // Use a single reliable cleanup mechanism with improved timing
    if (scrollTimeout.current) {
      clearTimeout(scrollTimeout.current)
    }
    
    scrollTimeout.current = setTimeout(() => {
      autoScrollingRef.current = false
      scrollTriggeredRef.current = false
      scrollTimeout.current = null
    }, 300)
  }, [containerRef, isAtBottom])

  useEffect(() => {
    if (!enabled) return

    const container = containerRef?.current
    if (!container) return

    lastScrollTopRef.current = container.scrollTop

    const handleScroll = () => {
      if (autoScrollingRef.current) return

      const currentScrollTop = container.scrollTop
      const wasAtBottom = isAtBottom(container)
      
      // Only disable auto-scroll if user is actually scrolling up
      if (currentScrollTop < lastScrollTopRef.current && 
          autoScrollEnabled && 
          Math.abs(currentScrollTop - lastScrollTopRef.current) > 10) {
        setAutoScrollEnabled(false)
        userScrollingRef.current = true
        
        // Reset user scrolling state after a short delay
        if (scrollTimeout.current) {
          clearTimeout(scrollTimeout.current)
        }
        
        scrollTimeout.current = setTimeout(() => {
          userScrollingRef.current = false
          scrollTimeout.current = null
        }, 300)
      }

      // Re-enable auto-scroll if user scrolls back to bottom
      if (wasAtBottom && !autoScrollEnabled) {
        setAutoScrollEnabled(true)
      }

      lastScrollTopRef.current = currentScrollTop
    }

    const handleWheel = (e: WheelEvent) => {
      // Mark that user is actively scrolling if scrolling up
      if (e.deltaY < 0) {
        userScrollingRef.current = true
        
        // Reset user scrolling after a delay
        if (scrollTimeout.current) {
          clearTimeout(scrollTimeout.current)
        }
        
        scrollTimeout.current = setTimeout(() => {
          userScrollingRef.current = false
          scrollTimeout.current = null
        }, 300)
        
        if (autoScrollEnabled) {
          setAutoScrollEnabled(false)
        }
      }
    }

    const handleTouchStart = () => {
      lastScrollTopRef.current = container.scrollTop
    }

    const handleTouchMove = () => {
      if (container.scrollTop < lastScrollTopRef.current && 
          autoScrollEnabled && 
          Math.abs(container.scrollTop - lastScrollTopRef.current) > 10) {
        setAutoScrollEnabled(false)
        userScrollingRef.current = true
      }

      lastScrollTopRef.current = container.scrollTop
    }

    const handleTouchEnd = () => {
      // Reset user scrolling state after touch ends
      setTimeout(() => {
        userScrollingRef.current = false
      }, 300)
      
      if (isAtBottom(container) && !autoScrollEnabled) {
        setAutoScrollEnabled(true)
      }
    }

    container.addEventListener("scroll", handleScroll, { passive: true })
    container.addEventListener("wheel", handleWheel, { passive: true })
    container.addEventListener("touchstart", handleTouchStart, {
      passive: true,
    })
    container.addEventListener("touchmove", handleTouchMove, { passive: true })
    container.addEventListener("touchend", handleTouchEnd, { passive: true })

    return () => {
      container.removeEventListener("scroll", handleScroll)
      container.removeEventListener("wheel", handleWheel)
      container.removeEventListener("touchstart", handleTouchStart)
      container.removeEventListener("touchmove", handleTouchMove)
      container.removeEventListener("touchend", handleTouchEnd)
      
      if (scrollTimeout.current) {
        clearTimeout(scrollTimeout.current)
      }
    }
  }, [containerRef, enabled, autoScrollEnabled, isAtBottom])

  return {
    autoScrollEnabled,
    scrollToBottom,
    isScrolling: autoScrollingRef.current,
    scrollTriggered: scrollTriggeredRef.current,
    userScrolling: userScrollingRef.current,
    newMessageAdded,
    setNewMessageAdded,
    prevChildrenCountRef,
  }
}

export type ChatContainerProps = {
  children: React.ReactNode
  className?: string
  autoScroll?: boolean
  scrollToRef?: React.RefObject<HTMLDivElement | null>
  ref?: React.RefObject<HTMLDivElement | null>
} & React.HTMLAttributes<HTMLDivElement>

function ChatContainer({
  className,
  children,
  autoScroll = true,
  scrollToRef,
  ref,
  ...props
}: ChatContainerProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const localBottomRef = useRef<HTMLDivElement>(null)
  const bottomRef = scrollToRef || localBottomRef
  const chatContainerRef = ref || containerRef
  const prevChildrenRef = useRef<React.ReactNode>(null)
  const contentChangedWithoutNewMessageRef = useRef(false)

  const { 
    autoScrollEnabled, 
    scrollToBottom, 
    isScrolling,
    scrollTriggered,
    newMessageAdded,
    setNewMessageAdded,
    prevChildrenCountRef
  } = useAutoScroll(
    chatContainerRef,
    autoScroll
  )

  // Improved content change detection
  useEffect(() => {
    const childrenArray = React.Children.toArray(children)
    const currentChildrenCount = childrenArray.length
    
    // Check if content is changing due to streaming or new message
    const isContentChange = prevChildrenRef.current !== children
    
    // New message detection
    if (currentChildrenCount > prevChildrenCountRef.current) {
      setNewMessageAdded(true)
    } 
    // Content update detection (like streaming) 
    else if (isContentChange) {
      contentChangedWithoutNewMessageRef.current = true
    }
    
    prevChildrenCountRef.current = currentChildrenCount
    prevChildrenRef.current = children
  }, [children, setNewMessageAdded])

  // Improved scroll behavior with more specific conditions
  useEffect(() => {
    if (!autoScroll) return
    
    const container = chatContainerRef.current
    if (!container) return
    
    // Handler for deciding when to auto-scroll
    const scrollHandler = () => {
      // Case 1: New message arrived - scroll to bottom if auto-scroll is enabled
      if (newMessageAdded && autoScrollEnabled) {
        scrollToBottom("smooth")
        setNewMessageAdded(false)
        contentChangedWithoutNewMessageRef.current = false
        return
      }
      
      // Case 2: Content is streaming or changing for existing message
      if (contentChangedWithoutNewMessageRef.current) {
        // Only auto-scroll if:
        // 1. Auto-scroll is enabled (user is at bottom)
        // 2. Not currently in manual scroll animation
        // 3. User isn't actively scrolling up
        if (autoScrollEnabled && !isScrolling && !scrollTriggered) {
          scrollToBottom("smooth")
        }
        contentChangedWithoutNewMessageRef.current = false
      }
    }
    
    // Use requestAnimationFrame for smooth performance
    requestAnimationFrame(scrollHandler)
    
  }, [
    children, 
    autoScroll, 
    autoScrollEnabled, 
    isScrolling,
    scrollTriggered,
    scrollToBottom, 
    newMessageAdded, 
    setNewMessageAdded
  ])

  return (
    <div
      className={cn("flex flex-col overflow-y-auto", className)}
      role="log"
      ref={chatContainerRef}
      {...props}
    >
      {children}
      <div
        ref={bottomRef}
        className="h-[1px] w-full shrink-0 scroll-mt-4"
        aria-hidden="true"
      />
    </div>
  )
}

export { ChatContainer, useAutoScroll }

================
File: src/components/chat/chat-content-client.tsx
================
import { useChat } from '@ai-sdk/react';
import { useCallback, useEffect, useRef, useState, useMemo } from 'react';

import { ArrowDown, Search } from 'lucide-react';
import { useSpaces } from '@/hooks/use-spaces';
import { useConversations } from '@/hooks/use-conversations';
import { UnifiedInput } from './unified-input';
import { ChatMessages } from './chat-messages';
import { UserProfileDropdown } from '@/components/auth/user-profile-dropdown';
import { SpaceTab } from '@/components/chat/ui/space-tab';
import { ModelTab } from '@/components/chat/ui/model-tab';
import { ChatModeTab } from '@/components/chat/ui/chat-mode-tab';
import { ActionsTab } from '@/components/chat/ui/actions-tab';
import { TasksTab } from '@/components/chat/ui/tasks-tab';
import { SuggestionsTab } from '@/components/chat/ui/suggestions-tab';
import { MessagesTab } from '@/components/chat/ui/messages-tab';
import { useRendererStore } from '@/store/renderer';
import { API_BASE_URL } from '@/config/api';
import { useCommandWindow } from '@/hooks/use-command-window';
import { ConversationTab } from '@/components/chat/ui/conversation-tab';
import { BaseTab } from '@/components/ui/base-tab';
import { toast } from '@/hooks/use-toast';
import { Conversation } from '@/types/conversation';

export default function ChatContent() {
  const { user, messages: messagesFromStore } = useRendererStore();
  const { activeSpace, isLoading: isSpaceLoading } = useSpaces();
  const { 
    activeConversation, 
    setActiveConversation,
    createConversation 
  } = useConversations();
  const { handleCommandWindowToggle } = useCommandWindow();

  const [searchMode, setSearchMode] = useState<'chat' | 'search' | 'semantic' | 'hybrid'>('chat');
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  const [fileReferences, setFileReferences] = useState<any[]>([]);
  const [isStickToBottom, setIsStickToBottom] = useState(true);

  const clearFileReferences = () => setFileReferences([]);
  const fileReferencesMap = useMemo(() => {
    const fileMap: Record<string, any> = {};
    fileReferences.forEach(fileRef => {
      fileMap[fileRef.id] = {
        id: fileRef.id,
        path: fileRef.path,
        name: fileRef.name,
        content: fileRef.content,
        type: fileRef.type
      };
    });
    return fileMap;
  }, [fileReferences]);

  const initialMessages = useMemo(() => messagesFromStore || [], [messagesFromStore]);

  const chatKey = `${activeConversation?.id || 'default'}-${activeSpace?.provider || ''}-${activeSpace?.model || ''}`;
  
  async function getHeaders() {
    const response = await window.electron.getAuthToken();
    console.log('Get auth token response:', response);
    if (!response.success || !response.data) {
      throw new Error('Failed to get access token');
    }
    return {
      Authorization: `Bearer ${response.data.accessToken}`,
    };
  }

  const customFetch: typeof fetch = async (input: RequestInfo | URL, init?: RequestInit) => {
    console.log('Custom fetch called with URL:', input);
    console.log('Custom fetch called with init:', init);
    const headers = await getHeaders(); 

    console.log('Headers:', headers);

    const url = typeof input === 'string' ? input : input.toString();

    const updatedOptions: RequestInit = {
      ...init,
      headers: {
        ...(init?.headers || {}),
        ...headers,
      },
    };

    console.log('Custom fetch called with updated URL:', url);

    return fetch(url, updatedOptions); 
  };

  const chatConfig = useMemo(() => ({
    id: chatKey,
    api: `${API_BASE_URL}/api/chat`,
    initialMessages,
    fetch: customFetch,
    body: {
      spaceId: activeSpace?.id || '',
      conversationId: activeConversation?.id || null,
      provider: activeSpace?.provider || '',
      model: activeSpace?.model || '',
      searchMode,
      chatMode: activeSpace?.chat_mode || 'ask',
      chatModeConfig: activeSpace?.chat_mode_config || { tools: [] },
      files: fileReferencesMap,
    },
    onFinish() {
      setData([]);
      clearFileReferences();
    },
  }), [
    chatKey,
    initialMessages,
    customFetch,
    activeSpace?.id,
    activeConversation?.id,
    activeSpace?.provider,
    activeSpace?.model,
    searchMode,
    activeSpace?.chat_mode,
    activeSpace?.chat_mode_config,
    fileReferencesMap,
  ]);

  const {
    messages,
    input,
    status,
    handleInputChange,
    handleSubmit,
    data,
    setData,
  } = useChat(chatConfig);

  const handleStickToBottomChange = useCallback((isAtBottom: boolean) => {
    setIsStickToBottom(isAtBottom);
  }, []);

  const scrollToBottomHandler = useRef<() => void>(() => {
    messagesContainerRef.current?.scrollTo({
      top: messagesContainerRef.current.scrollHeight,
      behavior: 'smooth',
    });
  });

  const handleScrollToBottom = useCallback((callback: () => void) => {
    scrollToBottomHandler.current = callback;
  }, []);

  const handleCreateConversation = async (title: string = 'New Conversation') => {
    if (!activeSpace?.id) {
      toast({
        title: 'Error',
        description: 'Please select a space first',
        variant: 'destructive',
      });
      return;
    }

    try {
      await createConversation(activeSpace.id, title);
    } catch (error) {
      console.error('Error creating conversation:', error);
      toast({
        title: 'Error',
        description: 'Failed to create conversation',
        variant: 'destructive',
      });
    }
  };

  const handleSelectConversation = async (conversation: Conversation) => {
    try {
      await setActiveConversation(conversation);
    } catch (error) {
      console.error('Error selecting conversation:', error);
      toast({
        title: 'Error',
        description: 'Failed to select conversation',
        variant: 'destructive',
      });
    }
  };

  return (
    <div className="h-full w-full">
      <div className="fixed top-4 right-4 z-50">
        {user && <UserProfileDropdown user={user} />}
      </div>
      <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50">
        <div
          className="relative p-1 rounded-full command-glass-effect">
          <div className="flex items-center divide-x divide-white/[0.08]">
            <div className="px-1 first:pl-1 last:pr-1">
              <SpaceTab activeSpace={activeSpace} />
            </div>
            <div className="px-1 first:pl-1 last:pr-1">
              <ModelTab space={activeSpace} />
            </div>
            <div className="px-1 first:pl-1 last:pr-1">
              <ChatModeTab space={activeSpace} />
            </div>
            {!isStickToBottom && messages.length > 0 && (
              <div className="px-1 first:pl-1 last:pr-1">
                <BaseTab
                  icon={<ArrowDown className="w-3 h-3" />}
                  label="Scroll to Bottom"
                  onClick={() => {
                    scrollToBottomHandler.current();
                  }}
                />
              </div>
            )}
          </div>
        </div>
      </div>
      <div className="flex-1 w-full h-full flex flex-col">
        <ChatMessages
          messages={messages}
          onStickToBottomChange={handleStickToBottomChange}
          onScrollToBottom={handleScrollToBottom}
          ref={messagesContainerRef}
          isLoading={status !== 'ready' || isSpaceLoading}
          streamData={data}
        />
        <div className="fixed left-1/2 bottom-8 -translate-x-1/2 w-[800px] z-50">
          <div className="relative w-full">
            <UnifiedInput
              value={input}
              onChange={handleInputChange}
              onSubmit={handleSubmit}
              disabled={!activeSpace || !activeConversation || status !== 'ready'}
              externalFileReferences={fileReferences}
              onFileReferencesChange={setFileReferences}
            >
              <div className="flex items-center divide-x divide-white/[0.05]">
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5 min-w-0 max-w-1/5 flex-shrink-0">
                  <ActionsTab onCreateConversation={handleCreateConversation} />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5 min-w-0 max-w-1/5 flex-shrink-0">
                  <MessagesTab
                    messages={messages.filter(m => m.role === 'user' || m.role === 'assistant').map(m => ({
                      id: m.id || '',
                      content: typeof m.content === 'string' ? m.content : '',
                      role: m.role as 'user' | 'assistant',
                      timestamp: m.createdAt ? new Date(m.createdAt) : new Date(),
                      annotations: m.annotations || []
                    }))}
                    conversationId={activeConversation?.id}
                    conversationName={activeConversation?.title}
                    spaceId={activeSpace?.id}
                    spaceName={activeSpace?.name}
                    onCommandWindowToggle={(mode) => handleCommandWindowToggle(mode as any)}
                    onMessageSearch={(query, searchScope) => {
                      if (searchScope === 'space') {
                        toast({
                          title: "Space Search",
                          description: `Searching entire space for "${query}"`,
                          variant: "default",
                        });
                      } else {
                        handleCommandWindowToggle('messageSearch');
                      }
                    }}
                  />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5 min-w-0 max-w-1/5 flex-shrink-0">
                  <TasksTab />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5 min-w-0 max-w-1/5 flex-shrink-0">
                  <SuggestionsTab />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5 min-w-0 max-w-1/5 flex-shrink-0">
                  <ConversationTab
                    onCreateConversation={handleCreateConversation}
                    onSelectConversation={handleSelectConversation}
                    activeConversation={activeConversation}
                  />
                </div>
              </div>
            </UnifiedInput>
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/chat/chat-message.tsx
================
import { User, MessageSquareIcon, Sparkles, FileText, File } from 'lucide-react';
import { memo, useMemo } from 'react';
import { ProviderIcon } from './provider-icon';
import { JSONValue } from 'ai';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { StreamStatus } from './stream-status';
import { Markdown } from './markdown';
import { Message, MessageAnnotation, SimilarMessage } from '@/types/message';
import { Provider } from '@/types/provider';
import DotSphere from '../space/planet-icon';
import { ModelDisplay } from '@/components/shared/model-display';
import { getModelDisplayInfo } from '@/utils/model-utils';

interface ChatMessageProps {
  message: Message;
  userAvatarUrl?: string;
  isLoading?: boolean;
  streamData?: JSONValue[];
  spaceId?: string;
}

const UserMessageWithMentions = memo(({ id, content }: { id: string, content: string }) => {
  const processedContent = useMemo(() => {
    const fileTagRegex = /@\[(.*?)\]\((.*?)\)/g;
    if (!fileTagRegex.test(content)) return <span>{content}</span>;
    
    const parts: React.ReactNode[] = [];
    let lastIndex = 0;
    let key = 0;
    let match;
    
    fileTagRegex.lastIndex = 0;
    while ((match = fileTagRegex.exec(content)) !== null) {
      const [fullMatch, fileName, filePath] = match;
      if (match.index > lastIndex) {
        parts.push(<span key={`text-${key++}`}>{content.substring(lastIndex, match.index)}</span>);
      }
      parts.push(
        <span key={`file-${key++}`} className="inline-flex items-center gap-1 px-1.5 py-0.5 mr-1 rounded bg-cyan-500/20 text-xs text-cyan-300" title={filePath}>
          <File className="h-3 w-3" />
          <span className="truncate max-w-[150px]">{fileName}</span>
        </span>
      );
      lastIndex = match.index + fullMatch.length;
    }
    if (lastIndex < content.length) {
      parts.push(<span key={`text-${key++}`}>{content.substring(lastIndex)}</span>);
    }
    return <>{parts}</>;
  }, [content]);
  
  return <div id={id}>{processedContent}</div>;
});

const UserAvatar = ({ avatarUrl }: { avatarUrl?: string }) => (
  <Avatar className="h-10 w-10 border bg-white/[0.03] border-white/[0.1]">
    <AvatarImage src={avatarUrl || ""} />
    <AvatarFallback className="bg-white/[0.03]">
      <User className="h-5 w-5 text-white/80" />
    </AvatarFallback>
  </Avatar>
);

const AIAvatar = ({ spaceId }: { spaceId?: string }) => (
  <div className="relative">
    <div className="relative h-12 w-12 flex items-center justify-center">
      <DotSphere size={40} seed={spaceId || "default-space"} dotCount={80} dotSize={0.9} expandFactor={1.15} transitionSpeed={400} highPerformance={true} />
    </div>
  </div>
);

const ModelInfo = ({ provider, modelName, similarMessages, chatMode }: { 
  provider?: Provider; 
  modelName: string;
  similarMessages?: SimilarMessage[];
  chatMode?: string;
}) => {
  const ModeModeIcon = Sparkles;
  const similarMessagesCount = similarMessages?.length ?? 0;
  const modelInfo = getModelDisplayInfo(modelName);
  
  return (
    <div className="flex items-center gap-1.5 mb-2.5 flex-wrap">
      {modelInfo && <ModelDisplay modelInfo={modelInfo} showIcon={true} />}
      {chatMode && (
        <div className="px-2.5 py-0.5 rounded bg-cyan-500/10 border border-cyan-500/20 text-cyan-300 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit">
          <ModeModeIcon size={11} />
          <span>{chatMode}</span>
        </div>
      )}
      {similarMessagesCount > 0 && similarMessages && (
        <button 
          onClick={() => {
            const win = window as any;
            if (win.openSimilarMessages) {
              win.openSimilarMessages(similarMessages);
            }
          }} 
          className="px-2.5 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-linear-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10 hover:bg-white/[0.07] transition-colors"
        >
          <MessageSquareIcon size={11} className="text-cyan-400/80" />
          <span>{similarMessagesCount} similar</span>
        </button>
      )}
    </div>
  );
};

export const ChatMessage = memo<ChatMessageProps>(({ message, userAvatarUrl, isLoading, streamData, spaceId }) => {
  const isUser = message.role === 'user';
  const isStreamingAssistant = !isUser && ((isLoading && message.content.length <= 0) || message.id === 'placeholder-assistant');

  const modelAnnotation = message.annotations?.[0] as MessageAnnotation | undefined;
  const provider = modelAnnotation?.provider;
  const modelUsed = modelAnnotation?.model_used;
  const chatMode = modelAnnotation?.chat_mode;
  const similarMessages = modelAnnotation?.similarMessages;
  const modelName = modelUsed || 'AI';

  return (
    <div className={`flex items-start gap-5 w-full mx-auto group transition-opacity ${isUser ? 'flex-row-reverse' : ''}`}>
      <div className={`shrink-0 ${isUser ? '' : 'mt-1'}`}>
        {isUser ? <UserAvatar avatarUrl={userAvatarUrl} /> : <AIAvatar spaceId={spaceId} />}
      </div>
      <div className="space-y-2 overflow-hidden max-w-[85%]">
        <div className="prose prose-invert max-w-none w-full">
          {!isUser && message.annotations && message.annotations.length > 0 && (
            <ModelInfo
              provider={provider}
              modelName={modelName}
              similarMessages={similarMessages}
              chatMode={chatMode}
            />
          )}
          {isUser ? (
            <div className="text-sm leading-relaxed whitespace-pre-wrap break-words text-white shadow-[0_0_15px_-5px_rgba(255,255,255,0.3)]">
              <UserMessageWithMentions id={`user-${message.id}`} content={message.content} />
            </div>
          ) : isStreamingAssistant ? (
            <div className="transition-all duration-500 ease-in-out will-change-transform">
              <div className="animate-appear transform-gpu transition-all duration-500 ease-out">
                <StreamStatus streamData={streamData} />
              </div>
            </div>
          ) : (
            <div className="prose prose-invert prose-zinc max-w-none">
              <Markdown id={message.id}>{message.content}</Markdown>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}, (prevProps, nextProps) => {
  if (prevProps.message.id !== nextProps.message.id) return false;
  if (prevProps.message.role !== nextProps.message.role) return false;
  if (prevProps.message.role === 'user') return prevProps.message.content === nextProps.message.content;
  
  const isStreamingPrev = prevProps.isLoading && (prevProps.message.id === 'placeholder-assistant' || prevProps.message.content.length === 0);
  const isStreamingNext = nextProps.isLoading && (nextProps.message.id === 'placeholder-assistant' || nextProps.message.content.length === 0);
  
  if (isStreamingPrev !== isStreamingNext) return false;
  
  if (isStreamingNext && prevProps.streamData && nextProps.streamData) {
    const prevLength = prevProps.streamData.length;
    const nextLength = nextProps.streamData.length;
    return nextLength <= prevLength || (nextLength - prevLength < 5);
  }
  
  return prevProps.message.content === nextProps.message.content;
});

ChatMessage.displayName = 'ChatMessage';

================
File: src/components/chat/chat-messages.tsx
================
import { ChatContainer, useAutoScroll } from '@/components/chat/chat-container';
import { useEffect, forwardRef, useRef, memo, useMemo } from 'react';
import { ChatMessage } from './chat-message';
import { JSONValue, Message } from 'ai';

interface ChatMessagesProps {
  messages: Message[];
  onStickToBottomChange?: (isStickToBottom: boolean) => void;
  onScrollToBottom?: (callback: () => void) => void;
  isLoading?: boolean;
  streamData?: JSONValue[] | undefined;
  spaceId?: string;
}

const MemoizedMessage = memo(({ 
  message, 
  index, 
  isLoading, 
  streamData, 
  messagesLength, 
  nextMessageRole, 
  shouldAddSeparator,
  spaceId 
}: { 
  message: Message; 
  index: number; 
  isLoading: boolean; 
  streamData?: JSONValue[];
  messagesLength: number;
  nextMessageRole?: string;
  shouldAddSeparator: boolean;
  spaceId?: string;
}) => {
  const messageRef = useRef<HTMLDivElement>(null);

  return (
    <>
      <div 
        key={message.id} 
        ref={messageRef}
        className="transition-all"
      >
        <ChatMessage 
          message={message} 
          isLoading={isLoading}
          streamData={streamData}
          spaceId={spaceId}
        />
      </div>
      {shouldAddSeparator && (
        <div className="w-full flex justify-center my-8">
          <div className="w-1/3 h-px bg-white/[0.05]" />
        </div>
      )}
    </>
  );
}, (prevProps, nextProps) => {
  if (prevProps.message.id !== nextProps.message.id) return false;
  if (prevProps.message.content !== nextProps.message.content) return false;
  if (prevProps.isLoading !== nextProps.isLoading) return false;
  
  if (prevProps.message.role === 'assistant' && prevProps.isLoading && nextProps.isLoading) {
    const prevStreamLength = prevProps.streamData?.length || 0;
    const nextStreamLength = nextProps.streamData?.length || 0;
    return (nextStreamLength - prevStreamLength < 5);
  }
  
  return true;
});

MemoizedMessage.displayName = 'MemoizedMessage';

const PlaceholderMessage = memo(({ 
  needsSeparator,
  streamData,
  spaceId
}: { 
  needsSeparator: boolean;
  streamData?: JSONValue[];
  spaceId?: string;
}) => {
  return (
    <div key="placeholder-assistant" className="space-y-2">
      {needsSeparator && (
        <div className="w-full flex justify-center my-8">
          <div className="w-1/3 h-px bg-white/[0.05]" />
        </div>
      )}
      <ChatMessage 
        message={{
          id: 'placeholder-assistant',
          role: 'assistant',
          content: '',
        }}
        isLoading={true}
        streamData={streamData || [{ status: 'Processing...' }]}
        spaceId={spaceId}
      />
    </div>
  );
}, (prevProps, nextProps) => {
  const prevStreamLength = prevProps.streamData?.length || 0;
  const nextStreamLength = nextProps.streamData?.length || 0;
  return (nextStreamLength - prevStreamLength < 5);
});

PlaceholderMessage.displayName = 'PlaceholderMessage';

const ChatMessagesComponent = forwardRef<HTMLDivElement, ChatMessagesProps>(
  ({ messages, onStickToBottomChange, onScrollToBottom, isLoading, streamData, spaceId }, ref) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const actualRef = (ref as React.RefObject<HTMLDivElement>) || containerRef;
    const prevMessagesLengthRef = useRef(messages.length);
    
    const { 
      autoScrollEnabled, 
      scrollToBottom 
    } = useAutoScroll(actualRef, true);
    
    useEffect(() => {
      if (onStickToBottomChange) {
        onStickToBottomChange(autoScrollEnabled);
      }
    }, [autoScrollEnabled, onStickToBottomChange]);
    
    useEffect(() => {
      if (onScrollToBottom && scrollToBottom) {
        const handleScrollToBottom = () => scrollToBottom("smooth");
        onScrollToBottom(handleScrollToBottom);
      }
    }, [onScrollToBottom, scrollToBottom]);
    
    useEffect(() => {
      if (prevMessagesLengthRef.current !== messages.length) {
        prevMessagesLengthRef.current = messages.length;
        console.log('[CLIENT] Chat messages count changed:', { 
          count: messages.length
        });
      }
    }, [messages.length]);

    const messageSeparatorMap = useMemo(() => {
      const separators: Record<string, boolean> = {};
      
      messages.forEach((message, index) => {
        if (index < messages.length - 1) {
          separators[message.id] = message.role !== messages[index + 1].role;
        } else {
          separators[message.id] = false;
        }
      });
      
      return separators;
    }, [messages]);

    const needsPlaceholderSeparator = useMemo(() => {
      return messages.length > 1 && 
        messages[messages.length - 1].role !== 'assistant';
    }, [messages]);
    
    const shouldShowPlaceholder = messages.length > 0 && 
      messages[messages.length - 1].role === 'user' && 
      isLoading;

    return (
        <ChatContainer
          ref={actualRef}
          className="absolute inset-0 py-12 px-4 pb-52 h-full"
          autoScroll={true}
        >
          <div className="max-w-[85%] w-full mx-auto">
            <div className="space-y-12">
              {messages.map((message, index) => (
                <MemoizedMessage
                  key={message.id}
                  message={message}
                  index={index}
                  isLoading={isLoading}
                  streamData={index === messages.length - 1 && message.role === 'assistant' ? streamData : undefined}
                  messagesLength={messages.length}
                  nextMessageRole={index < messages.length - 1 ? messages[index + 1].role : undefined}
                  shouldAddSeparator={messageSeparatorMap[message.id]}
                  spaceId={spaceId}
                />
              ))}
              
              {shouldShowPlaceholder && (
                <PlaceholderMessage 
                  needsSeparator={needsPlaceholderSeparator}
                  streamData={streamData}
                  spaceId={spaceId}
                />
              )}
            </div>
          </div>
        </ChatContainer>
    );
  }
);

ChatMessagesComponent.displayName = 'ChatMessagesComponent';
export const ChatMessages = memo(ChatMessagesComponent);
ChatMessages.displayName = 'ChatMessages';

================
File: src/components/chat/file-mention-input.tsx
================
import * as React from "react"
import { Command, File, X } from "lucide-react"
import { CommandList, CommandInput, CommandEmpty, CommandGroup, CommandItem } from "cmdk"

// Mock file data
const mockFiles = [
  { id: "1", name: "index.tsx", path: "/app/index.tsx" },
  { id: "2", name: "layout.tsx", path: "/app/layout.tsx" },
  { id: "3", name: "page.tsx", path: "/app/page.tsx" },
  { id: "4", name: "globals.css", path: "/app/globals.css" },
  { id: "5", name: "components/button.tsx", path: "/components/button.tsx" },
  { id: "6", name: "components/input.tsx", path: "/components/input.tsx" },
  { id: "7", name: "lib/utils.ts", path: "/lib/utils.ts" },
  { id: "8", name: "tailwind.config.js", path: "/tailwind.config.js" },
]

type FileTag = {
  id: string
  name: string
  path: string
}

type Token = {
  id: string
  type: "text" | "file"
  content: string
  file?: FileTag
}

export function FileMentionInput() {
  const [tokens, setTokens] = React.useState<Token[]>([{ id: "initial", type: "text", content: "" }])
  const [inputValue, setInputValue] = React.useState("")
  const [cursorPosition, setCursorPosition] = React.useState(0)
  const [showSuggestions, setShowSuggestions] = React.useState(false)
  const [suggestionQuery, setSuggestionQuery] = React.useState("")
  const [activeTokenIndex, setActiveTokenIndex] = React.useState(0)

  const containerRef = React.useRef<HTMLDivElement>(null)
  const inputRef = React.useRef<HTMLInputElement>(null)

  // Filter files based on the query
  const filteredFiles = React.useMemo(() => {
    if (!suggestionQuery) return mockFiles
    const query = suggestionQuery.toLowerCase().trim()
    return mockFiles.filter(
      (file) => file.name.toLowerCase().includes(query) || file.path.toLowerCase().includes(query),
    )
  }, [suggestionQuery])

  // Focus the input when clicking on the container
  const handleContainerClick = (e: React.MouseEvent) => {
    if (e.target === containerRef.current) {
      inputRef.current?.focus()
    }
  }

  // Handle input changes
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value
    setInputValue(value)

    // Check for @ symbol
    if (value.includes("@")) {
      const atIndex = value.lastIndexOf("@")
      const query = value.substring(atIndex + 1)
      setSuggestionQuery(query)
      setShowSuggestions(true)
    } else {
      setShowSuggestions(false)
    }
  }

  // Handle key events
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Backspace" && inputValue === "" && tokens.length > 0) {
      // Remove the last token if it's a file tag
      const lastToken = tokens[tokens.length - 1]
      if (lastToken.type === "file") {
        const newTokens = [...tokens]
        newTokens.pop()
        setTokens(newTokens)
      }
    } else if (e.key === "Escape" && showSuggestions) {
      setShowSuggestions(false)
      e.preventDefault()
    } else if (e.key === "Enter" && showSuggestions && filteredFiles.length > 0) {
      selectFile(filteredFiles[0])
      e.preventDefault()
    }
  }

  // Select a file from suggestions
  const selectFile = (file: FileTag) => {
    // Create a new file token
    const fileToken: Token = {
      id: `file-${Date.now()}`,
      type: "file",
      content: file.name,
      file,
    }

    // Add the file token and a new empty text token
    const newTextToken: Token = {
      id: `text-${Date.now()}`,
      type: "text",
      content: "",
    }

    // If the current input has an @ symbol, split it
    if (inputValue.includes("@")) {
      const atIndex = inputValue.lastIndexOf("@")
      const textBefore = inputValue.substring(0, atIndex)

      // Update the current text token with text before @
      const newTokens = [...tokens]
      if (newTokens[newTokens.length - 1].type === "text") {
        newTokens[newTokens.length - 1].content = textBefore
      }

      // Add the file token and a new empty text token
      setTokens([...newTokens, fileToken, newTextToken])
    } else {
      // Just add the file token after the current text
      setTokens([...tokens, fileToken, newTextToken])
    }

    // Reset input and suggestions
    setInputValue("")
    setShowSuggestions(false)

    // Focus back on the input
    setTimeout(() => {
      inputRef.current?.focus()
    }, 0)
  }

  // Remove a file tag
  const removeFileTag = (tokenId: string) => {
    const tokenIndex = tokens.findIndex((t) => t.id === tokenId)
    if (tokenIndex === -1) return

    const newTokens = [...tokens]

    // Remove the file token
    newTokens.splice(tokenIndex, 1)

    // If there are two adjacent text tokens now, merge them
    if (
      tokenIndex > 0 &&
      tokenIndex < newTokens.length &&
      newTokens[tokenIndex - 1].type === "text" &&
      newTokens[tokenIndex].type === "text"
    ) {
      newTokens[tokenIndex - 1].content += newTokens[tokenIndex].content
      newTokens.splice(tokenIndex, 1)
    }

    setTokens(newTokens)

    // Focus back on the input
    setTimeout(() => {
      inputRef.current?.focus()
    }, 0)
  }

  // Handle form submission
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()

    // Combine all tokens into a single string for demonstration
    const value = tokens
      .map((token) => {
        if (token.type === "text") return token.content
        return `@[${token.file?.name}](${token.file?.path})`
      })
      .join("")

    console.log("Submitted value:", value)
    console.log("Tokens:", tokens)

    // You could send this to your backend or process it further
  }

  return (
    <div className="w-full">
      <form onSubmit={handleSubmit}>
        <div
          ref={containerRef}
          className="flex flex-wrap items-center gap-1.5 rounded-md border border-input bg-background p-2 focus-within:ring-1 focus-within:ring-ring"
          onClick={handleContainerClick}
        >
          {tokens.map((token, index) =>
            token.type === "text" ? (
              index === tokens.length - 1 ? (
                <input
                  key={token.id}
                  ref={inputRef}
                  type="text"
                  className="flex-1 min-w-[120px] bg-transparent outline-hidden"
                  value={inputValue}
                  onChange={handleInputChange}
                  onKeyDown={handleKeyDown}
                  placeholder={tokens.length === 1 ? "Type @ to mention a file..." : ""}
                />
              ) : (
                <span key={token.id} className="inline-block">
                  {token.content}
                </span>
              )
            ) : (
              <span
                key={token.id}
                className="inline-flex items-center gap-1 rounded-md bg-primary/10 px-1.5 py-0.5 text-sm text-primary"
              >
                <File className="h-3 w-3" />
                {token.file?.name}
                <button
                  type="button"
                  className="ml-1 rounded-full hover:bg-primary/20"
                  onClick={() => removeFileTag(token.id)}
                >
                  <X className="h-3 w-3" />
                  <span className="sr-only">Remove</span>
                </button>
              </span>
            ),
          )}
        </div>

        {showSuggestions && (
          <div className="relative">
            <div className="absolute z-10 w-full mt-1 shadow-md">
              <Command>
                <CommandList>
                  <CommandInput
                    placeholder="Search files..."
                    value={suggestionQuery}
                    onValueChange={setSuggestionQuery}
                  />
                  <CommandEmpty>No files found.</CommandEmpty>
                  <CommandGroup heading="Files">
                    {filteredFiles.map((file) => (
                      <CommandItem key={file.id} value={file.path} onSelect={() => selectFile(file)}>
                        <File className="mr-2 h-4 w-4" />
                        <span>{file.name}</span>
                        <span className="ml-2 text-xs text-muted-foreground">{file.path}</span>
                      </CommandItem>
                    ))}
                  </CommandGroup>
                </CommandList>
              </Command>
            </div>
          </div>
        )}

        <div className="mt-4">
          <button
            type="submit"
            className="rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90"
          >
            Submit
          </button>
        </div>
      </form>
    </div>
  )
}

================
File: src/components/chat/markdown.tsx
================
import { marked } from "marked"
import { memo, useId, useMemo } from "react"
import ReactMarkdown, { Components } from "react-markdown"
import remarkGfm from "remark-gfm"
import { CodeBlock } from "@/components/ui/code-block"
import { cn } from "@/types/utils"
import { FileText, Folder, Hash, Code, Clock } from "lucide-react"

export type MarkdownProps = {
  children: string
  id?: string
  className?: string
  components?: Partial<Components>
}

function parseMarkdownIntoBlocks(markdown: string): string[] {
  const tokens = marked.lexer(markdown)
  return tokens.map((token) => token.raw)
}

function extractLanguage(className?: string): string {
  if (!className) return "plaintext"
  const match = className.match(/language-(\w+)/)
  return match ? match[1] : "plaintext"
}

// Custom component for rendering file mentions
// Component to display mentions of various content types
function ContentMention({ name, type }: { name: string; type?: string }) {
  // Get the appropriate icon based on content type
  const getIconForType = (type?: string): React.ReactNode => {
    switch (type) {
      case 'file':
        return <FileText className="h-3 w-3 text-cyan-400" />;
      case 'folder':
        return <Folder className="h-3 w-3 text-cyan-400" />;
      case 'gmail':
        return <Hash className="h-3 w-3 text-red-400" />;
      case 'gdrive':
        return <FileText className="h-3 w-3 text-blue-400" />;
      case 'dropbox':
        return <FileText className="h-3 w-3 text-blue-400" />;
      case 'github':
        return <Code className="h-3 w-3 text-purple-400" />;
      case 'conversation':
        return <Clock className="h-3 w-3 text-green-400" />;
      case 'message':
        return <Clock className="h-3 w-3 text-amber-400" />;
      default:
        return <FileText className="h-3 w-3 text-cyan-400" />;
    }
  };
  
  return (
    <span 
      className="inline-flex items-center gap-1 px-2 py-1 mr-1 mb-1 rounded bg-white/10 text-xs text-white/90"
      title={name}
    >
      {getIconForType(type)}
      <span className="truncate max-w-[150px]">{name}</span>
    </span>
  );
}

const INITIAL_COMPONENTS: Partial<Components> = {
  // Add custom content mention component
  span: function SpanComponent({ className, children, ...props }) {
    // Check if this is a content mention span
    if (className && className.includes('mention-')) {
      // Extract content type from className (e.g., mention-file, mention-gdrive)
      const type = className.replace('mention-', '');
      return <ContentMention name={children as string} type={type} />;
    }
    
    // Backward compatibility for old file-mention class
    if (className === 'file-mention') {
      return <ContentMention name={children as string} type="file" />;
    }
    
    // Otherwise render as regular span
    return <span className={className} {...props}>{children}</span>;
  },
  
  code: function CodeComponent({ className, children, ...props }) {
    const isInline =
      !props.node?.position?.start.line ||
      props.node?.position?.start.line === props.node?.position?.end.line

    if (isInline) {
      // Check if this is a file mention (starts with file:)
      const content = String(children);
      if (content.startsWith('file:')) {
        const fileName = content.substring(5); // Remove the 'file:' prefix
        return <FileMention name={fileName} />;
      }
      
      return (
        <span
          className={cn(
            "glass-effect px-1.5 py-0.5 text-[13px] font-mono text-zinc-200 rounded-md",
            "backdrop-blur-[4px] bg-white/[0.03] border border-white/[0.05]",
            className
          )}
          {...props}
        >
          {children}
        </span>
      )
    }

    const language = extractLanguage(className)

    return (
      <CodeBlock
        code={children as string}
        language={language}
        className={cn("glass-effect code-block-glow", className)}
      />
    )
  },
  pre: function PreComponent({ children }) {
    return <>{children}</>
  },
  // Enhance link styling
  a: function LinkComponent({ href, children, ...props }) {
    return (
      <a 
        href={href} 
        className="text-cyan-400 hover:text-cyan-300 underline underline-offset-2 transition-colors" 
        target="_blank" 
        rel="noopener noreferrer"
        {...props}
      >
        {children}
      </a>
    )
  },
  // Better list styling
  ul: function UlComponent({ children, ...props }) {
    return (
      <ul className="pl-6 list-disc space-y-1 my-4" {...props}>
        {children}
      </ul>
    )
  },
  ol: function OlComponent({ children, ...props }) {
    return (
      <ol className="pl-6 list-decimal space-y-1 my-4" {...props}>
        {children}
      </ol>
    )
  },
  // Headings with proper margins and styling
  h1: function H1Component({ children, ...props }) {
    return (
      <h1 className="text-2xl font-bold tracking-tight mt-8 mb-4 border-b border-zinc-800 pb-2" {...props}>
        {children}
      </h1>
    )
  },
  h2: function H2Component({ children, ...props }) {
    return (
      <h2 className="text-xl font-bold tracking-tight mt-6 mb-3" {...props}>
        {children}
      </h2>
    )
  },
  h3: function H3Component({ children, ...props }) {
    return (
      <h3 className="text-lg font-bold tracking-tight mt-5 mb-2" {...props}>
        {children}
      </h3>
    )
  },
  // Enhanced paragraph spacing
  p: function PComponent({ children, ...props }) {
    return (
      <p className="leading-7 not-first:mt-4" {...props}>
        {children}
      </p>
    )
  },
  // Better blockquote
  blockquote: function BlockquoteComponent({ children, ...props }) {
    return (
      <blockquote className="border-l-4 border-zinc-700 bg-zinc-900/30 pl-4 py-1 my-4 italic" {...props}>
        {children}
      </blockquote>
    )
  },
}

const MemoizedMarkdownBlock = memo(
  function MarkdownBlock({
    content,
    components,
    className,
  }: {
    content: string
    components: Partial<Components>
    className?: string
  }) {
    return (
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        components={components}
        className={cn("prose-zinc max-w-none", className)}
      >
        {content}
      </ReactMarkdown>
    )
  },
  (prevProps, nextProps) => prevProps.content === nextProps.content
)

MemoizedMarkdownBlock.displayName = "MemoizedMarkdownBlock"

// Function to preprocess markdown and transform content mentions
function preprocessMarkdown(markdown: string): string {
  // Find mentions in the format @[name](id)
  const mentionRegex = /@\[([^\]]+)\]\(([^)]+)\)/g;
  
  // Replace mentions with our custom component syntax
  return markdown.replace(mentionRegex, (match, name, id) => {
    // Replace any single backticks in the name to avoid breaking markdown
    const escapedName = name.replace(/`/g, "'");
    
    // Determine the content type from the ID
    let contentType = 'file'; // Default type
    
    if (id.startsWith('file-')) {
      contentType = 'file';
    } else if (id.startsWith('gdrive-')) {
      contentType = 'gdrive';
    } else if (id.startsWith('message-')) {
      contentType = 'message';
    } else if (id.startsWith('conversation-')) {
      contentType = 'conversation';
    } else if (id.startsWith('github-')) {
      contentType = 'github';
    } else if (id.startsWith('slack-')) {
      contentType = 'slack';
    } else if (id.startsWith('dropbox-')) {
      contentType = 'dropbox';
    }
    
    // Create a span with a class that indicates the content type
    return `<span class="mention-${contentType}">${escapedName}</span>`;
  });
}

function MarkdownComponent({
  children,
  id,
  className,
  components = INITIAL_COMPONENTS,
}: MarkdownProps) {
  // Preprocess markdown to transform file mentions
  const processedChildren = useMemo(() => {
    return preprocessMarkdown(children);
  }, [children]);
  
  const blocks = useMemo(() => {
    try {
      return parseMarkdownIntoBlocks(processedChildren)
    } catch (error) {
      console.error(error)
      return [processedChildren]
    }
  }, [processedChildren])

  // Use a stable ID for the content blocks
  const contentId = useId()
  const uniqueId = id || contentId

  return (
    <div id={uniqueId} className={cn("text-sm text-zinc-100 leading-7", className)}>
      {blocks.map((content, i) => (
        <MemoizedMarkdownBlock
          key={`${uniqueId}-block-${i}`}
          content={content}
          components={components}
        />
      ))}
    </div>
  )
}

const Markdown = memo(MarkdownComponent)
Markdown.displayName = "Markdown"

export { Markdown }

================
File: src/components/chat/provider-icon.tsx
================
import { 
  Anthropic, 
  OpenAI, 
  Cohere, 
  Mistral, 
  Google, 
  XAI, 
  Together, 
  DeepSeek, 
  Perplexity, 
  Groq 
} from '@lobehub/icons';
import { Provider } from '@/config/models';

interface ProviderIconProps {
  provider: Provider;
  size?: number;
  className?: string;
}

const PROVIDER_COMPONENTS = {
  groq: Groq,
  anthropic: Anthropic,
  openai: OpenAI,
  cohere: Cohere.Color,
  mistral: Mistral.Color,
  google: Google.Color,
  xai: XAI,
  togetherai: Together.Color,
  deepseek: DeepSeek.Color,
  cerebras: OpenAI,
  perplexity: Perplexity.Color
} as const;

export function ProviderIcon({ provider, size = 24, className = '' }: ProviderIconProps) {
  const IconComponent = PROVIDER_COMPONENTS[provider];
  if (!IconComponent) return null;
  
  return (
    <div className={`relative inline-block ${className}`} style={{ width: size, height: size }}>
      <IconComponent size={size} />
    </div>
  );
}

================
File: src/components/chat/stream-status.tsx
================
import { useEffect, useState, useRef, memo, useCallback } from 'react';
import { JSONValue } from 'ai';

interface StreamStatusProps {
  streamData?: JSONValue[] | undefined;
}

// Extract the latest status from stream data
function getLatestStatus(streamData?: JSONValue[]): string {
  if (!streamData || !Array.isArray(streamData) || streamData.length === 0) {
    return 'Processing...';
  }
  
  const lastItem = streamData[streamData.length - 1];
  
  // Handle case when we pass a status object directly
  if (typeof lastItem === 'object' && lastItem !== null && 'status' in lastItem) {
    return String(lastItem.status);
  }
  
  return String(lastItem);
}

export const StreamStatus = memo(({ streamData }: StreamStatusProps) => {
  // Use useRef for status history to avoid re-renders when history changes
  const statusHistoryRef = useRef<string[]>([]);
  const [currentStatus, setCurrentStatus] = useState<string>('Processing...');
  // Use useRef for current status to determine changes without triggering re-renders
  const currentStatusRef = useRef<string>(currentStatus);
  
  // Track timestamps
  const lastUpdateTimeRef = useRef<number>(Date.now());
  const transitionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const initialProcessingShownRef = useRef<boolean>(false);
  const lastProcessedDataLengthRef = useRef<number>(0);
  
  // Force re-render function - only call this when we really need to update the UI
  const [, forceUpdate] = useState({});
  const triggerRender = useCallback(() => forceUpdate({}), []);
  
  // Process streamData changes without causing re-renders for every update
  useEffect(() => {
    // Bail out early if no new data or not enough new chunks to warrant processing
    if (!streamData || !Array.isArray(streamData) || 
        streamData.length === 0 || 
        (streamData.length > 5 && streamData.length - lastProcessedDataLengthRef.current < 5)) {
      return;
    }
    
    // Update our reference to avoid processing the same data multiple times
    lastProcessedDataLengthRef.current = streamData.length;
    
    const newStatus = getLatestStatus(streamData);
    const currentTime = Date.now();
    
    // Only update if the status has changed to avoid unnecessary renders
    if (newStatus !== currentStatusRef.current) {
      // Clear any existing transition timeout
      if (transitionTimeoutRef.current) {
        clearTimeout(transitionTimeoutRef.current);
      }
      
      // Ensure minimum transition time of 800ms between status changes to reduce flickering
      const timeSinceLastUpdate = currentTime - lastUpdateTimeRef.current;
      const transitionDelay = Math.max(0, 800 - timeSinceLastUpdate);
      
      transitionTimeoutRef.current = setTimeout(() => {
        // First, add the current status to history (including the initial "Processing...")
        if (currentStatusRef.current === 'Processing...' && !initialProcessingShownRef.current) {
          initialProcessingShownRef.current = true;
          statusHistoryRef.current = [currentStatusRef.current, ...statusHistoryRef.current].slice(0, 3);
        } else {
          statusHistoryRef.current = [currentStatusRef.current, ...statusHistoryRef.current].slice(0, 3);
        }
        
        // Then, update current status to the new status
        currentStatusRef.current = newStatus;
        // Only update state (causing re-render) if it's actually different
        if (currentStatus !== newStatus) {
          setCurrentStatus(newStatus);
        } else {
          // Force a single render to show updated history
          triggerRender();
        }
        
        lastUpdateTimeRef.current = Date.now();
      }, transitionDelay);
    }
  }, [streamData, currentStatus, triggerRender]);
  
  // Get the status history from ref for rendering
  const statusHistory = statusHistoryRef.current;
  
  return (
    <div className="group rounded-lg backdrop-blur-xs border border-white/[0.05] overflow-hidden transform-gpu transition-all duration-300 ease-out hover:border-white/[0.1]">
      {/* Main status container styled like a tab */}
      <div className="px-3 py-2 relative overflow-hidden bg-white/[0.025] hover:bg-white/[0.035] transition-all duration-300">
        <div className="flex items-center gap-3 relative z-10">
          {/* Status indicator with pulse animation */}
          <div className="relative w-3.5 h-3.5 shrink-0">
            <div className="absolute inset-0 rounded-full bg-cyan-400/20 animate-pulse-slow" />
            <div className="absolute inset-0.5 rounded-full bg-cyan-400 group-hover:bg-[#3ecfff] transition-colors duration-300 animate-pulse-fast" />
          </div>
          
          {/* Current status with tab-like styling */}
          <div className="font-medium text-xs text-white/75 w-full group-hover:text-white/95 transition-colors duration-300">
            {currentStatus}
          </div>
        </div>
      </div>

      {/* Status history with improved transitions in a tab-like container */}
      {statusHistory.length > 0 && (
        <div className="bg-white/[0.015] px-3 py-1.5 space-y-1.5 border-t border-white/[0.025]">
          {statusHistory.map((status, index) => (
            <div 
              key={`status-${index}-${status}`}
              className="text-[10px] text-white/60 transition-all duration-500 flex items-center group-hover:text-white/70"
              style={{ 
                opacity: Math.max(0.7 - index * 0.2, 0.3),
              }}
            >
              <div className="w-1.5 h-1.5 rounded-full bg-white/30 mr-2 group-hover:bg-white/40 transition-colors duration-300" />
              {status}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // Only re-render if streamData has changed significantly
  if (!prevProps.streamData && !nextProps.streamData) return true;
  if (!prevProps.streamData || !nextProps.streamData) return false;
  
  const prevLength = prevProps.streamData.length;
  const nextLength = nextProps.streamData.length;
  
  // If the lengths are the same, don't re-render
  if (prevLength === nextLength) return true;
  
  // Only re-render after significant changes (at least 10 new chunks)
  // This dramatically reduces re-renders during fast streaming
  if (nextLength > prevLength && (nextLength - prevLength) < 10) {
    return true;
  }
  
  return false;
});

StreamStatus.displayName = 'StreamStatus';

================
File: src/components/chat/unified-input.tsx
================
import React, { ChangeEvent, useCallback, useEffect, useRef, useState, useMemo } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { File, Loader2, MessageSquare, X } from 'lucide-react';
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils/utils";
import { Command, CommandEmpty, CommandGroup, CommandItem, CommandList } from 'cmdk';
import path from 'path';
import { CommandCenterEvents, SearchEvents, MessageEvents } from '@/core/ipc/constants';


type FileTag = {
  id: string
  name: string
  path: string
}

type MessageTag = {
  id: string
  name: string
  conversationTitle: string
  role: 'user' | 'assistant' | 'system'
  conversationId: string
}

type Token = {
  id: string
  type: "text" | "file" | "message"
  content: string
  file?: FileTag
  message?: MessageTag
}

interface UnifiedInputProps {
  value: string;
  onChange: (e: ChangeEvent<HTMLInputElement> | ChangeEvent<HTMLTextAreaElement>) => void;
  onSubmit: () => void;
  disabled?: boolean;
  children?: React.ReactNode;
  externalFileReferences?: FileReference[];
  onFileReferencesChange?: (fileReferences: FileReference[]) => void;
}

interface FileReference {
  id: string;
  name: string;
  path: string;
  content?: string;
  type?: string;
}

export const UnifiedInput: React.FC<UnifiedInputProps> = ({
  value,
  onChange,
  onSubmit,
  disabled = false,
  children,
  externalFileReferences,
  onFileReferencesChange
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const [tokens, setTokens] = useState<Token[]>([{ id: "initial", type: "text", content: "" }]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [suggestionQuery, setSuggestionQuery] = useState("");
  
  // Use external file references if provided, otherwise use internal state
  const [internalFileReferences, setInternalFileReferences] = useState<FileReference[]>([]);
  
  // Determine which file references to use
  const fileReferences = externalFileReferences || internalFileReferences;
  
  // Function to update file references
  const updateFileReferences = useCallback((newFileReferences: FileReference[] | ((prev: FileReference[]) => FileReference[])) => {
    if (onFileReferencesChange) {
      // If using external state, call the change handler
      const nextReferences = typeof newFileReferences === 'function' 
        ? newFileReferences(fileReferences) 
        : newFileReferences;
      onFileReferencesChange(nextReferences);
    } else {
      // Otherwise update internal state
      setInternalFileReferences(newFileReferences);
    }
  }, [fileReferences, onFileReferencesChange]);

  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const addFileReference = (file: FileReference) => {
    updateFileReferences(prevReferences => {
      const existingFileIndex = prevReferences.findIndex(ref => ref.id === file.id);
      if (existingFileIndex !== -1) {
        // Update existing file reference
        const updatedReferences = [...prevReferences];
        updatedReferences[existingFileIndex] = file;
        return updatedReferences;
      } else {
        // Add new file reference
        return [...prevReferences, file];
      }
    });
  };
  
  // These will come from props in the future
  const spaceId = undefined;
  const activeConversationId = undefined;

  const [fileResults, setFileResults] = useState<FileTag[]>([]);
  const [messageResults, setMessageResults] = useState<MessageTag[]>([]);
  const [isSearching, setIsSearching] = useState(false);

  const fileReferencesMap = useMemo(() => {
    const fileMap: Record<string, any> = {};
    fileReferences.forEach(fileRef => {
      fileMap[fileRef.id] = {
        id: fileRef.id,
        path: fileRef.path,
        name: fileRef.name,
        content: fileRef.content,
        type: fileRef.type || 'file'
      };
    });
    return fileMap;
  }, [fileReferences]);

  // Search for files using CommandCenterEvents
  const searchFiles = useCallback(async (query: string) => {
    if (!query.trim()) {
      setFileResults([]);
      return;
    }

    setIsSearching(true);

    try {
      const response = await window.electron.invoke(CommandCenterEvents.SEARCH_FILES, {
        query,
        limit: 10, // Limit results to top 10 matches
        type: 'file', // Only search for files, not directories
        includeContent: false, // Don't include file content in search results for better performance
      });
      
      if (response.success && response.data) {
        // Convert to file tags with proper validation
        const fileTags: FileTag[] = response.data
          .filter((item: any) => item && item.path) // Ensure item and path exist
          .map((item: any) => ({
            id: item.id || `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name: item.name || item.fileName || path.basename(item.path),
            path: item.path,
          }));
        
        setFileResults(fileTags);
      } else {
        console.error("Error searching files:", response.error);
        setFileResults([]);
      }
    } catch (error) {
      console.error("Error searching files:", error);
      // Provide fallback results in case of error
      setFileResults([]);
    } finally {
      setIsSearching(false);
    }
  }, []);

  useEffect(() => {
    if (suggestionQuery) {
      searchFiles(suggestionQuery);
    }
  }, [suggestionQuery, searchFiles]);

  // Create memoized filtered results for both files and messages
  const filteredFiles = React.useMemo(() => {
    if (!suggestionQuery) return fileResults;
    return fileResults;
  }, [suggestionQuery, fileResults]);

  const filteredMessages = React.useMemo(() => {
    if (!suggestionQuery) return messageResults;
    return messageResults;
  }, [suggestionQuery, messageResults]);

  const focusInput = () => {
    inputRef.current?.focus();
  };

  useHotkeys('meta+/', (e) => {
    e.preventDefault();
    focusInput();
  }, { enableOnFormTags: true });

  const handleContainerClick = (e: React.MouseEvent) => {
    if (e.target === containerRef.current) {
      inputRef.current?.focus();
    }
  };

  const lastSearchTimeRef = useRef<number>(0);
  const searchTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange(e);
    
    if (e.target.value.includes("@")) {
      const atIndex = e.target.value.lastIndexOf("@");
      const caretPosition = e.target.selectionStart || 0;
      
      if (caretPosition > atIndex && caretPosition <= atIndex + 20) {
        const query = e.target.value.substring(atIndex + 1, caretPosition);
        
        if (query !== suggestionQuery) {
          setSuggestionQuery(query);
          setShowSuggestions(true);
        }
      } else if (caretPosition <= atIndex) {
        setShowSuggestions(false);
      }
    } else {
      setShowSuggestions(false);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Backspace" && value === "" && tokens.length > 0) {
      // Remove the last token if backspace is pressed and input is empty
      const lastToken = tokens[tokens.length - 1];
      if (lastToken.type === "file" || lastToken.type === "message") {
        const newTokens = [...tokens];
        newTokens.pop();
        setTokens(newTokens);
      }
    } else if (e.key === "Escape" && showSuggestions) {
      setShowSuggestions(false);
      e.preventDefault();
    } else if (e.key === "Enter" && showSuggestions) {
      // Handle selecting the first suggestion based on available results
      if (filteredFiles.length > 0) {
        selectFile(filteredFiles[0]);
        e.preventDefault();
      } else if (filteredMessages.length > 0) {
        selectMessage(filteredMessages[0]);
        e.preventDefault();
      }
    } else if (e.key === "Enter" && !e.shiftKey && !showSuggestions) {
      e.preventDefault();
      handleSubmit();
    }
  };

  // Select a file from suggestions
  const selectFile = async (file: FileTag) => {
    // Start loading state for this file
    setIsSearching(true);
    
    try {
      // Read file content using CommandCenterEvents.READ_FILE
      console.log(`Loading content for file: ${file.path}`);
      let fileContent = '';
      
      try {
        const response = await window.electron.invoke(CommandCenterEvents.READ_FILE, {
          filePath: file.path,
          maxSize: 1024 * 1024, // Limit to 1MB to prevent very large files
        });
        
        if (response.success && response.data) {
          fileContent = response.data.content;
          console.log(`File content loaded, size: ${fileContent.length} bytes`);
        } else {
          console.error(`Error loading file content: ${response.error}`);
          fileContent = `[Error loading file content: ${response.error}]`;
        }
      } catch (error) {
        console.error(`Error loading file content for ${file.path}:`, error);
        fileContent = `[Error loading file content: ${error instanceof Error ? error.message : String(error)}]`;
      }
      
      // Create a new file token, properly formatted with content
      const fileToken: Token = {
        id: file.id || `file-${Date.now()}`,
        type: "file",
        content: file.name,
        file: {
          id: file.id || `file-${Date.now()}`,
          name: file.name,
          path: file.path
        },
      };
      
      // Add the file reference with content
      addFileReference({
        id: fileToken.id,
        path: file.path,
        name: file.name,
        content: fileContent || '',
        type: 'file'
      });
      
      console.log(`Added file reference: ${file.name} with content length ${fileContent.length}`);
  
      // Add the file token and a new empty text token
      const newTextToken: Token = {
        id: `text-${Date.now()}`,
        type: "text",
        content: "",
      };
  
      // If the current input has an @ symbol, split it
      if (value.includes("@")) {
        const atIndex = value.lastIndexOf("@");
        const textBefore = value.substring(0, atIndex);
  
        // Update the current text token with text before @
        const newTokens = [...tokens];
        if (newTokens[newTokens.length - 1].type === "text") {
          newTokens[newTokens.length - 1].content = textBefore;
        }
  
        // Add the file token and a new empty text token
        setTokens([...newTokens, fileToken, newTextToken]);
      } else {
        // Just add the file token after the current text
        setTokens([...tokens, fileToken, newTextToken]);
      }
      
      // Clear the input after adding file token
      const event = { target: { value: "" } } as ChangeEvent<HTMLInputElement>;
      onChange(event);
    } catch (error) {
      console.error("Error selecting file:", error);
    } finally {
      setShowSuggestions(false);
      setIsSearching(false);
  
      // Focus back on the input
      setTimeout(() => {
        inputRef.current?.focus();
      }, 0);
    }
  };

  // Select a message from suggestions
  const selectMessage = async (message: MessageTag) => {
    setIsSearching(true);
    
    try {
      // Fetch the message content using the MessageEvents
      console.log(`Loading content for message: ${message.id}`);
      let messageContent = '';
      
      try {
        // Get the message by its ID
        const messageId = message.id.replace('message-', '');
        const response = await window.electron.invoke(MessageEvents.GET_CONVERSATION_MESSAGES, message.conversationId, messageId);
        
        if (response.success && response.data?.length > 0) {
          const messageData = response.data[0];
          messageContent = messageData.content;
          console.log(`Message content loaded, size: ${messageContent.length} bytes`);
        } else {
          console.error(`Error loading message data: ${response.error || 'Message not found'}`);
          messageContent = `[Error loading message content]`;
        }
      } catch (error) {
        console.error(`Error loading message content for ${message.id}:`, error);
        messageContent = `[Error loading message content: ${error instanceof Error ? error.message : String(error)}]`;
      }
      
      // Create a new message token
      const messageToken: Token = {
        id: message.id || `message-${Date.now()}`,
        type: "message",
        content: messageContent.substring(0, 30) + (messageContent.length > 30 ? '...' : ''),
        message: {
          id: message.id,
          name: message.name,
          conversationTitle: message.conversationTitle,
          role: message.role,
          conversationId: message.conversationId
        }
      };
      
      // Add a new empty text token
      const newTextToken: Token = {
        id: `text-${Date.now()}`,
        type: "text",
        content: "",
      };
  
      // If the current input has an @ symbol, split it
      if (value.includes("@")) {
        const atIndex = value.lastIndexOf("@");
        const textBefore = value.substring(0, atIndex);
  
        // Update the current text token with text before @
        const newTokens = [...tokens];
        if (newTokens[newTokens.length - 1].type === "text") {
          newTokens[newTokens.length - 1].content = textBefore;
        }
  
        // Add the message token and a new empty text token
        setTokens([...newTokens, messageToken, newTextToken]);
      } else {
        // Just add the message token after the current text
        setTokens([...tokens, messageToken, newTextToken]);
      }
      
      // Clear the input after adding message token
      const event = { target: { value: "" } } as ChangeEvent<HTMLInputElement>;
      onChange(event);
    } catch (error) {
      console.error("Error selecting message:", error);
    } finally {
      setShowSuggestions(false);
      setIsSearching(false);
  
      // Focus back on the input
      setTimeout(() => {
        inputRef.current?.focus();
      }, 0);
    }
  };

  // Remove a token (file or message)
  const removeToken = (tokenId: string) => {
    const tokenIndex = tokens.findIndex((t) => t.id === tokenId);
    if (tokenIndex === -1) return;

    const newTokens = [...tokens];
    const removedToken = newTokens[tokenIndex];

    // Remove the token
    newTokens.splice(tokenIndex, 1);

    // Remove associated file reference if it's a file token
    if (removedToken.type === "file" && removedToken.file) {
      updateFileReferences(prevReferences => 
        prevReferences.filter(ref => ref.id !== removedToken.file?.id)
      );
    }

    // If there are two adjacent text tokens now, merge them
    if (
      tokenIndex > 0 &&
      tokenIndex < newTokens.length &&
      newTokens[tokenIndex - 1].type === "text" &&
      newTokens[tokenIndex].type === "text"
    ) {
      newTokens[tokenIndex - 1].content += newTokens[tokenIndex].content;
      newTokens.splice(tokenIndex, 1);
    }

    setTokens(newTokens);

    // Focus back on the input
    setTimeout(() => {
      inputRef.current?.focus();
    }, 0);
  };

  // Track if a message is currently being submitted to prevent double submission
  const isSubmittingRef = useRef(false);

  const handleSubmit = async () => {
    if (disabled || isSubmittingRef.current) {
      console.log('[UnifiedInput] Submission blocked: disabled or already submitting');
      return;
    }
    
    isSubmittingRef.current = true;
    
    try {
      // Check if there's any content to submit
      const hasContent = tokens.some(token => 
        (token.type === "text" && token.content.trim() !== "") || 
        token.type === "file" ||
        token.type === "message"
      );
      
      if (!hasContent && value.trim() === "") {
        console.log('[UnifiedInput] Nothing to submit - empty message');
        isSubmittingRef.current = false;
        return;
      }
      
      // Combine all tokens into a cleaned display message
      const displayMessage = tokens
        .map((token) => {
          if (token.type === "text") return token.content;
          if (token.type === "file") return `@[${token.file?.name}](${token.file?.path})`;
          if (token.type === "message") {
            return `@[${token.message?.role === 'assistant' ? 'AI' : 'User'}](${token.message?.conversationTitle})`;
          }
          return '';
        })
        .join("") + value;
      
      console.log('[UnifiedInput] Submitting message:', displayMessage);
      console.log('[UnifiedInput] File references:', fileReferencesMap);
      
      // Ensure non-empty message
      let finalMessage = displayMessage.trim() || " ";
      
      try {
        // Save the current state in case we need to restore it
        const savedTokens = [...tokens];

        // Update parent value and submit
        const event = { target: { value: finalMessage } } as ChangeEvent<HTMLInputElement>;
        onChange(event);
        await Promise.resolve(onSubmit());
        
        // Only clear tokens and file references after successful submission
        setTokens([{ id: "initial", type: "text", content: "" }]);
        // Clear file references only if using internal state
        if (!externalFileReferences) {
          updateFileReferences([]);
        }
        console.log('[UnifiedInput] Message submitted successfully');
      } catch (error) {
        console.error('[UnifiedInput] Submission failed:', error);
        throw error;
      }
    } catch (error) {
      console.error('[UnifiedInput] Error during submission:', error);
      // Restore tokens if submission fails
      setTokens([{ id: "initial", type: "text", content: "" }]);
    } finally {
      isSubmittingRef.current = false;
    }
  };

  // Cleanup function to remove timers when component unmounts
  useEffect(() => {
    return () => {
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current);
      }
    };
  }, []);

  return (
    <div
      className={cn(
        "command-glass-effect relative rounded-2xl",
        "transition-all duration-300",
        "divide-y divide-white/[0.05]",
        isFocused && "bg-white/[0.03]"
      )}
    >
      {children}
      
      {/* Suggestions Popover (Files & Messages) */}
      {showSuggestions && (
        <div 
          className="absolute bottom-full left-0 right-0 z-50 mb-2 file-suggestions-menu"
          style={{ display: showSuggestions ? 'block' : 'none' }}
        >
          <div className="max-h-60 rounded-md bg-white/[0.03] backdrop-blur-xl">
            <Command className="bg-transparent">
              <CommandList className="max-h-[300px] overflow-y-auto scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent">
                {isSearching ? (
                  <div className="flex items-center justify-center py-6">
                    <Loader2 className="h-6 w-6 text-cyan-500 animate-spin" />
                    <span className="ml-2 text-white/60">Searching files and messages...</span>
                  </div>
                ) : filteredFiles.length === 0 && filteredMessages.length === 0 ? (
                  <CommandEmpty className="text-white/60 text-sm py-2 px-4">
                    No results found. Try a different search term.
                  </CommandEmpty>
                ) : (
                  <>
                    {/* File search results */}
                    {filteredFiles.length > 0 && (
                      <CommandGroup heading="Files" className="text-white/80">
                        {filteredFiles.map((file) => (
                          <CommandItem 
                            key={file.id} 
                            value={file.path} 
                            onSelect={() => selectFile(file)}
                            className="text-white/80 hover:bg-white/[0.05] hover:text-white/95 transition-all duration-200"
                          >
                            <File className="mr-2 h-4 w-4 text-white/60" />
                            <span>{file.name}</span>
                            <span className="ml-2 text-xs text-white/40 truncate max-w-[200px]">{file.path}</span>
                          </CommandItem>
                        ))}
                      </CommandGroup>
                    )}
                    
                    {/* Message search results */}
                    {filteredMessages.length > 0 && (
                      <CommandGroup heading="Messages" className="text-white/80">
                        {filteredMessages.map((message) => (
                          <CommandItem 
                            key={message.id} 
                            value={message.name} 
                            onSelect={() => selectMessage(message)}
                            className="text-white/80 hover:bg-white/[0.05] hover:text-white/95 transition-all duration-200"
                          >
                            <MessageSquare className={`mr-2 h-4 w-4 ${message.role === 'assistant' ? 'text-cyan-400' : 'text-white/60'}`} />
                            <div className="flex flex-col">
                              <span className="truncate max-w-[300px]">{message.name}</span>
                              <span className="text-xs text-white/40">From: {message.conversationTitle}</span>
                            </div>
                            <span className="ml-auto text-xs px-1.5 py-0.5 rounded bg-white/[0.05] text-white/60">
                              {message.role === 'assistant' ? 'AI' : 'User'}
                            </span>
                          </CommandItem>
                        ))}
                      </CommandGroup>
                    )}
                  </>
                )}
              </CommandList>
            </Command>
          </div>
        </div>
      )}
      
      <div>
        <div className="flex items-center">
          <div className="flex-1">
            <div 
              ref={containerRef}
              className="flex flex-wrap items-center gap-1.5 p-3 min-h-[48px] max-h-[200px] overflow-y-auto scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent"
              onClick={handleContainerClick}
            >
              {tokens.map((token, index) =>
                token.type === "text" ? (
                  index === tokens.length - 1 ? (
                    <input
                      key={token.id}
                      ref={inputRef}
                      type="text"
                      className="flex-1 min-w-[120px] bg-transparent outline-hidden text-white/90 text-sm placeholder:text-white/40"
                      value={value}
                      onChange={handleInputChange}
                      onKeyDown={handleKeyDown}
                      onFocus={() => setIsFocused(true)}
                      onBlur={() => {
                        // Longer delay to allow clicks on the suggestions menu
                        setTimeout(() => {
                          if (!document.activeElement?.closest('.file-suggestions-menu')) {
                            setIsFocused(false);
                            setShowSuggestions(false);
                          }
                        }, 200);
                      }}
                      placeholder={tokens.length === 1 ? "Type @ to mention a file or message (Press ⌘+/ to focus)" : ""}
                    />
                  ) : (
                    <span key={token.id} className="inline-block text-white/90 text-sm">
                      {token.content}
                    </span>
                  )
                ) : token.type === "file" ? (
                  <span
                    key={token.id}
                    className="inline-flex items-center gap-1 rounded-md bg-cyan-500/20 px-1.5 py-0.5 text-sm text-cyan-300"
                  >
                    <File className="h-3 w-3" />
                    {token.file?.name}
                    <button
                      type="button"
                      className="ml-1 rounded-full hover:bg-cyan-500/30"
                      onClick={() => removeToken(token.id)}
                    >
                      <X className="h-3 w-3" />
                      <span className="sr-only">Remove</span>
                    </button>
                  </span>
                ) : (
                  <span
                    key={token.id}
                    className="inline-flex items-center gap-1 rounded-md bg-purple-500/20 px-1.5 py-0.5 text-sm text-purple-300"
                  >
                    <MessageSquare className="h-3 w-3" />
                    {token.message?.role === 'assistant' ? 'AI' : 'User'} message
                    <button
                      type="button"
                      className="ml-1 rounded-full hover:bg-purple-500/30"
                      onClick={() => removeToken(token.id)}
                    >
                      <X className="h-3 w-3" />
                      <span className="sr-only">Remove</span>
                    </button>
                  </span>
                ),
              )}
            </div>
          </div>
          <div className="flex items-center mr-2">
            <Button
              variant="cyan"
              onClick={(e) => {
                e.preventDefault();
                handleSubmit();
              }}
              disabled={disabled}
              className="h-8 rounded-xl"
            >
              Send
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
};

================
File: src/components/dialogs/CreateSpaceDialog.tsx
================
import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Toast } from "@/components/ui/toast";
import { useSpaces } from "@/hooks/use-spaces";
import { useCommandCenter } from "@/hooks/use-command-center";
import { DialogComponentProps } from "@/types";

export const CreateSpaceDialog: React.FC<DialogComponentProps> = ({ data, onClose, onConfirm }) => {
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const { createSpace, isLoading } = useSpaces();
  const { refreshCommandCenter } = useCommandCenter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      // Using the default model and provider for simplicity
      const spaceData = {
        name,
        description,
        model: "claude-3-haiku-20240307", // Default model
        provider: "anthropic", // Default provider
        color: "#3ecfff" // Default color
      };
      
      const success = await createSpace(spaceData);
      
      if (success) {
        // Close dialog
        onClose();
        
        // Refresh command center
        refreshCommandCenter();
        
        // Show success toast
        toast({
          title: "Success",
          description: "Space created successfully",
          variant: "success",
        });
        
        // Navigate to the new space if user clicks
        if (onConfirm) {
          onConfirm(spaceData);
        }
      } else {
        toast({
          title: "Error",
          description: "Failed to create space",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error('Error creating space:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive",
      });
    }
  };

  // Don't render if no data provided
  if (!data) {
    return null;
  }

  return (
    <Dialog open={true} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Create New Space</DialogTitle>
          <DialogDescription>
            Create a new space to organize your conversations.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Enter space name"
                required
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Describe the purpose of this space"
                rows={3}
              />
            </div>
          </div>
          <DialogFooter>
            <Button type="button" variant="outline" onClick={onClose} disabled={isLoading}>
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading ? "Creating..." : "Create Space"}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

================
File: src/components/dialogs/DeleteConversationDialog.tsx
================
import React from "react";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { toast } from 'sonner';
import { useConversations } from "@/hooks/use-conversations";
import { useCommandCenter } from "@/hooks/use-command-center";
import { DialogComponentProps } from "@/types/dialog";

export const DeleteConversationDialog: React.FC<DialogComponentProps> = ({ data, onClose, onConfirm }) => {
  const { deleteConversation, isLoading: isDeleting } = useConversations();
  const { refreshCommandCenter } = useCommandCenter();

  const handleDelete = async () => {
    if (isDeleting) return;
    
    try {
      const success = await deleteConversation(data.spaceId, data.id);
      
      if (success) {
        // Refresh command center
        refreshCommandCenter();
        
        toast.success('Conversation deleted successfully');
        onConfirm?.(data);
        onClose();
      } else {
        toast.error('Failed to delete conversation');
      }
    } catch (error) {
      console.error('Error deleting conversation:', error);
      toast.error(error instanceof Error ? error.message : 'An unexpected error occurred');
    }
  };

  // Don't show the dialog if there's no data or ID
  if (!data || !data.id) {
    return null;
  }

  return (
    <Dialog open={!!data.id} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Delete Conversation</DialogTitle>
          <DialogDescription>
            Are you sure you want to delete this conversation? This action cannot be undone.
          </DialogDescription>
        </DialogHeader>
        <DialogFooter>
          <Button 
            type="button" 
            variant="outline" 
            onClick={onClose} 
            disabled={isDeleting}
          >
            Cancel
          </Button>
          <Button 
            type="button" 
            variant="destructive" 
            onClick={handleDelete} 
            disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : 'Delete'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

================
File: src/components/dialogs/DeleteSpaceDialog.tsx
================
import React from "react";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Toast } from "@/components/ui/toast";
import { DialogComponentProps } from "@/types/dialog";
import { Space } from "@/types/space";
import { useSpaces } from "@/hooks/use-spaces";
import { useCommandCenter } from "@/hooks/use-command-center";

export const DeleteSpaceDialog: React.FC<DialogComponentProps> = ({ data, onClose }) => {
  const space = data as Space;
  const { deleteSpace, isLoading: isDeleting } = useSpaces();
  const { refreshCommandCenter } = useCommandCenter();

  const handleDelete = async () => {
    if (!space || !space.id) return;
    
    try {
      const success = await deleteSpace(space.id);
      
      if (success) {
        // Refresh command center
        refreshCommandCenter();
        
        // Show success toast
        toast({
          title: "Success",
          description: "Space deleted successfully",
          variant: "success",
        });
        
        onClose();
      } else {
        toast({
          title: "Error",
          description: "Failed to delete space",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error('Error deleting space:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive",
      });
    }
  };

  // Don't render if no space data provided
  if (!space || !space.id) {
    return null;
  }

  return (
    <Dialog open={!!space.id} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Delete Space</DialogTitle>
          <DialogDescription>
            Are you sure you want to delete <strong>{space.name}</strong>? 
            This action cannot be undone and will delete all conversations within this space.
          </DialogDescription>
        </DialogHeader>
        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isDeleting}>
            Cancel
          </Button>
          <Button 
            variant="destructive" 
            onClick={handleDelete}
            disabled={isDeleting}
          >
            {isDeleting ? "Deleting..." : "Delete Space"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

================
File: src/components/dialogs/EditConversationDialog.tsx
================
import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Toast } from "@/components/ui/toast";
import { useConversations } from "@/hooks/use-conversations";
import { useCommandCenter } from "@/hooks/use-command-center";
import { DialogComponentProps } from "@/types/dialog";

export const EditConversationDialog: React.FC<DialogComponentProps> = ({ data, onClose, onConfirm }) => {
  const [title, setTitle] = useState(data.title || "");
  const { updateConversation, isLoading: isSubmitting } = useConversations();
  const { refreshCommandCenter } = useCommandCenter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (isSubmitting) return;

    const trimmedTitle = title.trim();
    if (!trimmedTitle) {
      toast.error('Please enter a valid title');
      return;
    }

    try {
      const success = await updateConversation(data.spaceId, data.id, trimmedTitle);
      
      if (success) {
        toast.success('Conversation updated successfully');
        
        // Refresh command center
        refreshCommandCenter();
        
        // Pass updated data with new title
        onConfirm?.({ ...data, title: trimmedTitle });
        onClose();
      } else {
        toast.error('Failed to update conversation');
      }
    } catch (error) {
      console.error('Error updating conversation:', error);
      toast.error(error instanceof Error ? error.message : 'An unexpected error occurred');
    }
  };

  // Don't render if no data or ID provided
  if (!data || !data.id) {
    return null;
  }

  return (
    <Dialog open={!!data.id} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Edit Conversation</DialogTitle>
          <DialogDescription>
            Give your conversation a meaningful title to help you find it later.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="title">Title</Label>
              <Input
                id="title"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder="Enter conversation title"
                required
                disabled={isSubmitting}
                autoFocus
              />
            </div>
          </div>
          <DialogFooter>
            <Button 
              type="button" 
              variant="outline" 
              onClick={onClose}
              disabled={isSubmitting}
            >
              Cancel
            </Button>
            <Button 
              type="submit"
              disabled={isSubmitting || !title.trim()}
            >
              {isSubmitting ? 'Saving...' : 'Save Changes'}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

================
File: src/components/dialogs/EditSpaceDialog.tsx
================
import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Toast } from "@/components/ui/toast";
import { DialogComponentProps } from "@/types/dialog";
import { Space } from "@/types/space";
import { useSpaces } from "@/hooks/use-spaces";
import { useCommandCenter } from "@/hooks/use-command-center";

export const EditSpaceDialog: React.FC<DialogComponentProps> = ({ data, onClose }) => {
  const space = data as Space;
  const [name, setName] = useState(space?.name || "");
  const [description, setDescription] = useState(space?.description || "");
  const { updateSpace, isLoading } = useSpaces();
  const { refreshCommandCenter } = useCommandCenter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!space || !space.id) return;
    
    try {
      const success = await updateSpace(space.id, {
        name,
        description
      });
      
      if (success) {
        // Refresh command center
        refreshCommandCenter();
        
        // Show success toast
        toast({
          title: "Success",
          description: "Space updated successfully",
          variant: "success",
        });
        
        onClose();
      } else {
        toast({
          title: "Error",
          description: "Failed to update space",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error('Error updating space:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive",
      });
    }
  };

  // Don't render if no space data provided
  if (!space || !space.id) {
    return null;
  }

  return (
    <Dialog open={!!space.id} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Edit Space</DialogTitle>
          <DialogDescription>
            Update the details of your space.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit}>
          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Space name"
                required
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Describe the purpose of this space"
                rows={3}
              />
            </div>
          </div>
          <DialogFooter>
            <Button 
              type="button" 
              variant="outline" 
              onClick={onClose}
              disabled={isLoading}
            >
              Cancel
            </Button>
            <Button 
              type="submit"
              disabled={isLoading}
            >
              {isLoading ? "Saving..." : "Save Changes"}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

================
File: src/components/providers/ActionsProvider.tsx
================
import React from 'react';
import { Play, Settings, Command, FileText, FolderOpen } from 'lucide-react';
import { Command as Cmdk } from 'cmdk';
import { ProviderComponentProps } from '@/types/provider';

interface Action {
  id: string;
  name: string;
  description: string;
  icon: React.ReactNode;
  category: 'system' | 'file' | 'navigation' | 'custom';
  shortcut?: string;
}

export function ActionsProvider({ searchQuery = '', onSelect }: ProviderComponentProps) {
  const actions: Action[] = [
    {
      id: 'open-settings',
      name: 'Open Settings',
      description: 'Configure application settings',
      icon: <Settings size={16} />,
      category: 'system',
      shortcut: '⌘,'
    },
    {
      id: 'open-command-center',
      name: 'Command Center',
      description: 'Open the command center',
      icon: <Command size={16} />,
      category: 'system',
      shortcut: '⌘K'
    },
    {
      id: 'new-file',
      name: 'New File',
      description: 'Create a new file',
      icon: <FileText size={16} className="text-green-500" />,
      category: 'file',
      shortcut: '⌘N'
    },
    {
      id: 'open-folder',
      name: 'Open Folder',
      description: 'Open a folder in the workspace',
      icon: <FolderOpen size={16} className="text-amber-500" />,
      category: 'navigation',
      shortcut: '⌘O'
    }
  ];

  const filteredActions = actions.filter(action => 
    action.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    action.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
    action.category.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const groupedActions = filteredActions.reduce((acc, action) => {
    const category = action.category;
    if (!acc[category]) {
      acc[category] = [];
    }
    acc[category].push(action);
    return acc;
  }, {} as Record<string, Action[]>);

  if (Object.keys(groupedActions).length === 0) {
    return (
      <Cmdk.List>
        <Cmdk.Empty>No actions found</Cmdk.Empty>
      </Cmdk.List>
    );
  }

  return (
    <Cmdk.List>
      {Object.entries(groupedActions).map(([category, categoryActions]) => (
        <Cmdk.Group 
          key={category} 
          heading={category.charAt(0).toUpperCase() + category.slice(1)}
        >
          {categoryActions.map(action => (
            <Cmdk.Item
              key={action.id}
              value={action.name}
              onSelect={() => onSelect?.({...action, closeOnSelect: true})}
            >
              {action.icon}
              <div>
                {action.name}
                <span className="cmdk-meta">{action.description}</span>
              </div>
              {action.shortcut && (
                <kbd className="cmdk-meta">{action.shortcut}</kbd>
              )}
            </Cmdk.Item>
          ))}
        </Cmdk.Group>
      ))}
    </Cmdk.List>
  );
}

================
File: src/components/providers/BackgroundTasksProvider.tsx
================
import React, { useState, useEffect } from 'react';
import { Activity, Clock, Check, X } from 'lucide-react';
import { Command } from 'cmdk';
import { Progress } from "@/components/ui/progress";
import { ProviderComponentProps } from '@/types/provider';

interface BackgroundTask {
  id: string;
  description: string;
  status: 'pending' | 'in-progress' | 'completed' | 'failed';
  createdAt: number;
  completedAt?: number;
  progress?: number;
}

export function BackgroundTasksProvider({ searchQuery, onSelect }: ProviderComponentProps) {
  const [tasks, setTasks] = useState<BackgroundTask[]>([]);

  const createBackgroundTask = (description: string) => {
    const newTask: BackgroundTask = {
      id: `task-${Date.now()}`,
      description,
      status: 'pending',
      createdAt: Date.now(),
    };
    
    setTasks(prevTasks => [...prevTasks, newTask]);
    return newTask.id;
  };

  const updateTaskStatus = (taskId: string, status: BackgroundTask['status'], progress?: number) => {
    setTasks(prevTasks => 
      prevTasks.map(task => 
        task.id === taskId 
          ? { 
              ...task, 
              status, 
              progress, 
              ...(status === 'completed' ? { completedAt: Date.now() } : {})
            } 
          : task
      )
    );
  };

  const removeTask = (taskId: string) => {
    setTasks(prevTasks => prevTasks.filter(task => task.id !== taskId));
  };

  useEffect(() => {
    const api = {
      createBackgroundTask,
      updateTaskStatus,
      removeTask
    };
    (window as any).backgroundTasks = api;
    return () => {
      delete (window as any).backgroundTasks;
    };
  }, []);

  const filteredTasks = tasks.filter(task => 
    task.description.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const getStatusIcon = (status: BackgroundTask['status']) => {
    switch (status) {
      case 'pending':
        return <Clock size={16} className="text-yellow-500" />;
      case 'in-progress':
        return <Activity size={16} className="text-blue-500" />;
      case 'completed':
        return <Check size={16} className="text-green-500" />;
      case 'failed':
        return <X size={16} className="text-destructive" />;
    }
  };

  const getStatusColor = (status: BackgroundTask['status']) => {
    switch (status) {
      case 'pending':
        return 'text-yellow-500';
      case 'in-progress':
        return 'text-blue-500';
      case 'completed':
        return 'text-green-500';
      case 'failed':
        return 'text-destructive';
    }
  };

  return (
    <Command.List>
      <Command.Group heading="Background Tasks">
        {filteredTasks.length === 0 ? (
          <Command.Empty>No background tasks found</Command.Empty>
        ) : (
          filteredTasks.map(task => (
            <Command.Item
              key={task.id}
              value={task.description}
              onSelect={() => onSelect?.({...task, closeOnSelect: true})}
            >
              {getStatusIcon(task.status)}
              <div>
                {task.description}
                <span className="cmdk-meta">
                  {task.status.charAt(0).toUpperCase() + task.status.slice(1)}
                  {task.progress !== undefined && ` • ${task.progress}%`}
                </span>
                {task.progress !== undefined && (
                  <div className="mt-1">
                    <Progress value={task.progress} className="h-1" />
                  </div>
                )}
              </div>
            </Command.Item>
          ))
        )}
      </Command.Group>
    </Command.List>
  );
}

================
File: src/components/providers/ChatModesProvider.tsx
================
import React from 'react';
import { Settings, PencilLine, Trash, Plus } from 'lucide-react';
import { Command } from 'cmdk';
import { Button } from "@/components/ui/button";
import { ProviderComponentProps } from '@/types/provider';
import { getAllChatModes, ChatModeConfig } from '@/config/chat-modes';
import { useSpaces } from '@/hooks/use-spaces';

export function ChatModesProvider({ searchQuery = '', onSelect, onAction }: ProviderComponentProps) {
  const { activeSpace, updateSpace } = useSpaces();
  const chatModes = getAllChatModes();
  const currentMode = activeSpace?.chat_mode || 'ask';

  const filteredModes = chatModes.filter(mode => 
    mode.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    mode.description.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleSelect = async (mode: ChatModeConfig) => {
    if (!activeSpace) return;
    
    try {
      await updateSpace(activeSpace.id, {
        chat_mode: mode.id
      });
      
      if (onSelect) onSelect({
        id: mode.id,
        name: mode.name,
        description: mode.description,
        closeOnSelect: true
      });
    } catch (error) {
      console.error('Failed to update chat mode:', error);
    }
  };

  const handleSettings = (e: React.MouseEvent, mode: ChatModeConfig) => {
    e.stopPropagation();
    e.preventDefault();
    if (onAction) onAction('settings', mode);
  };
  
  const handleEdit = (e: React.MouseEvent, mode: ChatModeConfig) => {
    e.stopPropagation();
    e.preventDefault();
    if (onAction) onAction('edit', mode);
  };
  
  const handleDelete = (e: React.MouseEvent, mode: ChatModeConfig) => {
    e.stopPropagation();
    e.preventDefault();
    if (onAction) onAction('delete', mode);
  };

  const handleCreate = () => {
    if (onAction) onAction('create', {});
  };

  return (
    <Command.List>
      <Command.Group heading="Chat Modes">
        {filteredModes.length === 0 ? (
          <Command.Empty>No chat modes found</Command.Empty>
        ) : (
          filteredModes.map(mode => {
            const Icon = mode.icon;
            const isActive = mode.id === currentMode;
            
            return (
              <Command.Item
                key={mode.id}
                value={mode.name}
                onSelect={() => handleSelect(mode)}
              >
                <Icon className={isActive ? undefined : "text-muted-foreground w-4 h-4"} />
                <div>
                  {mode.name}
                  <span className="cmdk-meta">{mode.description}</span>
                </div>
                <div className="cmdk-actions">
                  {isActive && (
                    <span className="text-primary">Active</span>
                  )}
                  <Button 
                    variant="ghost"
                    size="icon"
                    onClick={(e) => handleSettings(e, mode)}
                  >
                    <Settings size={14} />
                  </Button>
                  <Button 
                    variant="ghost"
                    size="icon"
                    onClick={(e) => handleEdit(e, mode)}
                  >
                    <PencilLine size={14} />
                  </Button>
                  {!isActive && (
                    <Button 
                      variant="ghost"
                      size="icon"
                      onClick={(e) => handleDelete(e, mode)}
                    >
                      <Trash size={14} />
                    </Button>
                  )}
                </div>
              </Command.Item>
            );
          })
        )}
      </Command.Group>
      <Command.Separator />
      <Command.Group>
        <Command.Item onSelect={handleCreate}>
          <Plus size={16} />
          Create new chat mode
        </Command.Item>
      </Command.Group>
    </Command.List>
  );
}

================
File: src/components/providers/ConversationsProvider.tsx
================
import React from "react";
import { PencilLine, Trash, MessageSquare, Plus } from "lucide-react";
import { Command } from 'cmdk';
import { Button } from "@/components/ui/button";
import { Conversation } from '@/types/conversation';
import { ProviderComponentProps } from "@/types/provider";
import { useSpaces } from '@/hooks/use-spaces';
import { useConversations } from '@/hooks/use-conversations';
import { useMessages } from '@/hooks/use-messages';

export const ConversationsProvider: React.FC<ProviderComponentProps> = ({ searchQuery, onSelect, onAction }) => {
  const { activeSpace, setActiveSpaceById } = useSpaces();
  const { conversations, isLoading } = useConversations();
  const { fetchMessages } = useMessages(null);

  const filteredConversations = conversations
    .filter(conv => conv.space_id === activeSpace?.id)
    .filter(conv =>
      (conv.title || 'Untitled').toLowerCase().includes(searchQuery.toLowerCase())
    );

  const handleSelect = async (conversation: Conversation) => {
    try {
      if (!conversation || !conversation.space_id) {
        console.error('[ConversationsProvider] Cannot select conversation: Invalid spaceId', conversation);
        return;
      }

      console.log('[ConversationsProvider] Selecting conversation:', conversation.id, 'in space:', conversation.space_id);
      
      const spaceSuccess = await setActiveSpaceById(conversation.space_id);
      if (spaceSuccess) {
        await fetchMessages(conversation.id);
        
        if (onSelect) {
          onSelect({...conversation, closeOnSelect: true});
        }
      } else {
        console.error('[ConversationsProvider] Error setting active space');
      }
    } catch (error) {
      console.error('[ConversationsProvider] Error handling conversation selection:', error);
    }
  };

  const handleEdit = (e: React.MouseEvent, conversation: Conversation) => {
    e.stopPropagation();
    e.preventDefault();
    if (onAction) onAction('edit', conversation);
  };

  const handleDelete = (e: React.MouseEvent, conversation: Conversation) => {
    e.stopPropagation();
    e.preventDefault();
    if (onAction) onAction('delete', conversation);
  };

  const handleCreate = () => {
    if (onAction) onAction('create', {});
  };

  if (!activeSpace) {
    return (
      <Command.List>
        <Command.Empty>No active space selected</Command.Empty>
      </Command.List>
    );
  }

  return (
    <Command.List>
      <Command.Group heading={`Conversations in ${activeSpace?.name || 'Current Space'}`}>
        {filteredConversations.length === 0 ? (
          <Command.Empty>No conversations found</Command.Empty>
        ) : (
          filteredConversations.map(conv => (
            <Command.Item
              key={conv.id}
              value={conv.title || 'Untitled'}
              onSelect={() => handleSelect({...conv, title: conv.title || 'Untitled'})}
            >
              <MessageSquare size={16} />
              <div>
                {conv.title || 'Untitled'}
              </div>
              <div className="cmdk-actions">
                <Button 
                  variant="ghost"
                  size="icon"
                  onClick={(e) => handleEdit(e, {...conv, title: conv.title || 'Untitled'})}
                >
                  <PencilLine size={14} />
                </Button>
                <Button 
                  variant="ghost"
                  size="icon"
                  onClick={(e) => handleDelete(e, {...conv, title: conv.title || 'Untitled'})}
                >
                  <Trash size={14} />
                </Button>
              </div>
            </Command.Item>
          ))
        )}
      </Command.Group>
      <Command.Separator />
      <Command.Group>
        <Command.Item onSelect={handleCreate}>
          <Plus size={16} />
          Create new conversation
        </Command.Item>
      </Command.Group>
    </Command.List>
  );
};

================
File: src/components/providers/MessageSearchProvider.tsx
================
import React, { useEffect, useState } from 'react';
import { MessageSquare } from 'lucide-react';
import { Command } from 'cmdk';
import { Message, Conversation, ProviderComponentProps } from '@/types';
import { MessageEvents } from '@/core/ipc/constants';

interface MessageWithConversation extends Message {
  timestamp: number;
  conversationName: string;
  conversation?: Conversation;
}

export function MessageSearchProvider({ searchQuery, onSelect }: ProviderComponentProps) {
  const [messages, setMessages] = useState<MessageWithConversation[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchMessages = async () => {
      if (!searchQuery || searchQuery.length < 2) {
        setMessages([]);
        setIsLoading(false);
        return;
      }

      try {
        setIsLoading(true);
        const result = await window.electron.invoke(MessageEvents.SEARCH_MESSAGES, searchQuery);
        
        if (result.success) {
          const messagesWithConversations: MessageWithConversation[] = (result.data || []).map((msg: any) => ({
            ...msg,
            timestamp: new Date(msg.createdAt).getTime(),
            conversationName: msg.conversationTitle || 'Untitled'
          })) || [];
          setMessages(messagesWithConversations);
        } else {
          console.error('Error fetching messages:', result.error);
        }
      } catch (error) {
        console.error('Error searching messages:', error);
      } finally {
        setIsLoading(false);
      }
    };

    const timer = setTimeout(() => {
      fetchMessages();
    }, 300); // Debounce search

    return () => clearTimeout(timer);
  }, [searchQuery]);

  const filteredMessages = messages.filter(message => 
    message.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
    message.conversationName.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const formatTimestamp = (timestamp: number) => {
    const date = new Date(timestamp);
    const now = new Date();
    const diffInHours = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60));
    
    if (diffInHours < 24) {
      return `${diffInHours} hour${diffInHours !== 1 ? 's' : ''} ago`;
    }
    return date.toLocaleDateString();
  };

  return (
    <Command.List>
      <Command.Group heading="Message Search">
        {isLoading ? (
          <Command.Loading>Searching messages...</Command.Loading>
        ) : filteredMessages.length === 0 ? (
          <Command.Empty>No messages found</Command.Empty>
        ) : (
          filteredMessages.map(message => (
            <Command.Item
              key={message.id}
              value={message.content}
              onSelect={() => onSelect?.({...message, closeOnSelect: true})}
            >
              <MessageSquare size={16} className={message.role === 'assistant' ? 'text-cyan-400' : 'text-white/60'} />
              <div>
                {message.content}
                <span className="cmdk-meta">
                  {message.conversationName} • {formatTimestamp(message.timestamp)}
                </span>
              </div>
            </Command.Item>
          ))
        )}
      </Command.Group>
    </Command.List>
  );
}

================
File: src/components/providers/ModelsProvider.tsx
================
import React from "react";
import { Command } from 'cmdk';
import { ProviderIcon } from "@lobehub/icons";
import { useSpaces } from "@/hooks/use-spaces";
import { toast } from "@/hooks/use-toast";
import { ProviderComponentProps, Model, Provider, AVAILABLE_MODELS, AvailableModel } from "@/types/provider";

export const ModelsProvider: React.FC<ProviderComponentProps> = ({ searchQuery = '', onSelect }) => {
  const { activeSpace, updateSpaceModel } = useSpaces();
  
  const modelsByProvider = Object.entries(AVAILABLE_MODELS).reduce<Record<string, Model[]>>((acc, [providerName, models]) => {
    const provider = providerName as Provider;
    const filteredModels = (models as ReadonlyArray<AvailableModel>).filter(model =>
      model.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      model.description?.toLowerCase().includes(searchQuery.toLowerCase())
    );
    
    if (filteredModels.length > 0) {
      acc[provider] = filteredModels.map(model => ({ ...model, provider }));
    }
    
    return acc;
  }, {});

  const handleModelSelect = async (model: Model, provider: Provider) => {
    if (!activeSpace?.id) {
      console.error('[ModelsProvider] Cannot update model: No active space');
      toast({
        title: "Error",
        description: "No active space selected",
        variant: "destructive",
      });
      return;
    }

    try {
      console.log('[ModelsProvider] Updating model to:', model.id, 'provider:', provider, 'for space:', activeSpace.id);
      
      const success = await updateSpaceModel(activeSpace.id, model.id, provider);
      
      if (success) {
        toast({
          title: "Success",
          description: `Model updated to ${model.name}`,
          variant: "default",
        });
        
        if (onSelect) {
          onSelect({ ...model, provider, closeOnSelect: true });
        }
      } else {
        toast({
          title: "Error",
          description: "Failed to update model",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error('[ModelsProvider] Error updating space model:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive",
      });
    }
  };

  if (Object.keys(modelsByProvider).length === 0) {
    return (
      <Command.List>
        <Command.Empty>No models found</Command.Empty>
      </Command.List>
    );
  }

  return (
    <Command.List>
      {Object.entries(modelsByProvider).map(([provider, models], index, array) => (
        <React.Fragment key={provider}>
          <Command.Group heading={provider.charAt(0).toUpperCase() + provider.slice(1)}>
            {models.map((model, idx) => (
              <Command.Item
                key={`${provider}-${idx}`}
                value={model.id}
                onSelect={() => handleModelSelect(model, provider as Provider)}
              >
                <ProviderIcon type="color" provider={model.provider} size={18} />
                <div>
                  {model.name}
                  {model.description && (
                    <span className="cmdk-meta">{model.description}</span>
                  )}
                </div>
              </Command.Item>
            ))}
          </Command.Group>
          {index < array.length - 1 && <Command.Separator />}
        </React.Fragment>
      ))}
    </Command.List>
  );
};

================
File: src/components/providers/SimilarMessagesProvider.tsx
================
import React from 'react';
import { MessageSquare } from 'lucide-react';
import { Command } from 'cmdk';
import { ProviderComponentProps } from '@/types/provider';

interface SimilarMessage {
  id: string;
  content: string;
  timestamp: number;
  conversationId: string;
  conversationName: string;
  similarity: number;
}

export function SimilarMessagesProvider({ searchQuery, onSelect }: ProviderComponentProps) {
  const similarMessages: SimilarMessage[] = [
    {
      id: '1',
      content: 'Here\'s how we implemented the command center pattern',
      timestamp: Date.now() - 86400000, // 1 day ago
      conversationId: 'conv1',
      conversationName: 'Architecture Discussion',
      similarity: 0.85
    },
    {
      id: '2',
      content: 'The command center should handle all user interactions',
      timestamp: Date.now() - 172800000, // 2 days ago
      conversationId: 'conv2',
      conversationName: 'Design Review',
      similarity: 0.75
    }
  ];

  const filteredMessages = similarMessages.filter(message => 
    message.content.toLowerCase().includes(searchQuery.toLowerCase()) ||
    message.conversationName.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const formatTimestamp = (timestamp: number) => {
    const date = new Date(timestamp);
    const now = new Date();
    const diffInDays = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
    
    if (diffInDays < 1) {
      return 'Today';
    } else if (diffInDays === 1) {
      return 'Yesterday';
    }
    return date.toLocaleDateString();
  };

  return (
    <Command.List>
      <Command.Group heading="Similar Messages">
        {filteredMessages.length === 0 ? (
          <Command.Empty>No similar messages found</Command.Empty>
        ) : (
          filteredMessages.map(message => (
            <Command.Item
              key={message.id}
              value={message.content}
              onSelect={() => onSelect?.({...message, closeOnSelect: true})}
            >
              <MessageSquare size={16} className="text-purple-500" />
              <div>
                {message.content}
                <span className="cmdk-meta">
                  {message.conversationName} • {formatTimestamp(message.timestamp)} • {Math.round(message.similarity * 100)}% similar
                </span>
              </div>
            </Command.Item>
          ))
        )}
      </Command.Group>
    </Command.List>
  );
}

================
File: src/components/providers/SpacesProvider.tsx
================
import React from "react";
import { PencilLine, Trash, Globe, Plus } from "lucide-react";
import { Command } from 'cmdk';
import { Button } from "@/components/ui/button";
import { Space } from '@/types/space';
import { useSpaces } from '@/hooks/use-spaces';
import { ProviderComponentProps } from "@/types/provider";

export const SpacesProvider: React.FC<ProviderComponentProps> = ({ searchQuery, onSelect, onAction }) => {
  const { spaces, setActiveSpaceById } = useSpaces();
  
  const filteredSpaces = spaces.filter((space) => 
    space.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    space.description?.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const handleSelect = async (space: Space): Promise<void> => {
    try {
      if (!space || !space.id) {
        console.error('[SpacesProvider] Cannot select space: Invalid space or missing ID', space);
        return;
      }

      console.log('[SpacesProvider] Selecting space:', space.id, space.name);
      
      // Ensure space.id is a string and not null/undefined
      const spaceId = String(space.id);
      
      try {
        const success = await setActiveSpaceById(spaceId);
        if (success) {
          if (onSelect) onSelect({...space, closeOnSelect: true});
        } else {
          console.error('[SpacesProvider] Error setting active space');
        }
      } catch (error) {
        console.error('[SpacesProvider] Exception setting active space:', error);
      }
    } catch (error) {
      console.error('[SpacesProvider] Error handling space selection:', error);
    }
  };

  const handleEdit = (e: React.MouseEvent<HTMLButtonElement>, space: Space): void => {
    e.stopPropagation();
    e.preventDefault();
    if (onAction) onAction('edit', space);
  };

  const handleDelete = (e: React.MouseEvent<HTMLButtonElement>, space: Space): void => {
    e.stopPropagation();
    e.preventDefault();
    if (onAction) onAction('delete', space);
  };

  const handleCreate = (): void => {
    if (onAction) onAction('create', {});
  };

  return (
    <Command.List>
      <Command.Group heading="Spaces">
        {filteredSpaces.length === 0 ? (
          <Command.Empty>No spaces found</Command.Empty>
        ) : (
          filteredSpaces.map((space: Space) => (
            <Command.Item
              key={space.id}
              value={space.name}
              onSelect={() => handleSelect(space)}
            >
              <Globe size={16} style={{ color: space.color || 'var(--primary)' }} />
              <div>
                {space.name}
                {space.description && (
                  <span className="cmdk-meta">{space.description}</span>
                )}
              </div>
              <div className="cmdk-actions">
                <Button 
                  variant="ghost"
                  size="icon"
                  onClick={(e) => handleEdit(e, space)}
                >
                  <PencilLine size={14} />
                </Button>
                <Button 
                  variant="ghost"
                  size="icon"
                  onClick={(e) => handleDelete(e, space)}
                >
                  <Trash size={14} />
                </Button>
              </div>
            </Command.Item>
          ))
        )}
      </Command.Group>
      <Command.Separator />
      <Command.Group>
        <Command.Item onSelect={handleCreate}>
          <Plus size={16} />
          Create new space
        </Command.Item>
      </Command.Group>
    </Command.List>
  );
};

================
File: src/components/providers/SuggestionsProvider.tsx
================
import React, { useState, useEffect } from 'react';
import { Lightbulb, Check, X, Plus } from 'lucide-react';
import { toast } from 'sonner';
import { Command } from 'cmdk';
import { Button } from "@/components/ui/button";
import { ProviderComponentProps } from "@/types/provider";

interface Suggestion {
  id: string;
  description: string;
  source: string;
  confidence: number;
  createdAt: number;
  accepted?: boolean;
}

export function SuggestionsProvider({ searchQuery = '', onSelect, onAction }: ProviderComponentProps) {
  const [suggestions, setSuggestions] = useState<Suggestion[]>([
    {
      id: 'suggestion-1',
      description: 'Open settings to configure application preferences',
      source: 'User activity analysis',
      confidence: 0.85,
      createdAt: Date.now() - 3600000,
    },
    {
      id: 'suggestion-2',
      description: 'Create a new conversation in Project Space',
      source: 'Recent workspace activity',
      confidence: 0.75,
      createdAt: Date.now() - 7200000,
    }
  ]);

  const addSuggestion = (description: string, source: string, confidence: number = 0.8) => {
    const newSuggestion: Suggestion = {
      id: `suggestion-${Date.now()}`,
      description,
      source,
      confidence,
      createdAt: Date.now(),
    };
    
    setSuggestions(prevSuggestions => [...prevSuggestions, newSuggestion]);
    return newSuggestion.id;
  };

  const acceptSuggestion = (suggestionId: string) => {
    setSuggestions(prevSuggestions => {
      const suggestion = prevSuggestions.find(s => s.id === suggestionId);
      
      if (suggestion) {
        toast.success('Suggestion Accepted', {
          description: `Now executing: ${suggestion.description}`
        });
        if (onSelect) onSelect({...suggestion, closeOnSelect: true});
      }
      
      return prevSuggestions.map(suggestion => 
        suggestion.id === suggestionId 
          ? { ...suggestion, accepted: true } 
          : suggestion
      );
    });
  };

  const rejectSuggestion = (suggestionId: string) => {
    setSuggestions(prevSuggestions => prevSuggestions.filter(s => s.id !== suggestionId));
    toast.info('Suggestion Dismissed');
  };

  const handleSelect = (suggestion: Suggestion) => {
    acceptSuggestion(suggestion.id);
  };

  const handleAccept = (e: React.MouseEvent, suggestionId: string) => {
    e.stopPropagation();
    e.preventDefault();
    acceptSuggestion(suggestionId);
  };

  const handleReject = (e: React.MouseEvent, suggestionId: string) => {
    e.stopPropagation();
    e.preventDefault();
    rejectSuggestion(suggestionId);
  };

  const handleCreate = () => {
    if (onAction) onAction('create', {});
  };

  useEffect(() => {
    const api = {
      addSuggestion,
      acceptSuggestion,
      rejectSuggestion
    };
    (window as any).suggestions = api;
    return () => {
      delete (window as any).suggestions;
    };
  }, []);

  const filteredSuggestions = suggestions.filter(suggestion => 
    suggestion.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
    suggestion.source.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <Command.List>
      <Command.Group heading="Suggestions">
        {filteredSuggestions.length === 0 ? (
          <Command.Empty>No suggestions available</Command.Empty>
        ) : (
          filteredSuggestions.map(suggestion => (
            <Command.Item
              key={suggestion.id}
              value={suggestion.description}
              onSelect={() => handleSelect(suggestion)}
            >
              <Lightbulb size={16} className="text-amber-500" />
              <div>
                {suggestion.description}
                <span className="cmdk-meta">{suggestion.source}</span>
              </div>
              <div className="cmdk-actions">
                <span className="text-amber-500">
                  {Math.round(suggestion.confidence * 100)}%
                </span>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={(e) => handleAccept(e, suggestion.id)}
                >
                  <Check size={14} />
                </Button>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={(e) => handleReject(e, suggestion.id)}
                >
                  <X size={14} />
                </Button>
              </div>
            </Command.Item>
          ))
        )}
      </Command.Group>
      <Command.Separator />
      <Command.Group>
        <Command.Item onSelect={handleCreate}>
          <Plus size={16} />
          Create new suggestion
        </Command.Item>
      </Command.Group>
    </Command.List>
  );
}

================
File: src/components/shared/dropdown-list.tsx
================
import React, { useState, useEffect, useRef, KeyboardEvent } from 'react';
import {
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
} from '@/components/ui/dropdown-menu';
import { Button } from '@/components/ui/button';

export interface DropdownItem {
  id: string;
  content: React.ReactNode;
  isActive?: boolean;
  isDisabled?: boolean;
  onSelect?: () => void;
}

export interface DropdownSection {
  title: string;
  items: DropdownItem[];
  actionButton?: {
    icon: React.ReactNode;
    label?: string;
    onClick: () => void;
    isLoading?: boolean;
    ariaLabel: string;
  };
}

export interface DropdownFooterAction {
  icon: React.ReactNode;
  label: string;
  onClick: (itemId: string) => void;
  variant?: 'default' | 'destructive';
  isDisabled?: boolean | ((itemId: string) => boolean);
  shouldShow?: (itemId: string) => boolean;
}

export interface DropdownListProps {
  sections: DropdownSection[];
  footerActions: DropdownFooterAction[];
  emptyState?: React.ReactNode;
  className?: string;
  headerContent?: React.ReactNode;
}

export function DropdownList({
  sections,
  footerActions,
  emptyState,
  className = '',
  headerContent,
}: DropdownListProps) {
  const [highlightedItemId, setHighlightedItemId] = useState<string | null>(null);
  const [keyboardControlActive, setKeyboardControlActive] = useState(false);
  const itemsRef = useRef<Map<string, HTMLElement>>(new Map());
  const allItems = sections.flatMap(section => section.items);
  
  // Set the first item as highlighted by default
  useEffect(() => {
    if (allItems.length > 0 && !highlightedItemId) {
      setHighlightedItemId(allItems[0].id);
    }
  }, [allItems, highlightedItemId]);

  const handleKeyDown = (e: KeyboardEvent) => {
    if (!allItems.length) return;
    
    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
      e.preventDefault();
      setKeyboardControlActive(true); // Enable keyboard control mode
      
      const currentIndex = allItems.findIndex(item => item.id === highlightedItemId);
      let newIndex;
      
      if (e.key === 'ArrowDown') {
        newIndex = currentIndex === allItems.length - 1 ? 0 : currentIndex + 1;
      } else {
        newIndex = currentIndex <= 0 ? allItems.length - 1 : currentIndex - 1;
      }
      
      // Skip disabled items
      while (allItems[newIndex].isDisabled && newIndex !== currentIndex) {
        newIndex = e.key === 'ArrowDown' 
          ? (newIndex === allItems.length - 1 ? 0 : newIndex + 1)
          : (newIndex <= 0 ? allItems.length - 1 : newIndex - 1);
      }
      
      const newItem = allItems[newIndex];
      setHighlightedItemId(newItem.id);
      
      // Scroll into view
      const element = itemsRef.current.get(newItem.id);
      if (element) {
        element.scrollIntoView({ block: 'nearest' });
      }
    } else if (e.key === 'Tab' || e.key === 'Escape') {
      // Disable keyboard mode when Tab or Escape is pressed
      setKeyboardControlActive(false);
    }
  };
  
  // Handle mouse click on container - disables keyboard control
  const handleMouseDown = () => {
    setKeyboardControlActive(false);
  };
  
  // Handle mouse hover on items
  const handleItemHover = (itemId: string) => {
    // Only update highlight if keyboard control is NOT active
    if (!keyboardControlActive) {
      setHighlightedItemId(itemId);
    }
  };

  // Check if any section has items
  const hasItems = sections.some(section => section.items.length > 0);

  return (
    <DropdownMenuContent 
      align="center" 
      className={`w-[340px] max-h-[480px] flex flex-col p-0 border border-white/10 shadow-xl ${className}`}
      sideOffset={4}
      onKeyDown={handleKeyDown}
      onMouseDown={handleMouseDown}
    >
      {headerContent && (
        <div className="flex-shrink-0 pt-2">
          {headerContent}
          {hasItems && <DropdownMenuSeparator className="my-1.5" />}
        </div>
      )}
      
      <div className="flex-1 overflow-y-auto py-2 px-0 min-h-0">
        {hasItems ? (
          <div role="menu">
            {sections.map((section, sectionIndex) => (
              <div key={section.title || sectionIndex} className="mb-3">
                <div className="px-3 mb-1 flex items-center justify-between">
                  <div className="text-xs uppercase tracking-wider text-white/40 font-medium">
                    {section.title}
                  </div>
                  {section.actionButton && (
                    <Button
                      variant="ghost"
                      size="icon"
                      className="h-6 w-6 rounded-full hover:bg-white/[0.06]"
                      onClick={section.actionButton.onClick}
                      disabled={section.actionButton.isLoading}
                      aria-label={section.actionButton.ariaLabel}
                    >
                      {section.actionButton.icon}
                    </Button>
                  )}
                </div>

                <div className="px-0.5 space-y-0.5">
                  {section.items.length === 0 ? (
                    <div className="px-3 py-2 text-sm text-white/50 text-center">
                      No items available
                    </div>
                  ) : (
                    section.items.map((item) => (
                      <DropdownMenuItem
                        key={item.id}
                        ref={(el) => {
                          if (el) itemsRef.current.set(item.id, el);
                          else itemsRef.current.delete(item.id);
                        }}
                        className={`flex items-start py-2 px-3 cursor-pointer mx-1.5 rounded-md transition-all duration-150 
                          ${item.isActive ? 'bg-white/[0.06]' : 'hover:bg-white/[0.04]'}
                          ${item.isDisabled ? 'opacity-50 cursor-not-allowed' : ''}
                          ${highlightedItemId === item.id ? 'ring-1 ring-white/20' : ''}
                        `}
                        onSelect={() => !item.isDisabled && item.onSelect?.()}
                        disabled={item.isDisabled}
                        onMouseEnter={() => handleItemHover(item.id)}
                        onClick={() => setKeyboardControlActive(false)} // Disable keyboard mode on click
                        role="menuitem"
                        tabIndex={0}
                      >
                        {item.content}
                      </DropdownMenuItem>
                    ))
                  )}
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="px-3 py-6 flex-1 flex items-center justify-center">
            {emptyState || <span className="text-sm text-white/50">No items available</span>}
          </div>
        )}
      </div>
      
      {/* Footer with actions */}
      {hasItems && footerActions.length > 0 && (
        <div className="flex-shrink-0 w-full bg-[#0e0e10] border-t border-white/[0.08] pt-1.5 pb-1.5">
          <div className="px-3 py-1.5 flex justify-center items-center">
            {footerActions
              .filter(action => !action.shouldShow || action.shouldShow(highlightedItemId || ''))
              .map((action, index) => (
                <Button
                  key={index}
                  variant={action.variant === 'destructive' ? 'ghost' : 'ghost'}
                  size="sm"
                  className={`text-xs ${
                    action.variant === 'destructive' 
                      ? 'text-red-400/80 hover:text-red-400 hover:bg-red-400/10' 
                      : 'text-white/50 hover:text-white/90 hover:bg-white/[0.05]'
                  } h-7 px-2 ${index > 0 ? 'ml-2' : ''}`}
                  onClick={() => action.onClick(highlightedItemId || '')}
                  disabled={
                    typeof action.isDisabled === 'function' 
                      ? action.isDisabled(highlightedItemId || '') 
                      : action.isDisabled || !highlightedItemId
                  }
                >
                  {action.icon && <span className="mr-1.5">{action.icon}</span>}
                  <span>{action.label}</span>
                </Button>
              ))}
          </div>
        </div>
      )}
    </DropdownMenuContent>
  );
}

================
File: src/components/shared/model-display.tsx
================
import { ProviderIcon } from "@/components/chat/provider-icon";
import { ModelDisplayInfo } from "@/utils/model-utils";

interface ModelDisplayProps {
  modelInfo: ModelDisplayInfo;
  showDescription?: boolean;
  showIcon?: boolean;
  className?: string;
}

export function ModelDisplay({ modelInfo, showDescription = false, showIcon = true, className = "" }: ModelDisplayProps) {
  return (
    <div className={`flex items-center gap-1.5 ${className}`}>
      {showIcon && (
        <div className="px-2 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-linear-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
          <ProviderIcon provider={modelInfo.provider} size={14} />
        </div>
      )}
      <div className="px-2.5 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-linear-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <span className="text-white">{modelInfo.displayName}</span>
      </div>
      {showDescription && modelInfo.description && (
        <span className="text-[10px] text-white/60">{modelInfo.description}</span>
      )}
    </div>
  );
}

================
File: src/components/space/planet-icon.tsx
================
import React, { useState, useMemo, useCallback } from 'react';

interface DotSphereProps {
  size?: number;
  seed?: string;
  dotCount?: number;
  dotSize?: number;
  className?: string;
  expandFactor?: number;
  transitionSpeed?: number;
  highPerformance?: boolean;
}

interface DotSphereComponent extends React.FC<DotSphereProps> {
  seedCache: Map<string, number>;
  callCount: number;
}

const round = (num: number, precision: number = 6): number => {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
};

const Dot = React.memo(({ 
  dot, 
  isHovering, 
  size, 
  expandFactor, 
  transitionSpeed 
}: { 
  dot: {
    x: number;
    y: number;
    z: number;
    color: string;
    size: number;
    opacity: number;
    zIndex: number;
  };
  isHovering: boolean;
  size: number;
  expandFactor: number;
  transitionSpeed: number;
}) => {
  const expandedX = useMemo(() => 
    round(dot.x + (dot.x - size / 2) * (expandFactor - 1), 6),
    [dot.x, size, expandFactor]
  );
  
  const expandedY = useMemo(() => 
    round(dot.y + (dot.y - size / 2) * (expandFactor - 1), 6),
    [dot.y, size, expandFactor]
  );
  
  const expandedZ = useMemo(() => 
    round(dot.z * expandFactor, 6), 
    [dot.z, expandFactor]
  );

  const currentX = isHovering ? expandedX : dot.x;
  const currentY = isHovering ? expandedY : dot.y;
  const currentZ = isHovering ? expandedZ : dot.z;

  return (
    <div
      className="absolute rounded-full"
      style={{
        backgroundColor: dot.color,
        width: `${round(dot.size, 6)}px`,
        height: `${round(dot.size, 6)}px`,
        opacity: round(dot.opacity, 6),
        transform: `translate3d(${round(currentX, 6)}px, ${round(currentY, 6)}px, ${round(currentZ, 6)}px)`,
        transitionProperty: 'transform',
        transitionDuration: `${transitionSpeed}ms`,
        transitionTimingFunction: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
        transitionDelay: '0s',
        zIndex: dot.zIndex,
        willChange: 'transform'
      }}
    />
  );
});

Dot.displayName = 'Dot';

const DotSphere: DotSphereComponent = ({
  size = 120,
  seed,
  dotCount = 150,
  dotSize = 2.5,
  className = '',
  expandFactor = 1.3,
  transitionSpeed = 800,
  highPerformance = false,
}) => {
  const [isHovering, setIsHovering] = useState(false);

  const actualDotCount = highPerformance ? Math.min(dotCount, 60) : dotCount;

  const seedNum = useMemo(() => {
    if (!seed) return Math.floor(Math.random() * 10000);
    
    if (!DotSphere.seedCache.has(seed)) {
      const hash = Array.from(seed).reduce((acc, char) => acc + char.charCodeAt(0), 0);
      DotSphere.seedCache.set(seed, hash);
    }
    
    return DotSphere.seedCache.get(seed)!;
  }, [seed]);

  const random = useCallback(() => {
    let x = Math.sin(seedNum + DotSphere.callCount++) * 10000;
    return x - Math.floor(x);
  }, [seedNum]);

  const dots = useMemo(() => {
    const sphereRadius = round((size / 2 - dotSize) * 0.8, 6);
    const points = [];
    const goldenRatio = (1 + Math.sqrt(5)) / 2;
    
    DotSphere.callCount = 1;

    for (let i = 0; i < actualDotCount; i++) {
      const y = round(1 - (i / (actualDotCount - 1)) * 2, 6);
      const radius = round(Math.sqrt(1 - y * y), 6);
      const theta = round(2 * Math.PI * i / goldenRatio, 6);
      const x = round(Math.cos(theta) * radius, 6);
      const z = round(Math.sin(theta) * radius, 6);

      const hue = round((seedNum % 360) + (i * 137.5) % 360, 2);
      const saturation = round(70 + random() * 30, 2);
      const lightness = round(45 + random() * 30, 2);
      const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

      const sizeVariation = round(0.8 + random() * 0.6, 6);
      const finalDotSize = round(dotSize * sizeVariation, 6);

      const posX = round(x * sphereRadius + size / 2, 6);
      const posY = round(y * sphereRadius + size / 2, 6);
      const posZ = round(z * sphereRadius, 6);

      const zIndex = Math.floor(posZ);
      const opacity = round(0.6 + (posZ / sphereRadius) * 0.4, 6);

      points.push({
        x: posX,
        y: posY,
        z: posZ,
        color,
        size: finalDotSize,
        opacity,
        zIndex,
      });
    }

    return points.sort((a, b) => a.zIndex - b.zIndex);
  }, [actualDotCount, dotSize, random, seedNum, size]);

  const handleMouseEnter = useCallback(() => setIsHovering(true), []);
  const handleMouseLeave = useCallback(() => setIsHovering(false), []);

  return (
    <div
      className={`relative ${className}`}
      style={{
        width: size,
        height: size,
        perspective: size * 3,
      }}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <div
        className="relative w-full h-full"
        style={{ transformStyle: 'preserve-3d' }}
      >
        {dots.map((dot, index) => (
          <Dot 
            key={index}
            dot={dot}
            isHovering={isHovering}
            size={size}
            expandFactor={expandFactor}
            transitionSpeed={transitionSpeed}
          />
        ))}
      </div>
    </div>
  );
};

DotSphere.seedCache = new Map<string, number>();
DotSphere.callCount = 1;

export default DotSphere;

================
File: src/components/ui/accordion.tsx
================
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

================
File: src/components/ui/alert-dialog.tsx
================
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/utils"
import { buttonVariants } from "@/components/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/70 backdrop-blur-sm",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-white/[0.03] backdrop-blur-xl border border-white/[0.05] data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg p-6 shadow-lg duration-200 sm:max-w-lg animate-command-dialog-pop",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

================
File: src/components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "text-destructive-foreground [&>svg]:text-current *:data-[slot=alert-description]:text-destructive-foreground/80",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }

================
File: src/components/ui/aspect-ratio.tsx
================
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

function AspectRatio({
  ...props
}: React.ComponentProps<typeof AspectRatioPrimitive.Root>) {
  return <AspectRatioPrimitive.Root data-slot="aspect-ratio" {...props} />
}

export { AspectRatio }

================
File: src/components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full border border-white/[0.05]",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-white/[0.03] text-white/80 backdrop-blur-xs",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: src/components/ui/badge.tsx
================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/utils";

const badgeVariants = cva(
  "inline-flex items-center border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80 rounded-full",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80 rounded-full",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80 rounded-full",
        outline: "text-foreground rounded-full",
        active: "bg-[#3ecfff]/10 text-[#3ecfff] border border-[#3ecfff]/20 rounded-md",
        info: "text-white/40 border border-white/10 rounded-md",
        count: "bg-white/5 text-white/60 border-transparent rounded-md",
      },
      size: {
        default: "px-2.5 py-0.5 text-xs",
        sm: "px-1.5 py-0.5 text-[10px]",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {
    /**
     * The visual style of the badge
     * @default "default"
     */
    variant?: "default" | "secondary" | "destructive" | "outline" | "active" | "info" | "count";
    
    /**
     * The size of the badge
     * @default "default"
     */
    size?: "default" | "sm";
}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

================
File: src/components/ui/base-tab.tsx
================
import { CommandType } from '@/types/command'
import { ReactNode, CSSProperties } from 'react'

interface BaseTabProps {
  icon?: ReactNode
  label: string
  shortcut?: string
  onClick?: () => void
  minWidth?: 'space' | 'model' | 'actions'
  roundedBottom?: boolean
  isActive?: boolean
  style?: CSSProperties
  wrapperStyle?: CSSProperties
  className?: string
  color?: string
  rightElement?: ReactNode
  commandType?: CommandType
}

export function BaseTab({
  icon,
  color,
  label,
  shortcut,
  onClick,
  minWidth,
  style,
  wrapperStyle,
  className = '',
  rightElement,
  commandType
}: BaseTabProps) {
  const minWidthClass = {
    space: 'min-w-[100px]',
    model: 'min-w-[120px]',
    actions: ''
  }[minWidth || 'actions']

  return (
    <div
      className={`relative w-full overflow-hidden`}
      style={{ 
        ...wrapperStyle 
      }}
    >
      <div
        onClick={onClick}
        className={`px-3 py-1.5 text-white text-xs font-medium flex items-center gap-1.5 relative overflow-hidden cursor-pointer ${minWidthClass}
           transition-all duration-300 group ${className} w-full`}
        style={{ 
          ...style,
        }}
      >
        {icon && (
          <div className="relative z-10 text-white/60 group-hover:text-[#3ecfff]/80 transition-colors duration-300 shrink-0">
            {icon}
          </div>
        )}
        <div className="flex-1 min-w-0 overflow-hidden">
          <span className="text-white/75 truncate relative z-10 group-hover:text-white/95 transition-colors duration-300 block">
            {label}
          </span>
        </div>
        {shortcut && (
          <span className="text-white/60 text-[10px] ml-1 shrink-0 relative z-10">⌘{shortcut}</span>
        )}
        {rightElement && (
          <div className="ml-auto relative z-10 shrink-0">
            {rightElement}
          </div>
        )}
      </div>
    </div>
  )
}

================
File: src/components/ui/breadcrumb.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}

================
File: src/components/ui/button.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center text-sm font-medium transition-all duration-200 focus-visible:outline-hidden disabled:opacity-50 disabled:pointer-events-none",
  {
    variants: {
      variant: {
        transparent: "bg-transparent text-white",
        default: "bg-primary text-white hover:bg-primary/90",
        outline: "border border-white/[0.05] bg-white/[0.02] text-white/90 hover:bg-white/[0.05] hover:text-white backdrop-blur-xs",
        ghost: "text-white/70 hover:bg-white/[0.04] hover:text-white",
        toggle: "text-white/70 hover:bg-white/[0.04] hover:text-white border-t border-white/[0.05] rounded-t-md rounded-b-none",
        cyan: "bg-[#3ecfff]/10 text-[#3ecfff] border border-[#3ecfff]/20 shadow-[0_0_12px_rgba(62,207,255,0.1)] hover:bg-[#3ecfff]/20 rounded-xl",
        destructive: "bg-red-500/10 text-red-500 hover:bg-red-500/20 border border-red-500/20",
        gradient: "bg-gradient-to-r from-indigo-500 to-blue-500 text-white shadow-sm hover:from-indigo-600 hover:to-blue-600",
      },
      size: {
        default: "h-10 py-2 px-4 rounded-md",
        sm: "h-8 px-3 rounded-md",
        icon: "h-8 w-8 rounded-md",
        lg: "h-12 px-6 rounded-md",
      },
      rounded: {
        default: "rounded-md",
        full: "rounded-full",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
      rounded: "default",
    },
  },
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  active?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, rounded, active, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, rounded, className }), active && "bg-white/[0.05] text-white")}
        ref={ref}
        {...props}
      />
    )
  },
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: src/components/ui/calendar.tsx
================
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/utils"
import { buttonVariants } from "@/components/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row gap-2",
        month: "flex flex-col gap-4",
        caption: "flex justify-center pt-1 relative items-center w-full",
        caption_label: "text-sm font-medium",
        nav: "flex items-center gap-1",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "size-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-x-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "size-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start:
          "day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_range_end:
          "day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("size-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("size-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}

export { Calendar }

================
File: src/components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & {
    glass?: boolean;
    border?: boolean;
    hover?: boolean;
    intensity?: 'low' | 'medium' | 'high';
    blur?: 'sm' | 'md' | 'lg';
  }
>(({ 
  className, 
  glass = false, 
  border = true, 
  hover = true, 
  intensity = 'medium',
  blur = 'md',
  ...props 
}, ref) => {
  
  const intensityStyles = {
    low: 'bg-black/20',
    medium: 'bg-black/40',
    high: 'bg-black/60'
  };
  
  const blurStyles = {
    sm: 'backdrop-blur-sm',
    md: 'backdrop-blur-md',
    lg: 'backdrop-blur-xl'
  };

  return (
    <div
      ref={ref}
      className={cn(
        "rounded-xl p-4",
        glass ? intensityStyles[intensity] : "bg-card",
        glass ? blurStyles[blur] : "",
        border ? "border border-white/10" : "",
        hover ? "transition-all hover:border-white/20 hover:bg-black/50" : "",
        className
      )}
      {...props}
    />
  );
})
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: src/components/ui/carousel.tsx
================
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/utils"
import { Button } from "@/components/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

function Carousel({
  orientation = "horizontal",
  opts,
  setApi,
  plugins,
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & CarouselProps) {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === "horizontal" ? "x" : "y",
    },
    plugins
  )
  const [canScrollPrev, setCanScrollPrev] = React.useState(false)
  const [canScrollNext, setCanScrollNext] = React.useState(false)

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) return
    setCanScrollPrev(api.canScrollPrev())
    setCanScrollNext(api.canScrollNext())
  }, [])

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev()
  }, [api])

  const scrollNext = React.useCallback(() => {
    api?.scrollNext()
  }, [api])

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === "ArrowLeft") {
        event.preventDefault()
        scrollPrev()
      } else if (event.key === "ArrowRight") {
        event.preventDefault()
        scrollNext()
      }
    },
    [scrollPrev, scrollNext]
  )

  React.useEffect(() => {
    if (!api || !setApi) return
    setApi(api)
  }, [api, setApi])

  React.useEffect(() => {
    if (!api) return
    onSelect(api)
    api.on("reInit", onSelect)
    api.on("select", onSelect)

    return () => {
      api?.off("select", onSelect)
    }
  }, [api, onSelect])

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation:
          orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        onKeyDownCapture={handleKeyDown}
        className={cn("relative", className)}
        role="region"
        aria-roledescription="carousel"
        data-slot="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  )
}

function CarouselContent({ className, ...props }: React.ComponentProps<"div">) {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div
      ref={carouselRef}
      className="overflow-hidden"
      data-slot="carousel-content"
    >
      <div
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CarouselItem({ className, ...props }: React.ComponentProps<"div">) {
  const { orientation } = useCarousel()

  return (
    <div
      role="group"
      aria-roledescription="slide"
      data-slot="carousel-item"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
}

function CarouselPrevious({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      data-slot="carousel-previous"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -left-12 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
}

function CarouselNext({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      data-slot="carousel-next"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -right-12 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight />
      <span className="sr-only">Next slide</span>
    </Button>
  )
}

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}

================
File: src/components/ui/chart.tsx
================
import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<"div"> & {
  config: ChartConfig
  children: React.ComponentProps<
    typeof RechartsPrimitive.ResponsiveContainer
  >["children"]
}) {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-slot="chart"
        data-chart={chartId}
        className={cn(
          "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = "dot",
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<"div"> & {
    hideLabel?: boolean
    hideIndicator?: boolean
    indicator?: "line" | "dot" | "dashed"
    nameKey?: string
    labelKey?: string
  }) {
  const { config } = useChart()

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null
    }

    const [item] = payload
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value =
      !labelKey && typeof label === "string"
        ? config[label as keyof typeof config]?.label || label
        : itemConfig?.label

    if (labelFormatter) {
      return (
        <div className={cn("font-medium", labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      )
    }

    if (!value) {
      return null
    }

    return <div className={cn("font-medium", labelClassName)}>{value}</div>
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ])

  if (!active || !payload?.length) {
    return null
  }

  const nestLabel = payload.length === 1 && indicator !== "dot"

  return (
    <div
      className={cn(
        "border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl",
        className
      )}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          const indicatorColor = color || item.payload.fill || item.color

          return (
            <div
              key={item.dataKey}
              className={cn(
                "[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5",
                indicator === "dot" && "items-center"
              )}
            >
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div
                        className={cn(
                          "shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)",
                          {
                            "h-2.5 w-2.5": indicator === "dot",
                            "w-1": indicator === "line",
                            "w-0 border-[1.5px] border-dashed bg-transparent":
                              indicator === "dashed",
                            "my-0.5": nestLabel && indicator === "dashed",
                          }
                        )}
                        style={
                          {
                            "--color-bg": indicatorColor,
                            "--color-border": indicatorColor,
                          } as React.CSSProperties
                        }
                      />
                    )
                  )}
                  <div
                    className={cn(
                      "flex flex-1 justify-between leading-none",
                      nestLabel ? "items-end" : "items-center"
                    )}
                  >
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">
                        {itemConfig?.label || item.name}
                      </span>
                    </div>
                    {item.value && (
                      <span className="text-foreground font-mono font-medium tabular-nums">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          )
        })}
      </div>
    </div>
  )
}

const ChartLegend = RechartsPrimitive.Legend

function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = "bottom",
  nameKey,
}: React.ComponentProps<"div"> &
  Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
    hideIcon?: boolean
    nameKey?: string
  }) {
  const { config } = useChart()

  if (!payload?.length) {
    return null
  }

  return (
    <div
      className={cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className
      )}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`
        const itemConfig = getPayloadConfigFromPayload(config, item, key)

        return (
          <div
            key={item.value}
            className={cn(
              "[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3"
            )}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        )
      })}
    </div>
  )
}

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}

================
File: src/components/ui/checkbox.tsx
================
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

================
File: src/components/ui/code-block.tsx
================
"use client"

import { cn } from "@/utils"
import React, { useEffect, useState } from "react"
import { codeToHtml } from "shiki"
import { Copy, CheckIcon } from "lucide-react"

interface CopyButtonProps {
  code: string
}

function CopyButton({ code }: CopyButtonProps) {
  const [copied, setCopied] = useState(false)

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(code)
      setCopied(true)
      setTimeout(() => setCopied(false), 2000)
    } catch (error) {
      console.error('Failed to copy:', error)
    }
  }

  return (
    <button
      onClick={handleCopy}
      className={cn(
        "flex items-center justify-center rounded-md p-1.5",
        "transition-all duration-200 ease-in-out",
        "bg-white/[0.03] hover:bg-white/[0.08] border border-white/[0.05]",
        copied 
          ? "text-green-400 hover:text-green-300 border-green-500/20 bg-green-500/10" 
          : "text-zinc-400 hover:text-zinc-200"
      )}
      title="Copy code"
    >
      {copied ? <CheckIcon size={14} /> : <Copy size={14} />}
    </button>
  )
}

export type CodeBlockProps = {
  children?: React.ReactNode
  className?: string
  code?: string
  language?: string
} & React.HTMLProps<HTMLDivElement>

function CodeBlock({ children, className, code, language, ...props }: CodeBlockProps) {
  // Generate a unique key based on code content or props if available
  const uniqueKey = React.useMemo(() => {
    return code ? `${language}-${code.slice(0, 20)}-${Math.random().toString(36).slice(2, 7)}` : `codeblock-${Math.random().toString(36).slice(2)}`
  }, [code, language])

  if (code && language) {
    return (
      <div
        className={cn(
          "not-prose flex w-full flex-col overflow-hidden my-4 rounded-lg",
          "glass-effect code-block-glow glass-highlight",
          className
        )}
        style={{
          background: 'rgba(255, 255, 255, 0.02)',
          backdropFilter: 'blur(12px)',
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
          border: '1px solid rgba(255, 255, 255, 0.05)'
        }}
        key={uniqueKey} // Add unique key at the top level
        {...props}
      >
        <div className="flex items-center justify-between w-full px-4 py-2 header" style={{background: 'rgba(255, 255, 255, 0.03)', borderBottom: '1px solid rgba(255, 255, 255, 0.05)'}}>
          <div className="flex items-center space-x-2">
            <div className="flex space-x-1.5">
              <div className="w-3 h-3 rounded-full bg-red-500/90 border border-red-600/30 shadow-inner shadow-red-700/20"></div>
              <div className="w-3 h-3 rounded-full bg-yellow-500/90 border border-yellow-600/30 shadow-inner shadow-yellow-700/20"></div>
              <div className="w-3 h-3 rounded-full bg-green-500/90 border border-green-600/30 shadow-inner shadow-green-700/20"></div>
            </div>
            <div className="text-xs text-zinc-400 ml-2">
              {code.split('\n')[0].startsWith('//') ? code.split('\n')[0].substring(2).trim() : ''}
            </div>
          </div>
          <div className="flex items-center gap-2">
          {language && (
                    <div 
                      className="flex items-center gap-1.5 text-xs rounded-md p-1.5 bg-white/[0.03] border border-white/[0.05] text-zinc-400"
                      key={`language-badge-${uniqueKey}`}
                    >
                      <span>{language}</span>
                    </div>
                  )}
            <CopyButton code={code} />
          </div>
        </div>
        <CodeBlockCode code={code} language={language} />
      </div>
    )
  }
  
  return (
    <div
      className={cn(
        "not-prose flex w-full flex-col overflow-hidden my-4 rounded-lg",
        "glass-effect code-block-glow glass-highlight",
        className
      )}
      style={{
        background: 'rgba(255, 255, 255, 0.02)',
        backdropFilter: 'blur(12px)',
        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }}
      key={uniqueKey} // Add unique key here too
      {...props}
    >
      {children}
    </div>
  )
}

export type CodeBlockCodeProps = {
  code: string
  language?: string
  theme?: string
  className?: string
} & React.HTMLProps<HTMLDivElement>

function CodeBlockCode({
  code,
  language = "tsx",
  theme = "github-dark",
  className,
  ...props
}: CodeBlockCodeProps) {
  const [highlightedHtml, setHighlightedHtml] = useState<string | null>(null)
  const [isLargeCode, setIsLargeCode] = useState(false)
  const codeLength = code?.length || 0

  useEffect(() => {
    if (codeLength > 10000) {
      setIsLargeCode(true)
    } else {
      setIsLargeCode(false)
    }

    let isMounted = true
    
    const timer = setTimeout(async () => {
      try {
        const customTheme = {
          name: 'glass-dark',
          type: 'dark',
          fg: '#EEEEEE',
          bg: '#00000000',
          settings: [
            {
              settings: {
                background: '#00000000',
                foreground: '#EEEEEE',
                caret: '#FFFFFF',
                selection: 'rgba(128, 203, 255, 0.2)',
                selectionBorder: 'rgba(128, 203, 255, 0.4)',
                lineHighlight: 'rgba(255, 255, 255, 0.05)',
                gutterForeground: 'rgba(175, 175, 175, 0.5)',
                gutterBorder: 'rgba(255, 255, 255, 0.05)',
              }
            },
            {
              scope: ['comment', 'punctuation.definition.comment', 'string.comment'],
              settings: {
                foreground: 'rgba(106, 153, 85, 0.9)'
              }
            },
            {
              scope: ['string', 'constant.other.symbol'],
              settings: {
                foreground: 'rgba(206, 145, 120, 0.9)'
              }
            },
            {
              scope: ['keyword', 'storage.type', 'storage.modifier'],
              settings: {
                foreground: 'rgba(86, 156, 214, 0.9)'
              }
            },
            {
              scope: ['entity.name.function', 'support.function'],
              settings: {
                foreground: 'rgba(220, 220, 170, 0.9)'
              }
            },
            {
              scope: ['variable', 'support.variable'],
              settings: {
                foreground: 'rgba(156, 220, 254, 0.9)'
              }
            }
          ]
        };

        const html = await codeToHtml(code, { 
          lang: language, 
          theme: "github-dark",
          transformers: [{
            root(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            pre(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            code(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            line(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              if (style.includes('background')) {
                nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              }
              return node;
            },
            tokens(node) {
              return node.map((token: any, index: number) => {
                const tokenAsAny = token as any;
                if (!tokenAsAny.properties) tokenAsAny.properties = {};
                const style = tokenAsAny.properties.style || '';
                if (style.includes('background')) {
                  tokenAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, '');
                }
                tokenAsAny.properties.key = `token-${index}`;
                return token;
              });
            }
          }]
        });

        if (isMounted) {
          const processedHtml = html
            .replace(/background-color: #24292e;/g, 'background-color: transparent !important;')
            .replace(/background-color: #1f2428;/g, 'background-color: transparent !important;')
            .replace(/background: #24292e;/g, 'background: transparent !important;')
            .replace(/background: #1f2428;/g, 'background: transparent !important;');
          
          setHighlightedHtml(processedHtml);
        }
      } catch (error) {
        console.error('Error highlighting code:', error)
      }
    }, isLargeCode ? 100 : 0)

    return () => {
      isMounted = false
      clearTimeout(timer)
    }
  }, [code, language, theme, codeLength, isLargeCode])

  const classNames = cn(
    "w-full overflow-x-auto text-[13px] relative",
    "bg-transparent [&>pre]:bg-transparent [&>pre]:px-4 [&>pre]:py-4 [&>pre]:rounded-b-lg",
    "[&>pre>code]:bg-transparent [&>pre>code]:font-mono [&>pre>code]:text-zinc-200 [&>.shiki]:bg-transparent [&>.shiki]:px-4 [&>.shiki]:py-4 [&>.shiki]:rounded-b-lg",
    "backdrop-blur-[2px]",
    "glass-highlight",
    className
  )

  if (isLargeCode && !highlightedHtml) {
    return (
      <div className={cn(classNames, "glass-code-content")} style={{background: 'transparent'}} {...props}>
        <pre className="bg-transparent text-zinc-200 px-4 py-4 rounded-b-lg font-mono" style={{background: 'transparent'}}>
          <code className={`language-${language} bg-transparent font-mono`} style={{background: 'transparent'}}>
            {code.length > 50000 
              ? code.substring(0, 50000) + '...\n\n(Code truncated for performance - full code will appear shortly)'
              : code}
          </code>
        </pre>
      </div>
    )
  }

  return highlightedHtml ? (
    <div
      className={cn(classNames, "glass-code-content")}
      style={{background: 'transparent'}}
      dangerouslySetInnerHTML={{ __html: highlightedHtml }}
      {...props}
    />
  ) : (
    <div className={cn(classNames, "glass-code-content")} style={{background: 'transparent'}} {...props}>
      <pre className="bg-transparent text-zinc-200 px-4 py-4 rounded-b-lg font-mono" style={{background: 'transparent'}}>
        <code className="font-mono bg-transparent" style={{background: 'transparent'}}>{code}</code>
      </pre>
    </div>
  )
}

export type CodeBlockGroupProps = React.HTMLAttributes<HTMLDivElement>

function CodeBlockGroup({
  children,
  className,
  ...props
}: CodeBlockGroupProps) {
  return (
    <div
      className={cn("flex items-center justify-between", className)}
      {...props}
    >
      {children}
    </div>
  )
}

export { CodeBlockGroup, CodeBlockCode, CodeBlock }

================
File: src/components/ui/collapsible.tsx
================
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

================
File: src/components/ui/command-badge.tsx
================
import { cn } from '@/utils';

/**
 * @deprecated Use the Badge component with variant="active"|"info"|"count" and size="sm" instead.
 * Example: <Badge variant="active" size="sm">Active</Badge>
 * This component will be removed in a future version.
 */
interface CommandBadgeProps {
  children: React.ReactNode;
  variant?: 'active' | 'info' | 'count';
  className?: string;
}

export function CommandBadge({ children, variant = 'info', className }: CommandBadgeProps) {
  return (
    <span
      className={cn(
        'px-1.5 py-0.5 rounded-md text-[10px] font-medium',
        variant === 'active' && 'bg-[#3ecfff]/10 text-[#3ecfff] border border-[#3ecfff]/20',
        variant === 'info' && 'text-white/40 border border-white/10',
        variant === 'count' && 'bg-white/5 text-white/60',
        className
      )}
    >
      {children}
    </span>
  );
}

================
File: src/components/ui/context-menu.tsx
================
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/utils"

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  )
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  )
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  )
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  )
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  )
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  )
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground data-[variant=destructive]:*:[svg]:!text-destructive-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  )
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  )
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}

================
File: src/components/ui/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/70 backdrop-blur-sm",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay className="fixed inset-0 z-50 bg-black/70 backdrop-blur-sm flex items-center justify-center" />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "glassy-ui-colored fixed z-50 grid w-full max-w-lg gap-4 p-6 rounded-2xl",
        "left-[50%] top-[50%] translate-x-[-50%] translate-y-[-50%]",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:text-white/70 hover:text-white">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left relative z-10",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 relative z-10",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight text-white/90",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-white/70", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: src/components/ui/drawer.tsx
================
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/utils"

function Drawer({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) {
  return <DrawerPrimitive.Root data-slot="drawer" {...props} />
}

function DrawerTrigger({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
  return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />
}

function DrawerPortal({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
  return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />
}

function DrawerClose({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Close>) {
  return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />
}

function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
  return (
    <DrawerPrimitive.Overlay
      data-slot="drawer-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}

function DrawerContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
  return (
    <DrawerPortal data-slot="drawer-portal">
      <DrawerOverlay />
      <DrawerPrimitive.Content
        data-slot="drawer-content"
        className={cn(
          "group/drawer-content bg-background fixed z-50 flex h-auto flex-col",
          "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg",
          "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg",
          "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:sm:max-w-sm",
          "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:sm:max-w-sm",
          className
        )}
        {...props}
      >
        <div className="bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" />
        {children}
      </DrawerPrimitive.Content>
    </DrawerPortal>
  )
}

function DrawerHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function DrawerFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function DrawerTitle({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
  return (
    <DrawerPrimitive.Title
      data-slot="drawer-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function DrawerDescription({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
  return (
    <DrawerPrimitive.Description
      data-slot="drawer-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

================
File: src/components/ui/dropdown-menu.tsx
================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md p-1 command-glass-effect",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "relative flex cursor-pointer items-center gap-2 rounded-sm px-2 py-1.5 text-sm text-white/80 outline-hidden select-none hover:bg-white/[0.05] hover:text-white/95 transition-all duration-200 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        variant === "destructive" && "text-red-500 hover:text-red-500 hover:bg-red-500/10",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "relative flex cursor-pointer items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm text-white/80 outline-hidden select-none hover:bg-white/[0.05] hover:text-white/95 transition-all duration-200 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "relative flex cursor-pointer items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm text-white/80 outline-hidden select-none hover:bg-white/[0.05] hover:text-white/95 transition-all duration-200 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium text-white/90 data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("-mx-1 my-1 h-px bg-white/[0.05]", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "ml-auto text-xs tracking-widest text-white/50",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm text-white/80 outline-hidden transition-all duration-200 hover:bg-white/[0.05] hover:text-white/95 data-[state=open]:bg-white/[0.05] data-[state=open]:text-white/95 data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4 text-white/60" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md p-1 bg-white/[0.03] text-white/90 backdrop-blur-xl",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}

================
File: src/components/ui/form.tsx
================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/utils"
import { Label } from "@/components/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive-foreground", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive-foreground text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

================
File: src/components/ui/glass-container.tsx
================
'use client';

import { cn } from "../utils";
import { forwardRef, HTMLAttributes } from 'react';

interface GlassContainerProps extends HTMLAttributes<HTMLDivElement> {
  intensity?: 'low' | 'medium' | 'high';
  border?: boolean;
  hover?: boolean;
  blur?: 'sm' | 'md' | 'lg';
}

/**
 * @deprecated Use Card component with glass=true instead. This component will be removed in a future version.
 * Example: <Card glass intensity="medium" blur="md" border hover />
 * 
 * GlassContainer component - Creates a translucent glass-like container
 */
export const GlassContainer = forwardRef<HTMLDivElement, GlassContainerProps>(
  ({ 
    className, 
    intensity = 'medium', 
    border = true, 
    hover = true, 
    blur = 'md', 
    ...props 
  }, ref) => {
    
    const intensityStyles = {
      low: 'bg-black/20',
      medium: 'bg-black/40',
      high: 'bg-black/60'
    };
    
    const blurStyles = {
      sm: 'backdrop-blur-sm',
      md: 'backdrop-blur-md',
      lg: 'backdrop-blur-xl'
    };

    return (
      <div
        ref={ref}
        className={cn(
          'rounded-xl',
          intensityStyles[intensity],
          blurStyles[blur],
          border && 'border border-white/10',
          hover && 'transition-all duration-300 hover:border-white/20 hover:bg-black/50',
          className
        )}
        {...props}
      />
    );
  }
);

GlassContainer.displayName = 'GlassContainer';

================
File: src/components/ui/gradient-text.tsx
================
'use client';

import { cn } from "../utils";
import { forwardRef, HTMLAttributes } from 'react';

interface GradientTextProps extends HTMLAttributes<HTMLSpanElement> {
  variant?: 'blue' | 'purple' | 'mixed' | 'custom';
}

/**
 * GradientText component - Creates text with a gradient fill
 */
export const GradientText = forwardRef<HTMLSpanElement, GradientTextProps>(
  ({ className, variant = 'blue', children, ...props }, ref) => {
    const gradientStyles = {
      blue: 'bg-gradient-to-r from-blue-400 to-indigo-600 bg-clip-text text-transparent',
      purple: 'bg-gradient-to-r from-indigo-500 to-purple-600 bg-clip-text text-transparent',
      mixed: 'bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 bg-clip-text text-transparent',
      custom: 'bg-clip-text text-transparent'
    };

    return (
      <span 
        ref={ref}
        className={cn(gradientStyles[variant], className)}
        {...props}
      >
        {children}
      </span>
    );
  }
);

GradientText.displayName = 'GradientText';

================
File: src/components/ui/hover-card.tsx
================
import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/utils"

function HoverCard({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />
}

function HoverCardTrigger({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return (
    <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
  )
}

function HoverCardContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Content
      data-slot="hover-card-content"
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 rounded-md border p-4 shadow-md outline-hidden",
        className
      )}
      {...props}
    />
  )
}

export { HoverCard, HoverCardTrigger, HoverCardContent }

================
File: src/components/ui/index.ts
================
export * from "./accordion";
export * from "./alert-dialog";
export * from "./alert";
export * from "./aspect-ratio";
export * from "./avatar";
export * from "./badge";
export * from "./base-tab";
export * from "./breadcrumb";
export * from "./button";
export * from "./calendar";
export * from "./card";
export * from "./carousel";
export * from "./chart";
export * from "./checkbox";
export * from "./code-block";
export * from "./collapsible";
export * from "./command-badge";
export * from "./context-menu";
export * from "./dialog";
export * from "./drawer";
export * from "./dropdown-menu";
export * from "./form";
export * from "./glass-container";
export * from "./gradient-text";
export * from "./hover-card";
export * from "./input-otp";
export * from "./input";
export * from "./label";
export * from "./menubar";
export * from "./navigation-menu";
export * from "./pagination";
export * from "./popover";
export * from "./progress";
export * from "./radio-group";
export * from "./resizable";
export * from "./scroll-area";
export * from "./select";
export * from "./separator";
export * from "./sheet";
export * from "./sidebar";
export * from "./skeleton";
export * from "./slider";
export * from "./sonner";
export * from "./switch";
export * from "./table";
export * from "./tabs";
export * from "./textarea";
export * from "./theme-switcher";
export * from "./toast";
export * from "./toaster";
export * from "./toggle-group";
export * from "./toggle";
export * from "./tooltip";

================
File: src/components/ui/input-otp.tsx
================
"use client"

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { MinusIcon } from "lucide-react"

import { cn } from "@/utils"

function InputOTP({
  className,
  containerClassName,
  ...props
}: React.ComponentProps<typeof OTPInput> & {
  containerClassName?: string
}) {
  return (
    <OTPInput
      data-slot="input-otp"
      containerClassName={cn(
        "flex items-center gap-2 has-disabled:opacity-50",
        containerClassName
      )}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  )
}

function InputOTPGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="input-otp-group"
      className={cn("flex items-center", className)}
      {...props}
    />
  )
}

function InputOTPSlot({
  index,
  className,
  ...props
}: React.ComponentProps<"div"> & {
  index: number
}) {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {}

  return (
    <div
      data-slot="input-otp-slot"
      data-active={isActive}
      className={cn(
        "border-input data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink bg-foreground h-4 w-px duration-1000" />
        </div>
      )}
    </div>
  )
}

function InputOTPSeparator({ ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="input-otp-separator" role="separator" {...props}>
      <MinusIcon />
    </div>
  )
}

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }

================
File: src/components/ui/input.tsx
================
import * as React from "react";

import { cn } from "@/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  description?: string;
  error?: string;
  containerClassName?: string;
  labelClassName?: string;
  descriptionClassName?: string;
  errorClassName?: string;
}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ 
    className, 
    type,
    label,
    description,
    error,
    containerClassName,
    labelClassName,
    descriptionClassName,
    errorClassName,
    ...props 
  }, ref) => {
    if (label || description || error) {
      return (
        <div className={cn("space-y-2", containerClassName)}>
          {label && (
            <label 
              htmlFor={props.id} 
              className={cn(
                "text-sm font-medium text-white/90",
                labelClassName
              )}
            >
              {label}
            </label>
          )}
          
          <input
            type={type}
            className={cn(
              "flex h-10 w-full rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 placeholder:text-white/40 outline-hidden focus:bg-white/[0.03] focus:border-white/[0.1] transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50",
              error && "border-red-500/30 focus:border-red-500/50",
              className,
            )}
            ref={ref}
            {...props}
          />
          
          {description && !error && (
            <p className={cn("text-xs text-white/60", descriptionClassName)}>
              {description}
            </p>
          )}
          
          {error && (
            <p className={cn("text-xs text-red-400", errorClassName)}>
              {error}
            </p>
          )}
        </div>
      );
    }
    
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 placeholder:text-white/40 outline-hidden focus:bg-white/[0.03] focus:border-white/[0.1] transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };

================
File: src/components/ui/label.tsx
================
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none text-white/80 peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

================
File: src/components/ui/menubar.tsx
================
import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/utils"

function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return (
    <MenubarPrimitive.Root
      data-slot="menubar"
      className={cn(
        "bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs",
        className
      )}
      {...props}
    />
  )
}

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return (
    <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
  )
}

function MenubarTrigger({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return (
    <MenubarPrimitive.Trigger
      data-slot="menubar-trigger"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none",
        className
      )}
      {...props}
    />
  )
}

function MenubarContent({
  className,
  align = "start",
  alignOffset = -4,
  sideOffset = 8,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </MenubarPortal>
  )
}

function MenubarItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <MenubarPrimitive.Item
      data-slot="menubar-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground data-[variant=destructive]:*:[svg]:!text-destructive-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function MenubarCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem
      data-slot="menubar-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  )
}

function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem
      data-slot="menubar-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  )
}

function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.Label
      data-slot="menubar-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function MenubarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return (
    <MenubarPrimitive.Separator
      data-slot="menubar-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function MenubarShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="menubar-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.SubTrigger
      data-slot="menubar-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  )
}

function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return (
    <MenubarPrimitive.SubContent
      data-slot="menubar-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent,
}

================
File: src/components/ui/navigation-menu.tsx
================
"use client"

import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/utils"

function NavigationMenu({
  className,
  children,
  viewport = true,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Root> & {
  viewport?: boolean
}) {
  return (
    <NavigationMenuPrimitive.Root
      data-slot="navigation-menu"
      data-viewport={viewport}
      className={cn(
        "group/navigation-menu relative flex max-w-max flex-1 items-center justify-center",
        className
      )}
      {...props}
    >
      {children}
      {viewport && <NavigationMenuViewport />}
    </NavigationMenuPrimitive.Root>
  )
}

function NavigationMenuList({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.List>) {
  return (
    <NavigationMenuPrimitive.List
      data-slot="navigation-menu-list"
      className={cn(
        "group flex flex-1 list-none items-center justify-center gap-1",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuItem({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Item>) {
  return (
    <NavigationMenuPrimitive.Item
      data-slot="navigation-menu-item"
      className={cn("relative", className)}
      {...props}
    />
  )
}

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1"
)

function NavigationMenuTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Trigger>) {
  return (
    <NavigationMenuPrimitive.Trigger
      data-slot="navigation-menu-trigger"
      className={cn(navigationMenuTriggerStyle(), "group", className)}
      {...props}
    >
      {children}{" "}
      <ChevronDownIcon
        className="relative top-[1px] ml-1 size-3 transition duration-300 group-data-[state=open]:rotate-180"
        aria-hidden="true"
      />
    </NavigationMenuPrimitive.Trigger>
  )
}

function NavigationMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Content>) {
  return (
    <NavigationMenuPrimitive.Content
      data-slot="navigation-menu-content"
      className={cn(
        "data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 top-0 left-0 w-full p-2 pr-2.5 md:absolute md:w-auto",
        "group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-200 **:data-[slot=navigation-menu-link]:focus:ring-0 **:data-[slot=navigation-menu-link]:focus:outline-none",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuViewport({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Viewport>) {
  return (
    <div
      className={cn(
        "absolute top-full left-0 isolate z-50 flex justify-center"
      )}
    >
      <NavigationMenuPrimitive.Viewport
        data-slot="navigation-menu-viewport"
        className={cn(
          "origin-top-center bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border shadow md:w-[var(--radix-navigation-menu-viewport-width)]",
          className
        )}
        {...props}
      />
    </div>
  )
}

function NavigationMenuLink({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Link>) {
  return (
    <NavigationMenuPrimitive.Link
      data-slot="navigation-menu-link"
      className={cn(
        "data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 [&_svg:not([class*='text-'])]:text-muted-foreground flex flex-col gap-1 rounded-sm p-2 text-sm transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuIndicator({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Indicator>) {
  return (
    <NavigationMenuPrimitive.Indicator
      data-slot="navigation-menu-indicator"
      className={cn(
        "data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden",
        className
      )}
      {...props}
    >
      <div className="bg-border relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm shadow-md" />
    </NavigationMenuPrimitive.Indicator>
  )
}

export {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
  navigationMenuTriggerStyle,
}

================
File: src/components/ui/pagination.tsx
================
import * as React from "react"
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  MoreHorizontalIcon,
} from "lucide-react"

import { cn } from "@/utils"
import { Button, buttonVariants } from "@/components/button"

function Pagination({ className, ...props }: React.ComponentProps<"nav">) {
  return (
    <nav
      role="navigation"
      aria-label="pagination"
      data-slot="pagination"
      className={cn("mx-auto flex w-full justify-center", className)}
      {...props}
    />
  )
}

function PaginationContent({
  className,
  ...props
}: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="pagination-content"
      className={cn("flex flex-row items-center gap-1", className)}
      {...props}
    />
  )
}

function PaginationItem({ ...props }: React.ComponentProps<"li">) {
  return <li data-slot="pagination-item" {...props} />
}

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<React.ComponentProps<typeof Button>, "size"> &
  React.ComponentProps<"a">

function PaginationLink({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? "page" : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: isActive ? "outline" : "ghost",
          size,
        }),
        className
      )}
      {...props}
    />
  )
}

function PaginationPrevious({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to previous page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pl-2.5", className)}
      {...props}
    >
      <ChevronLeftIcon />
      <span className="hidden sm:block">Previous</span>
    </PaginationLink>
  )
}

function PaginationNext({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to next page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pr-2.5", className)}
      {...props}
    >
      <span className="hidden sm:block">Next</span>
      <ChevronRightIcon />
    </PaginationLink>
  )
}

function PaginationEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      aria-hidden
      data-slot="pagination-ellipsis"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontalIcon className="size-4" />
      <span className="sr-only">More pages</span>
    </span>
  )
}

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}

================
File: src/components/ui/popover.tsx
================
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-white/[0.03] backdrop-blur-xl border border-white/[0.05] text-white/90 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 rounded-md p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

================
File: src/components/ui/progress.tsx
================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }

================
File: src/components/ui/radio-group.tsx
================
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"

import { cn } from "@/utils"

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }

================
File: src/components/ui/resizable.tsx
================
"use client"

import * as React from "react"
import { GripVerticalIcon } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/utils"

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      )}
      {...props}
    />
  )
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      )}
      {...props}
    >
      {withHandle && (
        <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="size-2.5" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  )
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

================
File: src/components/ui/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: src/components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 transition-all duration-200 focus:bg-white/[0.03] focus:border-white/[0.1] focus:outline-hidden disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 text-white/50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border border-white/[0.05] bg-white/[0.03] backdrop-blur-xl text-white/90 shadow-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm text-white/80 outline-hidden transition-all duration-200 hover:bg-white/[0.05] hover:text-white data-[state=checked]:bg-white/[0.05] data-[state=checked]:text-white focus:bg-white/[0.08] focus:text-white data-disabled:pointer-events-none data-disabled:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: src/components/ui/separator.tsx
================
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

================
File: src/components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/70 backdrop-blur-sm",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-white/[0.03] backdrop-blur-xl border border-white/[0.05] data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l border-white/[0.05] sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r border-white/[0.05] sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b border-white/[0.05]",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t border-white/[0.05]",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: src/components/ui/sidebar.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/utils"
import { Button } from "@/components/button"
import { Input } from "@/components/input"
import { Separator } from "@/components/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/sheet"
import { Skeleton } from "@/components/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContext>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

================
File: src/components/ui/skeleton.tsx
================
import { cn } from "@/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-primary/10 animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: src/components/ui/slider.tsx
================
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }

================
File: src/components/ui/sonner.tsx
================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

/**
 * SonnerToaster - A toast component based on the sonner library
 * Renamed from Toaster to avoid conflicts with our own Toaster component
 */
const SonnerToaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground font-medium",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground font-medium",
        },
      }}
      {...props}
    />
  )
}

export { SonnerToaster }

================
File: src/components/ui/switch.tsx
================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-xs transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

================
File: src/components/ui/table.tsx
================
"use client"

import * as React from "react"

import { cn } from "@/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-muted-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

================
File: src/components/ui/tabs.tsx
================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-1",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring inline-flex flex-1 items-center justify-center gap-1.5 rounded-md px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: src/components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 placeholder:text-white/40 outline-hidden focus:bg-white/[0.03] focus:border-white/[0.1] transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

================
File: src/components/ui/theme-switcher.tsx
================
"use client";

import { Button } from "@/components/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/dropdown-menu";
import { Laptop, Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";

const ThemeSwitcher = () => {
  const [mounted, setMounted] = useState(false);
  const { theme, setTheme } = useTheme();

  // useEffect only runs on the client, so now we can safely show the UI
  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  const ICON_SIZE = 16;

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size={"sm"}>
          {theme === "light" ? (
            <Sun
              key="light"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : theme === "dark" ? (
            <Moon
              key="dark"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : (
            <Laptop
              key="system"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-content" align="start">
        <DropdownMenuRadioGroup
          value={theme}
          onValueChange={(e) => setTheme(e)}
        >
          <DropdownMenuRadioItem className="flex gap-2" value="light">
            <Sun size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Light</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="dark">
            <Moon size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Dark</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="system">
            <Laptop size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>System</span>
          </DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

export { ThemeSwitcher };

================
File: src/components/ui/toast.tsx
================
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 right-0 z-9999 flex max-h-screen w-auto flex-col-reverse items-end gap-2 p-4",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full max-w-[350px] items-center justify-between space-x-2 overflow-hidden rounded-md p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-top-full data-[state=open]:slide-in-from-top-full data-[state=open]:duration-300 data-[state=closed]:duration-200",
  {
    variants: {
      variant: {
        default: 
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
        destructive:
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
        success:
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-hidden focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 hover:group-[.destructive]:border-destructive/30 hover:group-[.destructive]:bg-destructive hover:group-[.destructive]:text-destructive-foreground focus:group-[.destructive]:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-hidden focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 hover:group-[.destructive]:text-red-50 focus:group-[.destructive]:ring-red-400 focus:group-[.destructive]:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: src/components/ui/toaster.tsx
================
"use client"

import { useToast } from "@/hooks/use-toast";
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: src/components/ui/toggle-group.tsx
================
import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/utils"
import { toggleVariants } from "@/components/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

function ToggleGroup({
  className,
  variant,
  size,
  children,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <ToggleGroupPrimitive.Root
      data-slot="toggle-group"
      data-variant={variant}
      data-size={size}
      className={cn(
        "group/toggle-group flex w-fit items-center rounded-md data-[variant=outline]:shadow-xs",
        className
      )}
      {...props}
    >
      <ToggleGroupContext.Provider value={{ variant, size }}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
}

function ToggleGroupItem({
  className,
  children,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Item> &
  VariantProps<typeof toggleVariants>) {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      data-slot="toggle-group-item"
      data-variant={context.variant || variant}
      data-size={context.size || size}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        "min-w-0 flex-1 shrink-0 rounded-none shadow-none first:rounded-l-md last:rounded-r-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-l-0 data-[variant=outline]:first:border-l",
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
}

export { ToggleGroup, ToggleGroupItem }

================
File: src/components/ui/toggle.tsx
================
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <TogglePrimitive.Root
      data-slot="toggle"
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Toggle, toggleVariants }

================
File: src/components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-lg px-3 py-1.5 text-xs animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 bg-black/90 border border-white/10 backdrop-blur-xl shadow-xl shadow-black/20 text-white/90 font-medium",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: src/components/ErrorBoundary.tsx
================
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error('React ErrorBoundary caught an error:', error, errorInfo);
  }

  render(): ReactNode {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return this.props.fallback || (
        <div style={{ 
          margin: '20px', 
          padding: '20px', 
          border: '1px solid #f56565', 
          borderRadius: '5px',
          backgroundColor: '#fff5f5',
          color: '#c53030'
        }}>
          <h2>Something went wrong.</h2>
          <details style={{ whiteSpace: 'pre-wrap' }}>
            <summary>Show Error Details</summary>
            {this.state.error && this.state.error.message}
            <br />
            <br />
            {this.state.error && this.state.error.stack}
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

================
File: src/config/api.ts
================
export const API_CONFIG = {
  APP_BASE_URL: 'http://localhost:5173',
  API_BASE_URL: 'http://localhost:3000',
} as const;

export const { APP_BASE_URL, API_BASE_URL } = API_CONFIG;

================
File: src/config/chat-modes.ts
================
import { ReactNode } from 'react';
import { 
  MessagesSquare, 
  Bot, 
  Search, 
  BookOpen 
} from 'lucide-react';

export type ChatMode = 'ask' | 'agent' | 'research' | 'search';

export interface ChatModeConfig {
  id: ChatMode;
  name: string;
  description: string;
  icon: React.ComponentType<{ className?: string }>;
}

const chatModes: Record<ChatMode, ChatModeConfig> = {
  ask: {
    id: 'ask',
    name: 'Ask',
    description: 'Ask questions and get answers',
    icon: MessagesSquare
  },
  agent: {
    id: 'agent',
    name: 'Agent',
    description: 'Use an AI agent to accomplish tasks',
    icon: Bot
  },
  research: {
    id: 'research',
    name: 'Research',
    description: 'Research a topic with advanced analysis',
    icon: BookOpen
  },
  search: {
    id: 'search',
    name: 'Search',
    description: 'Search for information across the web',
    icon: Search
  }
};

export function getChatModeConfig(mode: string): ChatModeConfig {
  return chatModes[mode as ChatMode] || chatModes.ask;
}

export function getAllChatModes(): ChatModeConfig[] {
  return Object.values(chatModes);
}

================
File: src/core/auth/auth-service.ts
================
import { app, BrowserWindow } from 'electron';
import { join } from 'path';
import { writeFile, readFile, unlink, mkdirSync, existsSync } from 'fs';
import { API_BASE_URL, APP_BASE_URL } from '@/config/api';
import { useMainStore } from '@/store/main';
import { AuthSession } from '@/types/auth';

interface SignInResponse {
  session: AuthSession | null;
}

const STORAGE_DIR = join(app.getPath('userData'), 'secure');
const STORAGE_ACCESS_TOKEN_PATH = join(STORAGE_DIR, 'access_token.enc');
const STORAGE_REFRESH_TOKEN_PATH = join(STORAGE_DIR, 'refresh_token.enc');
const STORAGE_TOKEN_EXPIRY_PATH = join(STORAGE_DIR, 'token_expiry.enc');

if (!existsSync(STORAGE_DIR)) {
  try {
    mkdirSync(STORAGE_DIR, { recursive: true });
    console.log('[ELECTRON] Created secure storage directory:', STORAGE_DIR);
  } catch (error) {
    console.error('[ELECTRON] Failed to create secure storage directory:', error);
  }
}

export async function saveAuthData(access: string, refresh: string, safeStorage: Electron.SafeStorage, expiryTime?: number): Promise<void> {
  return new Promise((resolve, reject) => {
    try {
      if (!safeStorage.isEncryptionAvailable()) {
        throw new Error('Encryption is not available');
      }

      if (!existsSync(STORAGE_DIR)) {
        try {
          mkdirSync(STORAGE_DIR, { recursive: true });
          console.log('[ELECTRON] Created secure storage directory:', STORAGE_DIR);
        } catch (dirError) {
          console.error('[ELECTRON] Failed to create secure storage directory:', dirError);
          reject(dirError);
          return;
        }
      }

      console.log('[ELECTRON] Saving auth tokens to:', STORAGE_DIR);
      const encryptedAccessToken = safeStorage.encryptString(access);
      const encryptedRefreshToken = safeStorage.encryptString(refresh);
      
      let encryptedExpiryTime: Buffer | null = null;
      if (expiryTime) {
        encryptedExpiryTime = safeStorage.encryptString(expiryTime.toString());
      }

      writeFile(STORAGE_ACCESS_TOKEN_PATH, encryptedAccessToken, (err) => {
        if (err) {
          console.error('[ELECTRON] Failed to write access token file:', err);
          reject(err);
          return;
        }
        
        console.log('[ELECTRON] Access token saved to:', STORAGE_ACCESS_TOKEN_PATH);
        
        writeFile(STORAGE_REFRESH_TOKEN_PATH, encryptedRefreshToken, (err) => {
          if (err) {
            console.error('[ELECTRON] Failed to write refresh token file:', err);
            reject(err);
            return;
          }
          
          console.log('[ELECTRON] Refresh token saved to:', STORAGE_REFRESH_TOKEN_PATH);
          
          if (encryptedExpiryTime) {
            writeFile(STORAGE_TOKEN_EXPIRY_PATH, encryptedExpiryTime, (err) => {
              if (err) {
                console.error('[ELECTRON] Failed to write token expiry file:', err);
                resolve(); // Still resolve since we have the core tokens saved
                return;
              }
              
              console.log('[ELECTRON] Token expiry time saved to:', STORAGE_TOKEN_EXPIRY_PATH);
              console.log('[ELECTRON] Auth tokens and expiry encrypted and saved');
              resolve();
            });
          } else {
            console.log('[ELECTRON] Auth tokens encrypted and saved (no expiry time)');
            resolve();
          }
        });
      });
    } catch (error) {
      console.error('[ELECTRON] Failed to save auth tokens:', error);
      reject(error);
    }
  });
}

export async function loadAuthData(safeStorage: Electron.SafeStorage): Promise<{ accessToken: string | null, refreshToken: string | null, tokenExpiryTime: number | null }> {
  console.log('[ELECTRON] loadAuthData called');
  const store = useMainStore.getState();
  console.log('[ELECTRON] Store before loading: Access token exists:', !!store.accessToken, 'Refresh token exists:', !!store.refreshToken);
  return new Promise((resolve) => {
    if (!safeStorage.isEncryptionAvailable()) {
      console.error('[ELECTRON] Encryption not available during load');
      resolve({ accessToken: null, refreshToken: null, tokenExpiryTime: null });
      return;
    }

    if (!existsSync(STORAGE_DIR)) {
      console.log('[ELECTRON] Secure storage directory does not exist:', STORAGE_DIR);
      resolve({ accessToken: null, refreshToken: null, tokenExpiryTime: null });
      return;
    }

    console.log('[ELECTRON] Loading auth tokens from:', STORAGE_DIR);
    
    const accessTokenExists = existsSync(STORAGE_ACCESS_TOKEN_PATH);
    const refreshTokenExists = existsSync(STORAGE_REFRESH_TOKEN_PATH);
    const expiryTimeExists = existsSync(STORAGE_TOKEN_EXPIRY_PATH);
    
    if (!accessTokenExists && !refreshTokenExists) {
      console.log('[ELECTRON] No token files found in storage directory');
      resolve({ accessToken: null, refreshToken: null, tokenExpiryTime: null });
      return;
    }

    if (accessTokenExists) {
      readFile(STORAGE_ACCESS_TOKEN_PATH, (err, encryptedAccessToken) => {
        if (err) {
          console.log('[ELECTRON] Error reading access token file:', err);
          
          if (refreshTokenExists) {
            readFile(STORAGE_REFRESH_TOKEN_PATH, (err, encryptedRefreshToken) => {
              if (err) {
                console.log('[ELECTRON] Error reading refresh token file:', err);
                resolve({ accessToken: null, refreshToken: null });
                return;
              }
              
              try {
                const refreshToken = safeStorage.decryptString(encryptedRefreshToken);
                console.log('[ELECTRON] Refresh token loaded successfully');
                store.setRefreshToken(refreshToken);
                console.log('[ELECTRON] Store after setting refresh token: token exists:', !!store.refreshToken);
                
                if (expiryTimeExists) {
                  readFile(STORAGE_TOKEN_EXPIRY_PATH, (err, encryptedExpiryTime) => {
                    if (err) {
                      console.log('[ELECTRON] Error reading token expiry file:', err);
                      resolve({ accessToken: null, refreshToken, tokenExpiryTime: null });
                      return;
                    }
                    
                    try {
                      const expiryTimeStr = safeStorage.decryptString(encryptedExpiryTime);
                      const tokenExpiryTime = parseInt(expiryTimeStr, 10);
                      console.log('[ELECTRON] Token expiry loaded successfully:', new Date(tokenExpiryTime * 1000).toISOString());
                      store.setTokenExpiryTime(tokenExpiryTime);
                      resolve({ accessToken: null, refreshToken, tokenExpiryTime });
                    } catch (decryptError) {
                      console.error('[ELECTRON] Failed to decrypt token expiry time:', decryptError);
                      resolve({ accessToken: null, refreshToken, tokenExpiryTime: null });
                    }
                  });
                } else {
                  resolve({ accessToken: null, refreshToken, tokenExpiryTime: null });
                }
              } catch (decryptError) {
                console.error('[ELECTRON] Failed to decrypt refresh token:', decryptError);
                resolve({ accessToken: null, refreshToken: null });
              }
            });
          } else {
            resolve({ accessToken: null, refreshToken: null });
          }
          
          return;
        }
        
        try {
          const accessToken = safeStorage.decryptString(encryptedAccessToken);
          store.setAccessToken(accessToken);
          console.log('[ELECTRON] Access token loaded successfully');
          console.log('[ELECTRON] Store after setting access token: token exists:', !!store.accessToken);
          
          if (refreshTokenExists) {
            readFile(STORAGE_REFRESH_TOKEN_PATH, (err, encryptedRefreshToken) => {
              if (err) {
                console.log('[ELECTRON] Error reading refresh token file:', err);
                resolve({ accessToken, refreshToken: null });
                return;
              }
              
              try {
                const refreshToken = safeStorage.decryptString(encryptedRefreshToken);
                console.log('[ELECTRON] Both tokens loaded successfully');
                store.setRefreshToken(refreshToken);
                
                if (expiryTimeExists) {
                  readFile(STORAGE_TOKEN_EXPIRY_PATH, (err, encryptedExpiryTime) => {
                    if (err) {
                      console.log('[ELECTRON] Error reading token expiry file:', err);
                      resolve({ accessToken, refreshToken, tokenExpiryTime: null });
                      return;
                    }
                    
                    try {
                      const expiryTimeStr = safeStorage.decryptString(encryptedExpiryTime);
                      const tokenExpiryTime = parseInt(expiryTimeStr, 10);
                      console.log('[ELECTRON] Token expiry loaded successfully:', new Date(tokenExpiryTime * 1000).toISOString());
                      store.setTokenExpiryTime(tokenExpiryTime);
                      resolve({ accessToken, refreshToken, tokenExpiryTime });
                    } catch (decryptError) {
                      console.error('[ELECTRON] Failed to decrypt token expiry time:', decryptError);
                      resolve({ accessToken, refreshToken, tokenExpiryTime: null });
                    }
                  });
                } else {
                  resolve({ accessToken, refreshToken, tokenExpiryTime: null });
                }
              } catch (decryptError) {
                console.error('[ELECTRON] Failed to decrypt refresh token:', decryptError);
                resolve({ accessToken, refreshToken: null, tokenExpiryTime: null });
              }
            });
          } else {
            resolve({ accessToken, refreshToken: null, tokenExpiryTime: null });
          }
        } catch (decryptError) {
          console.error('[ELECTRON] Failed to decrypt access token:', decryptError);
          
          if (refreshTokenExists) {
            readFile(STORAGE_REFRESH_TOKEN_PATH, (err, encryptedRefreshToken) => {
              if (err) {
                console.log('[ELECTRON] Error reading refresh token file:', err);
                resolve({ accessToken: null, refreshToken: null });
                return;
              }
              
              try {
                const refreshToken = safeStorage.decryptString(encryptedRefreshToken);
                console.log('[ELECTRON] Only refresh token loaded successfully');
                store.setRefreshToken(refreshToken);
                
                if (expiryTimeExists) {
                  readFile(STORAGE_TOKEN_EXPIRY_PATH, (err, encryptedExpiryTime) => {
                    if (err) {
                      console.log('[ELECTRON] Error reading token expiry file:', err);
                      resolve({ accessToken: null, refreshToken, tokenExpiryTime: null });
                      return;
                    }
                    
                    try {
                      const expiryTimeStr = safeStorage.decryptString(encryptedExpiryTime);
                      const tokenExpiryTime = parseInt(expiryTimeStr, 10);
                      console.log('[ELECTRON] Token expiry loaded successfully:', new Date(tokenExpiryTime * 1000).toISOString());
                      store.setTokenExpiryTime(tokenExpiryTime);
                      resolve({ accessToken: null, refreshToken, tokenExpiryTime });
                    } catch (decryptError) {
                      console.error('[ELECTRON] Failed to decrypt token expiry time:', decryptError);
                      resolve({ accessToken: null, refreshToken, tokenExpiryTime: null });
                    }
                  });
                } else {
                  resolve({ accessToken: null, refreshToken, tokenExpiryTime: null });
                }
              } catch (decryptError) {
                console.error('[ELECTRON] Failed to decrypt refresh token:', decryptError);
                resolve({ accessToken: null, refreshToken: null });
              }
            });
          } else {
            resolve({ accessToken: null, refreshToken: null });
          }
        }
      });
    } else if (refreshTokenExists) {
      readFile(STORAGE_REFRESH_TOKEN_PATH, (err, encryptedRefreshToken) => {
        if (err) {
          console.log('[ELECTRON] Error reading refresh token file:', err);
          resolve({ accessToken: null, refreshToken: null, tokenExpiryTime: null });
          return;
        }
        
        try {
          const refreshToken = safeStorage.decryptString(encryptedRefreshToken);
          console.log('[ELECTRON] Only refresh token loaded successfully');
          store.setRefreshToken(refreshToken);
          
          if (expiryTimeExists) {
            readFile(STORAGE_TOKEN_EXPIRY_PATH, (err, encryptedExpiryTime) => {
              if (err) {
                console.log('[ELECTRON] Error reading token expiry file:', err);
                resolve({ accessToken: null, refreshToken, tokenExpiryTime: null });
                return;
              }
              
              try {
                const expiryTimeStr = safeStorage.decryptString(encryptedExpiryTime);
                const tokenExpiryTime = parseInt(expiryTimeStr, 10);
                console.log('[ELECTRON] Token expiry loaded successfully:', new Date(tokenExpiryTime * 1000).toISOString());
                store.setTokenExpiryTime(tokenExpiryTime);
                resolve({ accessToken: null, refreshToken, tokenExpiryTime });
              } catch (decryptError) {
                console.error('[ELECTRON] Failed to decrypt token expiry time:', decryptError);
                resolve({ accessToken: null, refreshToken, tokenExpiryTime: null });
              }
            });
          } else {
            resolve({ accessToken: null, refreshToken, tokenExpiryTime: null });
          }
        } catch (decryptError) {
          console.error('[ELECTRON] Failed to decrypt refresh token:', decryptError);
          resolve({ accessToken: null, refreshToken: null, tokenExpiryTime: null });
        }
      });
    } else {
      resolve({ accessToken: null, refreshToken: null, tokenExpiryTime: null });
    }
  });
}

export async function clearAuthData(): Promise<boolean> {
  let accessDeleted = false;
  let refreshDeleted = false;
  
  return new Promise((resolve) => {
    if (!existsSync(STORAGE_DIR)) {
      console.log('[ELECTRON] Secure storage directory does not exist:', STORAGE_DIR);
      resolve(false);
      return;
    }
    
    const accessTokenExists = existsSync(STORAGE_ACCESS_TOKEN_PATH);
    const refreshTokenExists = existsSync(STORAGE_REFRESH_TOKEN_PATH);
    const expiryTimeExists = existsSync(STORAGE_TOKEN_EXPIRY_PATH);
    
    if (!accessTokenExists && !refreshTokenExists) {
      console.log('[ELECTRON] No token files found to delete');
      resolve(false);
      return;
    }
    
    const deleteRefreshToken = () => {
      if (!refreshTokenExists) {
        console.log('[ELECTRON] Refresh token file does not exist, nothing to delete');
        
        if (existsSync(STORAGE_TOKEN_EXPIRY_PATH)) {
          unlink(STORAGE_TOKEN_EXPIRY_PATH, (err) => {
            if (err) {
              console.error('[ELECTRON] Failed to delete token expiry file:', err);
            } else {
              console.log('[ELECTRON] Token expiry deleted');
            }
            resolve(accessDeleted); // Return based on whether access token was deleted
          });
          return;
        }
        
        resolve(accessDeleted); // Return based on whether access token was deleted
        return;
      }
      
      unlink(STORAGE_REFRESH_TOKEN_PATH, (err) => {
        if (err) {
          console.error('[ELECTRON] Failed to delete refresh token file:', err);
        } else {
          refreshDeleted = true;
          console.log('[ELECTRON] Refresh token deleted');
        }
        
        // Also delete token expiry if it exists
        if (existsSync(STORAGE_TOKEN_EXPIRY_PATH)) {
          unlink(STORAGE_TOKEN_EXPIRY_PATH, (err) => {
            if (err) {
              console.error('[ELECTRON] Failed to delete token expiry file:', err);
            } else {
              console.log('[ELECTRON] Token expiry deleted');
            }
            // Return true if at least one token was deleted
            resolve(accessDeleted || refreshDeleted);
          });
        } else {
          // Return true if at least one token was deleted
          resolve(accessDeleted || refreshDeleted);
        }
      });
    };
    
    if (accessTokenExists) {
      unlink(STORAGE_ACCESS_TOKEN_PATH, (err) => {
        if (err) {
          console.error('[ELECTRON] Failed to delete access token file:', err);
        } else {
          accessDeleted = true;
          console.log('[ELECTRON] Access token deleted');
        }
        
        // Then delete refresh token
        deleteRefreshToken();
      });
    } else {
      // Only delete refresh token
      deleteRefreshToken();
    }
  });
}

export async function redirectToSignIn(): Promise<void> {
  const store = useMainStore.getState();
  store.setAccessToken(null);
  store.setRefreshToken(null);
  
  store.setAppState({ 
    spaces: [],
    activeSpace: null,
    conversations: [],
    messages: [],
    initialDataLoaded: false,
    lastFetched: null,
    user: null
  });
  
  await clearAuthData();
  
  BrowserWindow.getAllWindows().forEach((window) => {
    if (!window.isDestroyed()) {
      if (process.env.NODE_ENV === 'development') {
        window.loadURL(`http://localhost:5173/#/sign-in`);
      } else {
        const basePath = join(__dirname, '../renderer/index.html');
        window.loadURL(`file://${basePath}#/sign-in`);
      }
    }
  });
  
  const commandCenterWindow = BrowserWindow.getAllWindows().find(win => 
    win.webContents.getURL().includes('command-center'));
  
  if (commandCenterWindow && !commandCenterWindow.isDestroyed()) {
    commandCenterWindow.hide();
  }
}

/**
 * Refresh authentication tokens
 */
export async function refreshTokens(safeStorage: Electron.SafeStorage): Promise<boolean> {
  const store = useMainStore.getState();
  const refreshToken = store.refreshToken;
  
  if (!refreshToken) {
    console.log('[ELECTRON] No refresh token available');
    return false;
  }
  
  try {
    console.log('[ELECTRON] Attempting to refresh tokens');
    const response = await fetch(`${API_BASE_URL}/api/auth/refresh`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ refresh_token: refreshToken })
    });
    
    if (!response.ok) {
      console.error('[ELECTRON] Token refresh failed with status:', response.status);
      if (response.status === 401 || response.status === 403) {
        await redirectToSignIn();
      }
      return false;
    }
    
    const { status, error, data } = await response.json();
    
    if (status !== 'success' || !data?.session?.access_token) {
      console.error('[ELECTRON] Invalid response from refresh endpoint:', error || 'No session data');
      return false;
    }
    
    store.setAccessToken(data.session.access_token);
    
    if (data.session.refresh_token) {
      store.setRefreshToken(data.session.refresh_token);
    }
    
    if (!data.session.expires_at) {
      console.error('[ELECTRON] No expires_at received from refresh endpoint');
      return false;
    }
    
    store.setTokenExpiryTime(data.session.expires_at);
    
    console.log('[ELECTRON] Token expiry set from API:', new Date(data.session.expires_at * 1000).toISOString());
    
    if (data.session.refresh_token && safeStorage) {
      await saveAuthData(data.session.access_token, data.session.refresh_token, safeStorage, data.session.expires_at);
    } else {
      console.log('[ELECTRON] Safe storage not available or encryption not available, skipping token save');
    }
    
    return true;
  } catch (error) {
    console.error('[ELECTRON] Error refreshing tokens:', error);
    return false;
  }
}

/**
 * Check if the current token needs to be refreshed
 * Returns true if token expiry is less than 5 minutes away or already expired
 */
export function isTokenExpiringSoon(): boolean {
  const store = useMainStore.getState();
  const tokenExpiryTime = store.tokenExpiryTime;
  const accessToken = store.accessToken;
  
  // If there's no access token, no need to check expiry
  if (!accessToken) {
    return false;
  }
  
  // If there's no expiry time, but there is an access token, 
  // we should refresh to be safe and to get a proper expiry time
  if (!tokenExpiryTime) {
    console.warn('[ELECTRON] No token expiry time found for existing access token');
    return true;
  }
  
  const currentTimeSeconds = Math.floor(Date.now() / 1000);
  const fiveMinutesFromNow = currentTimeSeconds + 300;
  
  return tokenExpiryTime <= fiveMinutesFromNow;
}

/**
 * Helper to check server availability
 */
export async function checkServerAvailable(): Promise<boolean> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/health`);
    return response.ok;
  } catch (error) {
    console.error('[ELECTRON] Server check failed:', error);
    return false;
  }
}

/**
 * Sign in user and get auth tokens
 */
export async function signIn(email: string, password: string, safeStorage?: Electron.SafeStorage): Promise<{ success: boolean; error?: string; data?: any }> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/auth/sign-in`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });

    if (!response.ok) {
      return { 
        success: false, 
        error: `Server error: ${response.status} ${response.statusText}`
      };
    }

    const { status, error, data } = await response.json();

    if (status !== 'success' || !data?.session?.access_token || !data?.session?.refresh_token || !data?.session?.expires_at) {
      return { 
        success: false, 
        error: error || 'Invalid response from server'
      };
    }

    const store = useMainStore.getState();
    store.setAccessToken(data.session.access_token);
    store.setRefreshToken(data.session.refresh_token);
    store.setTokenExpiryTime(data.session.expires_at);
    
    if (data.session.user) {
      store.setUser(data.session.user);
    }
    
    // Save tokens and expiry time to secure storage
    try {
      if (safeStorage && safeStorage.isEncryptionAvailable()) {
        await saveAuthData(
          data.session.access_token, 
          data.session.refresh_token, 
          safeStorage,
          data.session.expires_at
        );
        console.log('[ELECTRON] Auth data saved to secure storage after sign-in');
      } else {
        console.log('[ELECTRON] Safe storage not available or encryption not available, skipping token save after sign-in');
      }
    } catch (error) {
      console.error('[ELECTRON] Error saving auth data after sign-in:', error);
      // Continue since we already have tokens in memory
    }

    return {
      success: true,
      data
    };
  } catch (error) {
    console.error('[ELECTRON] Sign in error:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Failed to sign in'
    };
  }
}

// Get current auth data
export async function getAuthData() {
  const store = useMainStore.getState();
  const { accessToken, refreshToken } = store;
  return { accessToken, refreshToken };
}

// Expose constants
export { API_BASE_URL, APP_BASE_URL };

================
File: src/core/ipc/handlers/app-state-handlers.ts
================
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import { getMainStoreState, useMainStore } from '@/store/main';
import {
  fetchInitialAppData,
  refreshAppData
} from '@/services/app-data/app-data-service';
import { AppStateEvents } from '@/core/ipc/constants';

interface AppStateResponse {
  success: boolean;
  data?: any;
  error?: string;
}

interface StateUpdate {
  type: string;
  payload: any;
}

function makeSerializable(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }
  
  if (Array.isArray(obj)) {
    return obj.map(makeSerializable);
  }
  
  if (obj instanceof Date) {
    return obj.toISOString();
  }
  
  if (typeof obj === 'object') {
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value !== 'function' && key !== 'zustand' && key !== 'store') {
        result[key] = makeSerializable(value);
      }
    }
    return result;
  }
  
  return obj;
}

/**
 * Register app state-related IPC handlers
 */
export function registerAppStateHandlers() {
  ipcMain.on(AppStateEvents.STATE_UPDATED, (event: Electron.IpcMainEvent, update: StateUpdate) => {
    console.log('[ELECTRON] Received state update from renderer:', update);
    const store = useMainStore.getState();
    const action = store[update.type as keyof typeof store];
    if (typeof action === 'function') {
      (action as Function)(update.payload);
    }
  });

  ipcMain.handle(AppStateEvents.SYNC_STATE, async (_event: IpcMainInvokeEvent, state: any): Promise<AppStateResponse> => {
    try {
      console.log('[ELECTRON] Syncing app state from renderer');
      
      if (!state || typeof state !== 'object') {
        console.log('[ELECTRON] Received invalid state object:', state);
        return { 
          success: false, 
          error: 'Invalid state object received',
        };
      }
      
      const currentState = useMainStore.getState();
      const mergedState = { ...currentState, ...state };
      
      Object.keys(state).forEach(key => {
        const setter = `set${key.charAt(0).toUpperCase() + key.slice(1)}`;
        const store = useMainStore.getState();
        const setterFn = store[setter as keyof typeof store];
        if (typeof setterFn === 'function') {
          (setterFn as Function)(state[key]);
        }
      });
      
      return { 
        success: true, 
      };
    } catch (error) {
      console.error('[ELECTRON] Error syncing app state:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  });

  ipcMain.handle(AppStateEvents.GET_STATE, async (_event: IpcMainInvokeEvent): Promise<AppStateResponse> => {
    try {
      const state = getMainStoreState();
      console.log('[ELECTRON] Getting app state from renderer, initialDataLoaded:', state.initialDataLoaded);
      
      const accessTokenExists = !!state.accessToken;
      const needsFreshData = !state.initialDataLoaded || (accessTokenExists && (!state.spaces || state.spaces.length === 0));
      
      if (needsFreshData) {
        const freshData = await fetchInitialAppData();
        if (!freshData.error) {
          console.log('[ELECTRON] Successfully fetched fresh data after GET_STATE');
          useMainStore.getState().setAppState({ ...freshData, initialDataLoaded: true });
          return { 
            success: true, 
            data: makeSerializable(getMainStoreState()),
          };
        }
        
        return { 
          success: false, 
          error: freshData.error
        };
      }
      const serializedState = makeSerializable(getMainStoreState());
      return { 
        success: true, 
        data: serializedState
      };
    } catch (error) {
      console.error('[ELECTRON] Error getting app state:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  });

  // Handler for refreshing app data
  ipcMain.handle(AppStateEvents.REFRESH_DATA, async (_event: IpcMainInvokeEvent): Promise<AppStateResponse> => {
    try {
      const refreshedData = await refreshAppData();
      if (!refreshedData.error) {
        useMainStore.getState().setAppState({ ...refreshedData });
        return {
          success: true,
          data: makeSerializable(getMainStoreState())
        };
      }
      return {
        success: false,
        error: refreshedData.error
      };
    } catch (error) {
      console.error('[ELECTRON] Error refreshing app data:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  });
}

================
File: src/core/ipc/handlers/auth-handlers.ts
================
import { ipcMain, IpcMainInvokeEvent, safeStorage } from 'electron';
import { API_BASE_URL } from '@/core/auth/auth-service';
import {
  signUp,
  resetPassword
} from '@/services/user/user-service';
import {
  redirectToSignIn,
  refreshTokens,
  saveAuthData,
  clearAuthData,
  signIn
} from '@/core/auth/auth-service';
import { AuthEvents } from '@/core/ipc/constants';
import { AuthResponse } from '@/types/auth';
import { useMainStore } from '@/store/main';
import { useStore } from 'zustand';

interface SessionResponse {
  status: string;
  data?: {
    session?: {
      user?: any;
    };
  };
  error?: string;
}


export function registerAuthHandlers() {
  ipcMain.handle(AuthEvents.SIGN_IN, async (_event: IpcMainInvokeEvent, email: string, password: string): Promise<AuthResponse> => {
    try {
      const signInResult = await signIn(email, password, safeStorage);
      
      if (!signInResult.success || !signInResult.data?.session?.access_token || !signInResult.data?.session?.refresh_token) {
        return { success: false, error: signInResult.error || 'Invalid credentials' };
      }
      
      return {
        success: true,
        data: signInResult.data,
        status: 'success'
      };
    } catch (error) {
      console.error('[ELECTRON] Sign in handler error:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to sign in', status: 'error' };
    }
  });

  ipcMain.handle(AuthEvents.VERIFY_TOKEN, async (_event: IpcMainInvokeEvent): Promise<AuthResponse> => {
    console.log('[ELECTRON] VERIFY_TOKEN handler called');
    try {
      const accessToken = useMainStore.getState().accessToken;
      console.log('[ELECTRON] Current access token exists:', !!accessToken);
      if (!accessToken) {
        console.log('[ELECTRON] No access token available to verify');
        return { 
          success: true, 
          data: { isValid: false },
          status: 'success'
        };
      }

      const response = await fetch(`${API_BASE_URL}/api/auth/verify-token`, {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      });
      
      const responseData = await response.json();
      
      return {
        success: true,
        data: { 
          isValid: response.ok && responseData.status === 'success' && !!responseData.data?.session
        },
        status: 'success'
      };
    } catch (error) {
      console.error('[ELECTRON] Error verifying token:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to verify token', 
        status: 'error' 
      };
    }
  });

  ipcMain.handle(AuthEvents.SIGN_UP, async (_event: IpcMainInvokeEvent, email: string, password: string): Promise<AuthResponse> => {
    try {
      return await signUp(email, password);
    } catch (error) {
      console.error('Error signing up:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to sign up', status: 'error' };
    }
  });

  ipcMain.handle(AuthEvents.RESET_PASSWORD, async (_event: IpcMainInvokeEvent, email: string): Promise<AuthResponse> => {
    try {
      return await resetPassword(email);
    } catch (error) {
      console.error('Error resetting password:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to reset password', status: 'error' };
    }
  });

  ipcMain.handle(AuthEvents.SET_AUTH_TOKENS, async (_event: IpcMainInvokeEvent, newAccessToken: string, newRefreshToken: string, expiresAt: number): Promise<AuthResponse> => {
    if (!newAccessToken || !newRefreshToken || !expiresAt) {
      console.error('[ELECTRON] Invalid token data received');
      return { success: false, error: 'Invalid token data received', status: 'error' };
    }
    
    console.log('[ELECTRON] Auth tokens received');
    
    try {
      await saveAuthData(newAccessToken, newRefreshToken, safeStorage, expiresAt);
      console.log('[ELECTRON] Auth tokens and expiry saved to secure storage');

      const store = useMainStore.getState();
      store.setAccessToken(newAccessToken);
      store.setRefreshToken(newRefreshToken);
      store.setTokenExpiryTime(expiresAt * 1000);
      console.log('[ELECTRON] Token expiry set from handler:', new Date(expiresAt * 1000).toISOString());
      
      return { success: true, data: { tokensValidated: true }, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error during auth setup:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Error during auth setup', status: 'error' };
    }
  });

  ipcMain.handle(AuthEvents.CLEAR_AUTH_DATA, async (_event: IpcMainInvokeEvent): Promise<AuthResponse> => {
    try {
      await clearAuthData();
      
      useMainStore.getState().setUser(null);
      useMainStore.getState().setAccessToken(null);
      useMainStore.getState().setRefreshToken(null);
      
      console.log('[ELECTRON] Auth data cleared successfully');
      return { success: true, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error clearing auth data:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Error clearing auth data', status: 'error' };
    }
  });

  ipcMain.handle(AuthEvents.REFRESH_AUTH_TOKENS, async (_event: IpcMainInvokeEvent): Promise<AuthResponse> => {
    try {
      console.log('[ELECTRON] Refresh tokens handler called');
      const refreshed = await refreshTokens(safeStorage);
      
      if (!refreshed) {
        console.log('[ELECTRON] Failed to refresh tokens');
        return { success: false, error: 'Failed to refresh tokens', status: 'error' };
      }
      
      const store = useMainStore.getState();
      return { 
        success: true, 
        data: {
          accessToken: store.accessToken,
          refreshToken: store.refreshToken
        },
        status: 'success'
      };
    } catch (error) {
      console.error('[ELECTRON] Error refreshing tokens:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Error refreshing tokens', status: 'error' };
    }
  });

  ipcMain.handle(AuthEvents.GET_AUTH_TOKEN, async (_event: IpcMainInvokeEvent): Promise<AuthResponse> => {
    try {
      const store = useMainStore.getState();
      return { 
        success: true, 
        data: {
          accessToken: store.accessToken,
          refreshToken: store.refreshToken
        },
        status: 'success'
      };
    } catch (error) {
      console.error('[ELECTRON] Error getting auth token:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Error getting auth token', status: 'error' };
    }
  });

  ipcMain.handle(AuthEvents.SIGN_OUT, async (_event: IpcMainInvokeEvent): Promise<AuthResponse> => {
    try {
      await redirectToSignIn();
      return { success: true, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error signing out:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Error signing out', status: 'error' };
    }
  });
}

================
File: src/core/ipc/handlers/command-center-handlers.ts
================
import { ipcMain, IpcMainInvokeEvent, BrowserWindow, app } from 'electron';
import {
  getCommandCenterWindow,
  getContextCommandWindow,
  toggleCommandCenterWindow,
  setDialogState,
  setCommandType
} from '@/core/window/window-service';
import { CommandType } from '@/types/command';
import { CommandCenterEvents } from '@/core/ipc/constants';
import { IpcResponse } from '@/types/ipc';
import * as fs from 'fs/promises';
import * as fsSync from 'fs';
import * as path from 'path';
import { exec as execCallback } from 'child_process';
import { promisify } from 'util';

const exec = promisify(execCallback);

// Cache for storing search results
const searchCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes TTL for cache entries

// Supported file extensions
const SUPPORTED_EXTENSIONS = [
  '.txt', '.md', '.pdf', '.doc', '.docx',
  '.rtf', '.odt', '.html', '.htm', '.xml',
  '.json', '.csv', '.js', '.ts', '.jsx', '.tsx', '.py',
  '.java', '.c', '.cpp', '.h', '.rb', '.go', '.rs',
  '.swift', '.php', '.css', '.scss', '.less',
];

function escapeMdfindQuery(queryPart: string): string {
  return queryPart.replace(/['"]/g, '\\$&');
}

function escapeShellArg(arg: string): string {
  return `'${arg.replace(/'/g, "'\\''")}'`;
}

interface DialogData {
  title?: string;
  message?: string;
  type?: string;
  buttons?: string[];
}

interface FileSearchOptions {
  query: string;
  limit?: number;
  type?: 'file' | 'directory' | 'all';
  includeContent?: boolean;
  directory?: string;
}

interface FileReadOptions {
  filePath: string;
  maxSize?: number;
}

interface FileSearchResult {
  id: string;
  path: string;
  name: string;
  type: 'file' | 'directory';
  lastModified: Date;
  size: number;
  content?: string;
}

// Start cache cleanup interval
const startCacheCleanup = () => {
  setInterval(() => {
    const now = Date.now();
    for (const [key, { timestamp }] of Array.from(searchCache.entries())) {
      if (now - timestamp > CACHE_TTL) {
        searchCache.delete(key);
      }
    }
  }, 60000);
};

export function registerCommandCenterHandlers(): void {
  // Start cache cleanup
  startCacheCleanup();

  ipcMain.handle(CommandCenterEvents.TOGGLE, async (_, commandType: CommandType = 'unified') => {
    try {
      const window = await toggleCommandCenterWindow(commandType);
      return { success: true, window: window ? true : false };
    } catch (error) {
      console.error('Error toggling command center:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to toggle command center' };
    }
  });

  ipcMain.handle(CommandCenterEvents.SHOW, async (_, commandType: CommandType = 'unified') => {
    try {
      const window = await toggleCommandCenterWindow(commandType);
      if (window) {
        window.show();
        window.focus();
      }
      return { success: true };
    } catch (error) {
      console.error('Error showing command center:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to show command center' };
    }
  });

  ipcMain.handle(CommandCenterEvents.CLOSE, async (_, commandType: CommandType = 'unified') => {
    try {
      const window = await getContextCommandWindow(commandType);

      if (window?.isVisible()) {
        window.hide();
      }
      return { success: true };
    } catch (error) {
      console.error('Error closing command center:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to close command center' };
    }
  });

  ipcMain.handle(CommandCenterEvents.OPEN_DIALOG, async (_, dialogType: string, data: any) => {
    try {
      setDialogState(true);
      return { success: true };
    } catch (error) {
      console.error('Error opening dialog:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to open dialog' };
    }
  });

  ipcMain.handle(CommandCenterEvents.DIALOG_CLOSED, async () => {
    try {
      setDialogState(false);
      return { success: true };
    } catch (error) {
      console.error('Error closing dialog:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to close dialog' };
    }
  });

  ipcMain.handle(CommandCenterEvents.REFRESH, async (_, commandType: CommandType = 'unified') => {
    try {
      const window = await getContextCommandWindow(commandType);

      if (window) {
        window.reload();
      }
      return { success: true };
    } catch (error) {
      console.error('Error refreshing command center:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to refresh command center' };
    }
  });

  ipcMain.handle(CommandCenterEvents.CHECK_TYPE, async (_, commandType: CommandType) => {
    try {
      const window = await getContextCommandWindow(commandType);
      return { success: true, data: { type: commandType, exists: window ? true : false } };
    } catch (error) {
      console.error('Error checking command type:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to check command type' };
    }
  });

  ipcMain.on(CommandCenterEvents.SET_TYPE, (_event: IpcMainInvokeEvent, commandType: CommandType) => {
    setCommandType(commandType);
  });

  ipcMain.on(CommandCenterEvents.SYNC_STATE, (_event: IpcMainInvokeEvent, action: string, data?: any) => {
    BrowserWindow.getAllWindows().forEach((window) => {
      if (!window.isDestroyed()) {
        window.webContents.send(CommandCenterEvents.SYNC_STATE, action, data);
      }
    });
  });

  ipcMain.on(CommandCenterEvents.ON_RESIZE, (_event: IpcMainInvokeEvent, dimensions: { width: number; height: number }, commandType?: CommandType) => {
    if (commandType) {
      const contextWindow = getContextCommandWindow(commandType);
      if (contextWindow && !contextWindow.isDestroyed()) {
        contextWindow.setSize(dimensions.width, dimensions.height);
      }
    } else {
      const commandCenterWindow = getCommandCenterWindow();
      if (commandCenterWindow && !commandCenterWindow.isDestroyed()) {
        commandCenterWindow.setSize(dimensions.width, dimensions.height);
      }
    }
  });

  // Spotlight-based file search implementation
  ipcMain.handle(CommandCenterEvents.SEARCH_FILES, async (_event: IpcMainInvokeEvent, options: string | FileSearchOptions): Promise<IpcResponse<FileSearchResult[]>> => {
    try {
      const searchOptions: FileSearchOptions = typeof options === 'string'
        ? { query: options }
        : options;

      const {
        query,
        limit = 100,
        directory,
      } = searchOptions;

      if (!query || query.trim() === '') {
        return { success: true, data: [], status: 'success' };
      }

      const searchTerm = query.toLowerCase().trim();
      
      // Check cache for results
      const cacheKey = searchTerm;
      if (searchCache.has(cacheKey)) {
        const { results, timestamp } = searchCache.get(cacheKey);
        if (Date.now() - timestamp < CACHE_TTL) {
          console.log(`[spotlight] Returning cached results for "${searchTerm}"`);
          return { success: true, data: results, status: 'success' };
        }
      }

      // Default to user's home directory if not specified
      const searchPath = directory || app.getPath('home');
      console.log(`[spotlight] Searching in: ${searchPath}`);

      // Use simpler Spotlight query focused on file names
      const cmd = `mdfind "kMDItemFSName == '*${escapeMdfindQuery(searchTerm)}*'c" -onlyin ${escapeShellArg(searchPath)} | head -n ${limit}`;
      console.log(`[spotlight] Executing search: ${cmd}`);

      const { stdout, stderr } = await exec(cmd);
      if (stderr) {
        console.warn(`[spotlight] Stderr: ${stderr}`);
      }

      if (!stdout.trim()) {
        return { success: true, data: [], status: 'success' };
      }

      const filePaths = stdout.trim().split('\n').filter(Boolean);
      console.log(`[spotlight] Found ${filePaths.length} raw results`);

      const results: FileSearchResult[] = [];
      
      for (const filePath of filePaths) {
        try {
          const stats = await fs.stat(filePath);
          const isDirectory = stats.isDirectory();
          const ext = path.extname(filePath).toLowerCase();
          
          // Filter by supported extensions for files
          if (!isDirectory && !SUPPORTED_EXTENSIONS.includes(ext)) {
            continue;
          }

          results.push({
            id: `file-${Buffer.from(filePath).toString('base64')}`,
            path: filePath,
            name: path.basename(filePath),
            type: isDirectory ? 'directory' : 'file',
            lastModified: stats.mtime,
            size: stats.size,
          });
          
        } catch (statError) {
          // Skip files that can't be accessed
          console.warn(`[spotlight] Could not access file ${filePath}`);
        }
        
        if (results.length >= limit) {
          break;
        }
      }

      // Sort results by relevance (exact name match first)
      results.sort((a, b) => {
        const aNameLower = a.name.toLowerCase();
        const bNameLower = b.name.toLowerCase();
        
        if (aNameLower === searchTerm && bNameLower !== searchTerm) return -1;
        if (bNameLower === searchTerm && aNameLower !== searchTerm) return 1;
        
        return aNameLower.localeCompare(bNameLower);
      });

      // Cache the results
      if (results.length > 0) {
        searchCache.set(cacheKey, {
          results,
          timestamp: Date.now(),
        });
      }

      console.log(`[spotlight] Returning ${results.length} formatted results`);
      return { success: true, data: results, status: 'success' };

    } catch (error: unknown) {
      console.error('[spotlight] Error searching files:', error);
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred during file search';
      return { success: false, error: errorMessage, status: 'error' };
    }
  });

  ipcMain.handle(CommandCenterEvents.READ_FILE, async (_event: IpcMainInvokeEvent, options: string | FileReadOptions): Promise<IpcResponse> => {
    try {
      const readOptions: FileReadOptions = typeof options === 'string'
        ? { filePath: options }
        : options;

      const { filePath, maxSize = 5 * 1024 * 1024 } = readOptions; // Default max 5MB

      if (!filePath) {
        return { success: false, error: 'No file path provided', status: 'error' };
      }

      const stats = await fs.stat(filePath);

      if (!stats.isFile()) {
        return { success: false, error: 'Not a file', status: 'error' };
      }

      if (stats.size > maxSize) {
        return {
          success: false,
          error: `File too large (${Math.round(stats.size / (1024 * 1024))}MB). Max size is ${Math.round(maxSize / (1024 * 1024))}MB.`,
          status: 'error'
        };
      }

      const ext = path.extname(filePath).toLowerCase();
      const textExtensions = [
        '.txt', '.md', '.js', '.ts', '.jsx', '.tsx', '.html', '.css',
        '.json', '.csv', '.xml', '.py', '.rb', '.java', '.c', '.cpp',
      ];

      if (!textExtensions.includes(ext)) {
        return {
          success: false,
          error: `Cannot read content of non-text files (${ext})`,
          status: 'error'
        };
      }

      let content: string;
      try {
        content = await fs.readFile(filePath, 'utf-8');
      } catch (readError) {
        console.error(`Error reading file content for ${filePath}:`, readError);
        return { 
          success: false, 
          error: `Failed to read file: ${readError instanceof Error ? readError.message : 'Unknown read error'}`, 
          status: 'error'
        };
      }

      const MAX_CHAR_LENGTH = 100000;
      let truncated = false;
      
      if (content.length > MAX_CHAR_LENGTH) {
        content = content.substring(0, MAX_CHAR_LENGTH) + '\n\n[Truncated...]';
        truncated = true;
      }

      const metadata = {
        name: path.basename(filePath),
        path: filePath,
        size: stats.size,
        lastModified: stats.mtime,
        extension: ext.replace('.', '') || 'txt',
        type: 'text',
        truncated
      };

      return {
        success: true,
        data: { content, metadata },
        status: 'success'
      };
    } catch (error: unknown) {
      console.error('Error reading file:', error);
      if (error instanceof Error && (error as NodeJS.ErrnoException).code === 'ENOENT') {
         return { success: false, error: 'File not found', status: 'error' };
      }
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred while reading the file';
      return { success: false, error: errorMessage, status: 'error' };
    }
  });

  ipcMain.handle(CommandCenterEvents.PING, () => ({ success: true, data: 'pong', status: 'success' }) as IpcResponse<string>);
}

================
File: src/core/ipc/handlers/conversation-handlers.ts
================
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import {
  fetchConversations,
  createConversation,
  updateConversation,
  deleteConversation,
  setActiveConversationInAPI
} from '@/services/conversations/conversation-service';
import { fetchMessages } from '@/services/messages/message-service';
import { ConversationResponse } from '@/types/conversation';
import { ConversationEvents, SpaceEvents, MessageEvents } from '@/core/ipc/constants';
import { CreateConversationRequest } from '@/types/conversation';
import { MessageResponse } from '@/types/message';

export function registerConversationHandlers() {
  ipcMain.handle(MessageEvents.GET_CONVERSATION_MESSAGES, async (_event: IpcMainInvokeEvent, conversationId: string): Promise<MessageResponse> => {
    try {
      const messages = await fetchMessages(conversationId);
      return { success: true, data: messages, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error in get-conversation-messages handler:', error);
      
      let errorMessage: string;
      if (error instanceof Error) {
        errorMessage = error.message;
      } else if (typeof error === 'object' && error !== null) {
        try {
          errorMessage = JSON.stringify(error);
        } catch (e) {
          errorMessage = 'Error occurred but could not be serialized';
        }
      } else {
        errorMessage = String(error);
      }
      
      return { success: false, error: errorMessage, status: 'error' };
    }
  });

  ipcMain.handle(ConversationEvents.GET_CONVERSATIONS, async (_event: IpcMainInvokeEvent): Promise<ConversationResponse> => {
    try {
      const conversations = await fetchConversations('');
      return { success: true, data: conversations, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error in get-conversations handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error', status: 'error' };
    }
  });

  ipcMain.handle(ConversationEvents.CREATE_CONVERSATION, async (_event: IpcMainInvokeEvent, data: CreateConversationRequest): Promise<ConversationResponse> => {
    try {
      const result = await createConversation(data.space_id, data.title);
      
      // Emit an event to notify all renderers that conversations have been updated
      const updatedConversations = await fetchConversations('');
      ipcMain.emit(ConversationEvents.CONVERSATIONS_UPDATED, null, { conversations: updatedConversations });
      
      return { success: true, data: result, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error in create-conversation handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error', status: 'error' };
    }
  });

  ipcMain.handle(ConversationEvents.UPDATE_CONVERSATION, async (_event: IpcMainInvokeEvent, data: { spaceId: string, id: string, title: string }): Promise<ConversationResponse> => {
    try {
      const result = await updateConversation(data.spaceId, data.id, data.title);
      
      // Emit an event to notify all renderers that conversations have been updated
      const updatedConversations = await fetchConversations('');
      ipcMain.emit(ConversationEvents.CONVERSATIONS_UPDATED, null, { conversations: updatedConversations });
      
      return { success: true, data: result, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error in update-conversation handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error', status: 'error' };
    }
  });

  ipcMain.handle(ConversationEvents.DELETE_CONVERSATION, async (_event: IpcMainInvokeEvent, data: { spaceId: string, conversationId: string }): Promise<ConversationResponse> => {
    try {
      const result = await deleteConversation(data.spaceId, data.conversationId);
      
      // Emit an event to notify all renderers that conversations have been updated
      const updatedConversations = await fetchConversations('');
      ipcMain.emit(ConversationEvents.CONVERSATIONS_UPDATED, null, { conversations: updatedConversations });
      
      return { success: true, data: { deleted: result }, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error in delete-conversation handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error', status: 'error' };
    }
  });

  ipcMain.handle(ConversationEvents.SET_ACTIVE_CONVERSATION, async (_event: IpcMainInvokeEvent, conversationId: string): Promise<ConversationResponse> => {
    try {
      if (!conversationId) {
        return { success: false, error: 'Conversation ID is required', status: 'error' };
      }
      
      await setActiveConversationInAPI(conversationId);
      const messages = await fetchMessages(conversationId);
      
      return { 
        success: true, 
        data: {
          messages
        },
        status: 'success'
      };
    } catch (error) {
      console.error('[ELECTRON] Error in set-active-conversation handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error', status: 'error' };
    }
  });
}

================
File: src/core/ipc/handlers/message-handlers.ts
================
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import {
  fetchMessages,
  sendChatMessage,
  deleteMessage,
  updateMessage
} from '@/services/messages/message-service';
import {
  searchAllMessages
} from '@/services/search/search-service';
import { MessageResponse } from '@/types/message';
import { MessageEvents, SearchEvents } from '@/core/ipc/constants';

export function registerMessageHandlers() {
  ipcMain.handle(SearchEvents.SEARCH_MESSAGES, async (_event: IpcMainInvokeEvent, query: string): Promise<MessageResponse> => {
    try {
      const messages = await searchAllMessages(query);
      return { success: true, data: messages };
    } catch (error) {
      console.error('Error searching messages:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to search messages' };
    }
  });

  ipcMain.handle(MessageEvents.SEND_MESSAGE, async (_event: IpcMainInvokeEvent, conversationId: string, message: string): Promise<MessageResponse> => {
    try {
      const result = await sendChatMessage(conversationId, message);
      return { success: true, data: result };
    } catch (error) {
      console.error('Error sending chat message:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to send message' };
    }
  });

  ipcMain.handle(MessageEvents.DELETE_MESSAGE, async (_event: IpcMainInvokeEvent, conversationId: string, messageId: string): Promise<MessageResponse> => {
    try {
      const success = await deleteMessage(conversationId, messageId);
      return { success: true, data: { deleted: success } };
    } catch (error) {
      console.error('Error deleting message:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to delete message' };
    }
  });

  ipcMain.handle(MessageEvents.UPDATE_MESSAGE, async (_event: IpcMainInvokeEvent, conversationId: string, messageId: string, content: string): Promise<MessageResponse> => {
    try {
      const updatedMessage = await updateMessage(conversationId, messageId, content);
      return { success: true, data: updatedMessage };
    } catch (error) {
      console.error('Error updating message:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Failed to update message' };
    }
  });
}

================
File: src/core/ipc/handlers/notification-handlers.ts
================
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import { 
  fetchNotifications, 
  markNotificationAsRead, 
  markAllNotificationsAsRead 
} from '@/services/notification/notification-service';
import { NotificationResponse } from '@/types/notification';
import { NotificationEvents } from '@/core/ipc/constants';


export function registerNotificationHandlers() {
  ipcMain.handle(NotificationEvents.GET_NOTIFICATIONS, async (_event: IpcMainInvokeEvent): Promise<NotificationResponse> => {
    try {
      const notifications = await fetchNotifications();
      return { 
        success: true, 
        data: notifications.data, 
        status: 'success' 
      };
    } catch (error) {
      console.error('[ELECTRON] Error in get-notifications handler:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error', 
        status: 'error' 
      };
    }
  });

  ipcMain.handle(NotificationEvents.MARK_AS_READ, async (_event: IpcMainInvokeEvent, notificationId: string): Promise<NotificationResponse> => {
    try {
      const result = await markNotificationAsRead(notificationId);
      return { 
        success: true, 
        data: { updated: result.data?.updated || false, id: notificationId }, 
        status: 'success' 
      };
    } catch (error) {
      console.error('[ELECTRON] Error in mark-notification-as-read handler:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error', 
        status: 'error' 
      };
    }
  });

  ipcMain.handle(NotificationEvents.MARK_ALL_AS_READ, async (_event: IpcMainInvokeEvent): Promise<NotificationResponse> => {
    try {
      const result = await markAllNotificationsAsRead();
      return { 
        success: true, 
        data: { updated: result.data?.updated || false, count: result.data?.count || 0 }, 
        status: 'success' 
      };
    } catch (error) {
      console.error('[ELECTRON] Error in mark-all-notifications-as-read handler:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error', 
        status: 'error' 
      };
    }
  });
}

================
File: src/core/ipc/handlers/profile-handlers.ts
================
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import { UserResponse } from '@/types/ipc';
import { UserEvents } from '@/core/ipc/constants';
import { 
  fetchUserProfile, 
  updateUserProfile,
  updateUserSettings,
  UserUpdateData
} from '@/services/user/user-service';

export function registerProfileHandlers() {
  ipcMain.handle(UserEvents.GET_PROFILE, async (_event: IpcMainInvokeEvent): Promise<UserResponse> => {
    try {
      const profile = await fetchUserProfile();
      return { 
        success: true, 
        data: profile, 
        status: 'success' 
      };
    } catch (error) {
      console.error('[ELECTRON] Error in GET_PROFILE handler:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error',
        status: 'error'
      };
    }
  });

  ipcMain.handle(UserEvents.UPDATE_PROFILE, async (_event: IpcMainInvokeEvent, profileData: UserUpdateData): Promise<UserResponse> => {
    try {
      const updatedProfile = await updateUserProfile(profileData);
      return { 
        success: true, 
        data: updatedProfile,
        status: 'success'
      };
    } catch (error) {
      console.error('[ELECTRON] Error in UPDATE_PROFILE handler:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error',
        status: 'error'
      };
    }
  });

  ipcMain.handle(UserEvents.UPDATE_SETTINGS, async (_event: IpcMainInvokeEvent, settings: any): Promise<UserResponse> => {
    try {
      const updatedSettings = await updateUserSettings(settings);
      return { 
        success: true, 
        data: updatedSettings,
        status: 'success'
      };
    } catch (error) {
      console.error('[ELECTRON] Error in UPDATE_SETTINGS handler:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error',
        status: 'error'
      };
    }
  });
}

================
File: src/core/ipc/handlers/space-handlers.ts
================
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import {
  updateSpace,
  updateSpaceModel,
  setActiveSpaceInAPI,
  createSpace,
  deleteSpace,
  fetchActiveSpace,
  fetchSpaces
} from '@/services/spaces/space-service';
import { fetchConversations } from '@/services/conversations/conversation-service';
import { SpaceEvents } from '@/core/ipc/constants';
import { SpaceResponse } from '@/types/space';
import { Space } from '@/types/space';
import { fetchMessages } from '@/services/messages/message-service';
import { Message } from '@/types/message';

export function registerSpaceHandlers() {
  ipcMain.handle(SpaceEvents.GET_SPACE_CONVERSATIONS, async (_event: IpcMainInvokeEvent, spaceId: string): Promise<SpaceResponse> => {
    try {
      const conversations = await fetchConversations(spaceId);
      return { success: true, data: conversations };
    } catch (error) {
      console.error('[ELECTRON] Error in get-space-conversations handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  });

  ipcMain.handle(SpaceEvents.GET_ACTIVE_SPACE, async (_event: IpcMainInvokeEvent): Promise<Space | null> => {
    try {
      const activeSpace = await fetchActiveSpace();
      return activeSpace;
    } catch (error) {
      console.error('[ELECTRON] Error in get-active-space handler:', error);
      throw error;
    }
  });

  ipcMain.handle(SpaceEvents.UPDATE_SPACE, async (_event: IpcMainInvokeEvent, spaceId: string, spaceData: Partial<Space>): Promise<SpaceResponse> => {
    try {
      const updatedSpace = await updateSpace(spaceId, spaceData);
      
      ipcMain.emit(SpaceEvents.SPACE_UPDATED, null, { space: updatedSpace });
      
      return { success: true, data: updatedSpace };
    } catch (error) {
      console.error('[ELECTRON] Error in update-space handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  });

  ipcMain.handle(SpaceEvents.UPDATE_SPACE_MODEL, async (_event: IpcMainInvokeEvent, spaceId: string, modelId: string, provider: string): Promise<SpaceResponse> => {
    try {
      await updateSpaceModel(spaceId, modelId, provider);
      
      const updatedSpace = await fetchActiveSpace();
      if (updatedSpace) {
        ipcMain.emit(SpaceEvents.SPACE_UPDATED, null, { space: updatedSpace });
      }
      
      return { success: true };
    } catch (error) {
      console.error('[ELECTRON] Error in update-space-model handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  });

  ipcMain.handle(SpaceEvents.SET_ACTIVE_SPACE, async (_event: IpcMainInvokeEvent, spaceId: string): Promise<SpaceResponse> => {
    try {
      const spaceIdStr = String(spaceId || '').trim();
      
      if (!spaceIdStr) {
        return { success: false, error: 'Space ID is required' };
      }
      
      await setActiveSpaceInAPI(spaceIdStr);
      const activeSpace = await fetchActiveSpace();
      
      if (!activeSpace) {
        return { success: false, error: 'Failed to fetch active space' };
      }

      const conversations = await fetchConversations(spaceIdStr);
      let firstConversationMessages: Message[] = [];
      
      if (conversations && conversations.length > 0) {
        firstConversationMessages = await fetchMessages(conversations[0].id);
      }

      const responseData = {
        space: activeSpace,
        conversations: conversations || [],
        messages: firstConversationMessages || []
      };

      ipcMain.emit(SpaceEvents.SPACE_UPDATED, null, responseData);
      
      return { 
        success: true, 
        data: responseData
      };
    } catch (error) {
      console.error('[ELECTRON] Error in set-active-space handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  });
  
  ipcMain.handle(SpaceEvents.CREATE_SPACE, async (_event: IpcMainInvokeEvent, spaceData: Partial<Space>): Promise<SpaceResponse> => {
    try {
      const newSpace = await createSpace(spaceData);
      
      const allSpaces = await fetchSpaces();
      
      if (allSpaces.length === 1) {
        await setActiveSpaceInAPI(newSpace.id);
        ipcMain.emit(SpaceEvents.SPACE_UPDATED, null, { space: newSpace });
      }
      
      return { success: true, data: newSpace };
    } catch (error) {
      console.error('[ELECTRON] Error in create-space handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  });
  
  ipcMain.handle(SpaceEvents.DELETE_SPACE, async (_event: IpcMainInvokeEvent, spaceId: string): Promise<SpaceResponse> => {
    try {
      await deleteSpace(spaceId);
      
      const allSpaces = await fetchSpaces();
      
      const activeSpace = await fetchActiveSpace();
      ipcMain.emit(SpaceEvents.SPACE_UPDATED, null, { space: activeSpace });
      
      return { success: true };
    } catch (error) {
      console.error('[ELECTRON] Error in delete-space handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  });
  
  ipcMain.handle(SpaceEvents.GET_SPACES, async (_event: IpcMainInvokeEvent): Promise<SpaceResponse> => {
    try {
      const spaces = await fetchSpaces();
      return { success: true, data: spaces };
    } catch (error) {
      console.error('[ELECTRON] Error in get-spaces handler:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  });
}

================
File: src/core/ipc/handlers/user-handlers.ts
================
import { ipcMain, IpcMainInvokeEvent } from 'electron';
import { UserEvents } from '@/core/ipc/constants';
import { 
  updateUserPassword, 
  updateUserEmailPreferences,
  getUserSettings,
  PasswordUpdateData, 
  EmailPreferences
} from '@/services/user/user-service';
import { UserResponse } from '@/types/ipc';

export function registerUserHandlers() {
  ipcMain.handle(UserEvents.UPDATE_PASSWORD, async (_event: IpcMainInvokeEvent, data: PasswordUpdateData): Promise<UserResponse> => {
    try {
      await updateUserPassword(data);
      return { success: true, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error in UPDATE_PASSWORD:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to update password',
        status: 'error' 
      };
    }
  });

  ipcMain.handle(UserEvents.UPDATE_EMAIL_PREFERENCES, async (_event: IpcMainInvokeEvent, preferences: EmailPreferences): Promise<UserResponse> => {
    try {
      await updateUserEmailPreferences(preferences);
      return { success: true, status: 'success' };
    } catch (error) {
      console.error('[ELECTRON] Error in UPDATE_EMAIL_PREFERENCES:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to update email preferences',
        status: 'error' 
      };
    }
  });

  ipcMain.handle(UserEvents.GET_SETTINGS, async (_event: IpcMainInvokeEvent): Promise<UserResponse> => {
    try {
      const settings = await getUserSettings();
      return { 
        success: true, 
        data: settings, 
        status: 'success' 
      };
    } catch (error) {
      console.error('[ELECTRON] Error in GET_SETTINGS:', error);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Failed to fetch settings',
        status: 'error' 
      };
    }
  });

  // Note: UPDATE_SETTINGS is handled in profile-handlers.ts
}

================
File: src/core/ipc/constants.ts
================
/**
 * Auth-related IPC events
 */
export const AuthEvents = {
  VERIFY_TOKEN: 'verify-token',
  GET_AUTH_TOKEN: 'get-auth-token',
  REFRESH_AUTH_TOKENS: 'refresh-auth-tokens',
  SIGN_IN: 'sign-in',
  SIGN_UP: 'sign-up',
  SIGN_OUT: 'sign-out',
  RESET_PASSWORD: 'reset-password',
  SET_AUTH_TOKENS: 'set-auth-tokens',
  CLEAR_AUTH_DATA: 'clear-auth-data',
} as const;

/**
 * Command center-related IPC events
 */
export const CommandCenterEvents = {
  TOGGLE: 'command-center:toggle',
  SHOW: 'command-center:show',
  CLOSE: 'command-center:close',
  OPEN_DIALOG: 'command-center:open-dialog',
  DIALOG_CLOSED: 'command-center:dialog-closed',
  REFRESH: 'command-center:refresh',
  CHECK_TYPE: 'command-center:check-type',
  SET_TYPE: 'command-center:set-type',
  SYNC_STATE: 'command-center:sync-state',
  ON_RESIZE: 'command-center:on-resize',
  SEARCH_FILES: 'command-center:search-files',
  READ_FILE: 'command-center:read-file',
  PING: 'command-center:ping'
} as const;

export type CommandCenterEvent = keyof typeof CommandCenterEvents;

/**
 * Space-related IPC events
 */
export const SpaceEvents = {
  GET_SPACE_CONVERSATIONS: 'get-space-conversations',
  UPDATE_SPACE: 'update-space',
  UPDATE_SPACE_MODEL: 'update-space-model',
  SET_ACTIVE_SPACE: 'set-active-space',
  GET_ACTIVE_SPACE: 'get-active-space',
  GET_SPACES: 'get-spaces',
  SPACE_UPDATED: 'space-updated',
  CREATE_SPACE: 'create-space',
  DELETE_SPACE: 'delete-space'
} as const;

/**
 * Message-related IPC events
 */
export const MessageEvents = {
  GET_CONVERSATION_MESSAGES: 'get-conversation-messages',
  SEND_MESSAGE: 'send-message',
  DELETE_MESSAGE: 'delete-message',
  UPDATE_MESSAGE: 'update-message'
} as const;

/**
 * Chat-related IPC events
 */
export const ChatEvents = {
  CHAT_STREAM_START: 'chat-stream-start',
  CHAT_STREAM_CHUNK: 'chat-stream-chunk',
  CHAT_STREAM_FINISH: 'chat-stream-finish',
  CHAT_STREAM_ERROR: 'chat-stream-error',
  INITIATE_CHAT: 'initiate-chat',
  CANCEL_CHAT: 'cancel-chat'
} as const;

/**
 * Search-related IPC events
 */
export const SearchEvents = {
  SEARCH_MESSAGES: 'search-messages',
  SEARCH_CONVERSATIONS: 'search-conversations',
  SEARCH_SPACES: 'search-spaces'
} as const;

/**
 * App state-related IPC events
 */
export const UserEvents = {
  GET_PROFILE: 'get-profile',
  UPDATE_PROFILE: 'update-profile',
  UPDATE_PASSWORD: 'update-password',
  UPDATE_EMAIL_PREFERENCES: 'update-email-preferences',
  GET_SETTINGS: 'get-settings',
  UPDATE_SETTINGS: 'update-settings'
} as const;

/**
 * Conversation-related IPC events
 */
export const ConversationEvents = {
  GET_CONVERSATIONS: 'get-conversations',
  CREATE_CONVERSATION: 'create-conversation',
  UPDATE_CONVERSATION: 'update-conversation',
  DELETE_CONVERSATION: 'delete-conversation',
  SET_ACTIVE_CONVERSATION: 'set-active-conversation',
  CONVERSATIONS_UPDATED: 'conversations-updated'
} as const;

export const AppStateEvents = {
  SYNC_STATE: 'sync-app-state',
  GET_STATE: 'get-app-state',
  REFRESH_DATA: 'refresh-app-data',
  STATE_UPDATED: 'state-updated'
} as const;

/**
 * Notification-related IPC events
 */
export const NotificationEvents = {
  GET_NOTIFICATIONS: 'get-notifications',
  MARK_AS_READ: 'mark-notification-as-read',
  MARK_ALL_AS_READ: 'mark-all-notifications-as-read',
  NOTIFICATION_RECEIVED: 'notification-received'
} as const;

// Type for all IPC events
export type IpcEvent = 
  | typeof AuthEvents[keyof typeof AuthEvents]
  | typeof CommandCenterEvents[keyof typeof CommandCenterEvents]
  | typeof SpaceEvents[keyof typeof SpaceEvents]
  | typeof MessageEvents[keyof typeof MessageEvents]
  | typeof SearchEvents[keyof typeof SearchEvents]
  | typeof UserEvents[keyof typeof UserEvents]
  | typeof ConversationEvents[keyof typeof ConversationEvents]
  | typeof AppStateEvents[keyof typeof AppStateEvents]
  | typeof NotificationEvents[keyof typeof NotificationEvents]
  | typeof ChatEvents[keyof typeof ChatEvents];

================
File: src/core/ipc/ipc-handlers.ts
================
import { registerAuthHandlers } from '@/core/ipc/handlers/auth-handlers';
import { registerMessageHandlers } from '@/core/ipc/handlers/message-handlers';
import { registerSpaceHandlers } from '@/core/ipc/handlers/space-handlers';
import { registerAppStateHandlers } from '@/core/ipc/handlers/app-state-handlers';
import { registerCommandCenterHandlers } from '@/core/ipc/handlers/command-center-handlers';
import { registerConversationHandlers } from '@/core/ipc/handlers/conversation-handlers';
import { registerUserHandlers } from '@/core/ipc/handlers/user-handlers';
import { registerNotificationHandlers } from '@/core/ipc/handlers/notification-handlers';

export function registerIpcHandlers(): void {
  registerAuthHandlers();
  registerMessageHandlers();
  registerSpaceHandlers();
  registerAppStateHandlers();
  registerCommandCenterHandlers();
  registerConversationHandlers();
  registerUserHandlers();
  registerNotificationHandlers();
}

================
File: src/core/utils/state-utils.ts
================
import { cloneDeep } from 'lodash';

export function makeSerializable<T>(state: T): T {
  try {
    const serialized = JSON.parse(JSON.stringify(cloneDeep(state)));
    return serialized;
  } catch (error) {
    console.error('Failed to serialize state:', error);
    return {} as T;
  }
}

export function sanitizeStateForIPC<T extends Record<string, any>>(state: T): Partial<T> {
  const sanitized: Partial<T> = {};
  
  for (const [key, value] of Object.entries(state)) {
    if (value === undefined || value === null) continue;
    if (typeof value === 'function') continue;
    if (value instanceof Error) {
      sanitized[key as keyof T] = value.message as any;
      continue;
    }
    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        sanitized[key as keyof T] = value.map(item => 
          typeof item === 'object' ? sanitizeStateForIPC(item) : item
        ) as any;
      } else {
        sanitized[key as keyof T] = sanitizeStateForIPC(value) as any;
      }
      continue;
    }
    sanitized[key as keyof T] = value;
  }
  
  return sanitized;
}

================
File: src/core/window/shortcuts.ts
================
import { globalShortcut, app, BrowserWindow } from 'electron';
import { CommandType, ShortcutKey } from '@/types/command';
import { 
  createCommandCenterWindow, 
  getContextCommandWindow,
  getAllVisibleCommandWindows,    
  getWindowState
} from './window-service';

interface ShortcutState {
  activeCommandType: CommandType | null;
  lastUsedShortcut: string | null;
  lastUsedTime: number;
}

const SHORTCUT_CONFIG = {
  TOGGLE_TIMEOUT: 1500,
  FOCUS_DELAY: 50
} as const;

const COMMAND_SHORTCUTS: Record<ShortcutKey, CommandType> = {
  "CommandOrControl+Option+S": "spaces",
  "CommandOrControl+Option+C": "conversations",
  "CommandOrControl+Option+M": "models",
  "CommandOrControl+Option+T": "backgroundTasks",
  "CommandOrControl+Option+G": "suggestions",
  "CommandOrControl+Option+H": "actions",
  "CommandOrControl+Option+Q": "chatModes",
  "CommandOrControl+Option+W": "messageSearch",
  "CommandOrControl+Option+E": "similarMessages",
  "CommandOrControl+Option+A": "actions",
} as const;

function hideAllWindowsExcept(commandType: CommandType) {
  Array.from(getWindowState().commandWindows.entries()).forEach(([type, win]) => {
    if (win && !win.isDestroyed() && win.isVisible() && type !== commandType) {
      win.hide();
    }
  });
}

function focusWindowWithDelay(window: BrowserWindow, commandType: CommandType) {
  window.focus();
  window.showInactive();
  
  setTimeout(() => {
    if (!window.isDestroyed()) {
      window.focus();
    }
  }, SHORTCUT_CONFIG.FOCUS_DELAY);
}

async function showExistingWindow(window: BrowserWindow, commandType: CommandType) {
  hideAllWindowsExcept(commandType);
  focusWindowWithDelay(window, commandType);
}

async function createAndShowNewWindow(commandType: CommandType) {
  const newWindow = await createCommandCenterWindow(commandType);
  if (newWindow) {
    hideAllWindowsExcept(commandType);
    focusWindowWithDelay(newWindow, commandType);
  }
  return newWindow;
}

function shouldCloseWindow(
  shortcut: string, 
  commandType: CommandType, 
  state: ShortcutState, 
  isWindowVisible: boolean
): boolean {
  const now = Date.now();
  const isSameShortcut = shortcut === state.lastUsedShortcut;
  const isWithinToggleTime = (now - state.lastUsedTime) < SHORTCUT_CONFIG.TOGGLE_TIMEOUT;
  
  return (isSameShortcut && isWithinToggleTime && isWindowVisible) || 
         (commandType === state.activeCommandType);
}

async function handleShortcutPress(
  shortcut: ShortcutKey, 
  commandType: CommandType, 
  state: ShortcutState
) {
  const window = getContextCommandWindow(commandType);
  const isWindowVisible = window?.isVisible() || false;

  if (shouldCloseWindow(shortcut, commandType, state, isWindowVisible)) {
    window?.hide();
    state.activeCommandType = null;
    state.lastUsedShortcut = null;
    return;
  }

  getAllVisibleCommandWindows().forEach(([type, win]) => {
    if (type !== commandType) win.hide();
  });

  if (window && !window.isDestroyed()) {
    await showExistingWindow(window, commandType);
  } else {
    await createAndShowNewWindow(commandType);
  }

  state.activeCommandType = commandType;
  state.lastUsedShortcut = shortcut;
  state.lastUsedTime = Date.now();
}

export function registerGlobalShortcuts() {
  const shortcutState: ShortcutState = {
    activeCommandType: null,
    lastUsedShortcut: null,
    lastUsedTime: 0
  };

  Object.entries(COMMAND_SHORTCUTS).forEach(([shortcut, commandType]) => {
    globalShortcut.register(shortcut as ShortcutKey, async () => {
      try {
        await handleShortcutPress(shortcut as ShortcutKey, commandType, shortcutState);
      } catch (error) {
        console.error(`[ELECTRON] Error handling shortcut for ${commandType}:`, error);
      }
    });
  });

  app.on("will-quit", () => globalShortcut.unregisterAll());
}

================
File: src/core/window/window-service.ts
================
import { BrowserWindow, screen, app } from 'electron';
import { join } from 'path';
import { CommandType } from '@/types/command';
import { APP_BASE_URL } from '../auth/auth-service';
import { CommandCenterEvents } from '../ipc/constants';
import { useMainStore } from '@/store/main';
import { sanitizeStateForIPC } from '../utils/state-utils';
import { fetchInitialAppData } from '../../services/app-data/app-data-service';
import debounce from 'lodash/debounce';

type CommandGroup = {
  type: CommandType;
  title: string;
  items: any[];
  icon: string;
  description: string;
};

const WINDOW_STATE = {
  main: null as BrowserWindow | null,
  commandWindows: new Map<CommandType, BrowserWindow>(),
  isDialogOpen: false,
  cachedState: null as any,
  lastStateUpdate: 0
};

const COMMAND_CENTER_CONFIG = {
  width: 680,
  height: 600,
  frame: false,
  transparent: false,
  backgroundColor: '#161617',
  alwaysOnTop: true,
  hasShadow: true,
  skipTaskbar: true,
  resizable: false,
  show: false,
  fullscreenable: false,
  type: 'panel',
  webPreferences: {
    preload: join(app.getAppPath(), 'out', 'preload', 'index.js'),
    nodeIntegration: false,
    contextIsolation: true
  }
} as const;

const CONTEXT_COMMAND_CONFIG = {
  ...COMMAND_CENTER_CONFIG,
  width: 580,
  height: 500,
  fullscreenable: false,
  type: 'panel'
} as const;

const MAIN_WINDOW_CONFIG = {
  width: 1200,
  height: 800,
  webPreferences: {
    preload: join(app.getAppPath(), 'out', 'preload', 'index.js'),
    nodeIntegration: false,
    contextIsolation: true
  }
} as const;

function getCommandGroups(state: any): CommandGroup[] {
  return [
    {
      type: 'spaces',
      title: 'Spaces',
      items: state.spaces || [],
      icon: 'SpaceIcon',
      description: 'Your workspaces'
    },
    {
      type: 'conversations',
      title: 'Conversations',
      items: state.conversations || [],
      icon: 'ChatIcon',
      description: 'Your chat history'
    },
    {
      type: 'models',
      title: 'Models',
      items: state.models || [],
      icon: 'ModelIcon',
      description: 'Available AI models'
    },
  ];
}

function getCachedState() {
  const now = Date.now();
  if (!WINDOW_STATE.cachedState || now - WINDOW_STATE.lastStateUpdate > 5000) {
    const state = useMainStore.getState();
    WINDOW_STATE.cachedState = sanitizeStateForIPC(state);
    WINDOW_STATE.lastStateUpdate = now;
  }
  return WINDOW_STATE.cachedState;
}

const debouncedStateSync = debounce((window: BrowserWindow, commandType?: CommandType) => {
  try {
    const sanitizedState = getCachedState();
    const payload = commandType === 'unified' as CommandType
      ? { ...sanitizedState, isUnified: true, groups: getCommandGroups(sanitizedState) }
      : { ...sanitizedState, isUnified: false };

    if (!window.isDestroyed()) {
      window.webContents.send(CommandCenterEvents.SYNC_STATE, { success: true, data: payload });
    }
  } catch (error) {
    console.error('Failed to sync state to window:', error);
  }
}, 100);

function syncStateToWindow(window: BrowserWindow, commandType?: CommandType) {
  debouncedStateSync(window, commandType);
}

function centerWindowOnScreen(window: BrowserWindow) {
  const { x, y, width } = screen.getDisplayNearestPoint(screen.getCursorScreenPoint()).workArea;
  const bounds = window.getBounds();
  window.setPosition(
    Math.floor(x + (width - bounds.width) / 2),
    Math.floor(y + 100)
  );
}

function configureWindowBehavior(window: BrowserWindow, commandType: CommandType) {
  window.setAlwaysOnTop(true, 'screen-saver');
  window.setVisibleOnAllWorkspaces(true);
  centerWindowOnScreen(window);
}

function setupBlurProtection(window: BrowserWindow, commandType: CommandType) {
  let lastShownTime = 0;
  let blurProtectionActive = false;

  window.on('show', () => {
    lastShownTime = Date.now();
    blurProtectionActive = true;
    setTimeout(() => blurProtectionActive = false, 500);
  });

  window.on('blur', () => {
    if (WINDOW_STATE.isDialogOpen) return;
    
    const timeSinceShown = Date.now() - lastShownTime;
    if (blurProtectionActive && timeSinceShown < 500) return;
    
    window.hide();
  });
}

function setupWindowEvents(window: BrowserWindow, commandType: CommandType) {
  window.webContents.once('did-finish-load', async () => {
    syncStateToWindow(window, commandType);
    try {
      const freshData = await fetchInitialAppData();
      useMainStore.getState().setAppState(freshData);
      syncStateToWindow(window, commandType);
    } catch (error) {
      console.error('Failed to fetch initial app data:', error);
    }
  });

  window.once('ready-to-show', () => {});
  
  window.on('close', event => {
    if (WINDOW_STATE.main?.isVisible()) {
      event.preventDefault();
      window.hide();
    }
  });

  setupBlurProtection(window, commandType);
}

function getWindowUrl(commandType: CommandType): string {
  return process.env.NODE_ENV === 'development'
    ? `http://localhost:5173/#/command-center/${commandType}`
    : `${APP_BASE_URL}/#/command-center/${commandType}`;
}

export async function preloadCommandWindows() {
  const commandTypes: CommandType[] = ['spaces', 'conversations', 'models', 'chatModes'];
  
  return Promise.all(commandTypes.map(async (type) => {
    if (!WINDOW_STATE.commandWindows.has(type)) {
      const window = await createCommandCenterWindow(type);
      if (window) {
        window.hide();
      }
    }
  }));
}

export async function toggleCommandCenterWindow(commandType: CommandType): Promise<BrowserWindow | null> {
  const window = getContextCommandWindow(commandType);
  
  if (window && !window.isDestroyed()) {
    if (window.isVisible()) {
      window.hide();
    } else {
      window.show();
      window.focus();
      
      setTimeout(() => {
        if (!window.isDestroyed()) {
          syncStateToWindow(window, commandType);
        }
      }, 0);
    }
    return window;
  }

  const newWindow = await createCommandCenterWindow(commandType);
  if (newWindow) {
    newWindow.show();
    newWindow.focus();
  }
  return newWindow;
}

export function getCommandCenterWindow(): BrowserWindow | null {
    return WINDOW_STATE.commandWindows.get('spaces') || null;
}

export function getContextCommandWindow(commandType: CommandType): BrowserWindow | null {
  return WINDOW_STATE.commandWindows.get(commandType) || null;
}

export function getAllVisibleCommandWindows(): [CommandType, BrowserWindow][] {
  return Array.from(WINDOW_STATE.commandWindows.entries())
    .filter(([_, win]) => win && !win.isDestroyed() && win.isVisible());
}

export function getWindowState() {
  return WINDOW_STATE;
}

export function setDialogState(isOpen: boolean) {
  WINDOW_STATE.isDialogOpen = isOpen;
}

export function setCommandType(commandType: CommandType) {
  const window = getContextCommandWindow(commandType);
  if (window && !window.isDestroyed()) {
    window.webContents.send(CommandCenterEvents.SET_TYPE, commandType);
  }
}

export async function createCommandCenterWindow(commandType: CommandType): Promise<BrowserWindow | null> {
  try {
    const config = commandType === 'spaces' ? COMMAND_CENTER_CONFIG : CONTEXT_COMMAND_CONFIG;
    const window = new BrowserWindow({
      ...config,
      show: false,
      fullscreenable: false,
      webPreferences: {
        ...config.webPreferences,
        backgroundThrottling: false
      }
    });
    
    window.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: true });
    window.setAlwaysOnTop(true, 'floating', 1);
    WINDOW_STATE.commandWindows.set(commandType, window);
    
    window.loadURL(getWindowUrl(commandType));
    
    window.once('ready-to-show', () => {
      setTimeout(() => {
        setupWindowEvents(window, commandType);
        if (process.env.NODE_ENV === 'development') {
          window.webContents.openDevTools({ mode: 'detach' });
        }
      }, 0);
    });
    
    return window;
  } catch (error) {
    console.error('Failed to create command center window:', error);
    return null;
  }
}

export async function createMainWindow(): Promise<BrowserWindow | null> {
  try {
    const window = new BrowserWindow(MAIN_WINDOW_CONFIG);
    WINDOW_STATE.main = window;

    const url = process.env.NODE_ENV === 'development'
      ? 'http://localhost:5173'
      : APP_BASE_URL;

    await window.loadURL(url);

    window.webContents.once('did-finish-load', async () => {
      try {
        const freshData = await fetchInitialAppData();
        useMainStore.getState().setAppState(freshData);
        window.webContents.send(CommandCenterEvents.SYNC_STATE, { success: true, data: sanitizeStateForIPC(useMainStore.getState()) });
      } catch (error) {
        console.error('Failed to fetch initial app data:', error);
      }
    });

    window.on('enter-full-screen', () => {
      getAllVisibleCommandWindows().forEach(([_, win]) => {
        if (!win.isDestroyed()) {
          win.hide();
        }
      });
    });

    return window;
  } catch (error) {
    console.error('Failed to create main window:', error);
    return null;
  }
}

export function getMainWindow(): BrowserWindow | null {
  return WINDOW_STATE.main;
}

================
File: src/errors/index.ts
================
export class BaseError extends Error {
  public statusCode: number;
  public details?: Record<string, any>;

  constructor(message: string, statusCode: number = 500, details?: Record<string, any>) {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.details = details;
    Object.setPrototypeOf(this, BaseError.prototype);
  }
}

export class AuthenticationError extends BaseError {
  constructor(message: string = 'Authentication failed', details?: Record<string, any>) {
    super(message, 401, details);
    Object.setPrototypeOf(this, AuthenticationError.prototype);
  }
}

export class AuthorizationError extends BaseError {
  constructor(message: string = 'You do not have permission to perform this action', details?: Record<string, any>) {
    super(message, 403, details);
    Object.setPrototypeOf(this, AuthorizationError.prototype);
  }
}

export class NotFoundError extends BaseError {
  constructor(resource: string = 'Resource', details?: Record<string, any>) {
    super(`${resource} not found`, 404, details);
    Object.setPrototypeOf(this, NotFoundError.prototype);
  }
}

export class ValidationError extends BaseError {
  constructor(message: string = 'Validation failed', details?: Record<string, any>) {
    super(message, 400, details);
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
}

export class RateLimitError extends BaseError {
  constructor(message: string = 'Rate limit exceeded', details?: Record<string, any>) {
    super(message, 429, details);
    Object.setPrototypeOf(this, RateLimitError.prototype);
  }
}

export class ServerError extends BaseError {
  constructor(message: string = 'Internal server error', details?: Record<string, any>) {
    super(message, 500, details);
    Object.setPrototypeOf(this, ServerError.prototype);
  }
}

export class ConflictError extends BaseError {
  constructor(message: string = 'Resource conflict', details?: Record<string, any>) {
    super(message, 409, details);
    Object.setPrototypeOf(this, ConflictError.prototype);
  }
}

================
File: src/hooks/use-app-state.ts
================
import { useState, useEffect } from 'react';
import { useRendererStore } from '@/store/renderer';

export function useAppState() {
  const rendererStore = useRendererStore();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let mounted = true;

    const fetchState = async () => {
      try {
        setIsLoading(true);
        await rendererStore.fetchAppState();
      } catch (error) {
        if (mounted) {
          console.error('[useAppState] Error fetching app state:', error);
          setError(error instanceof Error ? error : new Error('Failed to fetch app state'));
        }
      } finally {
        if (mounted) {
          setIsLoading(false);
        }
      }
    };

    fetchState();

    return () => {
      mounted = false;
    };
  }, []);

  return {
    isLoading,
    error,
    refetch: async () => {
      setIsLoading(true);
      try {
        await rendererStore.fetchAppState();
      } catch (error) {
        setError(error instanceof Error ? error : new Error('Failed to fetch app state'));
      } finally {
        setIsLoading(false);
      }
    }
  };
}

================
File: src/hooks/use-auth.ts
================
import { useState, useCallback } from 'react';
import { useToast } from '@/hooks/use-toast';
import { AuthEvents, AppStateEvents } from '@/core/ipc/constants';

interface AuthSession {
  access_token: string;
  refresh_token: string;
}

interface AuthCredentials {
  email: string;
  password: string;
}

export function useAuth() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [session, setSession] = useState<AuthSession | null>(null);
  const { toast } = useToast();
  
  const setupAuthListener = useCallback((callback?: (session: AuthSession | null) => void) => {
    if (typeof window === 'undefined' || !window.electron) {
      console.log('Electron API not available');
      return () => {};
    }
    
    // Set up listener for state updates
    const handleStateUpdate = (event: any, response: any) => {
      if (response.success && response.data?.session) {
        setSession(response.data.session);
        if (callback) callback(response.data.session);
      }
    };
    
    window.electron.on(AppStateEvents.STATE_UPDATED, handleStateUpdate);
    
    return () => {
      window.electron.off(AppStateEvents.STATE_UPDATED, handleStateUpdate);
    };
  }, []);
  
  const verifyAndGetToken = useCallback(async (): Promise<AuthSession | null> => {
    try {
      setIsLoading(true);
      setError(null);
      
      if (typeof window === 'undefined' || !window.electron) {
        throw new Error('Electron API not available');
      }
      
      const verifyResponse = await window.electron.invoke(AuthEvents.VERIFY_TOKEN);
      
      if (verifyResponse.success && verifyResponse.data?.isValid) {
        const tokenResponse = await window.electron.invoke(AuthEvents.GET_AUTH_TOKEN);
        
        if (tokenResponse?.success && tokenResponse.data) {
          const { accessToken, refreshToken } = tokenResponse.data;
          if (accessToken && refreshToken) {
            const authSession = {
              access_token: accessToken,
              refresh_token: refreshToken
            };
            setSession(authSession);
            return authSession;
          }
        }
      }
      
      return null;
    } catch (err) {
      console.error('Error verifying/getting tokens:', err);
      setError(err instanceof Error ? err.message : 'Failed to verify token');
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const handleError = (error: unknown) => {
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred';
    setError(errorMessage);
    toast({
      title: "Error",
      description: errorMessage,
      variant: "destructive"
    });
    return false;
  };

  const handleSuccess = (message: string) => {
    setError(null);
    toast({
      title: "Success",
      description: message,
      variant: "success"
    });
    return true;
  };

  const signIn = async ({ email, password }: AuthCredentials) => {
    try {
      setIsLoading(true);
      setError(null);

      if (!email || !password) {
        throw new Error("Please fill in all fields");
      }

      if (typeof window === 'undefined' || !window.electron) {
        throw new Error("Electron API not available");
      }

      const response = await window.electron.invoke(AuthEvents.SIGN_IN, email, password);

      if (!response.success) {
        throw new Error(response.error || 'Authentication failed');
      }

      if (response.data?.session) {
        setSession(response.data.session);
      }

      // Sync state and wait for the complete data to be loaded
      try {
        const syncResponse = await window.electron.invoke(AppStateEvents.SYNC_STATE);
        if (!syncResponse.success) {
          console.warn("State sync was not successful after login:", syncResponse.error);
        }
        
        // Get the complete state data after syncing
        const stateResponse = await window.electron.invoke(AppStateEvents.GET_STATE);
        if (!stateResponse.success) {
          console.warn("Failed to get app state after login:", stateResponse.error);
        }
      } catch (syncError) {
        console.error("Error during state synchronization after login:", syncError);
        // We don't throw here because we want to return successful login
        // The UI layer will handle data loading errors separately
      }

      return handleSuccess("Successfully signed in");
    } catch (error) {
      return handleError(error);
    } finally {
      setIsLoading(false);
    }
  };

  const signUp = async ({ email, password }: AuthCredentials) => {
    try {
      setIsLoading(true);
      setError(null);

      if (!email || !password) {
        throw new Error("Please fill in all fields");
      }

      if (password.length < 6) {
        throw new Error("Password must be at least 6 characters");
      }

      // Check if Electron API is available
      if (typeof window === 'undefined' || !window.electron) {
        throw new Error("Electron API not available");
      }

      const response = await window.electron.invoke(AuthEvents.SIGN_UP, { email, password });

      if (!response.success) {
        throw new Error(response.error || 'Failed to create account');
      }

      // Sync state and wait for the complete data to be loaded
      try {
        const syncResponse = await window.electron.invoke(AppStateEvents.SYNC_STATE);
        if (!syncResponse.success) {
          console.warn("State sync was not successful after signup:", syncResponse.error);
        }
        
        // Get the complete state data after syncing
        const stateResponse = await window.electron.invoke(AppStateEvents.GET_STATE);
        if (!stateResponse.success) {
          console.warn("Failed to get app state after signup:", stateResponse.error);
        }
      } catch (syncError) {
        console.error("Error during state synchronization after signup:", syncError);
        // We don't throw here because we want to return successful signup
        // The UI layer will handle data loading errors separately
      }

      return handleSuccess("Successfully signed up");
    } catch (error) {
      return handleError(error);
    } finally {
      setIsLoading(false);
    }
  };

  const resetPassword = async (email: string) => {
    try {
      setIsLoading(true);
      setError(null);

      if (!email) {
        throw new Error("Please provide an email address");
      }

      // Check if Electron API is available
      if (typeof window === 'undefined' || !window.electron) {
        throw new Error("Electron API not available");
      }

      const response = await window.electron.invoke(AuthEvents.RESET_PASSWORD, { email });

      if (!response.success) {
        throw new Error(response.error || 'Failed to reset password');
      }

      return handleSuccess("Password reset email sent");
    } catch (error) {
      return handleError(error);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Function to sync the application state
  const syncAppState = async (): Promise<boolean> => {
    try {
      setIsLoading(true);
      setError(null);
      
      // Check if Electron API is available
      if (typeof window === 'undefined' || !window.electron) {
        throw new Error("Electron API not available");
      }
      
      const response = await window.electron.invoke(AppStateEvents.SYNC_STATE);
      return response.success || false;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to sync app state');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  // Sign out function
  const signOut = async () => {
    try {
      setIsLoading(true);
      setError(null);

      // Check if Electron API is available
      if (typeof window === 'undefined' || !window.electron) {
        throw new Error("Electron API not available");
      }

      // Reset renderer state to ensure clean state on next sign-in
      if (window.electron) {
        try {
          // Reset initialDataLoaded in renderer store
          const rendererStore = window.rendererStore;
          if (rendererStore) {
            rendererStore.setAppState({ 
              initialDataLoaded: false,
              spaces: [],
              activeSpace: null,
              conversations: [],
              messages: [],
              user: null,
              profile: null
            });
          }
        } catch (storeError) {
          console.error("Error resetting renderer store:", storeError);
        }
      }

      const response = await window.electron.invoke(AuthEvents.SIGN_OUT);

      if (!response.success) {
        throw new Error(response.error || 'Failed to sign out');
      }

      setSession(null);
      return handleSuccess("Successfully signed out");
    } catch (error) {
      return handleError(error);
    } finally {
      setIsLoading(false);
    }
  };

  // Helper property to check if user is authenticated
  const isAuthenticated = !!session?.access_token;

  return {
    isLoading,
    error,
    session,
    isAuthenticated,
    setupAuthListener,
    verifyAndGetToken,
    signIn,
    signUp,
    signOut,
    resetPassword,
    syncAppState
  };
}

================
File: src/hooks/use-command-center.ts
================
import { useState, useCallback, useEffect } from 'react';
import { CommandType } from '@/types/command';
import { IpcResponse } from '@/types/ipc';

interface CommandCenterDialog {
  type: string;
  data: unknown;
}

interface CommandCenterHookState {
  isOpen: boolean;
  activeCommand?: CommandType;
  dialogType?: string;
  dialogData?: unknown;
  isDataLoaded: boolean;
}

interface CommandCenterHookReturn {
  state: CommandCenterHookState;
  isLoading: boolean;
  error: string | null;
  updateState: (newState: Partial<CommandCenterHookState>) => Promise<void>;
  openDialog: (dialogType: string, data: unknown) => Promise<void>;
  closeDialog: () => Promise<void>;
  close: () => Promise<void>;
  refreshCommandCenter: () => Promise<void>;
  currentProvider?: CommandType;
  currentDialog: CommandCenterDialog | null;
}

const initialState: CommandCenterHookState = {
  isOpen: false,
  activeCommand: undefined,
  dialogType: undefined,
  dialogData: undefined,
  isDataLoaded: false
};

type ElectronAPIKey = 'open-command-type' | 'open-dialog' | 'close-dialog' | 'close-command-center' | 'refresh-command-center';

async function handleIpcRequest<T>(
  request: () => Promise<IpcResponse<T>>,
  setLoading: (loading: boolean) => void,
  setError: (error: string | null) => void
): Promise<T | null> {
  try {
    setLoading(true);
    setError(null);
    const response = await request();
    
    if (!response?.success) {
      throw new Error(response?.error || 'Operation failed');
    }
    
    return response.data || null;
  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'An error occurred';
    setError(errorMessage);
    return null;
  } finally {
    setLoading(false);
  }
}

async function callElectronAPI<T>(
  key: ElectronAPIKey,
  args?: unknown[]
): Promise<IpcResponse<T>> {
  const api = window.electronAPI?.[key];
  if (!api) {
    return { success: false, error: `API ${key} not found` };
  }
  try {
    return await api(...(args || []));
  } catch (error) {
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

export function useCommandCenter(): CommandCenterHookReturn {
  const [state, setState] = useState<CommandCenterHookState>(initialState);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  const updateState = useCallback(async (newState: Partial<CommandCenterHookState>) => {
    if (newState.activeCommand && newState.activeCommand !== state.activeCommand) {
      await handleIpcRequest(
        () => callElectronAPI('open-command-type', [newState.activeCommand]),
        setIsLoading,
        setError
      );
    }
    setState(prevState => ({ ...prevState, ...newState }));
  }, [state.activeCommand]);

  const openDialog = useCallback(async (dialogType: string, data: unknown) => {
    const response = await handleIpcRequest(
      () => callElectronAPI('open-dialog', [dialogType, data]),
      setIsLoading,
      setError
    );
    
    if (response) {
      setState(prevState => ({
        ...prevState,
        dialogType,
        dialogData: data
      }));
    }
  }, []);

  const closeDialog = useCallback(async () => {
    const response = await handleIpcRequest(
      () => callElectronAPI('close-dialog'),
      setIsLoading,
      setError
    );
    
    if (response) {
      setState(prevState => ({
        ...prevState,
        dialogType: undefined,
        dialogData: undefined
      }));
    }
  }, []);

  const close = useCallback(async () => {
    const response = await handleIpcRequest(
      () => callElectronAPI('close-command-center'),
      setIsLoading,
      setError
    );
    
    if (response) {
      setState(prev => ({ ...prev, isOpen: false, activeCommand: undefined, dialogType: undefined, dialogData: undefined }));
    }
  }, []);

  const refreshCommandCenter = useCallback(async () => {
    await handleIpcRequest(
      () => callElectronAPI('refresh-command-center'),
      setIsLoading,
      setError
    );
  }, []);

  return {
    state,
    isLoading,
    error,
    updateState,
    openDialog,
    closeDialog,
    close,
    refreshCommandCenter,
    currentProvider: state.activeCommand,
    currentDialog: state.dialogType ? { type: state.dialogType, data: state.dialogData } : null
  };
}

================
File: src/hooks/use-command-window.ts
================
import { useCallback } from 'react';
import { CommandType } from '@/types/command';
import { toast } from '@/hooks/use-toast';

export function useCommandWindow() {
  const handleCommandWindowToggle = useCallback(async (commandType: CommandType) => {
    try {
      await window.electron.invoke('command-center:toggle', commandType);
    } catch (error) {
      console.error('Failed to toggle command window:', error);
      toast({
        title: 'Error',
        description: 'Failed to open command window',
        variant: 'destructive',
      });
    }
  }, []);

  return {
    handleCommandWindowToggle
  };
}

================
File: src/hooks/use-conversations.ts
================
import { useState, useCallback } from 'react';
import { ConversationEvents } from '@/core/ipc/constants';
import { useRendererStore } from '@/store/renderer';
import { Conversation } from '@/types/conversation';

export function useConversations() {
  const rendererStore = useRendererStore();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchConversations = useCallback(async (): Promise<Conversation[]> => {
    try {
      setIsLoading(true);
      setError(null);
      const response = await window.electron.invoke(ConversationEvents.GET_CONVERSATIONS);
      if (response && response.conversations) {
        rendererStore.setConversations(response.conversations);
        return response.conversations;
      }
      return [];
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to fetch conversations';
      setError(errorMessage);
      rendererStore.setError(errorMessage);
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [rendererStore]);

  const setupConversationsListener = useCallback((callback?: (conversations: Conversation[]) => void) => {
    const handleConversationsUpdate = (event: any, data: { conversations: Conversation[] }) => {
      rendererStore.setConversations(data.conversations);
      if (callback) callback(data.conversations);
    };

    window.electron.on(ConversationEvents.CONVERSATIONS_UPDATED, handleConversationsUpdate);
    
    return () => {
      window.electron.off(ConversationEvents.CONVERSATIONS_UPDATED, handleConversationsUpdate);
    };
  }, [rendererStore]);

  const setActiveConversation = useCallback(async (conversation: Conversation): Promise<boolean> => {
    try {
      setIsLoading(true);
      setError(null);
      
      const response = await window.electron.invoke(ConversationEvents.SET_ACTIVE_CONVERSATION, conversation.id);
      
      if (!response.success) {
        throw new Error(response.error || 'Failed to set active conversation');
      }

      if (conversation) {
        rendererStore.setConversations(
          rendererStore.conversations.map(c => ({
            ...c,
            active: c.id === conversation.id
          }))
        );
      }

      if (response.data) {
        rendererStore.setMessages(response.data.messages);
      } else {
        rendererStore.setMessages([]);
      }

      return true;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to set active conversation');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [rendererStore]);

  const createConversation = useCallback(async (spaceId: string, title: string): Promise<boolean> => {
    try {
      setIsLoading(true);
      setError(null);
      const response = await window.electron.invoke(ConversationEvents.CREATE_CONVERSATION, spaceId, title);
      return response.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to create conversation');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const deleteConversation = useCallback(async (conversationId: string): Promise<boolean> => {
    try {
      setIsLoading(true);
      const response = await window.electron.invoke(ConversationEvents.DELETE_CONVERSATION, conversationId);
      return response.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to delete conversation');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const updateConversation = useCallback(async (conversationId: string, data: Partial<Conversation>): Promise<boolean> => {
    try {
      setIsLoading(true);
      const response = await window.electron.invoke(ConversationEvents.UPDATE_CONVERSATION, conversationId, data);
      return response.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to update conversation');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const conversations = rendererStore.conversations;
  const activeConversation = conversations[0] || null;

  return {
    conversations,
    activeConversation,
    isLoading: isLoading || rendererStore.isLoading,
    error: error || rendererStore.error,
    fetchConversations,
    setupConversationsListener,
    setActiveConversation,
    createConversation,
    deleteConversation,
    updateConversation
  };
}

================
File: src/hooks/use-messages.ts
================
import { useState, useCallback, useMemo } from 'react';
import { MessageEvents } from '@/core/ipc/constants';
import { useRendererStore } from '@/store/renderer';
import { Message } from '@/types/message';

export function useMessages(conversationId: string | undefined | null) {
  const rendererStore = useRendererStore();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasFetched, setHasFetched] = useState(false);

  const messages = useMemo(() => 
    rendererStore.messages
      .filter(msg => msg.conversation_id === conversationId) as Message[],
    [rendererStore.messages, conversationId]
  );

  const fetchMessages = useCallback(async (id: string) => {
    if (!id || hasFetched) return null;
    
    try {
      setIsLoading(true);
      setError(null);
      
      const response = await window.electron.invoke(MessageEvents.GET_CONVERSATION_MESSAGES, id);
      
      if (response.success && response.data) {
        rendererStore.setMessages(response.data as Message[]);
        setHasFetched(true);
        return response.data;
      } else {
        let errorMsg = response.error || 'Failed to fetch messages';
        if (errorMsg.includes('[object Object]')) {
          errorMsg = 'Failed to fetch messages due to a serialization error';
        }
        setError(errorMsg);
        rendererStore.setError(errorMsg);
        console.warn(`Message fetch failed for conversation ${id}: ${errorMsg}`);
        return null;
      }
    } catch (err) {
      let errorMsg = '';
      if (err instanceof Error) {
        errorMsg = err.message;
      } else if (typeof err === 'object' && err !== null) {
        try {
          errorMsg = JSON.stringify(err);
        } catch (e) {
          errorMsg = 'An error occurred but could not be serialized';
        }
      } else {
        errorMsg = String(err) || 'An unknown error occurred while fetching messages';
      }
      
      if (errorMsg.includes('[object Object]')) {
        errorMsg = 'Failed to fetch messages due to a serialization error';
      }
      
      setError(errorMsg);
      rendererStore.setError(errorMsg);
      console.error(`Error fetching messages for conversation ${id}:`, err);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [rendererStore, hasFetched]);


  const sendMessage = useCallback(async (content: string): Promise<boolean> => {
    if (!conversationId) return false;
    
    try {
      setIsLoading(true);
      const response = await window.electron.invoke(MessageEvents.SEND_MESSAGE, {
        conversationId,
        content
      });
      
      return response.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to send message');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [conversationId]);

  const deleteMessage = useCallback(async (messageId: string): Promise<boolean> => {
    if (!conversationId) return false;
    
    try {
      setIsLoading(true);
      const response = await window.electron.invoke(MessageEvents.DELETE_MESSAGE, {
        conversationId,
        messageId
      });
      
      return response.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to delete message');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [conversationId]);

  const updateMessage = useCallback(async (messageId: string, content: string): Promise<boolean> => {
    if (!conversationId) return false;
    
    try {
      setIsLoading(true);
      const response = await window.electron.invoke(MessageEvents.UPDATE_MESSAGE, {
        conversationId,
        messageId,
        content
      });
      
      return response.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to update message');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [conversationId]);
  
  const formatMessagesForChat = useCallback(() => {
    if (!messages) return [];
    
    return messages.map(msg => ({
      id: msg.id,
      role: msg.role,
      content: msg.content,
      createdAt: new Date(msg.created_at)
    }));
  }, [messages]);

  return {
    messages,
    isLoading,
    error,
    fetchMessages,
    sendMessage,
    deleteMessage,
    updateMessage,
    formatMessagesForChat
  };
}

================
File: src/hooks/use-notifications.ts
================
import { useState, useEffect, useCallback } from 'react';
import { toast } from 'sonner';
import { NotificationEvents } from '@/core/ipc/constants';
import type { 
  NotificationResponse, 
  MarkNotificationResponse, 
  MarkAllNotificationsResponse 
} from '@/services/notification/notification-service';
import { Notification } from '@/types/notification';

export function useNotifications() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState<number>(0);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

    const fetchNotifications = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response: NotificationResponse = await window.electron.invoke(
        NotificationEvents.GET_NOTIFICATIONS
      );

      if (!response.success) {
        throw new Error(response.error || 'Failed to load notifications');
      }

      setNotifications(response.data || []);
      setUnreadCount(
        (response.data || []).filter(
          (notification) => !notification.is_read
        ).length
      );
    } catch (err: any) {
      setError(err.message);
      console.error('Error fetching notifications:', err);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const markAsRead = useCallback(async (notificationId: string) => {
    try {
      setError(null);

      const response: MarkNotificationResponse = await window.electron.invoke(
        NotificationEvents.MARK_AS_READ,
        notificationId
      );

      if (!response.success) {
        throw new Error(response.error || 'Failed to mark notification as read');
      }

      // Fetch updated notifications
      await fetchNotifications();
      
      return response.data;
    } catch (err: any) {
      setError(err.message);
      console.error('Error marking notification as read:', err);
      throw err;
    }
  }, [fetchNotifications]);

  const markAllAsRead = useCallback(async () => {
    try {
      setError(null);

      const response: MarkAllNotificationsResponse = await window.electron.invoke(
        NotificationEvents.MARK_ALL_AS_READ
      );

      if (!response.success) {
        throw new Error(response.error || 'Failed to mark all notifications as read');
      }

      // Fetch updated notifications
      await fetchNotifications();
      
      // Show success message
      toast.success('All notifications marked as read');
      
      return response.data;
    } catch (err: any) {
      setError(err.message);
      console.error('Error marking all notifications as read:', err);
      toast.error(err.message);
      throw err;
    }
  }, [fetchNotifications]);

  const setupNotificationListener = useCallback(() => {
    const handleNotificationReceived = (event: any, response: any) => {
      if (response.success && response.data) {
        fetchNotifications();
          
        const newNotification = response.data;
        toast(newNotification.title, {
          description: newNotification.description,
        });
      }
    };
    
    window.electron.on(
      NotificationEvents.NOTIFICATION_RECEIVED,
      handleNotificationReceived
    );
    
    return () => {
      window.electron.off(
        NotificationEvents.NOTIFICATION_RECEIVED,
        handleNotificationReceived
      );
    };
  }, [fetchNotifications]);

  return {
    notifications,
    unreadCount,
    isLoading,
    error,
    fetchNotifications,
    setupNotificationListener,
    markAsRead,
    markAllAsRead
  };
}

================
File: src/hooks/use-spaces.ts
================
import { useState, useCallback } from 'react';
import { SpaceEvents, MessageEvents } from '@/core/ipc/constants';
import { Space } from '@/types/space';
import { useRendererStore } from '@/store/renderer';
import { Conversation } from '@/types/conversation';
import { Message } from '@/types/message';
import { Provider } from '@/types/provider';

export function useSpaces() {
  const rendererStore = useRendererStore();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fetchSpaces = useCallback(async (): Promise<Space[]> => {
    try {
      setIsLoading(true);
      setError(null);
      const response = await window.electron.invoke(SpaceEvents.GET_SPACES);
      if (response && response.success) {
        rendererStore.setSpaces(response.data);
        return response.data;
      }
      return [];
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to fetch spaces';
      setError(errorMessage);
      rendererStore.setError(errorMessage);
      return [];
    } finally {
      setIsLoading(false);
    }
  }, [rendererStore]);

  const fetchActiveSpace = useCallback(async (): Promise<Space | null> => {
    try {
      setIsLoading(true);
      setError(null);
      const space = await window.electron.invoke(SpaceEvents.GET_ACTIVE_SPACE);
      if (space) {
        rendererStore.setActiveSpace(space);
      }
      return space;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to fetch active space';
      setError(errorMessage);
      rendererStore.setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [rendererStore]);

  const fetchSpaceConversations = useCallback(async (spaceId: string): Promise<Conversation[]> => {
    try {
      const response = await window.electron.invoke(SpaceEvents.GET_SPACE_CONVERSATIONS, spaceId);
      if (response && response.success) {
        rendererStore.setConversations(response.data);
        return response.data;
      }
      return [];
    } catch (error) {
      console.error('Error fetching conversations:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch conversations');
      return [];
    }
  }, [rendererStore]);

  const fetchConversationMessages = useCallback(async (conversationId: string): Promise<Message[]> => {
    try {
      const response = await window.electron.invoke(MessageEvents.GET_CONVERSATION_MESSAGES, conversationId);
      if (response && response.success) {
        rendererStore.setMessages(response.data);
        return response.data;
      }
      return [];
    } catch (error) {
      console.error('Error fetching messages:', error);
      setError(error instanceof Error ? error.message : 'Failed to fetch messages');
      return [];
    }
  }, [rendererStore]);

  const updateStoreWithSpaceData = useCallback(async (space: Space | null) => {
    if (!space) {
      rendererStore.setConversations([]);
      rendererStore.setMessages([]);
      return;
    }

    try {
      const conversations = await fetchSpaceConversations(space.id);
      if (conversations.length > 0) {
        await fetchConversationMessages(conversations[0].id);
      } else {
        rendererStore.setMessages([]);
      }
    } catch (error) {
      console.error('Error updating store with space data:', error);
      setError(error instanceof Error ? error.message : 'Failed to update store with space data');
    }
  }, [rendererStore, fetchSpaceConversations, fetchConversationMessages]);

  const setupSpaceListener = useCallback((callback?: (space: Space | null) => void) => {
    const handleSpaceUpdate = async (event: any, data: { space: Space | null; conversations: Conversation[]; messages: Message[] }) => {
      rendererStore.setActiveSpace(data.space);
      rendererStore.setConversations(data.conversations || []);
      rendererStore.setMessages(data.messages || []);
      if (callback) callback(data.space);
    };

    window.electron.on(SpaceEvents.SPACE_UPDATED, handleSpaceUpdate);
    
    return () => {
      window.electron.off(SpaceEvents.SPACE_UPDATED, handleSpaceUpdate);
    };
  }, [rendererStore]);

  const setActiveSpaceById = async (spaceId: string) => {
    try {
      setIsLoading(true);
      const response = await window.electron.invoke(SpaceEvents.SET_ACTIVE_SPACE, spaceId);
      
      if (response?.success && response.data && 'space' in response.data) {
        const { space, conversations, messages } = response.data;
        rendererStore.setActiveSpace(space);
        rendererStore.setConversations(conversations || []);
        rendererStore.setMessages(messages || []);
      }

      return response?.success || false;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to set active space');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const createSpace = async (spaceData: Partial<Space>): Promise<boolean> => {
    try {
      setIsLoading(true);
      const result = await window.electron.invoke(SpaceEvents.CREATE_SPACE, spaceData);
      if (result.success && result.data) {
        const spaces = [...rendererStore.spaces, result.data];
        rendererStore.setSpaces(spaces);
      }
      return result.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to create space');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const deleteSpace = async (spaceId: string): Promise<boolean> => {
    try {
      setIsLoading(true);
      const result = await window.electron.invoke(SpaceEvents.DELETE_SPACE, spaceId);
      if (result.success) {
        const spaces = rendererStore.spaces.filter(s => s.id !== spaceId);
        rendererStore.setSpaces(spaces);
        if (rendererStore.activeSpace?.id === spaceId) {
          rendererStore.setActiveSpace(null);
        }
      }
      return result.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to delete space');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const updateSpace = async (spaceId: string, spaceData: Partial<Space>): Promise<boolean> => {
    try {
      setIsLoading(true);
      const result = await window.electron.invoke(SpaceEvents.UPDATE_SPACE, spaceId, spaceData);
      if (result.success && result.data) {
        const spaces = rendererStore.spaces.map(s => 
          s.id === spaceId ? { ...s, ...result.data.space } : s
        );
        rendererStore.setSpaces(spaces);
        
        if (rendererStore.activeSpace?.id === spaceId) {
          rendererStore.setActiveSpace({ ...rendererStore.activeSpace, ...result.data.space });
        }
      }
      return result.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to update space');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const updateSpaceModel = async (spaceId: string, modelId: string, provider: string): Promise<boolean> => {
    try {
      setIsLoading(true);
      const result = await window.electron.invoke(SpaceEvents.UPDATE_SPACE_MODEL, spaceId, modelId, provider);
      if (result.success) {
        // Update spaces list
        const spaces = rendererStore.spaces.map(s => 
          s.id === spaceId ? { ...s, model: modelId, provider: provider as Provider } : s
        );
        rendererStore.setSpaces(spaces);
        
        // Update active space if this is the active one
        if (rendererStore.activeSpace?.id === spaceId) {
          rendererStore.setActiveSpace({
            ...rendererStore.activeSpace,
            model: modelId,
            provider: provider as Provider
          });
        }
      }
      return result.success;
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to update space model');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const spaces = rendererStore.spaces;
  const activeSpace = rendererStore.activeSpace;

  return { 
    activeSpace, 
    spaces,
    isLoading: isLoading || rendererStore.isLoading, 
    error: error || rendererStore.error,
    fetchSpaces,
    fetchActiveSpace,
    setupSpaceListener,
    setActiveSpaceById,
    createSpace,
    deleteSpace,
    updateSpace,
    updateSpaceModel
  };
}

================
File: src/hooks/use-toast.ts
================
"use client"

import * as React from "react"

import {
  Toast,
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: src/hooks/use-user.ts
================
import { useState, useCallback } from 'react';
import { useToast } from '@/hooks/use-toast';
import { UserEvents, AppStateEvents, AuthEvents } from '@/core/ipc/constants';
import { UserProfile, UserUpdateData, EmailPreferences } from '@/services/user/user-service';
import { useRendererStore } from '@/store/renderer';

export function useUser() {
  const rendererStore = useRendererStore();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { toast } = useToast();

  const setupProfileListener = useCallback((callback?: (profile: UserProfile | null) => void) => {
    const handleStateUpdate = (event: any, response: any) => {
      if (response.success && response.data?.profile) {
        rendererStore.setProfile(response.data.profile);
        if (callback) callback(response.data.profile);
      }
    };
    
    window.electron.on(AppStateEvents.STATE_UPDATED, handleStateUpdate);
    
    return () => {
      window.electron.off(AppStateEvents.STATE_UPDATED, handleStateUpdate);
    };
  }, [rendererStore]);
  
  const fetchProfile = useCallback(async (): Promise<UserProfile | null> => {
    try {
      setIsLoading(true);
      setError(null);
      
      const response = await window.electron.invoke(UserEvents.GET_PROFILE);
      
      if (response.success && response.data?.profile) {
        rendererStore.setProfile(response.data.profile);
        return response.data.profile;
      }
      
      return null;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to fetch user profile';
      setError(errorMessage);
      rendererStore.setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [rendererStore]);

  const handleError = (error: unknown) => {
    const errorMessage = error instanceof Error ? error.message : 'An unexpected error occurred';
    setError(errorMessage);
    toast({
      title: "Error",
      description: errorMessage,
      variant: "destructive"
    });
    return false;
  };

  const handleSuccess = (message: string) => {
    setError(null);
    toast({
      title: "Success",
      description: message,
      variant: "success"
    });
    return true;
  };

  const updateProfile = async (updatedProfile: UserUpdateData) => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await window.electron.invoke(UserEvents.UPDATE_PROFILE, updatedProfile);

      if (!response.success) {
        throw new Error(response.error || 'Failed to update profile');
      }

      if (response.data?.profile) {
        rendererStore.setProfile(response.data.profile);
      }

      return handleSuccess("Profile updated successfully");
    } catch (error) {
      return handleError(error);
    } finally {
      setIsLoading(false);
    }
  };

  const updatePassword = async (currentPassword: string, newPassword: string) => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await window.electron.invoke(UserEvents.UPDATE_PASSWORD, {
        currentPassword,
        newPassword
      });

      if (!response.success) {
        throw new Error(response.error || 'Failed to update password');
      }

      return handleSuccess("Password updated successfully");
    } catch (error) {
      return handleError(error);
    } finally {
      setIsLoading(false);
    }
  };

  const updateEmailPreferences = async (preferences: EmailPreferences) => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await window.electron.invoke(UserEvents.UPDATE_EMAIL_PREFERENCES, preferences);

      if (!response.success) {
        throw new Error(response.error || 'Failed to update email preferences');
      }

      return handleSuccess("Email preferences updated successfully");
    } catch (error) {
      return handleError(error);
    } finally {
      setIsLoading(false);
    }
  };

  const signOut = async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await window.electron.invoke(AuthEvents.SIGN_OUT);

      if (!response.success) {
        throw new Error(response.error || 'Failed to sign out');
      }
      
      rendererStore.setProfile(null);

      return handleSuccess("Signed out successfully");
    } catch (error) {
      return handleError(error);
    } finally {
      setIsLoading(false);
    }
  };

  // Get profile from renderer store
  const profile = rendererStore.profile;

  return {
    isLoading: isLoading || rendererStore.isLoading,
    error: error || rendererStore.error,
    profile,
    fetchProfile,
    setupProfileListener,
    updateProfile,
    updatePassword,
    updateEmailPreferences,
    signOut
  };
}

================
File: src/layouts/AuthLayout.tsx
================
import { Outlet } from 'react-router-dom';

export default function AuthLayout() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-[#111112] text-white relative overflow-hidden">
      <div className="absolute top-0 left-0 w-full h-screen pointer-events-none">
        <div className="absolute top-0 left-[20%] w-[500px] h-[500px] bg-[#3ecfff]/[0.03] blur-[100px] rounded-full" />
        <div className="absolute top-[20%] right-[20%] w-[400px] h-[400px] bg-[#D4966A]/[0.03] blur-[80px] rounded-full" />
        <div className="absolute bottom-[10%] left-[30%] w-[600px] h-[600px] bg-[#3ecfff]/[0.02] blur-[110px] rounded-full" />
      </div>
      <div className="relative z-10 w-full max-w-[480px] p-6">
        <Outlet />
      </div>
    </div>
  );
}

================
File: src/layouts/ProtectedLayout.tsx
================
import { Outlet } from 'react-router-dom';

export default function ProtectedLayout() {
  return (
    <div className="min-h-screen w-full bg-[#111112] text-white">
      <div className="w-full h-full">
        <Outlet />
      </div>
    </div>
  );
}

================
File: src/lib/utils/env-utils.ts
================
export function isDevelopment(): boolean {
  return process.env.NODE_ENV === 'development';
}

export function isProduction(): boolean {
  return process.env.NODE_ENV === 'production';
}

export function isPlatform(platform: 'darwin' | 'win32' | 'linux'): boolean {
  return process.platform === platform;
}

export function isMac(): boolean {
  return isPlatform('darwin');
}

export function isWindows(): boolean {
  return isPlatform('win32');
}

export function isLinux(): boolean {
  return isPlatform('linux');
}

================
File: src/lib/utils/utils.ts
================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";


export function buildRedirectUrl(
  type: "error" | "success",
  path: string,
  message: string,
): string {
  return `${path}?${type}=${encodeURIComponent(message)}`;
}

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };
export type Nullable<T> = T | null;
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

================
File: src/pages/CommandCenter.tsx
================
import { useState, useEffect, useRef, useCallback } from "react";
import { Command } from 'cmdk';
import { providers } from "@/registry/providers";
import { dialogs } from "@/registry/dialogs";
import { useCommandCenter } from '@/hooks/use-command-center';
import { useParams } from 'react-router-dom';
import { CommandType } from '@/types/command';
import { useAppState } from '@/hooks/use-app-state';
import '@/styles/cmdk.css';

interface CommandCenterProps {}

function useCommandCenterFocus(inputRef: React.RefObject<HTMLInputElement>, commandType: CommandType) {
  useEffect(() => {
    const focusInput = () => {
      if (inputRef.current) {
        inputRef.current.focus();
      }
    };
    
    focusInput();
  }, [commandType]);
}

function useEscapeKey(onEscape: () => void) {
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onEscape();
    };
    window.addEventListener('keydown', handleEscape);
    return () => window.removeEventListener('keydown', handleEscape);
  }, [onEscape]);
}

const CommandCenter: React.FC<CommandCenterProps> = () => {
  const { type = 'unified' } = useParams<{ type: CommandType }>();
  const {
    currentProvider,
    currentDialog,
    updateState,
    openDialog,
    closeDialog,
    close,
  } = useCommandCenter();
  const [searchQuery, setSearchQuery] = useState("");
  const inputRef = useRef<HTMLInputElement>(null);
  const commandType = type as CommandType;

  useEscapeKey(close);
  useCommandCenterFocus(inputRef as React.RefObject<HTMLInputElement>, commandType);
  useAppState();

  const handleSearchChange = useCallback((value: string) => {
    setSearchQuery(value);
  }, []);

  const handleSelect = useCallback((item: { closeOnSelect?: boolean }) => {
    if (item?.closeOnSelect) {
      close();
    }
  }, [close]);

  const handleAction = useCallback(async (action: string, data: unknown) => {
    const dialogType = `${action}-${currentProvider?.slice(0, -1)}`;
    if (dialogs[dialogType as keyof typeof dialogs]) {
      await openDialog(dialogType, data);
    }
  }, [currentProvider, openDialog]);

  const renderProviderUI = useCallback(() => {
    if (!commandType || !providers[commandType as keyof typeof providers]) {
      return (
        <Command.List>
          <Command.Group heading="Select a category">
            {Object.entries(providers).map(([key, Provider]) => (
              <Command.Item 
                key={key}
                onSelect={() => updateState({ activeCommand: key as CommandType })}
              >
                {key.charAt(0).toUpperCase() + key.slice(1)}
              </Command.Item>
            ))}
          </Command.Group>
        </Command.List>
      );
    }
    
    const ProviderComponent = providers[commandType as keyof typeof providers];
    return (
      <ProviderComponent 
        searchQuery={searchQuery} 
        onSelect={handleSelect}
        onAction={handleAction}
      />
    );
  }, [commandType, searchQuery, handleSelect, handleAction, updateState]);

  const renderDialog = useCallback(() => {
    if (!currentDialog?.type || !dialogs[currentDialog.type as keyof typeof dialogs]) return null;
    
    const DialogComponent = dialogs[currentDialog.type as keyof typeof dialogs];
    return (
      <div className="dialog">
        <DialogComponent data={currentDialog.data} onClose={closeDialog} />
      </div>
    );
  }, [currentDialog, closeDialog]);

  return (
    <div className="vinci">
      <Command shouldFilter={false} loop autoFocus>
        <Command.Input 
          ref={inputRef}
          value={searchQuery}
          onValueChange={handleSearchChange}
          placeholder={`Search ${commandType} commands...`}
          autoFocus={true}
        />
        
        <Command.Empty>No results found.</Command.Empty>
        
        {currentDialog ? (
          <div className="flex-1 flex justify-center items-start pt-5 overflow-y-auto">
            {renderDialog()}
          </div>
        ) : (
          <div className="flex-1 overflow-y-auto">
            {renderProviderUI()}
          </div>
        )}
      </Command>
    </div>
  );
};

export default CommandCenter;

================
File: src/pages/ForgotPassword.tsx
================
import { Link } from 'react-router-dom';

export default function ForgotPassword() {
  return (
    <div className="flex flex-col w-full">
      <h1>Forgot Password Page</h1>
      <Link to="/sign-in">Back to Sign in</Link>
    </div>
  );
}

================
File: src/pages/Profile.tsx
================
import { Link } from 'react-router-dom';

export default function Profile() {
  return (
    <div className="flex flex-col w-full">
      <h1>Profile Page</h1>
      <Link to="/protected">Back to Protected</Link>
    </div>
  );
}

================
File: src/pages/Protected.tsx
================
import { useEffect } from 'react';
import ChatContentClient from '@/components/chat/chat-content-client';
import { useNavigate } from 'react-router-dom';
import { useAppState } from '@/hooks/use-app-state';
import { Toast } from '@/components/ui/toast';

export default function Protected() {
  const navigate = useNavigate();
  const { error } = useAppState();

  useEffect(() => {
    if (error) {
      toast({
        title: 'Error',
        description: 'Failed to load application data. Please sign in again.',
        variant: 'destructive'
      });
      navigate('/sign-in');
    }
  }, [error, navigate]);

  if (error) return null;

  return (
    <div className="flex flex-col w-full h-full">
      <ChatContentClient />
    </div>
  );
}

================
File: src/pages/ResetPassword.tsx
================
import { Link } from 'react-router-dom';

export default function ResetPassword() {
  return (
    <div className="flex flex-col w-full">
      <h1>Reset Password Page</h1>
      <Link to="/protected">Back to Protected</Link>
    </div>
  );
}

================
File: src/pages/SignIn.tsx
================
import { useNavigate } from 'react-router-dom';
import { useState } from 'react';
import { SubmitButton } from '@/components/auth/submit-button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Toast } from '@/components/ui/toast';
import { Link } from 'react-router-dom';
import { useAuth } from '@/hooks/use-auth';
import { useRendererStore } from '@/store/renderer';

export default function SignIn() {
  const navigate = useNavigate();
  const { signIn, isLoading, error } = useAuth();
  const rendererStore = useRendererStore();
  const [loadingData, setLoadingData] = useState(false);
  
  return (
    <div className="flex items-center justify-center w-full">
      <form className="w-full max-w-[480px]">
        <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-8">
          <div className="flex flex-col gap-2 mb-8">
            <h1 className="text-2xl font-medium text-white/90">Sign in</h1>
          </div>
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-2">
              <Label htmlFor="email" className="text-white/60">Email</Label>
              <Input 
                name="email" 
                placeholder="you@example.com" 
                required 
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <div className="flex flex-col gap-2">
              <div className="flex justify-between items-center">
                <Label htmlFor="password" className="text-white/60">Password</Label>
                <Link
                  className="text-xs text-[#3ecfff]/60 hover:text-[#3ecfff]/80 transition-colors"
                  to="/forgot-password"
                >
                  Forgot Password?
                </Link>
              </div>
              <Input
                type="password"
                name="password"
                placeholder="Your password"
                required
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            {error && (
              <div className="text-red-500 text-sm mb-4">{error}</div>
            )}
            <SubmitButton 
              pendingText="Signing in..." 
              formAction={async (formData: FormData) => {
                const email = formData.get('email') as string;
                const password = formData.get('password') as string;
                const success = await signIn({ email, password });
                
                if (success) {
                  try {
                    setLoadingData(true);
                    const dataLoaded = await rendererStore.fetchAppState();
                    if (dataLoaded) {
                      navigate('/protected');
                    } else {
                      console.error("Failed to load application data after login");
                      toast({
                        title: "Error",
                        description: "Successfully signed in, but failed to load your data. Please try again.",
                        variant: "destructive"
                      });
                    }
                  } catch (error) {
                    console.error("Error loading application data:", error);
                    toast({
                      title: "Error",
                      description: "Failed to load application data after login. Please try again.",
                      variant: "destructive"
                    });
                  } finally {
                    setLoadingData(false);
                  }
                }
              }}
              variant="cyan"
              disabled={isLoading || loadingData}
            >
              {isLoading || loadingData ? "Signing in..." : "Sign in"}
            </SubmitButton>
          </div>
        </div>
      </form>
    </div>
  );
}

================
File: src/registry/dialogs.tsx
================
import { DeleteSpaceDialog } from "@/components/dialogs/DeleteSpaceDialog";
import { EditSpaceDialog } from "@/components/dialogs/EditSpaceDialog";
import { CreateSpaceDialog } from "@/components/dialogs/CreateSpaceDialog";
import { EditConversationDialog } from "@/components/dialogs/EditConversationDialog";
import { DeleteConversationDialog } from "@/components/dialogs/DeleteConversationDialog";

type DialogRegistry = {
  deleteSpace: React.ComponentType<{ onClose: () => void }>;
  editSpace: React.ComponentType<{ onClose: () => void }>;
  createSpace: React.ComponentType<{ onClose: () => void }>;
  editConversation: React.ComponentType<{ onClose: () => void }>;
  deleteConversation: React.ComponentType<{ onClose: () => void }>;
};

export const dialogs: DialogRegistry = {
  deleteSpace: DeleteSpaceDialog,
  editSpace: EditSpaceDialog,
  createSpace: CreateSpaceDialog,
  editConversation: EditConversationDialog,
  deleteConversation: DeleteConversationDialog,
};

================
File: src/registry/providers.tsx
================
import { SpacesProvider } from "@/components/providers/SpacesProvider";
import { ConversationsProvider } from "@/components/providers/ConversationsProvider";
import { ModelsProvider } from "@/components/providers/ModelsProvider";
import { BackgroundTasksProvider } from "@/components/providers/BackgroundTasksProvider";
import { SuggestionsProvider } from "@/components/providers/SuggestionsProvider";
import { ChatModesProvider } from "@/components/providers/ChatModesProvider";
import { MessageSearchProvider } from "@/components/providers/MessageSearchProvider";
import { SimilarMessagesProvider } from "@/components/providers/SimilarMessagesProvider";
import { ActionsProvider } from "@/components/providers/ActionsProvider";

type ProviderRegistry = {
  spaces: typeof SpacesProvider;
  conversations: typeof ConversationsProvider;
  models: typeof ModelsProvider;
  actions: typeof ActionsProvider;
  chatModes: typeof ChatModesProvider;
  messageSearch: typeof MessageSearchProvider;
  similarMessages: typeof SimilarMessagesProvider;
  backgroundTasks: typeof BackgroundTasksProvider;
  suggestions: typeof SuggestionsProvider;
};

export const providers: ProviderRegistry = {
  spaces: SpacesProvider,
  conversations: ConversationsProvider,
  models: ModelsProvider,
  actions: ActionsProvider,
  chatModes: ChatModesProvider,
  messageSearch: MessageSearchProvider,
  similarMessages: SimilarMessagesProvider,
  backgroundTasks: BackgroundTasksProvider,
  suggestions: SuggestionsProvider,
};

================
File: src/schemas/auth.ts
================
import { z } from 'zod';

export const signInSchema = z.object({
  email: z.string().email({ message: 'Invalid email address' }),
  password: z.string().min(8, { message: 'Password must be at least 8 characters long' }),
});

export const signUpSchema = z.object({
  email: z.string().email({ message: 'Invalid email address' }),
  password: z.string().min(8, { message: 'Password must be at least 8 characters long' }),
  firstName: z.string().min(1, { message: 'First name is required' }),
  lastName: z.string().min(1, { message: 'Last name is required' }),
});

export const resetPasswordSchema = z.object({
  email: z.string().email({ message: 'Invalid email address' }),
});

export const refreshTokenSchema = z.object({
  refreshToken: z.string().min(10, { message: 'Invalid refresh token' }),
});

================
File: src/schemas/conversations.ts
================
import { z } from 'zod';

export const createConversationSchema = z.object({
  title: z.string().min(1, { message: 'Conversation title is required' }),
  spaceId: z.string().uuid({ message: 'Valid space ID is required' }),
});

export const updateConversationSchema = z.object({
  title: z.string().min(1, { message: 'Conversation title is required' }).optional(),
});

export const createMessageSchema = z.object({
  content: z.string().min(1, { message: 'Message content is required' }),
  role: z.enum(['user', 'assistant', 'system'], { 
    required_error: 'Message role is required', 
    invalid_type_error: 'Message role must be user, assistant, or system'
  }),
  conversationId: z.string().uuid({ message: 'Valid conversation ID is required' }),
});

export const updateMessageSchema = z.object({
  content: z.string().min(1, { message: 'Message content is required' }).optional(),
});

================
File: src/schemas/spaces.ts
================
import { z } from 'zod';

export const createSpaceSchema = z.object({
  name: z.string().min(1, { message: 'Space name is required' }),
  description: z.string().optional(),
});

export const updateSpaceSchema = z.object({
  name: z.string().min(1, { message: 'Space name is required' }).optional(),
  description: z.string().optional(),
});

================
File: src/services/api/api-service.ts
================
import { API_BASE_URL, refreshTokens, redirectToSignIn } from '@/core/auth/auth-service';
import { useMainStore } from '@/store/main';
import { safeStorage } from 'electron';

export async function fetchWithAuth(url: string, options: RequestInit = {}): Promise<Response> {
  try {
    const store = useMainStore.getState();
    
    const currentTimeSeconds = Math.floor(Date.now() / 1000);
    const isTokenExpired = !store.tokenExpiryTime || store.tokenExpiryTime <= currentTimeSeconds;
    
    if (isTokenExpired && store.refreshToken) {
      console.log('[ELECTRON] Token expired, attempting refresh');
      const refreshed = await refreshTokens(safeStorage);
      if (!refreshed) {
        console.log('[ELECTRON] Failed to refresh tokens and no valid token available');
        await redirectToSignIn();
        throw new Error('Failed to refresh authentication tokens');
      }
    }
    
    const currentToken = useMainStore.getState().accessToken;
    if (!currentToken) {
      console.log('[ELECTRON] No access token available');
      await redirectToSignIn();
      throw new Error('No authentication token available');
    }
    
    const headers = new Headers(options.headers);
    headers.set('Authorization', `Bearer ${currentToken}`);
    
    const response = await fetch(url, {
      ...options,
      headers
    });
    
    if ((response.status === 401 || response.status === 403) && store.refreshToken) {
      console.log(`[ELECTRON] Got ${response.status}, attempting one-time token refresh`);
      const refreshed = await refreshTokens(safeStorage);
      
      if (refreshed) {
        const retryToken = useMainStore.getState().accessToken;
        if (retryToken) {
          headers.set('Authorization', `Bearer ${retryToken}`);
          return fetch(url, { ...options, headers });
        }
      }
      
      await redirectToSignIn();
      throw new Error('Authentication failed after token refresh attempt');
    }
    
    return response;
  } catch (error) {
    console.error('[ELECTRON] Error in fetchWithAuth:', error);
    throw error;
  }
}

export async function checkServerHealth(): Promise<boolean> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/health`);
    return response.ok;
  } catch (error) {
    console.error('[ELECTRON] Server health check failed:', error);
    return false;
  }
}

================
File: src/services/app-data/app-data-service.ts
================
import { useMainStore } from '@/store/main';
import { fetchSpaces, fetchActiveSpace } from '@/services/spaces/space-service';
import { fetchActiveConversation, fetchConversations } from '@/services/conversations/conversation-service';
import { fetchMessages } from '@/services/messages/message-service';
import { fetchUserProfile } from '@/services/user/user-service';
import { checkServerHealth } from '@/services/api/api-service';
import { isTokenExpiringSoon, refreshTokens } from '@/core/auth/auth-service';
import { safeStorage } from 'electron';
import { Conversation } from '@/types/conversation';
import { Message } from '@/types/message';
import { Space } from '@/types/space';
import { User } from '@supabase/supabase-js';

interface AppStateResult {
    spaces: Space[];
  activeSpace: Space | null;
  conversations: Conversation[];
  messages: Message[];
  initialDataLoaded: boolean;
  lastFetched: number | null;
  user: User | null;
  accessToken?: string | null;
  refreshToken?: string | null;
  tokenExpiryTime?: number | null;
  error?: string;
}

export async function fetchInitialAppData(): Promise<AppStateResult> {
  const store = useMainStore.getState();
  
  try {
    if (!await checkServerHealth()) {
      return {
        ...useMainStore.getState(),
        error: 'Server not available',
        lastFetched: Date.now(),
        user: null
      };
    }
    
    if (!store.accessToken) {
      return {
        ...useMainStore.getState(),
        error: 'Authentication required',
        lastFetched: Date.now(),
        user: null
      };
    }

    if (store.refreshToken && isTokenExpiringSoon()) {
      const refreshed = await refreshTokens(safeStorage);
      if (!refreshed) {
        return {
          ...useMainStore.getState(),
          error: 'Authentication expired',
          lastFetched: Date.now(),
          user: null
        };
      }
    }

    let user = null;
    try {
      user = await fetchUserProfile();
    } catch (error) {
      console.error('[ELECTRON] Error fetching user profile:', error);
    }

    const spaces = await fetchSpaces();
    const activeSpace = await fetchActiveSpace();
    
    let conversations: any[] = [];
    let messages: any[] = [];
    
    if (activeSpace) {
      conversations = await fetchConversations(activeSpace.id);
      const activeConversation = await fetchActiveConversation();

      if (activeConversation) {
        messages = await fetchMessages(activeConversation.id);
      }
    }

    const currentStore = useMainStore.getState();
    
    return {
      spaces,
      activeSpace,
      conversations,
      messages,
      initialDataLoaded: true,
      lastFetched: Date.now(),
      user: user as User | null,
      accessToken: currentStore.accessToken,
      refreshToken: currentStore.refreshToken,
      tokenExpiryTime: currentStore.tokenExpiryTime
    };
  } catch (error) {
    console.error('[ELECTRON] Fetch initial data failed:', error);
    return {
      ...useMainStore.getState(),
      error: error instanceof Error ? error.message : 'Unknown error',
      lastFetched: Date.now()
    };
  }
}

export async function refreshAppData(): Promise<AppStateResult> {
  try {
    const freshData = await fetchInitialAppData();
    if (!freshData.error) {
      const store = useMainStore.getState();
      store.setAppState(freshData);
    }
    return freshData;
  } catch (error) {
    console.error('[ELECTRON] Refresh failed:', error);
    return {
      ...useMainStore.getState(),
      error: error instanceof Error ? error.message : 'Unknown error',
      lastFetched: Date.now()
    };
  }
}

================
File: src/services/conversations/conversation-service.ts
================
import { API_BASE_URL } from '@/config/api';
import { useMainStore } from '@/store/main';
import { fetchWithAuth } from '@/services/api/api-service';
import { Conversation } from '@/types/conversation';

export async function fetchConversations(spaceId: string): Promise<Conversation[]> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces/${spaceId}/conversations`);
    const { status, error, data } = await response.json();

    console.log('[ELECTRON] Conversations response:', data);
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to fetch conversations');
    }

    const conversations = data?.data || [];
    console.log(`[ELECTRON] Fetched ${conversations.length} conversations for space ${spaceId}`);
    
    useMainStore.getState().updateConversations(conversations);
    
    return conversations;
  } catch (error) {
    console.error(`[ELECTRON] Error fetching conversations for space ${spaceId}:`, error);
    throw error;
  }
}


export async function createConversation(spaceId: string, title: string): Promise<Conversation> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces/${spaceId}/conversations`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ title })
    });
    
    const { status, error, data: conversation } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to create conversation');
    }
    
    const store = useMainStore.getState();
    const conversations = [conversation, ...store.conversations];
    store.updateConversations(conversations);
    
    return conversation;
  } catch (error) {
    console.error(`[ELECTRON] Error creating conversation in space ${spaceId}:`, error);
    throw error;
  }
}


export async function updateConversation(spaceId: string, conversationId: string, title: string): Promise<Conversation> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces/${spaceId}/conversations/${conversationId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ title })
    });
    
    const { status, error, data: updatedConversation } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to update conversation');
    }
    
    const store = useMainStore.getState();
    const conversations = store.conversations.map(c => 
      c.id === conversationId ? { ...c, title } : c
    );
    store.updateConversations(conversations);
    
    return updatedConversation;
  } catch (error) {
    console.error(`[ELECTRON] Error updating conversation ${conversationId}:`, error);
    throw error;
  }
}

export async function deleteConversation(spaceId: string, conversationId: string): Promise<boolean> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces/${spaceId}/conversations/${conversationId}`, {
      method: 'DELETE'
    });
    
    const { status, error } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to delete conversation');
    }
    
    const store = useMainStore.getState();
    const conversations = store.conversations.filter(c => c.id !== conversationId);
    store.updateConversations(conversations);
    
    return true;
  } catch (error) {
    console.error(`[ELECTRON] Error deleting conversation ${conversationId}:`, error);
    throw error;
  }
}


export async function setActiveConversationInAPI(conversationId: string) {
  try {
    if (!conversationId) {
      throw new Error('Conversation ID is required');
    }

    console.log(`[ELECTRON] Setting active conversation: ${conversationId}`);
    
    const response = await fetchWithAuth(`${API_BASE_URL}/api/user/active-conversation`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ conversationId })
    });
    
    const responseText = await response.text();
    console.log(`[ELECTRON] Active conversation API response status: ${response.status}`);
    
    let parsedResponse;
    try {
      parsedResponse = JSON.parse(responseText);
    } catch (e) {
      console.error('[ELECTRON] Failed to parse response as JSON:', e);
      throw new Error('Invalid response from server');
    }
    
    const { status, error, data } = parsedResponse;
    
    if (status !== 'success') {
      console.error('[ELECTRON] API error response:', parsedResponse);
      throw new Error(error || 'Failed to set active conversation');
    }
    
    const store = useMainStore.getState();
    const conversation = store.conversations?.find(c => c.id === conversationId);
    
    if (conversation) {
      const updatedConversations = store.conversations.map(c => ({
        ...c,
        active: c.id === conversationId
      }));
      store.updateConversations(updatedConversations);
    } else {
      console.warn(`[ELECTRON] Conversation with ID ${conversationId} not found in Zustand store`);
    }
    
    return data;
  } catch (error) {
    console.error(`[ELECTRON] Error setting active conversation ${conversationId}:`, error);
    throw error;
  }
}

export async function fetchActiveConversation(): Promise<Conversation | null> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/user/active-conversation`);
    const { status, error, data } = await response.json();

    if (status !== 'success') {
      throw new Error(error || 'Failed to fetch active conversation');
    }

    return data?.data || null;
  } catch (error) {
    console.error('[ELECTRON] Error fetching active conversation:', error);
    throw error;
  }
}

================
File: src/services/messages/message-service.ts
================
import { API_BASE_URL } from '@/core/auth/auth-service';
import { useMainStore } from '@/store/main';
import { fetchWithAuth } from '@/services/api/api-service';
import { Message } from '@/types/message';

export async function fetchMessages(conversationId: string): Promise<Message[]> {
  try {
    const spaceId = useMainStore.getState().activeSpace?.id;
    if (!spaceId) {
      throw new Error('No active space found');
    }

    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces/${spaceId}/conversations/${conversationId}/messages`);
    const { status, error, data } = await response.json();

    console.log('[ELECTRON] Messages response:', data);
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to fetch messages');
    }

    const messages = data?.data || [];
    console.log(`[ELECTRON] Fetched ${messages.length} messages for conversation ${conversationId}`);
    
    useMainStore.getState().updateMessages(messages);
    
    return messages;
  } catch (error) {
    console.error(`[ELECTRON] Error fetching messages for conversation ${conversationId}:`, error);
    if (error instanceof Error) {
      throw new Error(error.message);
    } else if (typeof error === 'object' && error !== null) {
      throw new Error(JSON.stringify(error));
    } else {
      throw new Error(String(error));
    }
  }
}

/**
 * Send a chat message
 */ 
export async function sendChatMessage(conversationId: string, content: string): Promise<Message> {
  try {
    const store = useMainStore.getState();
    if (!store.activeSpace) {
      throw new Error('No active space found');
    }
    
    const response = await fetchWithAuth(
      `${API_BASE_URL}/api/spaces/${store.activeSpace.id}/conversations/${conversationId}/chat`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content })
      }
    );
    
    const { status, error, data: message } = await response.json();
    
    if (status !== 'success' || !message) {
      throw new Error(error || 'Failed to send message');
    }
    
    const messages = [...store.messages, message];
    store.updateMessages(messages);
    
    return message;
  } catch (error) {
    console.error(`[ELECTRON] Error sending chat message in conversation ${conversationId}:`, error);
    throw error;
  }
}

/**
 * Delete a message
 */
export async function deleteMessage(conversationId: string, messageId: string): Promise<boolean> {
  try {
    const store = useMainStore.getState();
    if (!store.activeSpace) {
      throw new Error('No active space found');
    }
    
    const response = await fetchWithAuth(
      `${API_BASE_URL}/api/spaces/${store.activeSpace.id}/conversations/${conversationId}/messages/${messageId}`,
      { method: 'DELETE' }
    );
    
    const { status, error } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to delete message');
    }
    
    // Update messages in Zustand store
    const messages = store.messages.filter(m => m.id !== messageId);
    store.updateMessages(messages);
    
    return true;
  } catch (error) {
    console.error(`[ELECTRON] Error deleting message ${messageId}:`, error);
    throw error;
  }
}

/**
 * Update a message
 */
export async function updateMessage(conversationId: string, messageId: string, content: string): Promise<Message> {
  try {
    const store = useMainStore.getState();
    if (!store.activeSpace) {
      throw new Error('No active space found');
    }
    
    const response = await fetchWithAuth(
      `${API_BASE_URL}/api/spaces/${store.activeSpace.id}/conversations/${conversationId}/messages/${messageId}`,
      {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content })
      }
    );
    
    const { status, error, data: message } = await response.json();
    
    if (status !== 'success' || !message) {
      throw new Error(error || 'Failed to update message');
    }
    
    // Update messages in Zustand store
    const messages = store.messages.map(m => m.id === messageId ? { ...m, content } : m);
    store.updateMessages(messages);
    
    return message;
  } catch (error) {
    console.error(`[ELECTRON] Error updating message ${messageId}:`, error);
    throw error;
  }
}

/**
 * Search messages
 */
export async function searchMessages(query: string): Promise<Message[]> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/search/messages?q=${encodeURIComponent(query)}`);
    const { status, error, data: messages } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to search messages');
    }
    
    return messages || [];
  } catch (error) {
    console.error('[ELECTRON] Error searching messages:', error);
    throw error;
  }
}

================
File: src/services/notification/notification-service.ts
================
import { API_BASE_URL } from '@/core/auth/auth-service';
import { fetchWithAuth } from '@/services/api/api-service';
import { Notification, NotificationType } from '@/types/notification';

export interface NotificationResponse {
  success: boolean;
  data?: Notification[];
  error?: string;
}

export interface MarkNotificationResponse {
  success: boolean;
  data?: {
    id: string;
    updated: boolean;
  };
  error?: string;
}

export interface MarkAllNotificationsResponse {
  success: boolean;
  data?: {
    count: number;
    updated: boolean;
  };
  error?: string;
}

export interface CreateNotificationOptions {
  title: string;
  description: string;
  userId: string;
  type: NotificationType;
  sourceId?: string;
  actionUrl?: string;
}

/**
 * Fetch all notifications for the current user
 */
export async function fetchNotifications(): Promise<NotificationResponse> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/notifications`);
    const { status, error, data: notifications } = await response.json();
    
    if (status !== 'success') {
      return {
        success: false,
        error: error || 'Failed to fetch notifications'
      };
    }
    
    return {
      success: true,
      data: notifications || []
    };
  } catch (error: any) {
    console.error('[ELECTRON] Error fetching notifications:', error);
    return {
      success: false,
      error: error.message || 'Failed to fetch notifications'
    };
  }
}

/**
 * Mark a notification as read
 */
export async function markNotificationAsRead(notificationId: string): Promise<MarkNotificationResponse> {
  try {
    const response = await fetchWithAuth(
      `${API_BASE_URL}/api/notifications/${notificationId}/read`,
      {
        method: 'PUT'
      }
    );
    const { status, error } = await response.json();
    
    if (status !== 'success') {
      return {
        success: false,
        error: error || 'Failed to mark notification as read'
      };
    }
    
    return {
      success: true,
      data: {
        id: notificationId,
        updated: true
      }
    };
  } catch (error: any) {
    console.error('[ELECTRON] Error marking notification as read:', error);
    return {
      success: false,
      error: error.message || 'Failed to mark notification as read'
    };
  }
}

/**
 * Mark all notifications as read for the current user
 */
export async function markAllNotificationsAsRead(): Promise<MarkAllNotificationsResponse> {
  try {
    const response = await fetchWithAuth(
      `${API_BASE_URL}/api/notifications/read-all`,
      {
        method: 'PUT'
      }
    );
    const { status, error, data } = await response.json();
    
    if (status !== 'success') {
      return {
        success: false,
        error: error || 'Failed to mark all notifications as read'
      };
    }
    
    return {
      success: true,
      data: {
        count: data?.count || 0,
        updated: true
      }
    };
  } catch (error: any) {
    console.error('[ELECTRON] Error marking all notifications as read:', error);
    return {
      success: false,
      error: error.message || 'Failed to mark all notifications as read'
    };
  }
}

/**
 * Create a new notification
 */
export async function createNotification(options: CreateNotificationOptions): Promise<NotificationResponse> {
  try {
    const response = await fetchWithAuth(
      `${API_BASE_URL}/api/notifications`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          title: options.title,
          description: options.description,
          user_id: options.userId,
          type: options.type,
          source_id: options.sourceId,
          action_url: options.actionUrl
        })
      }
    );
    const { status, error, data: notification } = await response.json();
    
    if (status !== 'success') {
      return {
        success: false,
        error: error || 'Failed to create notification'
      };
    }
    
    return {
      success: true,
      data: [notification] // Return as array to match response type
    };
  } catch (error: any) {
    console.error('[ELECTRON] Error creating notification:', error);
    return {
      success: false,
      error: error.message || 'Failed to create notification'
    };
  }
}

================
File: src/services/search/search-service.ts
================
import { API_BASE_URL } from '@/core/auth/auth-service';
import { fetchWithAuth } from '@/services/api/api-service';
import { Message } from '@/types/message';

export async function searchAllMessages(query: string): Promise<Message[]> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/search/messages?q=${encodeURIComponent(query)}`);
    const { status, error, data: messages } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to search messages');
    }
    
    return messages || [];
  } catch (error) {
    console.error('[ELECTRON] Error searching messages:', error);
    throw error;
  }
}


export async function searchSpaceMessages(spaceId: string, query: string): Promise<Message[]> {
  try {
    const response = await fetchWithAuth(
      `${API_BASE_URL}/api/search/spaces/${spaceId}/messages?q=${encodeURIComponent(query)}`
    );
    const { status, error, data: messages } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to search space messages');
    }
    
    return messages || [];
  } catch (error) {
    console.error(`[ELECTRON] Error searching messages in space ${spaceId}:`, error);
    throw error;
  }
}

export async function searchConversationMessages(conversationId: string, query: string): Promise<Message[]> {
  try {
    const response = await fetchWithAuth(
      `${API_BASE_URL}/api/search/conversations/${conversationId}/messages?q=${encodeURIComponent(query)}`
    );
    const { status, error, data: messages } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to search conversation messages');
    }
    
    return messages || [];
  } catch (error) {
    console.error(`[ELECTRON] Error searching messages in conversation ${conversationId}:`, error);
    throw error;
  }
}

export async function findSimilarMessages(messageId: string, limit: number = 5): Promise<Message[]> {
  try {
    const response = await fetchWithAuth(
      `${API_BASE_URL}/api/search/similar-messages/${messageId}?limit=${limit}`
    );
    const { status, error, data: messages } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to find similar messages');
    }
    
    return messages || [];
  } catch (error) {
    console.error(`[ELECTRON] Error finding similar messages to ${messageId}:`, error);
    throw error;
  }
}

================
File: src/services/spaces/space-service.ts
================
import { API_BASE_URL } from '@/core/auth/auth-service';
import { Space } from '@/types/space';
import { useMainStore } from '@/store/main';
import { fetchWithAuth } from '@/services/api/api-service';
import { fetchConversations } from '@/services/conversations/conversation-service';
import { fetchMessages } from '@/services/messages/message-service';
import { Provider } from '@/types/provider';

export async function fetchSpaces(): Promise<Space[]> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces`);
    const { status, error, data } = await response.json();

    console.log("[ELECTRON] Fetch spaces response:", status, error, data.spaces);
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to fetch spaces');
    }
    
    useMainStore.getState().updateSpaces(data.spaces || []);
    
    return data.spaces || [];
  } catch (error) {
    console.error('[ELECTRON] Error fetching spaces:', error);
    throw error;
  }
}

export async function fetchActiveSpace(): Promise<Space | null> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/user/active-space`);
    const { status, error, data } = await response.json();

    console.log("[ELECTRON] Fetch active space response:", status, error, data);
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to fetch active space');
    }
    
    if (data?.space) {
      useMainStore.getState().setActiveSpace(data.space);
    }
    
    return data?.space || null;
  } catch (error) {
    console.error('[ELECTRON] Error fetching active space:', error);
    throw error;
  }
}

/**
 * Update a space with new data
 */
export async function updateSpace(spaceId: string, spaceData: Partial<Space>): Promise<Space> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces/${spaceId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(spaceData)
    });
    
    const { status, error, data: updatedSpace } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to update space');
    }
    
    // Update Zustand store
    const store = useMainStore.getState();
    const spaces = store.spaces.map(s => s.id === spaceId ? { ...s, ...updatedSpace } : s);
    store.updateSpaces(spaces);
    
    // If this is the active space, update that too
    if (store.activeSpace && store.activeSpace.id === spaceId) {
      const updatedSpaceFromStore = spaces.find(s => s.id === spaceId);
      if (updatedSpaceFromStore) {
        store.setActiveSpace(updatedSpaceFromStore);
      }
    }
    
    return updatedSpace;
  } catch (error) {
    console.error(`[ELECTRON] Error updating space ${spaceId}:`, error);
    throw error;
  }
}

/**
 * Create a new space
 */
export async function createSpace(spaceData: Partial<Space>): Promise<Space> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(spaceData)
    });
    
    const { status, error, data: newSpace } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to create space');
    }
    
    // Update Zustand store - add new space to list
    const store = useMainStore.getState();
    const spaces = [...store.spaces, newSpace];
    store.updateSpaces(spaces);
    
    return newSpace;
  } catch (error) {
    console.error('[ELECTRON] Error creating space:', error);
    throw error;
  }
}

/**
 * Delete a space
 */
export async function deleteSpace(spaceId: string): Promise<boolean> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces/${spaceId}`, {
      method: 'DELETE'
    });
    
    const { status, error } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to delete space');
    }
    
    // Update Zustand store - remove deleted space
    const store = useMainStore.getState();
    const spaces = store.spaces.filter(s => s.id !== spaceId);
    store.updateSpaces(spaces);
    
    // If this was the active space, clear it
    if (store.activeSpace && store.activeSpace.id === spaceId) {
      store.setActiveSpace(null);
    }
    
    return true;
  } catch (error) {
    console.error(`[ELECTRON] Error deleting space ${spaceId}:`, error);
    throw error;
  }
}


export async function updateSpaceModel(spaceId: string, modelId: string, provider: string): Promise<boolean> {
  try {
    console.log(`[ELECTRON] Updating space ${spaceId} with model ID: ${modelId}, provider: ${provider}`);
    
    const response = await fetchWithAuth(`${API_BASE_URL}/api/spaces/${spaceId}`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ model: modelId, provider })
    });
    
    const { status, error } = await response.json();

    if (status !== 'success') {
      throw new Error(error || 'Failed to update space model');
    }
    
    const store = useMainStore.getState();
    if (store.spaces) {
      const spaces = store.spaces.map(space => 
        space.id === spaceId ? { ...space, model: modelId as Provider, provider: provider as Provider } : space
      );
      store.updateSpaces(spaces);
      
      if (store.activeSpace && store.activeSpace.id === spaceId) {
        store.setActiveSpace({
          ...store.activeSpace,
          model: modelId as Provider,
          provider: provider as Provider
        });
      }
    }
    
    return true;
  } catch (error) {
    console.error(`[ELECTRON] Error updating model for space ${spaceId}:`, error);
    throw error;
  }
}

/**
 * Set the active space
 */
export async function setActiveSpaceInAPI(spaceId: string) {
  try {
    // Validate space ID
    if (!spaceId) {
      throw new Error('Space ID is required');
    }

    console.log(`[ELECTRON] Setting active space: ${spaceId}`);
    
    const response = await fetchWithAuth(`${API_BASE_URL}/api/user/active-space`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ spaceId })
    });
    
    const responseText = await response.text();
    console.log(`[ELECTRON] Active space API response status: ${response.status}`);
    
    let parsedResponse;
    try {
      parsedResponse = JSON.parse(responseText);
    } catch (e) {
      console.error('[ELECTRON] Failed to parse response as JSON:', e);
      throw new Error('Invalid response from server');
    }
    
    const { status, error, data } = parsedResponse;
    
    if (status !== 'success') {
      console.error('[ELECTRON] API error response:', parsedResponse);
      throw new Error(error || 'Failed to set active space');
    }
    
    // Find the space in our spaces array from Zustand store
    const store = useMainStore.getState();
    const space = store.spaces?.find(s => s.id === spaceId);
    
    if (space) {
      // Update the active space in our Zustand store
      store.setActiveSpace(space);
      
      // Also fetch the conversations for this space
      const conversations = await fetchConversations(spaceId);
      
      // If we have conversations, fetch messages for the most recent one
      if (conversations.length > 0) {
        try {
          await fetchMessages(conversations[0].id);
        } catch (error) {
          console.error(`[ELECTRON] Error fetching messages for conversation ${conversations[0].id}:`, error);
        }
      }
      
      // State is automatically synchronized with Zustand
    } else {
      console.warn(`[ELECTRON] Space with ID ${spaceId} not found in Zustand store`);
    }
    
    return data;
  } catch (error) {
    console.error(`[ELECTRON] Error setting active space ${spaceId}:`, error);
    throw error;
  }
}

================
File: src/services/user/user-service.ts
================
import { API_BASE_URL } from '@/core/auth/auth-service';
import { fetchWithAuth } from '@/services/api/api-service';
import { useMainStore } from '@/store/main'; 

export interface UserProfile {
  full_name: string;
  avatar_url: string;
  website: string;
  bio: string;
  email: string;
}

export interface UserUpdateData {
  full_name?: string;
  avatar_url?: string;
  website?: string;
  bio?: string;
}

export interface PasswordUpdateData {
  currentPassword: string;
  newPassword: string;
}

export interface EmailPreferences {
  [key: string]: boolean;
}

/**
 * Fetch current user profile
 */
export async function fetchUserProfile(): Promise<UserProfile> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/user`);
    
    // Check if response is valid before parsing JSON
    if (!response.ok) {
      const statusText = `Status code: ${response.status}`;
      console.error(`[ELECTRON] User profile API returned error: ${statusText}`);
      
      // Try to get text content to see what was returned
      try {
        const textContent = await response.text();
        const isHtml = textContent.trim().startsWith('<!DOCTYPE') || textContent.trim().startsWith('<html');
        
        if (isHtml) {
          console.error('[ELECTRON] API returned HTML instead of JSON. Server may be down or returning error page.');
          throw new Error(`API returned HTML instead of JSON. ${statusText}`);
        } else {
          console.error('[ELECTRON] API returned non-JSON response:', textContent);
          throw new Error(`Invalid API response. ${statusText}`);
        }
      } catch (error) {
        console.error('[ELECTRON] Failed to read error response:', error);
        throw new Error(`Failed to read error response. ${statusText}`);
      }
    }

    const { status, error, data } = await response.json();
    
    console.log('[ELECTRON] User profile response:', data);

    if (status !== 'success') {
      throw new Error(error || 'Failed to fetch user profile');
    }

    const user = data?.user;
    if (!user) {
      throw new Error('User profile not found in response');
    }

    // Update user in store
    useMainStore.getState().setUser(user);

    return user;
  } catch (error) {
    console.error('[ELECTRON] Error fetching user profile:', error);
    throw error;
  }
}

/**
 * Update user profile
 */
export async function updateUserProfile(data: UserUpdateData): Promise<UserProfile> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/users/profile`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });
    
    const { status, error, data: profile } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to update user profile');
    }

    useMainStore.getState().setUser(profile);

    return profile;
  } catch (error) {
    console.error('[ELECTRON] Error updating user profile:', error);
    throw error;
  }
}

/**
 * Sign up a new user
 */
export async function signUp(email: string, password: string): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/auth/sign-up`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });
    
    const data = await response.json();
    
    if (data.status === 'success' && data.data?.session?.access_token && data.data?.session?.refresh_token && data.data?.session?.expires_at) {
      const store = useMainStore.getState();
      store.setAccessToken(data.data.session.access_token);
      store.setRefreshToken(data.data.session.refresh_token);
      store.setTokenExpiryTime(data.data.session.expires_at);
      console.log('[ELECTRON] Sign-up: Token expiry set from API:', new Date(data.data.session.expires_at * 1000).toISOString());
    }
    
    return data;
  } catch (error) {
    console.error('[ELECTRON] Error signing up:', error);
    throw error;
  }
}

/**
 * Reset user password
 */
export async function resetPassword(email: string): Promise<any> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/auth/reset-password`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    });
    
    return await response.json();
  } catch (error) {
    console.error('[ELECTRON] Error resetting password:', error);
    throw error;
  }
}

/**
 * Get user preference settings
 */
export async function getUserSettings(): Promise<any> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/users/settings`);
    const { status, error, data: settings } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to fetch user settings');
    }
    
    return settings || {};
  } catch (error) {
    console.error('[ELECTRON] Error fetching user settings:', error);
    throw error;
  }
}

/**
 * Update user preference settings
 */
export async function updateUserSettings(settings: any): Promise<any> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/users/settings`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(settings)
    });
    
    const { status, error, data: updatedSettings } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to update user settings');
    }
    
    return updatedSettings;
  } catch (error) {
    console.error('[ELECTRON] Error updating user settings:', error);
    throw error;
  }
}

/**
 * Update user password
 */
export async function updateUserPassword(data: PasswordUpdateData): Promise<void> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/users/password`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    const { status, error } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to update password');
    }
  } catch (error) {
    console.error('[ELECTRON] Error updating password:', error);
    throw error;
  }
}

/**
 * Update user email preferences
 */
export async function updateUserEmailPreferences(preferences: EmailPreferences): Promise<void> {
  try {
    const response = await fetchWithAuth(`${API_BASE_URL}/api/users/email-preferences`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ preferences })
    });

    const { status, error, data: user } = await response.json();
    
    if (status !== 'success') {
      throw new Error(error || 'Failed to update email preferences');
    }

    useMainStore.getState().setUser(user);
  } catch (error) {
    console.error('[ELECTRON] Error updating email preferences:', error);
    throw error;
  }
}

================
File: src/store/main/index.ts
================
import { create } from 'zustand';
import { User } from '@supabase/supabase-js';
import { Conversation } from '@/types/conversation';
import { Message } from '@/types/message';
import { Space } from '@/types/space';

export interface MainProcessState {
  spaces: Space[];
  activeSpace: Space | null;
  conversations: Conversation[];
  messages: Message[];
  initialDataLoaded: boolean;
  lastFetched: number | null;
  user: User | null;
  accessToken: string | null;
  refreshToken: string | null;
  tokenExpiryTime: number | null;
}

const initialState: MainProcessState = {
  spaces: [],
  activeSpace: null,
  conversations: [],
  messages: [],
  initialDataLoaded: false,
  lastFetched: null,
  user: null,
  accessToken: null,
  refreshToken: null,
  tokenExpiryTime: null
};

export const useMainStore = create<MainProcessState & {
  setAppState: (state: Partial<MainProcessState>) => void;
  updateSpaces: (spaces: MainProcessState['spaces']) => void;
  setActiveSpace: (space: MainProcessState['activeSpace']) => void;
  updateConversations: (conversations: MainProcessState['conversations']) => void;
  updateMessages: (messages: MainProcessState['messages']) => void;
  setUser: (user: MainProcessState['user']) => void;
  setAccessToken: (token: MainProcessState['accessToken']) => void;
  setRefreshToken: (token: MainProcessState['refreshToken']) => void;
  setTokenExpiryTime: (time: MainProcessState['tokenExpiryTime']) => void;
}>((set) => ({
  ...initialState,
  setAppState: (newState) => set((state) => ({ ...state, ...newState, initialDataLoaded: true })),
  updateSpaces: (spaces) => set({ spaces }),
  setActiveSpace: (activeSpace) => set({ activeSpace }),
  updateConversations: (conversations) => set({ conversations }),
  updateMessages: (messages) => set({ messages }),
  setUser: (user) => set({ user }),
  setAccessToken: (accessToken) => set({ accessToken }),
  setRefreshToken: (refreshToken) => set({ refreshToken }),
  setTokenExpiryTime: (tokenExpiryTime) => set({ tokenExpiryTime })
}));

export const getMainStoreState = () => useMainStore.getState();

export const subscribeToMainStore = (callback: (state: MainProcessState) => void) => {
  return useMainStore.subscribe(callback);
};

================
File: src/store/renderer/index.ts
================
import { create } from 'zustand';
import { User } from '@supabase/supabase-js';
import { AppStateEvents } from '@/core/ipc/constants';
import { UserProfile } from '@/services/user/user-service';
import { Conversation } from '@/types/conversation';
import { Message } from '@/types/message';
import { Space } from '@/types/space';

export interface RendererProcessState {
  spaces: Space[];
  activeSpace: Space | null;
  conversations: Conversation[];
  messages: Message[];
  initialDataLoaded: boolean;
  isLoading: boolean;
  error: string | null;
  lastSynced: number | null;
  user: User | null;
  profile: UserProfile | null;
}

const initialState: RendererProcessState = {
  spaces: [],
  activeSpace: null,
  conversations: [],
  messages: [],
  initialDataLoaded: false,
  isLoading: false,
  error: null,
  lastSynced: null,
  user: null,
  profile: null
};

export const useRendererStore = create<RendererProcessState & {
  setAppState: (state: Partial<RendererProcessState>) => void;
  setSpaces: (spaces: Space[]) => void;
  setActiveSpace: (space: Space | null) => void;
  setConversations: (conversations: Conversation[]) => void;
  setMessages: (messages: Message[]) => void;
  setUser: (user: User | null) => void;
  setProfile: (profile: UserProfile | null) => void;
  setLoading: (isLoading: boolean) => void;
  setError: (error: string | null) => void;
  
  fetchAppState: () => Promise<boolean>;
  syncWithMainProcess: () => Promise<boolean>;
}>((set, get) => ({
  ...initialState,
  
  setAppState: (newState) => set((state) => ({ 
    ...state, 
    ...newState,
    initialDataLoaded: true,
    lastSynced: Date.now()
  })),
  
  setSpaces: (spaces) => set((state) => ({ ...state, spaces })),
  setActiveSpace: (activeSpace) => set((state) => ({ ...state, activeSpace })),
  setConversations: (conversations) => set((state) => ({ ...state, conversations })),
  setMessages: (messages) => set((state) => ({ ...state, messages })),
  setUser: (user) => set((state) => ({ ...state, user })),
  setProfile: (profile) => set((state) => ({ ...state, profile })),
  setLoading: (isLoading) => set((state) => ({ ...state, isLoading })),
  setError: (error) => set((state) => ({ ...state, error })),
  
  fetchAppState: async () => {
    try {
      const response = await window.electron.invoke(AppStateEvents.GET_STATE);
      console.log('App state response', response);
      if (response.success && response.data) {
        console.log('App state data', response.data);
        
        const {
          spaces = [],
          activeSpace = null,
          conversations = [],
          messages = [],
          user = null,
          profile = null,
          initialDataLoaded = false
        } = response.data;

        console.log('[RENDERER] Setting state with:', {
          spaces,
          activeSpace,
          conversations: conversations.length,
          messages: messages.length,
          user: user?.email,
          initialDataLoaded
        });

        set((state) => ({
          ...state,
          isLoading: false,
          error: null,
          spaces,
          activeSpace,
          conversations,
          messages,
          user,
          profile,
          initialDataLoaded: true,
          lastSynced: Date.now()
        }));
        return true;
      } else {
        console.error('[RENDERER] Failed to fetch app state:', response.error);
        set((state) => ({ 
          ...state,
          isLoading: false,
          error: response.error || 'Failed to fetch app state'
        }));
        return false;
      }
    } catch (error) {
      console.error('[RENDERER] Error fetching app state:', error);
      set((state) => ({ 
        ...state,
        isLoading: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      }));
      return false;
    }
  },
  
  syncWithMainProcess: async () => {
    try {
      const currentState = get();
      const response = await window.electron.invoke(AppStateEvents.SYNC_STATE, {
        spaces: currentState.spaces,
        activeSpace: currentState.activeSpace,
        conversations: currentState.conversations,
        messages: currentState.messages,
        user: currentState.user,
        profile: currentState.profile
      });
      
      if (response.success) {
        set((state) => ({ ...state, lastSynced: Date.now() }));
        return true;
      }
      
      set((state) => ({ ...state, error: response.error || 'Failed to sync with main process' }));
      return false;
    } catch (error) {
      set((state) => ({ ...state, error: error instanceof Error ? error.message : 'Unknown error occurred' }));
      return false;
    }
  }
}));

export const getRendererStoreState = () => useRendererStore.getState();

================
File: src/store/actions.ts
================
import { AppState } from '@/types/app';

export interface StoreActions {
  setAppState: (state: Partial<AppState>) => void;
  updateSpaces: (spaces: AppState['spaces']) => void;
  setActiveSpace: (space: AppState['activeSpace']) => void;
  updateConversations: (conversations: AppState['conversations']) => void;
  updateMessages: (messages: AppState['messages']) => void;
  setUser: (user: AppState['user']) => void;
  setAccessToken: (token: AppState['accessToken']) => void;
  setRefreshToken: (token: AppState['refreshToken']) => void;
  setTokenExpiryTime: (time: AppState['tokenExpiryTime']) => void;
}

export type Store = AppState & StoreActions;

================
File: src/styles/cmdk.css
================
.vinci {
  height: 100vh;
  width: 100vw;
  display: flex;
  align-items: flex-start;
  justify-content: flex-start;
  background: #161617;
  border: 2px solid rgba(235, 235, 245, 0.06);

  [cmdk-root] {
    width: 100%;
    height: 100%;
    background: transparent;
    border-radius: 0;
    padding: 0;
    font-family: var(--font-sans);
    box-shadow: none;
    border: none;
    position: relative;
    outline: none;
    display: flex;
    flex-direction: column;
  }

  [cmdk-input] {
    font-family: var(--font-sans);
    border: none;
    width: 100%;
    font-size: 16px;
    padding: 12px;
    outline: none;
    background: transparent;
    color: rgba(235, 235, 245, 0.6);
    border-bottom: 2px solid rgba(235, 235, 245, 0.06);

    &::placeholder {
      color: rgba(235, 235, 245, 0.3);
    }
  }

  [cmdk-list] {
    padding: 8px;
    flex: 1;
    overflow: auto;
    overscroll-behavior: contain;
    transition: 100ms ease;
    margin: 0;
    display: flex;
    flex-direction: column;
  }

  [cmdk-item] {
    content-visibility: auto;
    cursor: pointer;
    height: 44px;
    border-radius: 8px;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 0 12px;
    color: rgba(235, 235, 245, 0.6);
    user-select: none;
    will-change: background, color;
    transition: all 150ms ease;
    margin: 0;
    position: relative;
    background: transparent;

    &[data-selected='true'] {
      background: rgba(235, 235, 245, 0.06);
      color: rgba(235, 235, 245, 0.9);
    }

    &[data-disabled='true'] {
      color: rgba(235, 235, 245, 0.2);
      cursor: not-allowed;
    }

    &:active {
      background: rgba(235, 235, 245, 0.08);
    }

    svg {
      width: 16px;
      height: 16px;
      color: rgba(235, 235, 245, 0.4);
    }
  }

  [cmdk-group] {
    margin: 8px 0;
    padding: 0;
  }

  [cmdk-group-heading] {
    user-select: none;
    font-size: 12px;
    color: rgba(235, 235, 245, 0.4);
    padding: 0 12px;
    display: flex;
    align-items: center;
    margin-bottom: 8px;
  }

  [cmdk-empty] {
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 48px;
    white-space: pre-wrap;
    color: rgba(235, 235, 245, 0.4);
    padding: 0 16px;
  }

  [cmdk-separator] {
    height: 1px;
    width: 100%;
    background: rgba(235, 235, 245, 0.06);
    margin: 4px 0;
  }

  *:not([hidden]) + [cmdk-group] {
    margin-top: 8px;
  }

  .cmdk-actions {
    position: absolute;
    right: 8px;
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .cmdk-meta {
    margin-left: auto;
    color: rgba(235, 235, 245, 0.4);
    font-size: 12px;
  }

  .dialog {
    background: rgba(22, 22, 23, 0.95);
    border-radius: 12px;
    padding: 24px;
    width: 100%;
    max-width: 640px;
    margin: 0 auto;
    border: 1px solid rgba(235, 235, 245, 0.06);
    backdrop-filter: blur(20px);
  }
}

@media (max-width: 640px) {
  .vinci {
    [cmdk-input] {
      font-size: 16px;
    }
  }
}

================
File: src/styles/globals.css
================
@import 'tailwindcss';

@plugin "tailwindcss-animate";

@variant dark (&:is(.dark *));

@source "./src/**/*.{js,ts,jsx,tsx}";

:root {
  /* Base colors */
  --background: #000000;
  --foreground: #f4f4f8;
  --card: rgba(0, 0, 0, 0.8);
  --card-foreground: #f4f4f8;
  --card-border: rgba(255, 255, 255, 0.07);
  --card-border-hover: rgba(255, 255, 255, 0.15);
  --popover: rgba(0, 0, 0, 0.9);
  --popover-foreground: #f4f4f8;

  /* Surface colors */
  --surface: #000000;
  --surface-elevated: #050508;
  
  /* Text colors */
  --text: #ffffff;
  --text-secondary: rgba(255, 255, 255, 0.8);
  --text-tertiary: rgba(255, 255, 255, 0.65);
  --text-muted: rgba(255, 255, 255, 0.5);
  

  /* Primary colors */
  --primary: #ffffff;
  --primary-foreground: #000000;
  --primary-light: #eeeeee;
  --primary-dark: #cccccc;

  /* Secondary colors */
  --secondary: rgba(255, 255, 255, 0.8);
  --secondary-foreground: #000000;

  /* Accent colors */
  --accent: #3366ff;
  --accent-light: #4477ff;
  --accent-foreground: #f4f4f8;

  /* UI feedback colors */
  --destructive: #ef4444;
  --destructive-foreground: #f4f4f8;
  --success: #10b981;
  --warning: #f59e0b;
  --info: #3b82f6;

  /* Border and outline colors */
  --border: rgba(255, 255, 255, 0.06);
  --border-hover: rgba(255, 255, 255, 0.12);
  --input: rgba(255, 255, 255, 0.08);
  --ring: rgba(51, 102, 255, 0.5);
  --muted: rgba(255, 255, 255, 0.1);
  --muted-foreground: rgba(255, 255, 255, 0.5);

  /* Chart colors */
  --chart-1: #f43f5e;
  --chart-2: #0ea5e9;
  --chart-3: #3c85fc;
  --chart-4: #f59e0b;
  --chart-5: #a3e635;

  /* Sidebar specific colors */
  --sidebar: #050508;
  --sidebar-foreground: #f4f4f8;
  --sidebar-primary: #ffffff;
  --sidebar-primary-foreground: #000000;
  --sidebar-accent: #3366ff;
  --sidebar-accent-foreground: #f4f4f8;
  --sidebar-border: rgba(255, 255, 255, 0.06);
  --sidebar-ring: rgba(51, 102, 255, 0.5);

  /* Glass effects */
  --glass-background: rgba(0, 0, 0, 0.2);
  --glass-border: rgba(255, 255, 255, 0.08);
  --glass-background-hover: rgba(0, 0, 0, 0.25);
  --glass-border-hover: rgba(255, 255, 255, 0.12);
  --glass-backdrop-filter: blur(12px);
  --glass-glow: 0 0 20px rgba(62, 207, 255, 0.1);
  --glass-inner-glow: inset 0 0 20px rgba(62, 207, 255, 0.05);
  --glass-shimmer: linear-gradient(90deg, rgba(255, 255, 255, 0) 15%, rgba(255, 255, 255, 0.05) 50%, rgba(255, 255, 255, 0) 85%);
  
  /* Effect colors */
  --blue-glow: rgba(150, 150, 150, 0.5);
  --purple-glow: rgba(180, 180, 180, 0.4);
  --glow-opacity: 0.05;

  /* Font typography */
  --font-sans: var(--font-inter), ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  
  /* Font sizes */
  --font-size-xs: 0.75rem;      /* 12px */
  --font-size-sm: 0.875rem;     /* 14px */
  --font-size-base: 1rem;       /* 16px */
  --font-size-lg: 1.125rem;     /* 18px */
  --font-size-xl: 1.25rem;      /* 20px */
  --font-size-2xl: 1.5rem;      /* 24px */
  --font-size-3xl: 1.875rem;    /* 30px */
  --font-size-4xl: 2.25rem;     /* 36px */
  --font-size-5xl: 3rem;        /* 48px */
  --font-size-6xl: 3.75rem;     /* 60px */
  --font-size-7xl: 4.5rem;      /* 72px */
  --font-size-8xl: 6rem;        /* 96px */
  --font-size-9xl: 8rem;        /* 128px */

  /* Line heights */
  --line-height-none: 1;
  --line-height-tight: 1.1;
  --line-height-snug: 1.25;
  --line-height-normal: 1.5;
  --line-height-relaxed: 1.625;
  --line-height-loose: 2;

  /* Letter spacing */
  --letter-spacing-tighter: -0.05em;
  --letter-spacing-tight: -0.025em;
  --letter-spacing-normal: 0em;
  --letter-spacing-wide: 0.025em;
  --letter-spacing-wider: 0.05em;
  --letter-spacing-widest: 0.1em;

  /* Font weights */
  --font-weight-thin: 100;
  --font-weight-extralight: 200;
  --font-weight-light: 300;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  --font-weight-extrabold: 800;
  --font-weight-black: 900;

  /* Shadow values */
  --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 8px rgba(255, 255, 255, 0.03);
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.9);
  --shadow-md: 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255, 255, 255, 0.05);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.7), 0 4px 6px -2px rgba(0, 0, 0, 0.5);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.8);
  --shadow-glow: 0 0 20px rgba(99, 102, 241, 0.3);
  --shadow-glow-blue: 0 0 15px rgba(14, 165, 233, 0.5);
  --shadow-glow-purple: 0 0 15px rgba(139, 92, 246, 0.5);

  /* Transition properties */
  --transition-property-common: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform;
  --transition-property-typography: color, opacity, transform;
  --transition-property-backdrop: backdrop-filter, background-color;

  --transition-duration-75: 75ms;
  --transition-duration-100: 100ms;
  --transition-duration-150: 150ms;
  --transition-duration-200: 200ms;
  --transition-duration-250: 250ms;
  --transition-duration-300: 300ms;
  --transition-duration-400: 400ms;
  --transition-duration-500: 500ms;
  --transition-duration-700: 700ms;
  --transition-duration-1000: 1000ms;

  --transition-timing-linear: linear;
  --transition-timing-in: cubic-bezier(0.4, 0, 1, 1);
  --transition-timing-out: cubic-bezier(0, 0, 0.2, 1);
  --transition-timing-in-out: cubic-bezier(0.4, 0, 0.2, 1);
  --transition-timing-smooth: cubic-bezier(0.4, 0, 0.2, 1);
  --transition-timing-bounce: cubic-bezier(0.34, 1.56, 0.64, 1);

  /* Gradient backgrounds */
  --gradient-dark: linear-gradient(to bottom, #050510, #080820, #0a0a25);
  --gradient-card: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0));
  --gradient-blue: linear-gradient(to right, #0ea5e9, #38bdf8);
  --gradient-purple: linear-gradient(to right, #8b5cf6, #c084fc);
  --gradient-indigo: linear-gradient(90deg, #818cf8 0%, #c4b5fd 100%);
  --gradient-glow: linear-gradient(45deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.04));
  --gradient-shimmer: linear-gradient(90deg, rgba(255, 255, 255, 0) 15%, rgba(99, 102, 241, 0.6) 50%, rgba(255, 255, 255, 0) 85%);
  --gradient-card-border: linear-gradient(180deg, rgba(99, 102, 241, 0.3) 49.5%, rgba(99, 102, 241, 0) 100%);

  /* Radius */
  --radius: 0.5rem;
  --radius-xs: calc(var(--radius) - 6px);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-full: 9999px;
  --radius-card: 0.75rem;
  --radius-button: 0.5rem;

  /* Set dark mode as default */
  color-scheme: dark;
}

@theme {
  /* Colors */
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-card-border: var(--card-border);
  --color-card-border-hover: var(--card-border-hover);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary-light: var(--primary-light);
  --color-primary-dark: var(--primary-dark);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-accent: var(--accent);
  --color-accent-light: var(--accent-light);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-success: var(--success);
  --color-warning: var(--warning);
  --color-info: var(--info);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-border: var(--border);
  --color-border-hover: var(--border-hover);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-surface: var(--surface);
  --color-surface-elevated: var(--surface-elevated);
  --color-text: var(--text);
  --color-text-secondary: var(--text-secondary);
  --color-text-tertiary: var(--text-tertiary);
  --color-text-muted: var(--text-muted);
  --color-glass-background: var(--glass-background);
  --color-glass-border: var(--glass-border);
  --color-glass-background-hover: var(--glass-background-hover);
  --color-glass-border-hover: var(--glass-border-hover);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  
  /* Border Radius */
  --radius-xs: var(--radius-xs);
  --radius-sm: var(--radius-sm);
  --radius-md: var(--radius-md);
  --radius-lg: var(--radius-lg);
  --radius-xl: var(--radius-xl);
  --radius-2xl: var(--radius-2xl);
  --radius-full: var(--radius-full);
  
  /* Box Shadow */
  --shadow-card: var(--shadow-card);
  --shadow-sm: var(--shadow-sm);
  --shadow-md: var(--shadow-md);
  --shadow-lg: var(--shadow-lg);
  --shadow-xl: var(--shadow-xl);
  --shadow-glow: var(--shadow-glow);
  --shadow-glow-blue: var(--shadow-glow-blue);
  --shadow-glow-purple: var(--shadow-glow-purple);
  
  /* Font Size */
  --text-xs: var(--font-size-xs);
  --text-sm: var(--font-size-sm);
  --text-base: var(--font-size-base);
  --text-lg: var(--font-size-lg);
  --text-xl: var(--font-size-xl);
  --text-2xl: var(--font-size-2xl);
  --text-3xl: var(--font-size-3xl);
  --text-4xl: var(--font-size-4xl);
  --text-5xl: var(--font-size-5xl);
  --text-6xl: var(--font-size-6xl);
  --text-7xl: var(--font-size-7xl);
  --text-8xl: var(--font-size-8xl);
  --text-9xl: var(--font-size-9xl);
  
  /* Line Height */
  --leading-none: var(--line-height-none);
  --leading-tight: var(--line-height-tight);
  --leading-snug: var(--line-height-snug);
  --leading-normal: var(--line-height-normal);
  --leading-relaxed: var(--line-height-relaxed);
  --leading-loose: var(--line-height-loose);
  
  /* Letter Spacing */
  --tracking-tighter: var(--letter-spacing-tighter);
  --tracking-tight: var(--letter-spacing-tight);
  --tracking-normal: var(--letter-spacing-normal);
  --tracking-wide: var(--letter-spacing-wide);
  --tracking-wider: var(--letter-spacing-wider);
  --tracking-widest: var(--letter-spacing-widest);
  
  /* Font Weight */
  --font-weight-thin: var(--font-weight-thin);
  --font-weight-extralight: var(--font-weight-extralight);
  --font-weight-light: var(--font-weight-light);
  --font-weight-normal: var(--font-weight-normal);
  --font-weight-medium: var(--font-weight-medium);
  --font-weight-semibold: var(--font-weight-semibold);
  --font-weight-bold: var(--font-weight-bold);
  --font-weight-extrabold: var(--font-weight-extrabold);
  --font-weight-black: var(--font-weight-black);
  
  /* Container Configuration */
  --container-padding: 2rem;
  --breakpoint-2xl: 1400px;
}

/* Custom Animation Keyframes */
@keyframes accordion-down {
  from { height: 0 }
  to { height: var(--radix-accordion-content-height) }
}

@keyframes accordion-up {
  from { height: var(--radix-accordion-content-height) }
  to { height: 0 }
}

@keyframes pulse-slow {
  0%, 100% { opacity: 1; transform: scale(0.98) }
  50% { opacity: 0.7; transform: scale(1.02) }
}

@keyframes shimmer {
  0% { background-position: -200% 0 }
  100% { background-position: 200% 0 }
}

@keyframes glow {
  0%, 100% { opacity: 0.8 }
  50% { opacity: 0.5 }
}

@keyframes float {
  0%, 100% { transform: translateY(0) }
  50% { transform: translateY(-8px) }
}

@keyframes border-glow {
  0%, 100% { border-color: rgba(99, 102, 241, 0.3) }
  50% { border-color: rgba(99, 102, 241, 0.1) }
}

@keyframes typing {
  0% { width: 0% }
  100% { width: 100% }
}

@keyframes blink {
  0%, 100% { border-color: transparent }
  50% { border-color: white }
}

@keyframes marquee {
  0% { transform: translateX(0%) }
  100% { transform: translateX(-100%) }
}

/* Custom Utilities for Animations */
@utility animate-accordion-down {
  animation: accordion-down 0.2s ease-out;
}

@utility animate-accordion-up {
  animation: accordion-up 0.2s ease-out;
}

@utility animate-pulse-slow {
  animation: pulse-slow 3s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@utility animate-shimmer {
  /* Disabled for performance */
  background-size: 200% 100%;
}

@utility animate-command-item-shimmer {
  /* Disabled for performance */
  background-size: 300% 100%;
}

@utility animate-glow {
  animation: glow 5s ease-in-out infinite;
}

@utility animate-float {
  animation: float 6s ease-in-out infinite;
}

@utility animate-border-glow {
  animation: border-glow 4s ease-in-out infinite;
}

@utility animate-typing {
  overflow: hidden;
  white-space: nowrap;
  animation: typing 3.5s steps(40, end);
}

@utility animate-cursor {
  border-right: 0.15em solid;
  animation: blink 1s step-end infinite;
}

@utility animate-marquee {
  animation: marquee 25s linear infinite;
}

/* Custom Utilities for Shadows */
@utility shadow-card {
  box-shadow: var(--shadow-card);
}

@utility shadow-sm {
  box-shadow: var(--shadow-sm);
}

@utility shadow-md {
  box-shadow: var(--shadow-md);
}

@utility shadow-lg {
  box-shadow: var(--shadow-lg);
}

@utility shadow-xl {
  box-shadow: var(--shadow-xl);
}

@utility shadow-glow {
  box-shadow: var(--shadow-glow);
}

@utility shadow-glow-blue {
  box-shadow: var(--shadow-glow-blue);
}

@utility shadow-glow-purple {
  box-shadow: var(--shadow-glow-purple);
}

/* Custom Utilities for Backgrounds */
@utility bg-gradient-dark {
  background-image: var(--gradient-dark);
}

@utility bg-gradient-card {
  background-image: var(--gradient-card);
}

@utility bg-gradient-blue {
  background-image: var(--gradient-blue);
}

@utility bg-gradient-purple {
  background-image: var(--gradient-purple);
}

@utility bg-gradient-indigo {
  background-image: var(--gradient-indigo);
}

@utility bg-gradient-glow {
  background-image: var(--gradient-glow);
}

@utility bg-gradient-shimmer {
  background-image: var(--gradient-shimmer);
  background-size: 200% 100%;
}

/* Glassy UI System */
@utility glassy-ui {
  background: var(--glass-background);
  border: 1px solid var(--glass-border);
  backdrop-filter: var(--glass-backdrop-filter);
  -webkit-backdrop-filter: var(--glass-backdrop-filter);
  box-shadow: var(--glass-glow), var(--glass-inner-glow);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  border-radius: inherit;
  
  &:hover {
    background: var(--glass-background-hover);
    border-color: var(--glass-border-hover);
    box-shadow: 0 0 25px rgba(62, 207, 255, 0.15), inset 0 0 25px rgba(62, 207, 255, 0.08);
  }
  
  &:focus-within {
    background: var(--glass-background-hover);
    border-color: var(--glass-border-hover);
    box-shadow: 0 0 25px rgba(62, 207, 255, 0.15), inset 0 0 25px rgba(62, 207, 255, 0.08);
  }
  
  /* Shimmer effect on hover */
  &::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: var(--glass-shimmer);
    background-size: 200% 100%;
    animation: shimmer 12s linear infinite;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  
  &:hover::after {
    opacity: 0.3;
  }
}

/* Variant: Subtle */
@utility glassy-ui-subtle {
  background: rgba(0, 0, 0, 0.15);
  border: 1px solid var(--glass-border);
  backdrop-filter: var(--glass-backdrop-filter);
  -webkit-backdrop-filter: var(--glass-backdrop-filter);
  box-shadow: 0 0 15px rgba(62, 207, 255, 0.05), inset 0 0 15px rgba(62, 207, 255, 0.03);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  border-radius: inherit;
  
  &:hover {
    background: rgba(0, 0, 0, 0.2);
    border-color: var(--glass-border-hover);
    box-shadow: 0 0 20px rgba(62, 207, 255, 0.08), inset 0 0 20px rgba(62, 207, 255, 0.04);
  }
  
  /* Shimmer effect on hover */
  &::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: var(--glass-shimmer);
    background-size: 200% 100%;
    animation: shimmer 12s linear infinite;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  
  &:hover::after {
    opacity: 0.2;
  }
}

/* Variant: Prominent */
@utility glassy-ui-prominent {
  background: rgba(0, 0, 0, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  box-shadow: 0 0 30px rgba(62, 207, 255, 0.15), inset 0 0 30px rgba(62, 207, 255, 0.08);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  border-radius: inherit;
  
  &:hover {
    background: rgba(0, 0, 0, 0.3);
    border-color: rgba(255, 255, 255, 0.15);
    box-shadow: 0 0 40px rgba(62, 207, 255, 0.2), inset 0 0 40px rgba(62, 207, 255, 0.1);
  }
  
  /* Shimmer effect on hover */
  &::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: var(--glass-shimmer);
    background-size: 200% 100%;
    animation: shimmer 12s linear infinite;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  
  &:hover::after {
    opacity: 0.4;
  }
}

/* Custom utility for color-tinted glass */
@utility glassy-ui-colored {
  --color: var(--color, #3ecfff);
  background: rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.08);
  backdrop-filter: var(--glass-backdrop-filter);
  -webkit-backdrop-filter: var(--glass-backdrop-filter);
  box-shadow: 0 0 20px color-mix(in srgb, var(--color) 10%, transparent), 
              inset 0 0 20px color-mix(in srgb, var(--color) 5%, transparent);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  border-radius: inherit;
  
  &:hover {
    background: rgba(0, 0, 0, 0.25);
    border-color: rgba(255, 255, 255, 0.12);
    box-shadow: 0 0 25px color-mix(in srgb, var(--color) 15%, transparent), 
                inset 0 0 25px color-mix(in srgb, var(--color) 8%, transparent);
  }
  
  /* Shimmer effect on hover */
  &::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: var(--glass-shimmer);
    background-size: 200% 100%;
    animation: shimmer 12s linear infinite;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  
  &:hover::after {
    opacity: 0.3;
  }
}

/* Legacy utilities - kept for backward compatibility */
@utility glass-effect {
  background: var(--glass-background);
  border: 1px solid var(--glass-border);
  backdrop-filter: var(--glass-backdrop-filter);
  -webkit-backdrop-filter: var(--glass-backdrop-filter);
  box-shadow: var(--glass-glow), var(--glass-inner-glow);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  
  &:hover {
    background: var(--glass-background-hover);
    border-color: var(--glass-border-hover);
    box-shadow: 0 0 25px rgba(62, 207, 255, 0.15), inset 0 0 25px rgba(62, 207, 255, 0.08);
  }
  
  &::after {
    content: '';
    position: absolute;
    inset: 0;
    background: var(--glass-shimmer);
    background-size: 200% 100%;
    animation: shimmer 12s linear infinite;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s ease;
  }
  
  &:hover::after {
    opacity: 0.3;
  }
}

@utility command-glass-effect {
  background: var(--command-bg, rgba(0, 0, 0, 0.2));
  border: 1px solid var(--command-border, rgba(255, 255, 255, 0.08));
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  border-radius: var(--command-border-radius, inherit);
  width: var(--command-width, auto);
  max-width: var(--command-max-width, none);
  max-height: var(--command-max-height, none);
}


/* Custom Utilities for Text Gradients */
@utility text-gradient-blue {
  background-image: var(--gradient-blue);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

@utility text-gradient-purple {
  background-image: var(--gradient-purple);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

@utility text-gradient-indigo {
  background-image: var(--gradient-indigo);
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
}

/* Background Patterns */
@utility bg-grid {
  background-image: linear-gradient(rgba(255, 255, 255, 0.07) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.07) 1px, transparent 1px);
  background-size: 24px 24px;
  background-position: center;
}

@utility bg-dots {
  background-image: radial-gradient(circle, rgba(30, 30, 60, 0.1) 1px, transparent 1px);
  background-size: 16px 16px;
  background-position: center;
}

/* Glow Border */
@utility glow-border {
  position: relative;
  border: 1px solid var(--glass-border);
  
  &::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    box-shadow: 0 0 15px 2px rgba(99, 102, 241, 0.3);
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
}

@utility hover-glow {
  &:hover {
    box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);
    border-color: rgba(99, 102, 241, 0.4);
  }
}

/* Glass Nav */
@utility glass-nav {
  background: rgba(10, 10, 30, 0.25);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-bottom: 1px solid rgba(255, 255, 255, 0.03);
  transition: all 0.3s ease;
  
  &.scrolled {
    background: rgba(10, 10, 30, 0.65);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  }
}

/* Dark Mode Styles */
.dark {
  /* Base colors */
  --background: #000000;
  --foreground: #f4f4f8;
  --card: rgba(0, 0, 0, 0.8);
  --card-foreground: #f4f4f8;
  --card-border: rgba(255, 255, 255, 0.07);
  --card-border-hover: rgba(255, 255, 255, 0.15);
  --popover: rgba(0, 0, 0, 0.9);
  --popover-foreground: #f4f4f8;

  /* Surface colors */
  --surface: #000000;
  --surface-elevated: #050508;
  
  /* Text colors */
  --text: #ffffff;
  --text-secondary: rgba(255, 255, 255, 0.8);
  --text-tertiary: rgba(255, 255, 255, 0.65);
  --text-muted: rgba(255, 255, 255, 0.5);
  
  /* Other colors */
  --muted: rgba(255, 255, 255, 0.1);
  --muted-foreground: rgba(255, 255, 255, 0.5);
  
  /* Sidebar colors */
  --sidebar: #050508;
  --sidebar-foreground: #f4f4f8;
  --sidebar-primary: #ffffff;
  --sidebar-primary-foreground: #000000;
  --sidebar-accent: #3366ff;
  --sidebar-accent-foreground: #f4f4f8;
  --sidebar-border: rgba(255, 255, 255, 0.06);
  --sidebar-ring: rgba(51, 102, 255, 0.5);
  
  /* Glass effects */
  --glass-background: rgba(15, 15, 40, 0.3);
  --glass-border: rgba(255, 255, 255, 0.05);
  --glass-background-hover: rgba(15, 15, 40, 0.4);
  --glass-border-hover: rgba(255, 255, 255, 0.1);
}

================
File: src/types/api.ts
================
export interface ApiErrorResponse {
  error: {
    message: string;
    code?: number;
    details?: Record<string, any>;
  };
  toast?: ToastConfig;
}

export interface ApiSuccessResponse<T = any> {
  data: T;
  toast?: ToastConfig;
}

export interface ToastConfig {
  title: string;
  description?: string;
  variant: 'default' | 'success' | 'warning' | 'error';
}

export interface PaginationParams {
  page: number;
  limit: number;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';

================
File: src/types/app.ts
================
import { Space } from '@/types/space';
import { Conversation } from '@/types/conversation';
import { Message } from '@/types/message';
import { User } from '@/types/user';

export interface AppState {
  spaces: Space[];
  activeSpace: Space | null;
  conversations: Conversation[];
  messages: Message[];
  initialDataLoaded: boolean;
  lastFetched: number | null;
  user: User | null;
  accessToken: string | null;
  refreshToken: string | null;
  tokenExpiryTime: number | null;
}

================
File: src/types/auth.ts
================
import { IpcResponse } from '@/types/ipc';

export interface AuthSession {
  accessToken: string;
  refreshToken: string;
  expiresAt: number; // Unix timestamp in seconds
  userId: string;
}

export interface AuthResponse extends IpcResponse {
  data?: any;
}

export interface SignInRequest {
  email: string;
  password: string;
}

export interface SignInResponse {
  session: AuthSession | null;
}

export interface SignUpRequest {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
}

export interface SignUpResponse {
  session: AuthSession | null;
  userId: string;
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  session: AuthSession | null;
}

export interface ResetPasswordRequest {
  email: string;
}

export interface ResetPasswordResponse {
  success: boolean;
  message: string;
}

================
File: src/types/chat.ts
================
import { IpcResponse } from '@/types/ipc';

export interface ChatResponse extends IpcResponse {
  chatId?: string;
  chunk?: any;
  error?: string;
}

export interface ChatStreamStartEvent {
  chatId: string;
}

export interface ChatStreamChunkEvent {
  chatId: string;
  chunk: any;
}

export interface ChatStreamFinishEvent {
  chatId: string;
}

export interface ChatStreamErrorEvent {
  chatId: string;
  error: string;
}

================
File: src/types/command.ts
================
export type CommandType = 
  | 'spaces'
  | 'conversations'
  | 'models'
  | 'backgroundTasks'
  | 'suggestions'
  | 'actions'
  | 'chatModes'
  | 'chat-modes'
  | 'messageSearch'
  | 'similarMessages'
  | 'application'
  | 'background-tasks'
  | 'unified';

export type ShortcutKey = 
  | 'CommandOrControl+Option+A'
  | 'CommandOrControl+Option+S'
  | 'CommandOrControl+Option+C'
  | 'CommandOrControl+Option+M'
  | 'CommandOrControl+Option+T'
  | 'CommandOrControl+Option+G'
  | 'CommandOrControl+Option+H'
  | 'CommandOrControl+Option+Q'
  | 'CommandOrControl+Option+W'
  | 'CommandOrControl+Option+E';

================
File: src/types/conversation.ts
================
import { IpcResponse } from '@/types/ipc';

export interface Conversation {
  id: string;
  space_id: string;
  title?: string;
  is_deleted: boolean;
  created_at: string;
  updated_at: string;
  messageCount?: number;
  lastMessage?: string;
}

export interface ConversationResponse extends IpcResponse {
  data?: Conversation | Conversation[] | { deleted: boolean } | { updated: boolean } | { messages: any[] };
}

export interface ActiveConversation {
  id: string;
  user_id: string;
  conversation_id: string;
  created_at: string;
}

export interface CreateConversationRequest {
  title?: string;
  space_id: string;
}

export interface CreateConversationResponse {
  conversation: Conversation;
}

export interface UpdateConversationRequest {
  title?: string;
  is_deleted?: boolean;
}

export interface UpdateConversationResponse {
  conversation: Conversation;
}

export interface GetConversationsResponse {
  conversations: Conversation[];
}

export interface GetConversationResponse {
  conversation: Conversation;
}

export interface DeleteConversationResponse {
  success: boolean;
}

================
File: src/types/electron.d.ts
================
// electron.d.ts
/**
 * TypeScript definitions for Electron API
 * This file defines types for the APIs exposed through the preload script
 * and augments the Window interface to include our IPC communication types
 */

import { AuthEvents, AppStateEvents, CommandCenterEvents, SpaceEvents, MessageEvents, NotificationEvents, ConversationEvents } from '@/core/ipc/constants';
import { IpcResponse, IpcStateResponse } from '.';

// Types for API responses
type ApiResponse<T = any> = {
  success: boolean;
  data?: T;
  error?: string;
};

// Types for auth-related responses
type AuthTokenResponse = {
  accessToken: string;
  refreshToken: string;
  expiresAt: number;
};

// Types for space-related data
type Space = {
  id: string;
  name: string;
  description?: string;
  model?: string;
  provider?: string;
  conversations?: Conversation[];
};

// Types for conversation-related data
type Conversation = {
  id: string;
  spaceId: string;
  title: string;
  messages: Message[];
  createdAt: string;
  updatedAt: string;
};

// Types for message-related data
type Message = {
  id: string;
  conversationId: string;
  content: string;
  role: 'user' | 'assistant' | 'system';
  createdAt: string;
};

// Types for command center data
type CommandCenterState = {
  isOpen: boolean;
  activeCommand?: string;
  dialogType?: string;
  dialogData?: any;
};

/**
 * Main ElectronAPI interface that defines all available IPC methods
 */
interface ElectronAPI {
  /**
   * Set authentication tokens for Electron main process
   */
  [AuthEvents.SET_AUTH_TOKENS]?: (accessToken: string, refreshToken: string) => Promise<boolean>;
  
  /**
   * Get current authentication token from Electron main process
   * Will automatically refresh if needed using the refresh token
   */
  [AuthEvents.GET_SESSION]?: () => Promise<string | null>;
  
  /**
   * Force refresh of authentication tokens
   */
  [AuthEvents.REFRESH_TOKEN]?: () => Promise<{ 
    success: boolean; 
    accessToken?: string; 
    expiresAt?: number;
    error?: string;
  }>;
  
  /**
   * Sign out and clear all tokens
   */
  [AuthEvents.SIGN_OUT]?: () => Promise<boolean>;
  
  /**
   * Get access token from main process
   */
  [AuthEvents.GET_ACCESS_TOKEN]?: () => Promise<IpcResponse<string>>;

  /**
   * Set access token in main process
   */
  [AuthEvents.SET_ACCESS_TOKEN]?: (token: string) => Promise<IpcResponse<void>>;

  /**
   * Get the current application state
   */
  [AppStateEvents.GET_STATE]?: () => Promise<{
    success: boolean;
    data?: AppState;
    error?: string;
  }>;

  /**
   * Refresh the application data from the server
   */
  [AppStateEvents.REFRESH_DATA]?: () => Promise<{
    success: boolean;
    data?: AppState;
    error?: string;
  }>;

  /**
   * Get conversations for a specific space
   */
  [SpaceEvents.GET_CONVERSATIONS]?: (spaceId: string) => Promise<{
    success: boolean;
    data?: any[];
    error?: string;
  }>;

  /**
   * Get messages for a specific conversation
   */
  [MessageEvents.GET_MESSAGES]?: (conversationId: string) => Promise<{
    success: boolean;
    data?: any[];
    error?: string;
  }>;

  /**
   * Update a space with new data
   */
  [SpaceEvents.UPDATE_SPACE]?: (spaceId: string, spaceData: any) => Promise<{
    success: boolean;
    data?: any;
    error?: string;
  }>;

  /**
   * Update a space's model and provider
   */
  [SpaceEvents.UPDATE_MODEL]?: (spaceId: string, model: string, provider: string) => Promise<{
    success: boolean;
    error?: string;
  }>;

  /**
   * Set the active space
   */
  [SpaceEvents.SET_ACTIVE]?: (spaceId: string) => Promise<{
    success: boolean;
    data?: any;
    error?: string;
  }>;

  /**
   * Sync application state changes to other windows
   */
  [AppStateEvents.SYNC_STATE]?: (newState: any) => void;

  /**
   * Listen for initialization of app state
   */
  [AppStateEvents.GET_STATE]?: (callback: (event: any, state: any) => void) => () => void;

  /**
   * Listen for app data updates
   */
  [AppStateEvents.STATE_UPDATED]?: (callback: (event: Electron.IpcRendererEvent, update: {
    success: boolean;
    data?: AppState;
    error?: string;
  }) => void) => () => void;
  /**
   * Open a specific command type
   */
  [CommandCenterEvents.OPEN]?: (commandType: string) => void;

  /**
   * Close the command center window
   */
  [CommandCenterEvents.CLOSE]?: () => void;

  /**
   * Refresh command center data
   */
  [CommandCenterEvents.REFRESH]?: () => void;

  /**
   * Register listener for command center toggle events
   */
  [CommandCenterEvents.TOGGLE]?: (callback: () => void) => () => void;

  /**
   * Register listener for refreshing command center
   */
  [CommandCenterEvents.REFRESH]?: (callback: () => void) => () => void;

  /**
   * Register listener for synced command center state across all windows
   */
  [CommandCenterEvents.SYNC_STATE]?: (callback: (event: any, action: string, data?: any) => void) => () => void;

  /**
   * Open a dialog with a specific type and data
   */
  /**
   * Open a dialog with a specific type and data
   */
  [CommandCenterEvents.OPEN_DIALOG]?: (dialogType: string, data: any) => void;

  /**
   * Notify the main process that a dialog has opened
   */
  [CommandCenterEvents.DIALOG_OPENED]?: () => void;

  /**
   * Notify the main process that a dialog has closed
   */
  [CommandCenterEvents.DIALOG_CLOSED]?: () => void;

  /**
   * Register listener for opening dialogs
   */
  [CommandCenterEvents.ON_DIALOG_OPEN]?: (callback: (event: any, dialogType: string, data: any) => void) => () => void;

  /**
   * Check if a command type is active
   */
  [CommandCenterEvents.CHECK_TYPE]?: (commandType: string) => void;

  /**
   * Register listener for checking command type
   */
  [CommandCenterEvents.ON_CHECK_TYPE]?: (callback: (event: any, commandType: string) => void) => () => void;

  /**
   * Window resize listener
   */
  [CommandCenterEvents.ON_RESIZE]?: (callback: (event: any, dimensions: { width: number; height: number }) => void) => () => void;

  /**
   * Remove window resize listener
   */
  [CommandCenterEvents.REMOVE_RESIZE_LISTENER]?: () => void;

  /**
   * Search for files based on a search term
   */
  [CommandCenterEvents.SEARCH_FILES]?: (searchTerm: string) => Promise<Array<{
    path: string;
    name: string;
    type: string;
    size?: number;
    modified?: number | string;
  }>>;

  /**
   * Read file content using IPC
   */
  [CommandCenterEvents.READ_FILE]?: (filePath: string) => Promise<{
    content: string;
    metadata?: any;
  }>;

  /**
   * Test function to check if Electron API is available
   */
  [CommandCenterEvents.PING]?: () => string;

  /**
   * Toggle command center visibility
   */
  [CommandCenterEvents.TOGGLE]?: () => void;

  /**
   * Register listener for setting command type
   */
  [CommandCenterEvents.ON_SET_TYPE]?: (callback: (event: any, commandType: string) => void) => () => void;
}

/**
 * Augment the global Window interface to include electronAPI and IPC events
 */
declare global {
  interface Window {
    electronAPI: ElectronAPI;
    
    /**
     * Application-specific global properties
     */
    __SPATIAL_APP_VERSION__: string;
    __SPATIAL_ENV__: 'development' | 'production' | 'test';
    __SPATIAL_PLATFORM__: 'darwin' | 'win32' | 'linux';
    
    /**
     * Zustand store access for internal use
     * This allows direct access to the store for special cases
     */
    electron: {
      invoke(channel: string, ...args: any[]): Promise<any>;
      on(channel: string, listener: (event: any, ...args: any[]) => void): void;
      off(channel: string, listener: Function): void;
    };
    
    /**
     * Direct access to the renderer store for reset operations
     */
    rendererStore?: {
      getState(): any;
      setState(state: any): void;
      setAppState(state: any): void;
      setSpaces(spaces: any[]): void;
      setActiveSpace(space: any): void;
      setConversations(conversations: any[]): void;
      setMessages(messages: any[]): void;
      setUser(user: any): void;
      setProfile(profile: any): void;
      setLoading(isLoading: boolean): void;
      setError(error: string | null): void;
      fetchAppState(): Promise<boolean>;
      syncWithMainProcess(): Promise<boolean>;
    };
    
    /**
     * IPC Event Handlers
     * These are injected by the preload script
     */
    ipcRenderer: {
      // Standard IPC methods
      invoke<T = any>(channel: string, ...args: any[]): Promise<T>;
      send(channel: string, ...args: any[]): void;
      on(channel: string, listener: (event: any, ...args: any[]) => void): void;
      once(channel: string, listener: (event: any, ...args: any[]) => void): void;
      removeListener(channel: string, listener: Function): void;
      removeAllListeners(channel: string): void;
      
      // Typed event handlers for our IPC events
      on(event: typeof AuthEvents[keyof typeof AuthEvents], listener: (event: any, ...args: any[]) => void): void;
      on(event: typeof AppStateEvents[keyof typeof AppStateEvents], listener: (event: any, state: AppState) => void): void;
      on(event: typeof CommandCenterEvents[keyof typeof CommandCenterEvents], listener: (event: any, ...args: any[]) => void): void;
      on(event: typeof SpaceEvents[keyof typeof SpaceEvents], listener: (event: any, ...args: any[]) => void): void;
      on(event: typeof MessageEvents[keyof typeof MessageEvents], listener: (event: any, ...args: any[]) => void): void;
      on(event: typeof NotificationEvents[keyof typeof NotificationEvents], listener: (event: any, ...args: any[]) => void): void;
      on(event: typeof ConversationEvents[keyof typeof ConversationEvents], listener: (event: any, ...args: any[]) => void): void;
    };
  }
}

// Initialize electronAPI
window.electronAPI = {} as ElectronAPI;

// Export types for use in other files
export type {
  ApiResponse,
  AuthTokenResponse,
  Space,
  Conversation,
  Message,
  CommandCenterState,
  ElectronAPI
};

export interface IpcResponse<T = any> {
  success: boolean;
  error?: string;
  data?: T;
}

export interface CommandCenterState {
  isOpen: boolean;
  activeCommand?: CommandType;
  dialogType?: string;
  dialogData?: any;
}

export interface ElectronAPI {
  [CommandCenterEvents.SYNC_STATE]: (callback: (event: any, response: IpcResponse<CommandCenterState>) => void) => () => void;
  toggleCommandCenter: (commandType?: CommandType) => Promise<IpcResponse>;
  openCommandType: (commandType: CommandType) => Promise<IpcResponse>;
  openDialog: (dialogType: string, data: any) => Promise<IpcResponse>;
  closeDialog: () => Promise<IpcResponse>;
  closeCommandCenter: (commandType?: CommandType) => Promise<IpcResponse>;
  refreshCommandCenter: (commandType?: CommandType) => Promise<IpcResponse>;
  checkCommandType: (commandType: CommandType) => Promise<IpcResponse>;
  searchFiles: (searchTerm: string) => Promise<any[]>;
  readFile: (filePath: string) => Promise<any>;
  ping: () => Promise<{ success: true; data: string }>;
}

declare global {
  interface Window {
    electronAPI?: ElectronAPI;
  }
}

================
File: src/types/ipc.ts
================
export interface IpcResponse<T = any> {
  success: boolean;
  status?: string;
  data?: T;
  error?: string;
}

export interface StateUpdate {
  type: string;
  payload: any;
}

export type AppStateResponse = IpcResponse;
export type CommandCenterResponse = IpcResponse;
export type UserResponse = IpcResponse;

================
File: src/types/message.ts
================
import { Provider } from "@/types/provider";
import { IpcResponse } from "@/types/ipc";

export interface Message {
  id: string;
  user_id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  annotations?: MessageAnnotation[];
  conversation_id: string;
  is_deleted: boolean;
  created_at: string;
  updated_at: string;
}

export interface MessageResponse extends IpcResponse {
  data?: Message | Message[] | { deleted: boolean };
}

export interface MessageAnnotation {
  provider: Provider;
  chat_mode: string;
  model_used: string;
  similarMessages?: SimilarMessage[];
  chat_mode_config?: {
    tools: string[];
    mcp_servers?: string[];
  };
}

export interface SimilarMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  score: number;
  conversationId?: string;
  metadata?: Record<string, any>;
}

export interface MessageSearchResult {
  id: string;
  conversation_id: string;
  content: string;
  role: string;
  created_at: string;
  ts_rank: number;
}

export interface CreateMessageRequest {
  content: string;
  role: 'user' | 'assistant' | 'system';
  conversation_id: string;
  annotations?: MessageAnnotation[];
}

export interface CreateMessageResponse {
  message: Message;
}

export interface GetMessagesResponse {
  messages: Message[];
}

export interface GetMessageResponse {
  message: Message;
}

export interface UpdateMessageRequest {
  content?: string;
  annotations?: MessageAnnotation[];
  is_deleted?: boolean;
}

export interface UpdateMessageResponse {
  message: Message;
}

export interface DeleteMessageResponse {
  success: boolean;
}

export interface SearchConversationMessagesRequest {
  conversation_id: string;
  query: string;
  limit?: number;
}

export interface SearchSpaceMessagesRequest {
  space_id: string;
  query: string;
  limit?: number;
}

export interface SearchAllUserMessagesRequest {
  query: string;
  limit?: number;
}

export interface SearchMessagesResponse {
  messages: MessageSearchResult[];
}

================
File: src/types/notification.ts
================
import { IpcResponse } from '@/types/ipc';

export type NotificationType =
  | 'space_created'
  | 'space_deleted'
  | 'model_changed'
  | 'conversation_created'
  | 'conversation_deleted';

export interface Notification {
  id: string;
  user_id: string;
  type: NotificationType;
  title: string;
  description: string;
  metadata: Record<string, any>;
  is_read: boolean;
  created_at: string;
  updated_at: string;
}

export interface NotificationResponse extends IpcResponse {
  data?: Notification | Notification[] | { deleted: boolean } | { updated: boolean };
}

export interface GetNotificationsResponse {
  notifications: Notification[];
}

export interface UpdateNotificationRequest {
  is_read?: boolean;
}

export interface UpdateNotificationResponse {
  notification: Notification;
}

================
File: src/types/provider.ts
================
export type Provider = 'groq' | 'anthropic' | 'openai' | 'cohere' | 'mistral' | 'google' | 'xai' | 'togetherai' | 'perplexity';

export type Model = {
  id: string;
  name: string;
  description?: string;
  contextWindow: number;
  provider?: Provider;
  multimodal?: boolean;
};

export type AvailableModel = Readonly<Model>;

export interface ModelsByProvider {
  [key: string]: ReadonlyArray<AvailableModel>;
}

export const PROVIDER_NAMES: Record<Provider, string> = {
  groq: 'Groq',
  anthropic: 'Anthropic',
  openai: 'OpenAI',
  cohere: 'Cohere',
  mistral: 'Mistral',
  google: 'Google',
  xai: 'xAI',
  togetherai: 'Together AI',
  perplexity: 'Perplexity'
};

export const PROVIDER_DESCRIPTIONS: Record<Provider, string> = {
  groq: 'Ultra-fast inference optimized for real-time applications',
  anthropic: 'Advanced language models with strong reasoning capabilities',
  openai: 'State-of-the-art models with broad capabilities',
  cohere: 'Specialized models for enterprise and business use cases',
  mistral: 'Open-source foundation models with various specializations',
  google: 'Cutting-edge multimodal models from Google DeepMind',
  xai: 'Advanced models focused on reasoning and transparency',
  togetherai: 'Curated collection of top open-source models',
  perplexity: 'Research-focused models optimized for reasoning tasks'
};

export const AVAILABLE_MODELS = {
  groq: [
    { id: 'deepseek-r1-distill-llama-70b', name: 'Deepseek R1 70B', description: 'Powerful general-purpose model with fast inference', contextWindow: 32768 },
    { id: 'mixtral-8x7b-instruct', name: 'Mixtral 8x7B', description: 'Efficient model balancing speed and capability', contextWindow: 32768 },
    { id: 'deepseek-r1-distill-llama-70b-specdec', name: 'Deepseek R1 70B SpecDec', description: 'Specialized for technical documentation', contextWindow: 32768 },
    { id: 'gemma2-9b-it', name: 'Gemma 2 9B', description: 'Compact model optimized for quick responses', contextWindow: 8192 },
    { id: 'llama-3.3-70b-versatile', name: 'LLaMA 3.3 70B Versatile', description: 'Latest LLaMA optimized for versatility', contextWindow: 128000 },
  ],
  anthropic: [
    { id: 'claude-3-opus-latest', name: 'Claude 3 Opus', description: 'Most capable model for complex tasks', contextWindow: 128000 },
    { id: 'claude-3-5-sonnet-latest', name: 'Claude 3.5 Sonnet', description: 'Balanced performance and speed', contextWindow: 128000 },
    { id: 'claude-3-5-haiku-latest', name: 'Claude 3.5 Haiku', description: 'Fast, efficient for simple tasks', contextWindow: 128000 },
  ],
  openai: [
    { id: 'gpt-4o', name: 'GPT-4o', description: 'Most powerful model for complex reasoning', contextWindow: 128000, multimodal: true },
    { id: 'gpt-4o-mini', name: 'GPT-4o Mini', description: 'Efficient version of GPT-4', contextWindow: 128000, multimodal: true },
    { id: 'o1', name: 'O1', description: 'Fast, general-purpose assistant', contextWindow: 128000 },
    { id: 'o3-mini', name: 'O3 Mini', description: 'Quick responses for simple tasks', contextWindow: 128000 },
  ],
  cohere: [
    { id: 'command', name: 'Command', description: 'Enterprise-grade general model', contextWindow: 128000 },
    { id: 'command-light', name: 'Command Light', description: 'Faster, lighter version of Command', contextWindow: 32768 },
    { id: 'command-nightly', name: 'Command Nightly', description: 'Latest experimental features', contextWindow: 128000 },
    { id: 'command-light-nightly', name: 'Command Light Nightly', description: 'Fast experimental version', contextWindow: 32768 }
  ],
  mistral: [
    { id: 'mistral-large-latest', name: 'Mistral Large', description: 'Most capable open model', contextWindow: 32000 },
    { id: 'codestral-latest', name: 'Codestral', description: 'Specialized for code generation', contextWindow: 32000 },
    { id: 'pixtral-large-latest', name: 'Pixtral Large', description: 'Vision and image understanding', contextWindow: 128000, multimodal: true },
    { id: 'ministral-3b-latest', name: 'Ministral 3B', description: 'Ultra-compact, fast responses', contextWindow: 4096 },
    { id: 'ministral-8b-latest', name: 'Ministral 8B', description: 'Balanced size and capability', contextWindow: 8192 },
    { id: 'mistral-small-latest', name: 'Mistral Small', description: 'Efficient for simple tasks', contextWindow: 4096 },
  ],
  google: [
    { id: 'gemini-2.0-flash-001', name: 'Gemini 2.0 Flash', description: 'Ultra-fast responses, latest version', contextWindow: 1000000, multimodal: true },
    { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro', description: 'Balanced performance model', contextWindow: 1000000, multimodal: true },
  ],
  xai: [
    { id: 'grok-2-1212', name: 'Grok 2', description: 'Advanced reasoning capabilities', contextWindow: 128000 },
    { id: 'grok-2-vision-1212', name: 'Grok 2 Vision', description: 'Multimodal understanding', contextWindow: 128000, multimodal: true },
  ],
  togetherai: [
    { id: 'deepseek-ai/DeepSeek-R1', name: 'DeepSeek R1', description: 'General purpose reasoning', contextWindow: 128000 },
    { id: 'deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free', name: 'DeepSeek R1 Distill Llama 70B', description: 'Efficient large model', contextWindow: 32768 },
    { id: 'deepseek-ai/DeepSeek-V3', name: 'DeepSeek V3', description: 'Latest architecture improvements', contextWindow: 128000 },
    { id: 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free', name: 'Llama 3.3 70B Instruct Turbo', description: 'Fast instruction following', contextWindow: 128000 },
    { id: 'meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo', name: 'Llama 3.1 405B Instruct Turbo', description: 'Massive model, best quality', contextWindow: 128000 },
  ],
  perplexity: [
    { id: 'sonar-reasoning-pro', name: 'Sonar Reasoning Pro', description: 'Advanced reasoning capabilities', contextWindow: 200000 },
    { id: 'sonar-reasoning', name: 'Sonar Reasoning', description: 'Efficient reasoning model', contextWindow: 200000 },
    { id: 'sonar-pro', name: 'Sonar Pro', description: 'Professional general use', contextWindow: 200000 },
    { id: 'sonar', name: 'Sonar', description: 'Fast, reliable model', contextWindow: 200000 }
  ]
} as const;

export type ProviderComponentProps = {
  searchQuery?: string;
  onSelect?: (item: any) => void;
  onAction?: (action: string, data: any) => void;
};

================
File: src/types/space.ts
================
import { Provider } from '@/types/provider';
import { IpcResponse } from '@/types/ipc';
import { Conversation } from './conversation';
import { Message } from './message';

export interface Space {
  id: string;
  user_id: string;
  name: string;
  description?: string;
  model: string;
  provider: Provider;
  chat_mode: string;
  chat_mode_config: Record<string, any>;
  is_archived: boolean;
  is_deleted: boolean;
  created_at: string;
  updated_at: string;
  color?: string;
  isActive?: boolean;
}

export interface SpaceResponse {
  success: boolean;
  error?: string;
  data?: {
    space: Space;
    conversations: Conversation[];
    messages: Message[];
  } | Space[];
}

export interface ActiveSpace {
  id: string;
  user_id: string;
  space_id: string;
  created_at: string;
  updated_at: string;
}

export type SpaceActionType = 
  | 'created'
  | 'deleted'
  | 'updated'
  | 'model_changed'
  | 'conversation_added'
  | 'conversation_deleted';

export interface SpaceHistory {
  id: string;
  space_id: string;
  user_id: string;
  action_type: SpaceActionType;
  title: string;
  description: string;
  metadata: Record<string, any>;
  created_at: string;
}

export interface SpaceUserRelation {
  id: string;
  space_id: string;
  user_id: string;
  role: 'owner' | 'editor' | 'viewer';
  created_at: string;
}

export interface CreateSpaceRequest {
  name: string;
  description?: string;
  model?: string;
  provider?: Provider;
  chat_mode?: string;
  chat_mode_config?: Record<string, any>;
}

export interface UpdateSpaceRequest {
  name?: string;
  description?: string;
  model?: string;
  provider?: Provider;
  is_archived?: boolean;
  chat_mode?: string;
  chat_mode_config?: Record<string, any>;
}

export interface CreateSpaceResponse {
  space: Space;
}

export interface UpdateSpaceResponse {
  space: Space;
}

export interface GetSpacesResponse {
  spaces: Space[];
}

export interface GetSpaceResponse {
  space: Space;
}

export interface DeleteSpaceResponse {
  success: boolean;
}

export interface GetSpaceHistoryResponse {
  history: SpaceHistory[];
}

================
File: src/types/user.ts
================
export interface User {
  id: string;
  email: string;
  user_metadata?: {
    full_name?: string;
    avatar_url?: string;
  };
  created_at: string;
}

================
File: src/types/utils.ts
================
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };
export type Nullable<T> = T | null;
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

================
File: src/utils/auth.ts
================
import { AuthenticationError } from '@/errors';
import { AuthSession } from '@/types/auth';

export function extractAuthToken(request: Request): string {
  const authHeader = request.headers.get('authorization');
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    throw new AuthenticationError('Missing or invalid Authorization header');
  }
  
  const token = authHeader.split(' ')[1];
  
  if (!token) {
    throw new AuthenticationError('Missing token in Authorization header');
  }
  
  return token;
}

export function parseJwt<T extends object = any>(token: string): T {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) {
      throw new Error('Invalid JWT format');
    }
    
    const base64Url = parts[1];
    if (!base64Url) {
      throw new Error('Invalid JWT payload');
    }
    
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  } catch (error) {
    throw new AuthenticationError('Invalid token format');
  }
}

export function isSessionExpired(session: AuthSession): boolean {
  return Date.now() / 1000 > session.expiresAt - 60;
}

================
File: src/utils/index.ts
================
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export * from './responseHelper';
export * from './validation';
export * from './auth';
export * from './logger';

================
File: src/utils/logger.ts
================
export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error',
}

export interface LogContext {
  [key: string]: any;
}

export class Logger {
  private context: string;
  private minLogLevel: LogLevel;

  constructor(context: string, minLogLevel: LogLevel = LogLevel.INFO) {
    this.context = context;
    this.minLogLevel = minLogLevel;
  }

  public setMinLogLevel(level: LogLevel): void {
    this.minLogLevel = level;
  }

  public debug(message: string, context?: LogContext): void {
    this.log(LogLevel.DEBUG, message, context);
  }

  public info(message: string, context?: LogContext): void {
    this.log(LogLevel.INFO, message, context);
  }

  public warn(message: string, context?: LogContext): void {
    this.log(LogLevel.WARN, message, context);
  }

  public error(message: string, context?: LogContext): void {
    this.log(LogLevel.ERROR, message, context);
  }

  private log(level: LogLevel, message: string, context?: LogContext): void {
    if (!this.shouldLog(level)) {
      return;
    }

    const timestamp = new Date().toISOString();
    const formattedMessage = `[${timestamp}] [${level.toUpperCase()}] [${this.context}] ${message}`;
    
    const logData = {
      timestamp,
      level,
      context: this.context,
      message,
      ...(context || {}),
    };

    switch (level) {
      case LogLevel.DEBUG:
        console.debug(formattedMessage, context ? context : '');
        break;
      case LogLevel.INFO:
        console.info(formattedMessage, context ? context : '');
        break;
      case LogLevel.WARN:
        console.warn(formattedMessage, context ? context : '');
        break;
      case LogLevel.ERROR:
        console.error(formattedMessage, context ? context : '');
        break;
    }
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = Object.values(LogLevel);
    const minLevelIndex = levels.indexOf(this.minLogLevel);
    const currentLevelIndex = levels.indexOf(level);
    
    return currentLevelIndex >= minLevelIndex;
  }
}

================
File: src/utils/model-utils.ts
================
import { AVAILABLE_MODELS, Provider } from "@/types/provider";

export interface ModelDisplayInfo {
  displayName: string;
  provider: Provider;
  description?: string;
  contextWindow?: number;
  multimodal?: boolean;
}

export function getModelDisplayInfo(modelId: string): ModelDisplayInfo | null {
  for (const [provider, models] of Object.entries(AVAILABLE_MODELS)) {
    const model = models.find(m => m.id === modelId);
    if (model) {
      return {
        displayName: model.name,
        provider: provider as Provider,
        description: model.description,
        contextWindow: model.contextWindow,
        multimodal: model.multimodal
      };
    }
  }
  return null;
}

export function getFormattedModelLabel(modelId: string | undefined | null): string {
  if (!modelId) return 'Select Model';
  const modelInfo = getModelDisplayInfo(modelId);
  return modelInfo ? modelInfo.displayName : 'Select Model';
}

================
File: src/utils/responseHelper.ts
================
import { ApiErrorResponse, ApiSuccessResponse, ToastConfig } from '@/types/api';
import { BaseError } from '@/errors';

export class ResponseHelper {
  public success<T = any>(options: {
    data: T;
    toast?: ToastConfig;
    headers?: Record<string, string>;
    status?: number;
  }): Response {
    const { data, toast, headers = {}, status = 200 } = options;
    
    const responseBody: ApiSuccessResponse<T> = {
      data,
      ...(toast && { toast }),
    };

    return new Response(JSON.stringify(responseBody), {
      status,
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
    });
  }

  public error(
    errorOrMessage: string | Error | BaseError,
    statusCode: number = 500,
    toastConfig?: Omit<ToastConfig, 'variant'>
  ): Response {
    let message: string;
    let code: number = statusCode;
    let details: Record<string, any> | undefined;

    if (typeof errorOrMessage === 'string') {
      message = errorOrMessage;
    } else if (errorOrMessage instanceof BaseError) {
      message = errorOrMessage.message;
      code = errorOrMessage.statusCode;
      details = errorOrMessage.details;
    } else {
      message = errorOrMessage.message || 'An unexpected error occurred';
    }

    const toast: ToastConfig | undefined = toastConfig 
      ? { ...toastConfig, variant: 'error' }
      : {
          title: 'Error',
          description: message,
          variant: 'error',
        };

    const responseBody: ApiErrorResponse = {
      error: {
        message,
        code,
        ...(details && { details }),
      },
      toast,
    };

    return new Response(JSON.stringify(responseBody), {
      status: code,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  }
}

================
File: src/utils/validation.ts
================
import { z } from 'zod';
import { ValidationError } from '@/errors';

export function validateData<T>(
  data: unknown, 
  schema: z.ZodType<T>
): T {
  try {
    return schema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const formattedErrors = error.errors.reduce((acc: Record<string, string>, curr: z.ZodIssue) => {
        const key = curr.path.join('.');
        acc[key] = curr.message;
        return acc;
      }, {});
      
      throw new ValidationError('Validation failed', formattedErrors);
    }
    throw new ValidationError('Invalid data format');
  }
}

export async function validateRequest<T>(
  request: Request, 
  schema: z.ZodType<T>
): Promise<T> {
  let data: unknown;
  
  try {
    data = await request.json();
  } catch (error) {
    throw new ValidationError('Invalid JSON');
  }
  
  return validateData(data, schema);
}

export function validateQueryParams<T>(
  params: URLSearchParams, 
  schema: z.ZodType<T>
): T {
  const queryObject = Object.fromEntries(params.entries());
  return validateData(queryObject, schema);
}

================
File: src/App.tsx
================
import { HashRouter, Routes, Route } from 'react-router-dom';
import SignIn from '@/pages/SignIn';
import ForgotPassword from '@/pages/ForgotPassword';
import Protected from '@/pages/Protected';
import Profile from '@/pages/Profile';
import ResetPassword from '@/pages/ResetPassword';
import CommandCenter from '@/pages/CommandCenter';
import AuthLayout from '@/layouts/AuthLayout';
import ProtectedLayout from '@/layouts/ProtectedLayout';
import { Toaster } from '@/components/ui/toaster';

function App() {
  return (
    <HashRouter>
      <Toaster />
      <Routes>
        <Route element={<AuthLayout />}>
          <Route path="/sign-in" element={<SignIn />} />
          <Route path="/forgot-password" element={<ForgotPassword />} />
        </Route>
        <Route path="/" element={<SignIn />} /> {/* Default route */}
        <Route element={<ProtectedLayout />}>
          <Route path="/protected" element={<Protected />} />
          <Route path="/protected/profile" element={<Profile />} />
          <Route path="/protected/reset-password" element={<ResetPassword />} />
        </Route>
        <Route path="/command-center">
          <Route path="unified" element={<CommandCenter />} />
          <Route path=":type" element={<CommandCenter />} />
        </Route>
      </Routes>
    </HashRouter>
  );
}

export default App;

================
File: src/main.tsx
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from '@/App';
import '@/styles/globals.css';
import ErrorBoundary from '@/components/ErrorBoundary';

const FallbackUI = () => (
  <div style={{ 
    padding: '2rem', 
    maxWidth: '800px', 
    margin: '0 auto', 
    textAlign: 'center',
    fontFamily: 'system-ui, -apple-system, sans-serif'
  }}>
    <h1>Vinci Application</h1>
    <p style={{ color: '#777' }}>Loading application...</p>
  </div>
);

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ErrorBoundary fallback={<FallbackUI />}>
      <App />
    </ErrorBoundary>
  </React.StrictMode>
);

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.aider*

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: electron.vite.config.ts
================
import { defineConfig } from 'electron-vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  main: {
    build: {
      outDir: 'out/main',
      rollupOptions: {
        input: {
          index: path.resolve(__dirname, 'electron/main.ts'),
        },
        output: {
          entryFileNames: '[name].js',
        },
      },
    },
    resolve: {
      alias: [
        {
          find: '@',
          replacement: path.resolve(__dirname, 'src')
        },
        // Add a specific alias for store to make it work in the Electron main process
        {
          find: /^@\/store(\/.*)?$/,
          replacement: path.resolve(__dirname, 'src/store$1')
        },
        {
          find: /^@\/lib(\/.*)?$/,
          replacement: path.resolve(__dirname, 'src/lib$1')
        },
        {
          find: /^@\/core(\/.*)?$/,
          replacement: path.resolve(__dirname, 'src/core$1')
        },
        {
          find: /^@\/services(\/.*)?$/,
          replacement: path.resolve(__dirname, 'src/services$1')
        }
      ]
    },
  },
  preload: {
    build: {
      outDir: 'out/preload',
      rollupOptions: {
        input: {
          index: path.resolve(__dirname, 'electron/preload.ts'),
        },
        output: {
          entryFileNames: '[name].js',
        },
      },
    },
    resolve: {
      alias: [
        {
          find: '@',
          replacement: path.resolve(__dirname, 'src')
        },
        // Add specific aliases for preload
        {
          find: /^@\/store(\/.*)?$/,
          replacement: path.resolve(__dirname, 'src/store$1')
        },
        {
          find: /^@\/lib(\/.*)?$/,
          replacement: path.resolve(__dirname, 'src/lib$1')
        },
        {
          find: /^@\/core(\/.*)?$/,
          replacement: path.resolve(__dirname, 'src/core$1')
        },
        {
          find: /^@\/services(\/.*)?$/,
          replacement: path.resolve(__dirname, 'src/services$1')
        }
      ]
    },
  },
  renderer: {
    root: __dirname,
    build: {
      outDir: 'out/renderer',
      rollupOptions: {
        input: path.resolve(__dirname, 'index.html'),
        external: [
          'electron',
          '@electron/remote'
        ]
      },
    },
    plugins: [react()],
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src')
      },
    },
    server: {
      port: 5173,
    },
    optimizeDeps: {
      include: [
        'react',
        'react-dom',
        'react-router-dom',
        'zustand'
      ],
    },
  },
});

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vinci App</title>
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>

================
File: package.json
================
{
  "name": "vinci",
  "version": "0.0.1",
  "private": true,
  "main": "out/main/index.js",
  "scripts": {
    "dev": "electron-vite dev",
    "build": "electron-vite build",
    "preview": "electron-vite preview",
    "start": "electron ./out/main/index.js",
    "package": "electron-forge package",
    "make": "electron-forge make",
    "publish": "electron-forge publish"
  },
  "dependencies": {
    "@agentic/ai-sdk": "^7.3.1",
    "@ai-sdk/anthropic": "^1.1.6",
    "@ai-sdk/cerebras": "^0.1.8",
    "@ai-sdk/cohere": "^1.1.7",
    "@ai-sdk/deepseek": "^0.1.8",
    "@ai-sdk/fireworks": "^0.1.8",
    "@ai-sdk/google": "^1.1.10",
    "@ai-sdk/groq": "^1.1.7",
    "@ai-sdk/mistral": "^1.1.6",
    "@ai-sdk/openai": "^1.1.9",
    "@ai-sdk/perplexity": "^0.0.7",
    "@ai-sdk/togetherai": "^0.1.9",
    "@ai-sdk/xai": "^1.1.8",
    "@electron-toolkit/utils": "^3.0.0",
    "@icons-pack/react-simple-icons": "^12.0.0",
    "@langchain/openai": "^0.4.4",
    "@lobehub/icons": "^1.68.0",
    "@openrouter/ai-sdk-provider": "^0.2.0",
    "@pinecone-database/pinecone": "^5.0.0",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-progress": "^1.0.3",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@supabase/supabase-js": "latest",
    "@types/highlight.js": "^10.1.0",
    "@types/markdown-it": "^14.1.2",
    "@types/marked": "^6.0.0",
    "@types/node-fetch": "^2.6.12",
    "@types/prismjs": "^1.26.5",
    "@upstash/qstash": "^2.7.22",
    "@upstash/redis": "^1.34.4",
    "ai": "^4.1.34",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.4",
    "date-fns": "^4.1.0",
    "developer-icons": "^5.2.9",
    "electron-redux": "^2.0.0",
    "electron-squirrel-startup": "^1.0.1",
    "emoji-picker-react": "^4.12.0",
    "framer-motion": "^12.0.6",
    "get-port-please": "^3.1.2",
    "highlight.js": "^11.11.1",
    "isomorphic-dompurify": "^2.21.0",
    "latest": "^0.2.0",
    "lodash": "^4.17.21",
    "lucide-react": "^0.468.0",
    "markdown-it": "^14.1.0",
    "markdown-it-jsx": "^1.1.0",
    "marked": "^15.0.7",
    "marked-base-url": "^1.1.6",
    "marked-gfm-heading-id": "^4.1.1",
    "marked-highlight": "^2.2.1",
    "marked-mangle": "^1.1.10",
    "next-themes": "^0.4.3",
    "node-fetch": "^3.3.2",
    "prettier": "^3.3.3",
    "prismjs": "^1.29.0",
    "rate-limiter-flexible": "^6.0.0",
    "react": "19.0.0",
    "react-colorful": "^5.6.1",
    "react-dom": "19.0.0",
    "react-hotkeys-hook": "^4.6.1",
    "react-icons": "^5.5.0",
    "react-intersection-observer": "^9.15.1",
    "react-markdown": "^9.1.0",
    "react-router-dom": "^7.3.0",
    "react-syntax-highlighter": "^15.6.1",
    "react-textarea-autosize": "^8.5.7",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.1",
    "shiki": "^2.5.0",
    "sonner": "^2.0.1",
    "use-stick-to-bottom": "^1.0.46",
    "zod": "^3.24.1",
    "zod-to-json-schema": "^3.24.1",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@electron-forge/cli": "^7.7.0",
    "@electron-forge/maker-deb": "^7.7.0",
    "@electron-forge/maker-squirrel": "^7.7.0",
    "@electron-forge/maker-zip": "^7.7.0",
    "@swc/core": "^1.10.12",
    "@swc/helpers": "^0.5.15",
    "@tailwindcss/postcss": "^4.0.12",
    "@types/lodash": "^4.17.15",
    "@types/node": "22.10.2",
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4",
    "@types/react-syntax-highlighter": "^15.5.13",
    "@vitejs/plugin-react": "^4.3.4",
    "cross-env": "^7.0.3",
    "electron": "^34.0.2",
    "electron-vite": "^3.0.0",
    "nodemon": "^3.1.9",
    "npm-run-all": "^4.1.5",
    "postcss": "8.4.49",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "^4.0.12",
    "tailwindcss-animate": "^1.0.7",
    "tsconfig-paths": "^4.2.0",
    "tsup": "^8.3.6",
    "typescript": "5.7.2",
    "vite": "^6.2.2"
  },
  "overrides": {
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4"
  },
  "build": {
    "appId": "com.vinci.app",
    "asar": true,
    "files": [
      "**/*"
    ],
    "mac": {
      "entitlements": "entitlements.plist",
      "entitlementsInherit": "entitlements.plist"
    }
  },
  "config": {
    "forge": {
      "packagerConfig": {},
      "makers": [
        {
          "name": "@electron-forge/maker-squirrel",
          "config": {
            "name": "electron_quick_start"
          }
        },
        {
          "name": "@electron-forge/maker-zip",
          "platforms": [
            "darwin"
          ]
        },
        {
          "name": "@electron-forge/maker-deb",
          "config": {}
        },
        {
          "name": "@electron-forge/maker-rpm",
          "config": {}
        }
      ]
    }
  }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};

================
File: README.md
================
<a href="https://demo-nextjs-with-supabase.vercel.app/">
  <img alt="Next.js and Supabase Starter Kit - the fastest way to build apps with Next.js and Supabase" src="https://demo-nextjs-with-supabase.vercel.app/opengraph-image.png">
  <h1 align="center">Next.js and Supabase Starter Kit</h1>
</a>

<p align="center">
 The fastest way to build apps with Next.js and Supabase
</p>

<p align="center">
  <a href="#features"><strong>Features</strong></a> ·
  <a href="#demo"><strong>Demo</strong></a> ·
  <a href="#deploy-to-vercel"><strong>Deploy to Vercel</strong></a> ·
  <a href="#clone-and-run-locally"><strong>Clone and run locally</strong></a> ·
  <a href="#feedback-and-issues"><strong>Feedback and issues</strong></a>
  <a href="#more-supabase-examples"><strong>More Examples</strong></a>
</p>
<br/>

## Features

- Works across the entire [Next.js](https://nextjs.org) stack
  - App Router
  - Pages Router
  - Middleware
  - Client
  - Server
  - It just works!
- supabase-ssr. A package to configure Supabase Auth to use cookies
- Styling with [Tailwind CSS](https://tailwindcss.com)
- Components with [shadcn/ui](https://ui.shadcn.com/)
- Optional deployment with [Supabase Vercel Integration and Vercel deploy](#deploy-your-own)
  - Environment variables automatically assigned to Vercel project

## Demo

You can view a fully working demo at [demo-nextjs-with-supabase.vercel.app](https://demo-nextjs-with-supabase.vercel.app/).

## Deploy to Vercel

Vercel deployment will guide you through creating a Supabase account and project.

After installation of the Supabase integration, all relevant environment variables will be assigned to the project so the deployment is fully functioning.

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&project-name=nextjs-with-supabase&repository-name=nextjs-with-supabase&demo-title=nextjs-with-supabase&demo-description=This+starter+configures+Supabase+Auth+to+use+cookies%2C+making+the+user%27s+session+available+throughout+the+entire+Next.js+app+-+Client+Components%2C+Server+Components%2C+Route+Handlers%2C+Server+Actions+and+Middleware.&demo-url=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2F&external-id=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&demo-image=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2Fopengraph-image.png)

The above will also clone the Starter kit to your GitHub, you can clone that locally and develop locally.

If you wish to just develop locally and not deploy to Vercel, [follow the steps below](#clone-and-run-locally).

## Clone and run locally

1. You'll first need a Supabase project which can be made [via the Supabase dashboard](https://database.new)

2. Create a Next.js app using the Supabase Starter template npx command

   ```bash
   npx create-next-app --example with-supabase with-supabase-app
   ```

   ```bash
   yarn create next-app --example with-supabase with-supabase-app
   ```

   ```bash
   pnpm create next-app --example with-supabase with-supabase-app
   ```

3. Use `cd` to change into the app's directory

   ```bash
   cd with-supabase-app
   ```

4. Rename `.env.example` to `.env.local` and update the following:

   ```
   NEXT_PUBLIC_SUPABASE_URL=[INSERT SUPABASE PROJECT URL]
   NEXT_PUBLIC_SUPABASE_ANON_KEY=[INSERT SUPABASE PROJECT API ANON KEY]
   ```

   Both `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` can be found in [your Supabase project's API settings](https://app.supabase.com/project/_/settings/api)

5. You can now run the Next.js local development server:

   ```bash
   npm run dev
   ```

   The starter kit should now be running on [localhost:3000](http://localhost:3000/).

6. This template comes with the default shadcn/ui style initialized. If you instead want other ui.shadcn styles, delete `components.json` and [re-install shadcn/ui](https://ui.shadcn.com/docs/installation/next)

> Check out [the docs for Local Development](https://supabase.com/docs/guides/getting-started/local-development) to also run Supabase locally.

## Feedback and issues

Please file feedback and issues over on the [Supabase GitHub org](https://github.com/supabase/supabase/issues/new/choose).

## More Supabase examples

- [Next.js Subscription Payments Starter](https://github.com/vercel/nextjs-subscription-payments)
- [Cookie-based Auth and the Next.js 13 App Router (free course)](https://youtube.com/playlist?list=PL5S4mPUpp4OtMhpnp93EFSo42iQ40XjbF)
- [Supabase Auth and the Next.js App Router](https://github.com/supabase/supabase/tree/master/examples/auth/nextjs)
# spatial-application

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "paths": {
      "@/*": ["./src/*"],
      "@components/*": ["./src/components/*"],
      "@services/*": ["./src/services/*"],
      "@core/*": ["./src/core/*"],
      "@types/*": ["./src/types/*"],
      "@utils/*": ["./src/utils/*"],
      "@store/*": ["./src/store/*"],
      "@electron/*": ["./electron/*"]
    }
  },
  "include": ["electron/**/*", "types/**/*.d.ts", "**/*.ts", "**/*.tsx", "src/**/*"],
  "exclude": ["node_modules"]
}



================================================================
End of Codebase
================================================================
