This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-06T21:11:51.170Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    project.mdc
app/
  (auth-pages)/
    forgot-password/
      page.tsx
    sign-in/
      page.tsx
    sign-up/
      page.tsx
    layout.tsx
    smtp-message.tsx
  actions/
    utils/
      caching.ts
      responses.ts
    auth.ts
    conversations.ts
    history.ts
    index.ts
    notifications.ts
    spaces.ts
  api/
    auth/
      callback/
        route.ts
    chat/
      route.ts
  lib/
    cache-utils.ts
    cache.ts
  protected/
    profile/
      page.tsx
    reset-password/
      page.tsx
    settings/
      page.tsx
    spaces/
      [spaceId]/
        conversations/
          [conversationId]/
            page.tsx
          page.tsx
      page.tsx
    layout.tsx
    page.tsx
  actions.ts
  globals.css
  layout.tsx
  page.tsx
components/
  ui/
    auth/
      form-message.tsx
      header-auth.tsx
      submit-button.tsx
      user-profile-dropdown.tsx
    chat/
      chat-content-client.tsx
      chat-message.tsx
      chat-messages-skeleton.tsx
      chat-messages.tsx
      chat-mode-tab.tsx
      content-tag.tsx
      loading-message.tsx
      markdown.tsx
      mention-menu.tsx
      model-tab.tsx
      provider-icon.tsx
      rich-input.css
      stream-status.tsx
      unified-input.tsx
    common/
      avatar.tsx
      badge.tsx
      base-tab.tsx
      button.tsx
      card.tsx
      checkbox.tsx
      code-block.tsx
      command-badge.tsx
      dialog.tsx
      dropdown-menu.tsx
      input.tsx
      label.tsx
      scroll-area.tsx
      select.tsx
      switch.tsx
      textarea.tsx
      theme-switcher.tsx
      toast.tsx
      toaster.tsx
      tooltip.tsx
    conversation/
      conversation-sphere.tsx
      conversation-tab.tsx
      create-conversation-button.tsx
    space/
      create-space-button.tsx
      planet-icon.tsx
      space-tab.tsx
    chat-container.tsx
    command.tsx
    dialog.tsx
    popover.tsx
    quick-actions-tab.tsx
    scroll-button.tsx
    tab-skeleton.tsx
    tabs.tsx
  AllCommandProviders.tsx
  CommandButton.tsx
  CommandCenter.tsx
  CommandProviders.tsx
  CommandRoot.tsx
  CommandShortcuts.tsx
  file-mention-input.tsx
  SimilarMessagesCommandProvider.tsx
config/
  chat-modes/
    index.ts
  models.ts
docs/
  COMMAND_SYSTEM.md
electron/
  main.ts
  preload.ts
  tsconfig.json
hooks/
  use-stick-to-bottom.ts
  use-toast.ts
  useCommandCenter.tsx
  useLoadingOperation.ts
  useMentionSystem.tsx
  useOperationToast.ts
  useRouteTransition.ts
lib/
  providers/
    file-system-provider.tsx
    message-provider.tsx
    provider-registry.tsx
  mention-utils.ts
  utils.ts
public/
  icons/
    providers/
      default.svg
      groq.svg
stores/
  space-store.ts
supabase/
  migrations/
    20250204124800_create_complete_schema.sql
    20250204124900_alter_space_table.sql
    20250204125000_create_active_space_table.sql
    20250204125100_update_rls_policies.sql
    20250221221400_add_active_conversations.sql
    20250223171800_add_notifications.sql
    20250223171900_add_realtime_notifications.sql
    20250223175200_add_space_history.sql
    20250223175201_migration_add_is_deleted_to_conversations.sql
    20250223175202_migration_add_performance_indexes.sql
    20250225012800_add_conversations_update_policy.sql
    20250302143641_add_full_text_search.sql
    20250303000000_update_search_functions.sql
    20250303000100_add_chat_mode_to_spaces.sql
  .gitignore
  config.toml
  repomix-output.txt
types/
  electron.d.ts
  index.ts
  mention.ts
utils/
  supabase/
    check-env-vars.ts
    client.ts
    middleware.ts
    server.ts
  file-sync.ts
  pinecone.ts
.gitignore
CLAUDE.md
components.json
constants.ts
middleware.ts
next.config.ts
nodemon.json
package.json
postcss.config.js
README.md
tailwind.config.ts
tsconfig.json
tsup.config.ts

================================================================
Files
================================================================

================
File: .cursor/rules/project.mdc
================
---
description: 
globs: 
alwaysApply: true
---
You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS, and modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You provide thoughtful, nuanced, and accurate answers, excelling at logical reasoning and best practices.

Strictly adhere to the user’s requirements, implementing all requested functionality completely.
Plan your solution step-by-step in detailed pseudocode before coding, ensuring clarity and structure.
Confirm the plan with the user, then proceed to write code.
Write clean, bug-free, fully functional code following the DRY (Don’t Repeat Yourself) principle, SOLID principles (e.g., Single Responsibility, Open/Closed), and the Code Implementation Guidelines below.
Prioritize readability, simplicity, and scalability—design solutions to be reusable and maintainable, avoiding hardcoding or repetition, as if supporting a million users or a million conditional cases.
Include all necessary imports and use descriptive, meaningful names for variables, constants, and components.
Leave no incomplete sections, placeholders, or TODOs—deliver fully verified, production-ready code.
If a solution isn’t feasible or you lack sufficient knowledge, clearly state so instead of guessing.
Coding Environment
You specialize in:

ReactJS
NextJS
JavaScript
TypeScript
TailwindCSS
HTML
CSS
Code Implementation Guidelines
Adhere to these best practices:

Use early returns to flatten logic and enhance readability.
Style with TailwindCSS classes exclusively; avoid raw CSS or <style> tags.
Prefer class: syntax over ternary operators in class attributes where applicable.
Use clear, descriptive names (e.g., handleClick for onClick, handleKeyDown for onKeyDown).
Ensure accessibility (a11y) with attributes like tabindex="0", aria-label, and event handlers (onClick, onKeyDown).
Favor const arrow functions (e.g., const toggle = () =>) over traditional function declarations, and define TypeScript types where applicable.
For scalability, favor data-driven approaches (e.g., arrays, maps, or configs) over repetitive conditionals or static code, ensuring easy extension and reuse.

================
File: app/(auth-pages)/forgot-password/page.tsx
================
import { forgotPasswordAction } from "@/app/actions/auth";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import Link from "next/link";
import { SmtpMessage } from "../smtp-message";

export default async function ForgotPassword(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  return (
    <>
      <form className="flex flex-col w-full">
        <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-6">
          <div className="flex flex-col gap-2 mb-8">
            <h1 className="text-2xl font-medium text-white/90">Reset Password</h1>
            <p className="text-sm text-white/60">
              Already have an account?{" "}
              <Link className="text-[#3ecfff]/80 hover:text-[#3ecfff] transition-colors" href="/sign-in">
                Sign in
              </Link>
            </p>
          </div>
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-2">
              <Label htmlFor="email" className="text-white/60">Email</Label>
              <Input 
                name="email" 
                placeholder="you@example.com" 
                required 
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <SubmitButton 
              formAction={forgotPasswordAction} 
              pendingText="Sending reset link..."
              variant="cyan"
            >
              Reset Password
            </SubmitButton>
            <FormMessage message={searchParams} />
          </div>
        </div>
      </form>
      <div className="mt-6">
        <SmtpMessage />
      </div>
    </>
  );
}

================
File: app/(auth-pages)/sign-in/page.tsx
================
import { signInAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import Link from "next/link";

export default async function Login(props: { searchParams: Promise<Message> }) {
  const searchParams = await props.searchParams;
  return (
    <form className="flex flex-col w-full">
      <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-6">
        <div className="flex flex-col gap-2 mb-8">
          <h1 className="text-2xl font-medium text-white/90">Sign in</h1>
          <p className="text-sm text-white/60">
            Don't have an account?{" "}
            <Link className="text-[#3ecfff]/80 hover:text-[#3ecfff] transition-colors" href="/sign-up">
              Sign up
            </Link>
          </p>
        </div>
        <div className="flex flex-col gap-4">
          <div className="flex flex-col gap-2">
            <Label htmlFor="email" className="text-white/60">Email</Label>
            <Input 
              name="email" 
              placeholder="you@example.com" 
              required 
              className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
            />
          </div>
          <div className="flex flex-col gap-2">
            <div className="flex justify-between items-center">
              <Label htmlFor="password" className="text-white/60">Password</Label>
              <Link
                className="text-xs text-[#3ecfff]/60 hover:text-[#3ecfff]/80 transition-colors"
                href="/forgot-password"
              >
                Forgot Password?
              </Link>
            </div>
            <Input
              type="password"
              name="password"
              placeholder="Your password"
              required
              className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
            />
          </div>
          <SubmitButton 
            pendingText="Signing In..." 
            formAction={signInAction}
            variant="cyan"
          >
            Sign in
          </SubmitButton>
          <FormMessage message={searchParams} />
        </div>
      </div>
    </form>
  );
}

================
File: app/(auth-pages)/sign-up/page.tsx
================
import { signUpAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import Link from "next/link";
import { SmtpMessage } from "../smtp-message";

export default async function Signup(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  if ("message" in searchParams) {
    return (
      <div className="w-full flex-1 flex items-center justify-center">
        <FormMessage message={searchParams} />
      </div>
    );
  }

  return (
    <>
      <form className="flex flex-col w-full">
        <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-6">
          <div className="flex flex-col gap-2 mb-8">
            <h1 className="text-2xl font-medium text-white/90">Sign up</h1>
            <p className="text-sm text-white/60">
              Already have an account?{" "}
              <Link className="text-[#3ecfff]/80 hover:text-[#3ecfff] transition-colors" href="/sign-in">
                Sign in
              </Link>
            </p>
          </div>
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-2">
              <Label htmlFor="email" className="text-white/60">Email</Label>
              <Input 
                name="email" 
                placeholder="you@example.com" 
                required 
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <div className="flex flex-col gap-2">
              <Label htmlFor="password" className="text-white/60">Password</Label>
              <Input
                type="password"
                name="password"
                placeholder="Your password"
                minLength={6}
                required
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <SubmitButton 
              formAction={signUpAction} 
              pendingText="Signing up..."
              variant="cyan"
            >
              Sign up
            </SubmitButton>
            <FormMessage message={searchParams} />
          </div>
        </div>
      </form>
      <div className="mt-6">
        <SmtpMessage />
      </div>
    </>
  );
}

================
File: app/(auth-pages)/layout.tsx
================
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-black text-white relative overflow-hidden">
      <div className="absolute top-0 left-0 w-full h-screen pointer-events-none">
        <div className="absolute top-0 left-[20%] w-[500px] h-[500px] bg-[#3ecfff]/[0.015] blur-[120px] rounded-full" />
        <div className="absolute top-[20%] right-[20%] w-[400px] h-[400px] bg-[#D4966A]/[0.015] blur-[100px] rounded-full" />
        <div className="absolute bottom-[10%] left-[30%] w-[600px] h-[600px] bg-[#3ecfff]/[0.01] blur-[130px] rounded-full" />
      </div>
      <div className="relative z-10 w-full max-w-md p-6">
        {children}
      </div>
    </div>
  );
}

================
File: app/(auth-pages)/smtp-message.tsx
================
import { ArrowUpRight, InfoIcon } from "lucide-react";
import Link from "next/link";

export function SmtpMessage() {
  return (
    <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-lg px-5 py-4 flex gap-4">
      <InfoIcon size={16} className="mt-0.5 text-white/60" />
      <div className="flex flex-col gap-1">
        <small className="text-sm text-white/60">
          <strong className="text-white/80">Note:</strong> Emails are rate limited. Enable Custom SMTP to
          increase the rate limit.
        </small>
        <div>
          <Link
            href="https://supabase.com/docs/guides/auth/auth-smtp"
            target="_blank"
            className="text-[#3ecfff]/60 hover:text-[#3ecfff]/80 transition-colors flex items-center text-sm gap-1"
          >
            Learn more <ArrowUpRight size={14} />
          </Link>
        </div>
      </div>
    </div>
  );
}

================
File: app/actions/utils/caching.ts
================
"use server";

import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";

/**
 * Invalidate cache for a specific key
 */
export async function invalidateCache(key: string): Promise<void> {
  await redis.del(key);
}

/**
 * Invalidate all cache keys related to a space
 */
export async function invalidateSpaceCache(spaceId: string, userId?: string): Promise<void> {
  await Promise.all([
    redis.del(CACHE_KEYS.SPACE(spaceId)),
    redis.del(CACHE_KEYS.SPACE_DATA(spaceId)),
    redis.del(CACHE_KEYS.SPACE_HISTORY(spaceId)),
    redis.del(CACHE_KEYS.CONVERSATIONS(spaceId)),
    userId ? redis.del(CACHE_KEYS.SPACES(userId)) : Promise.resolve(),
  ]);
}

/**
 * Invalidate all cache keys related to a conversation
 */
export async function invalidateConversationCache(conversationId: string, spaceId?: string): Promise<void> {
  await Promise.all([
    redis.del(CACHE_KEYS.MESSAGES(conversationId)),
    spaceId ? redis.del(CACHE_KEYS.CONVERSATIONS(spaceId)) : Promise.resolve(),
    spaceId ? redis.del(CACHE_KEYS.SPACE_DATA(spaceId)) : Promise.resolve(),
  ]);
}

/**
 * Get Redis client instance
 */
export async function getRedisClient(): Promise<Redis> {
  return redis;
}

/**
 * Get cache key for a resource
 */
export async function getCacheKey(
  type: keyof typeof CACHE_KEYS, 
  id: string
): Promise<string> {
  return CACHE_KEYS[type](id);
}

/**
 * Get cache TTL for a resource type
 */
export async function getCacheTTL(type: keyof typeof CACHE_TTL): Promise<number> {
  return CACHE_TTL[type];
}

================
File: app/actions/utils/responses.ts
================
"use server";

/**
 * Standardized response types for consistent error handling
 */
export interface ActionResponse<T> {
  status: 'success' | 'error';
  data?: T;
  error?: string;
  redirectTo?: string; // Add optional redirect URL
  toast?: {
    title: string;
    description: string;
    variant: 'default' | 'success' | 'destructive';
  };
}

/**
 * Create a successful response
 */
export async function successResponse<T>(data: T, toast?: ActionResponse<T>['toast'], redirectTo?: string): Promise<ActionResponse<T>> {
  return {
    status: 'success',
    data,
    toast,
    redirectTo
  };
}

/**
 * Create an error response
 */
export async function errorResponse<T>(error: string, toast?: ActionResponse<T>['toast']): Promise<ActionResponse<T>> {
  return {
    status: 'error',
    error,
    toast: toast || {
      title: 'Error',
      description: error,
      variant: 'destructive'
    }
  };
}

/**
 * Create a not found response
 */
export async function notFoundResponse<T>(resource = 'Resource'): Promise<ActionResponse<T>> {
  return await errorResponse<T>(`${resource} not found`, 404);
}

/**
 * Create an unauthorized response
 */
export async function unauthorizedResponse<T>(): Promise<ActionResponse<T>> {
  return await errorResponse<T>('Unauthorized', 401);
}

/**
 * Handle errors consistently across server actions
 */
export async function handleActionError<T>(error: any): Promise<ActionResponse<T>> {
  console.error('Server action error:', error);
  
  let errorMessage = 'An unexpected error occurred';
  
  if (error instanceof Error) {
    errorMessage = error.message;
  } else if (typeof error === 'string') {
    errorMessage = error;
  }
  
  return errorResponse(errorMessage, {
    title: 'Action Failed',
    description: errorMessage,
    variant: 'destructive'
  });
}

================
File: app/actions/auth.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { redis, CACHE_KEYS } from "@/app/lib/cache";
import { ActionResponse, successResponse, errorResponse, handleActionError } from "./utils/responses";

/**
 * Sign out the current user and clear all cache
 */
export async function signOutAction(): Promise<ActionResponse<{ success: boolean }>> {
  try {
    const supabase = await createClient();
    
    // Clear all redis cache for the user
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      await Promise.all([
        redis.del(CACHE_KEYS.SPACES(user.id)),
        redis.del(CACHE_KEYS.ACTIVE_SPACE(user.id)),
        redis.del(CACHE_KEYS.NOTIFICATIONS(user.id))
      ]);
    }

    // Sign out from Supabase
    await supabase.auth.signOut();

    return await successResponse({ success: true });
  } catch (error) {
    console.error('Error during sign out:', error);
    return await handleActionError(error);
  }
}

================
File: app/actions/conversations.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { COLUMNS, DB_TABLES, DEFAULTS } from "@/constants";
import { Conversation } from "@/types";
import { SpaceData } from "./spaces";
import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";
import { invalidateConversationCache } from "./utils/caching";
import { ActionResponse, successResponse, errorResponse, handleActionError, notFoundResponse } from "./utils/responses";

// Define the Message type here
export interface Message {
  id: string;
  conversation_id: string;
  content: string;
  role: 'user' | 'assistant' | 'system';
  created_at: string;
  updated_at: string;
  is_deleted: boolean;
  metadata?: Record<string, any>;
  annotations?: any[];
}

// Define an interface for the search results from the RPC functions
interface SearchResult {
    id: string;
    conversation_id: string;
    content: string;
    role: 'user' | 'assistant' | 'system';
    created_at: string;
    ts_rank: number;
}

/**
 * Get the most recently updated conversation for a space
 * @param spaceId - The ID of the space to search within
 * @returns The most recently updated conversation, or an error response
 */
export async function getMostRecentConversation(spaceId: string): Promise<ActionResponse<Conversation>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (!spaceId) {
            return errorResponse('Space ID is required');
        }

        const cacheKey = CACHE_KEYS.MOST_RECENT_CONVERSATION(spaceId);
        const cachedConversation = await redis.get<Conversation>(cacheKey);
        if (cachedConversation) {
            return successResponse(cachedConversation);
        }

        const { data, error } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("*")
            .eq(COLUMNS.SPACE_ID, spaceId)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.UPDATED_AT, { ascending: false })
            .limit(1)
            .single();

        if (error) {
            console.error("Error fetching most recent conversation:", error);
            if (error.code === 'PGRST116') { // No rows returned
                return notFoundResponse('Conversation');
            }
            return errorResponse(`Error fetching most recent conversation: ${error.message}`);
        }

        if (!data) {
            return notFoundResponse('Conversation');
        }

        // Cache the result
        await redis.set(cacheKey, data, { ex: CACHE_TTL.CONVERSATIONS });

        return successResponse(data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get all conversations for a space
 */
export async function getConversations(spaceId: string): Promise<ActionResponse<Conversation[]>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (!spaceId) {
            return successResponse([]);
        }

        const cacheKey = CACHE_KEYS.CONVERSATIONS(spaceId);
        const cachedConversations = await redis.get<Conversation[]>(cacheKey);
        if (cachedConversations) {
            return successResponse(cachedConversations);
        }

        const { data, error } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("*")
            .eq(COLUMNS.SPACE_ID, spaceId)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.UPDATED_AT, { ascending: false });

        if (error) {
            console.error("Error fetching conversations:", error);
            return errorResponse(`Error fetching conversations: ${error.message}`);
        }

        if (data) {
            await redis.set(cacheKey, data, { ex: CACHE_TTL.CONVERSATIONS });
        }

        return successResponse(data || []);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Create a new conversation
 */
export async function createConversation(spaceId: string, title?: string): Promise<ActionResponse<Conversation>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return await errorResponse('User not authenticated');
        }

        if (!spaceId) {
            return await errorResponse('Space ID is required');
        }

        const timestamp = new Date().toISOString();
        const { data, error } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .insert([{
                space_id: spaceId,
                title: title || DEFAULTS.CONVERSATION_TITLE,
                created_at: timestamp,
                updated_at: timestamp,
                is_deleted: false
            }])
            .select()
            .single();

        if (error) {
            console.error("Error creating conversation:", error);
            return await errorResponse(`Error creating conversation: ${error.message}`);
        }

        // Invalidate relevant caches
        await redis.del(CACHE_KEYS.SPACE_DATA(spaceId));
        await redis.del(CACHE_KEYS.CONVERSATIONS(spaceId));

        return await successResponse(data, {
            title: 'Conversation Created',
            description: 'Start chatting now!',
            variant: 'success'
        }, `/protected/spaces/${spaceId}/conversations/${data.id}`);
    } catch (error) {
        return await handleActionError(error);
    }
}

/**
 * Get a specific conversation by ID
 */
export async function getConversation(id: string): Promise<ActionResponse<Conversation>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        const { data, error } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("*")
            .eq(COLUMNS.ID, id)
            .eq(COLUMNS.IS_DELETED, false) // Don't return deleted conversations
            .single();

        if (error) {
            console.error("Error fetching conversation:", error);
            return notFoundResponse('Conversation');
        }

        return successResponse(data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get all messages for a conversation
 */
export async function getMessages(conversationId: string): Promise<ActionResponse<Message[]>> {
    try {
        console.log('[SERVER] Getting messages for conversation:', conversationId);
        const supabase = await createClient();
        
        // First check if the user has access to this conversation
        const { data: conversation, error: convError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select('id, space_id')
            .eq('id', conversationId)
            .eq('is_deleted', false)
            .single();
        
        if (convError || !conversation) {
            console.error('[SERVER] Error fetching conversation:', convError?.message || 'Conversation not found');
            return notFoundResponse('Conversation not found');
        }
        
        // Get messages - include annotations field to get model and provider info
        const { data, error } = await supabase
            .from(DB_TABLES.MESSAGES)
            .select(`
                id, 
                conversation_id, 
                content, 
                role, 
                created_at, 
                updated_at, 
                is_deleted,
                annotations
            `)
            .eq('conversation_id', conversationId)
            .eq('is_deleted', false)
            .order('created_at', { ascending: true });
        
        if (error) {
            console.error('[SERVER] Error fetching messages:', error.message);
            return errorResponse(error.message);
        }
        
        console.log('[SERVER] Successfully fetched messages:', data.length);
        return successResponse(data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Update the title of a conversation
 */
export async function updateConversationTitle(conversationId: string, title: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (!conversationId) {
            return errorResponse('Conversation ID is required');
        }

        if (!title) {
            return errorResponse('Title is required');
        }

        // Get the conversation to find its space_id
        const { data: conversation, error: getError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select('space_id')
            .eq(COLUMNS.ID, conversationId)
            .single();

        if (getError) {
            console.error("Error getting conversation:", getError);
            return notFoundResponse('Conversation');
        }

        // Update the conversation title in the database
        const { error: updateError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .update({ title })
            .eq(COLUMNS.ID, conversationId);

        if (updateError) {
            console.error("Error updating conversation title:", updateError);
            return errorResponse(`Error updating conversation title: ${updateError.message}`);
        }

        // Update all relevant caches
        try {
            // Update conversations cache
            const conversationsCacheKey = CACHE_KEYS.CONVERSATIONS(conversation.space_id);
            const cachedConversations = await redis.get<Conversation[]>(conversationsCacheKey);
            if (cachedConversations) {
                const updatedConversations = cachedConversations.map(conv =>
                    conv.id === conversationId ? { ...conv, title } : conv
                );
                await redis.set(conversationsCacheKey, updatedConversations, { ex: CACHE_TTL.CONVERSATIONS });
            }

            // Update space data cache
            const spaceDataCacheKey = CACHE_KEYS.SPACE_DATA(conversation.space_id);
            const cachedSpaceData = await redis.get<SpaceData>(spaceDataCacheKey);
            if (cachedSpaceData?.conversations) {
                const updatedSpaceData = {
                    ...cachedSpaceData,
                    conversations: cachedSpaceData.conversations.map(conv =>
                        conv.id === conversationId ? { ...conv, title } : conv
                    )
                };
                await redis.set(spaceDataCacheKey, updatedSpaceData, { ex: CACHE_TTL.SPACE_DATA });
            }
        } catch (error) {
            console.error("Error updating caches:", error);
            // Don't fail the operation because of cache issues
        }

        return successResponse(undefined);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Create a new message in a conversation
 */
export async function createMessage(messageData: Partial<Message>, conversationId: string): Promise<ActionResponse<Message>> {
    try {
        console.log('[SERVER] Creating message for conversation:', { conversationId, role: messageData.role });
        const supabase = await createClient();
        
        // Get the current user - needed for RLS
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
            console.error('[SERVER] Error: User not authenticated');
            return errorResponse('User not authenticated');
        }
        
        // Make sure we have the required fields
        if (!messageData.content || !messageData.role) {
            console.error('[SERVER] Missing required fields for message creation');
            return errorResponse('Missing required fields');
        }
        
        // First check if the user has access to this conversation
        const { data: conversation, error: convError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select('id, space_id')
            .eq('id', conversationId)
            .eq('is_deleted', false)
            .single();
        
        if (convError || !conversation) {
            console.error('[SERVER] Error accessing conversation:', convError?.message || 'Conversation not found');
            return errorResponse('Conversation not found or access denied');
        }
        
        // Create the message - include user_id for RLS and all other important fields
        const { data, error } = await supabase
            .from(DB_TABLES.MESSAGES)
            .insert({
                conversation_id: conversationId,
                content: messageData.content,
                role: messageData.role,
                user_id: user.id,
                annotations: messageData.annotations || []
            })
            .select()
            .single();
        
        if (error) {
            console.error('[SERVER] Error creating message:', error.message);
            return errorResponse(error.message);
        }
        
        // Invalidate cache for conversations
        await invalidateConversationCache(conversation.space_id, conversationId);
        
        console.log('[SERVER] Message successfully created:', { messageId: data.id });
        return successResponse(data);
    } catch (error) {
        console.error('[SERVER] Error in createMessage action:', error);
        return handleActionError(error);
    }
}

/**
 * Send a message and get AI response
 */
export async function sendMessage({ 
    content, 
    spaceId, 
    conversationId, 
    searchMode 
}: { 
    content: string, 
    spaceId: string, 
    conversationId: string, 
    searchMode: string 
}): Promise<ActionResponse<{ success: boolean }>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
            return errorResponse('User not authenticated');
        }
        
        if (!content || !conversationId) {
            return errorResponse('Content and conversation ID are required');
        }
        
        // Create only the user message - don't create a placeholder assistant message
        // The API chat route will handle creating the assistant message with AI
        const userMessageResponse = await createMessage({
            role: 'user',
            content,
        }, conversationId);
        
        if (!userMessageResponse.data) {
            return errorResponse('Failed to create user message');
        }
        
        // Return success - the API route will handle the AI response separately
        return successResponse({ success: true });
    } catch (error) {
        console.error('Error sending message:', error);
        return handleActionError(error);
    }
}

/**
 * Switch to a specific conversation
 */
export async function switchConversation(conversationId: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
            return errorResponse('User not authenticated');
        }
        
        if (!conversationId) {
            return errorResponse('Conversation ID is required');
        }
        
        // Get the conversation
        const conversationResponse = await getConversation(conversationId);
        
        if (!conversationResponse.data) {
            return notFoundResponse('Conversation');
        }
        
        return successResponse(undefined);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Delete a conversation (soft delete)
 */
export async function deleteConversation(conversationId: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        console.log(`Attempting to delete conversation with ID: ${conversationId} for user: ${user.id}`);

        // Step 1: Fetch conversation to verify it exists and get space_id
        const { data: conversation, error: fetchError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select(`${COLUMNS.ID}, ${COLUMNS.SPACE_ID}, ${COLUMNS.IS_DELETED}`)
            .eq(COLUMNS.ID, conversationId)
            .single();

        if (fetchError || !conversation) {
            console.error('Fetch error:', fetchError?.message || 'Conversation not found');
            return notFoundResponse('Conversation');
        }

        console.log(`Found conversation: ID=${conversation[COLUMNS.ID]}, space_id=${conversation[COLUMNS.SPACE_ID]}, is_deleted=${conversation[COLUMNS.IS_DELETED]}`);

        if (conversation[COLUMNS.IS_DELETED]) {
            console.log('Conversation is already deleted, no update needed');
            return successResponse(undefined);
        }

        // Step 2: Verify space ownership (redundant with RLS, but kept for safety)
        const spaceId = conversation[COLUMNS.SPACE_ID];
        const { data: space, error: spaceError } = await supabase
            .from(DB_TABLES.SPACES)
            .select('id')
            .eq(COLUMNS.ID, spaceId)
            .eq(COLUMNS.USER_ID, user.id)
            .single();

        if (spaceError || !space) {
            console.error('Space verification error:', spaceError?.message || 'Space not found or not owned by user');
            return errorResponse('Unauthorized: Space does not belong to user');
        }

        console.log(`Verified space ownership for space_id: ${spaceId}`);

        // Step 3: Perform the soft delete
        const { data: updateData, error: deleteError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .update({ 
                [COLUMNS.IS_DELETED]: true, 
                [COLUMNS.UPDATED_AT]: new Date().toISOString() 
            })
            .eq(COLUMNS.ID, conversationId)
            .select();

        if (deleteError) {
            console.error('Delete error:', deleteError.message);
            return errorResponse(`Failed to delete conversation: ${deleteError.message}`);
        }

        if (!updateData || updateData.length === 0) {
            console.error('No rows updated - RLS or data issue persists');
            return errorResponse('No rows updated');
        }

        console.log('Conversation successfully deleted:', updateData);

        // Step 4: Delete the messages from Pinecone as well
        try {
            // Import deleteMessagesByConversationId from the Pinecone utils
            const { deleteMessagesByConversationId } = await import('@/utils/pinecone');
            await deleteMessagesByConversationId(conversationId);
            console.log(`Successfully deleted messages from Pinecone for conversation: ${conversationId}`);
        } catch (pineconeError) {
            console.error('Error deleting messages from Pinecone:', pineconeError);
            // We don't want to fail the whole operation if Pinecone deletion fails
            // Just log the error and continue
        }

        await invalidateConversationCache(conversationId, spaceId);
        console.log('Cleared conversation caches');

        return successResponse(undefined);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Search for messages
 */
export async function searchMessages(
    searchTerm: string, 
    searchScope: string, 
    searchMode: string, 
    conversationId?: string, 
    spaceId?: string, 
    limit = 50
): Promise<ActionResponse<any>> {
    try {
        if (!searchTerm || searchTerm.length < 2) {
            return successResponse({ results: [] });
        }

        // Trim and sanitize search term
        const sanitizedSearchTerm = searchTerm.trim();
        
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (searchScope === 'conversation' && !conversationId) {
            return errorResponse("Conversation ID is required for conversation scope");
        }

        if (searchScope === 'space' && !spaceId) {
            return errorResponse("Space ID is required for space scope");
        }

        let searchResults: SearchResult[] = [];

        // Use the appropriate full-text search function based on search scope
        if (searchScope === 'conversation' && conversationId) {
            // Search within a specific conversation
            const { data, error } = await supabase
                .rpc('search_conversation_messages', { 
                    conversation_uuid: conversationId,
                    search_query: sanitizedSearchTerm,
                    result_limit: limit
                });
            
            if (error) {
                console.error('Error searching conversation messages:', error);
                return errorResponse(`Error searching messages: ${error.message}`);
            }
            
            searchResults = data as SearchResult[] || [];
        } 
        else if (searchScope === 'space' && spaceId) {
            // Search within a specific space
            const { data, error } = await supabase
                .rpc('search_space_messages', { 
                    space_uuid: spaceId,
                    search_query: sanitizedSearchTerm,
                    result_limit: limit
                });
            
            if (error) {
                console.error('Error searching space messages:', error);
                return errorResponse(`Error searching messages: ${error.message}`);
            }
            
            searchResults = data as SearchResult[] || [];
        } 
        else {
            // Search across all user spaces
            const { data, error } = await supabase
                .rpc('search_all_user_messages', { 
                    search_query: sanitizedSearchTerm,
                    result_limit: limit
                });
            
            if (error) {
                console.error('Error searching all messages:', error);
                return errorResponse(`Error searching messages: ${error.message}`);
            }
            
            searchResults = data as SearchResult[] || [];
        }

        // If we got this far but have no results, return empty array
        if (!searchResults || searchResults.length === 0) {
            return successResponse({ results: [] });
        }

        // Get conversation info for titles
        const conversationIds = Array.from(new Set(searchResults.map(result => result.conversation_id)));
        
        const { data: conversations, error: convError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select(`${COLUMNS.ID}, ${COLUMNS.TITLE}`)
            .in(COLUMNS.ID, conversationIds);
            
        if (convError) {
            console.error('Error fetching conversations:', convError);
            return errorResponse(`Error fetching conversation details: ${convError.message}`);
        }
        
        // Create a mapping of conversation ID to title
        const conversationTitleMap = new Map<string, string>();
        conversations?.forEach(conv => {
            conversationTitleMap.set(conv.id, conv.title || 'Untitled Conversation');
        });

        // Process the results to add conversation titles and format for UI consumption
        const processedResults = searchResults.map((result: SearchResult) => {
            return {
                id: result.id,
                content: result.content,
                role: result.role,
                conversation_id: result.conversation_id,
                created_at: result.created_at,
                conversationTitle: conversationTitleMap.get(result.conversation_id) || 'Untitled Conversation',
                searchRank: result.ts_rank
            };
        });

        return successResponse({ results: processedResults });
    } catch (error) {
        return handleActionError(error);
    }
}

================
File: app/actions/history.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";
import { ActionResponse, successResponse, errorResponse, handleActionError } from "./utils/responses";

export type SpaceActionType = 
  | 'space_created'
  | 'space_updated'
  | 'space_deleted'
  | 'conversation_created'
  | 'conversation_deleted'
  | 'model_changed'
  | 'message_sent'
  | 'message_deleted';

export interface SpaceHistoryEntry {
  id: string;
  space_id: string;
  user_id: string;
  action_type: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  created_at: string;
}

export interface CreateSpaceHistoryOptions {
  spaceId: string;
  actionType: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
}

/**
 * Create a new space history entry
 */
export async function createSpaceHistory({
  spaceId,
  actionType,
  title,
  description,
  metadata
}: CreateSpaceHistoryOptions): Promise<ActionResponse<SpaceHistoryEntry>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    const { data, error } = await supabase
      .from('space_history')
      .insert([{
        space_id: spaceId,
        user_id: user.id,
        action_type: actionType,
        title,
        description,
        metadata
      }])
      .select()
      .single();

    if (error) {
      console.error("Error creating space history entry:", error);
      return errorResponse(`Error creating space history entry: ${error.message}`);
    }

    // Update space history cache
    const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
    const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey) || [];
    await redis.set(cacheKey, [data, ...cachedHistory], { ex: CACHE_TTL.SPACE_HISTORY });

    return successResponse(data);
  } catch (error) {
    return handleActionError(error);
  }
}

/**
 * Get space history entries
 */
export async function getSpaceHistory(spaceId: string, limit = 50): Promise<ActionResponse<SpaceHistoryEntry[]>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
    const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey);
    if (cachedHistory) {
      return successResponse(cachedHistory);
    }

    const { data, error } = await supabase
      .from('space_history')
      .select("*")
      .eq("space_id", spaceId)
      .order("created_at", { ascending: false })
      .limit(limit);

    if (error) {
      console.error("Error fetching space history:", error);
      return errorResponse(`Error fetching space history: ${error.message}`);
    }

    // Cache the result
    if (data) {
      await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE_HISTORY });
    }

    return successResponse(data || []);
  } catch (error) {
    return handleActionError(error);
  }
}

================
File: app/actions/index.ts
================
"use server";

// Re-export all actions

// Space Actions
export * from './spaces';

// Conversation Actions
export * from './conversations';

// Notification Actions
export * from './notifications';

// History Actions
export * from './history';

// Auth Actions
export * from './auth';

// Export response utilities
export * from './utils/responses';

================
File: app/actions/notifications.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { COLUMNS, DB_TABLES } from "@/constants";
import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";
import { ActionResponse, successResponse, errorResponse, handleActionError } from "./utils/responses";

export type NotificationType = 
  | 'space_created'
  | 'space_deleted'
  | 'model_changed'
  | 'conversation_created'
  | 'conversation_deleted';

export interface Notification {
  id: string;
  user_id: string;
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  is_read: boolean;
  created_at: string;
  updated_at: string;
}

export interface CreateNotificationOptions {
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  isInApp?: boolean; // If true, notification will be marked as read automatically
}

/**
 * Create a new notification
 */
export async function createNotification({
  type,
  title,
  description,
  metadata,
  isInApp = true // Default to true for backward compatibility
}: CreateNotificationOptions): Promise<ActionResponse<Notification>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    const { data, error } = await supabase
      .from(DB_TABLES.NOTIFICATIONS)
      .insert([{
        user_id: user.id,
        type,
        title,
        description,
        metadata,
        is_read: isInApp, // Automatically mark as read if it's an in-app notification
      }])
      .select()
      .single();

    if (error) {
      console.error("Error creating notification:", error);
      return errorResponse(`Error creating notification: ${error.message}`);
    }

    // Update notifications cache
    const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
    const cachedNotifications = await redis.get<Notification[]>(cacheKey) || [];
    await redis.set(cacheKey, [data, ...cachedNotifications], { ex: CACHE_TTL.NOTIFICATIONS });

    return successResponse(data);
  } catch (error) {
    return handleActionError(error);
  }
}

/**
 * Get all notifications for the current user
 */
export async function getNotifications(limit = 50): Promise<ActionResponse<Notification[]>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
    const cachedNotifications = await redis.get<Notification[]>(cacheKey);
    if (cachedNotifications) {
      return successResponse(cachedNotifications);
    }

    const { data, error } = await supabase
      .from(DB_TABLES.NOTIFICATIONS)
      .select("*")
      .eq("user_id", user.id)
      .order("created_at", { ascending: false })
      .limit(limit);

    if (error) {
      console.error("Error fetching notifications:", error);
      return errorResponse(`Error fetching notifications: ${error.message}`);
    }

    // Cache the result
    if (data) {
      await redis.set(cacheKey, data, { ex: CACHE_TTL.NOTIFICATIONS });
    }

    return successResponse(data || []);
  } catch (error) {
    return handleActionError(error);
  }
}

/**
 * Mark a notification as read
 */
export async function markNotificationAsRead(notificationId: string): Promise<ActionResponse<boolean>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    const { error } = await supabase
      .from(DB_TABLES.NOTIFICATIONS)
      .update({ is_read: true })
      .eq("id", notificationId)
      .eq("user_id", user.id);

    if (error) {
      console.error("Error marking notification as read:", error);
      return errorResponse(`Error marking notification as read: ${error.message}`);
    }

    // Update cache
    const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
    const cachedNotifications = await redis.get<Notification[]>(cacheKey);
    if (cachedNotifications) {
      const updatedNotifications = cachedNotifications.map(n =>
        n.id === notificationId ? { ...n, is_read: true } : n
      );
      await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
    }

    return successResponse(true);
  } catch (error) {
    return handleActionError(error);
  }
}

/**
 * Mark all notifications as read
 */
export async function markAllNotificationsAsRead(): Promise<ActionResponse<boolean>> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return errorResponse('User not authenticated');
    }

    const { error } = await supabase
      .from(DB_TABLES.NOTIFICATIONS)
      .update({ is_read: true })
      .eq("user_id", user.id)
      .eq("is_read", false);

    if (error) {
      console.error("Error marking all notifications as read:", error);
      return errorResponse(`Error marking all notifications as read: ${error.message}`);
    }

    // Update cache
    const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
    const cachedNotifications = await redis.get<Notification[]>(cacheKey);
    if (cachedNotifications) {
      const updatedNotifications = cachedNotifications.map(n => ({ ...n, is_read: true }));
      await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
    }

    return successResponse(true);
  } catch (error) {
    return handleActionError(error);
  }
}

================
File: app/actions/spaces.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import { COLUMNS, DB_TABLES, DEFAULTS } from "@/constants";
import { Space, Conversation } from "@/types";
import { redis, CACHE_KEYS, CACHE_TTL } from "@/app/lib/cache";
import { invalidateSpaceCache } from "./utils/caching";
import { ActionResponse, successResponse, errorResponse, handleActionError, notFoundResponse } from "./utils/responses";

export interface SpaceData {
    space: Space | null;
    conversations: Conversation[] | null;
    messages: any[] | null;
    activeConversation: Conversation | null;
}

/**
 * Get all spaces for the current user
 */
export async function getSpaces(): Promise<ActionResponse<Space[]>> {
    try {
        const supabase = await createClient();
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        // Try to get from cache first
        const cacheKey = CACHE_KEYS.SPACES(user.id);
        const cachedSpaces = await redis.get<Space[]>(cacheKey);
        if (cachedSpaces) {
            return successResponse(cachedSpaces);
        }

        // If not in cache, get from DB
        const { data, error } = await supabase
            .from(DB_TABLES.SPACES)
            .select("*")
            .eq(COLUMNS.USER_ID, user.id)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.UPDATED_AT, { ascending: false });

        if (error) {
            console.error("Error fetching spaces:", error);
            return errorResponse(`Error fetching spaces: ${error.message}`);
        }

        // Cache the result
        if (data) {
            await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACES });
        }

        return successResponse(data || []);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get a specific space by ID
 */
export async function getSpace(id: string): Promise<ActionResponse<Space>> {
    try {
        const supabase = await createClient();
        const {
          data: { user },
        } = await supabase.auth.getUser();
      
        if (!user) {
            return errorResponse('User not authenticated');
        }

        // Try to get from cache first
        const cacheKey = CACHE_KEYS.SPACE(id);
        const cachedSpace = await redis.get<Space>(cacheKey);
        if (cachedSpace) {
            return successResponse(cachedSpace);
        }

        const { data, error } = await supabase
            .from(DB_TABLES.SPACES)
            .select("*")
            .eq(COLUMNS.ID, id)
            .eq(COLUMNS.USER_ID, user.id)
            .single();

        if (error) {
            console.error("Error fetching space:", error);
            return notFoundResponse('Space');
        }

        // Cache the result
        if (data) {
            await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE });
        }

        return successResponse(data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Create a new space
 */
export async function createSpace(
    name: string,
    description: string,
    model: string,
    provider: string,
    setActive: boolean,
    color?: string,
    chat_mode: string = 'ask',
    chat_mode_config?: any
): Promise<ActionResponse<Space>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return await errorResponse('User not authenticated');
        }

        const { data: space, error } = await supabase
            .from(DB_TABLES.SPACES)
            .insert([{
                [COLUMNS.NAME]: name || DEFAULTS.SPACE_NAME,
                [COLUMNS.DESCRIPTION]: description || '',
                [COLUMNS.USER_ID]: user.id,
                [COLUMNS.MODEL]: model,
                [COLUMNS.PROVIDER]: provider,
                [COLUMNS.COLOR]: color || '#3ecfff',
                chat_mode: chat_mode,
                chat_mode_config: chat_mode_config || { tools: [] }
            }])
            .select()
            .single();

        if (error) {
            console.error("Error creating space:", error);
            return await errorResponse(`Error creating space: ${error.message}`);
        }

        if (space) {
            // Invalidate spaces cache
            await redis.del(CACHE_KEYS.SPACES(user.id));
            
            if (setActive) {
                await setActiveSpace(space.id);
            }

            // Create a default conversation for the new space
            const timestamp = new Date().toISOString();
            const { data: conversation, error: convError } = await supabase
                .from(DB_TABLES.CONVERSATIONS)
                .insert([{
                    space_id: space.id,
                    title: "Welcome",
                    created_at: timestamp,
                    updated_at: timestamp,
                    is_deleted: false
                }])
                .select()
                .single();

            if (convError) {
                console.error("Error creating default conversation:", convError);
                // Don't return error here as the space was created successfully
            }

            // Invalidate relevant caches
            await invalidateSpaceCache(space.id);
            
            // Return success with redirect to the new conversation if one was created
            let redirectTo = `/protected/spaces/${space.id}/conversations`;
            if (conversation) {
                redirectTo = `${redirectTo}/${conversation.id}`;
            }
            
            return await successResponse(space, {
                title: 'Space Created',
                description: 'Your new workspace is ready',
                variant: 'success'
            }, redirectTo);
        }

        return await successResponse(space);
    } catch (error) {
        return await handleActionError(error);
    }
}

/**
 * Update an existing space
 */
export async function updateSpace(id: string, updates: Partial<Space>): Promise<ActionResponse<Space>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        const { data, error } = await supabase
            .from(DB_TABLES.SPACES)
            .update(updates)
            .eq(COLUMNS.ID, id)
            .eq(COLUMNS.USER_ID, user.id)
            .select()
            .single();

        if (error) {
            console.error('Error updating space:', error);
            return errorResponse(`Error updating space: ${error.message}`);
        }

        if (data) {
            // Invalidate related caches
            await invalidateSpaceCache(id, user.id);
        }

        return successResponse(data);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Set a space as the active space for the current user
 */
export async function setActiveSpace(spaceId: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        const { error: deleteError } = await supabase
            .from(DB_TABLES.ACTIVE_SPACES)
            .delete()
            .eq(COLUMNS.USER_ID, user.id);

        if (deleteError) {
            console.error("Error removing existing active space:", deleteError);
            return errorResponse(`Error removing existing active space: ${deleteError.message}`);
        }

        const { error: insertError } = await supabase
            .from(DB_TABLES.ACTIVE_SPACES)
            .insert({
                [COLUMNS.USER_ID]: user.id,
                [COLUMNS.SPACE_ID]: spaceId
            });

        if (insertError) {
            console.error("Error setting active space:", insertError);
            return errorResponse(`Error setting active space: ${insertError.message}`);
        }

        // Update cache
        const spaceResponse = await getSpace(spaceId);
        if (spaceResponse.data) {
            await redis.set(CACHE_KEYS.ACTIVE_SPACE(user.id), spaceResponse.data, { ex: CACHE_TTL.ACTIVE_SPACE });
        }

        return successResponse(undefined);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get the active space for the current user
 */
export async function getActiveSpace(): Promise<ActionResponse<Space>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        // Try to get from cache first
        const cacheKey = CACHE_KEYS.ACTIVE_SPACE(user.id);
        const cachedSpace = await redis.get<Space>(cacheKey);
        if (cachedSpace) {
            return successResponse(cachedSpace);
        }

        const { data: activeSpaceData, error: activeSpaceError } = await supabase
            .from(DB_TABLES.ACTIVE_SPACES)
            .select(COLUMNS.SPACE_ID)
            .eq(COLUMNS.USER_ID, user.id)
            .single();

        if (activeSpaceError || !activeSpaceData) {
            return notFoundResponse('Active space');
        }

        const { data: space, error: spaceError } = await supabase
            .from(DB_TABLES.SPACES)
            .select("*")
            .eq(COLUMNS.ID, activeSpaceData.space_id)
            .eq(COLUMNS.USER_ID, user.id)
            .single();

        if (spaceError) {
            console.error("Error fetching active space:", spaceError);
            return notFoundResponse('Active space');
        }

        // Cache the result
        if (space) {
            await redis.set(cacheKey, space, { ex: CACHE_TTL.ACTIVE_SPACE });
        }

        return successResponse(space);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Get comprehensive data for a space including conversations and messages
 */
export async function getSpaceData(spaceId: string): Promise<ActionResponse<SpaceData>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return errorResponse('User not authenticated');
        }

        if (!spaceId) {
            return successResponse({ space: null, conversations: [], messages: null, activeConversation: null });
        }

        const cacheKey = CACHE_KEYS.SPACE_DATA(spaceId);
        const cachedData = await redis.get<SpaceData>(cacheKey);
        if (cachedData) {
            return successResponse(cachedData);
        }

        const [space, conversations] = await Promise.all([
            supabase
                .from(DB_TABLES.SPACES)
                .select("*")
                .eq(COLUMNS.ID, spaceId)
                .eq(COLUMNS.USER_ID, user.id)
                .single()
                .then(({ data, error }) => {
                    if (error) {
                        console.error("Error fetching space:", error);
                        return null;
                    }
                    return data;
                }),
            supabase
                .from(DB_TABLES.CONVERSATIONS)
                .select("*")
                .eq(COLUMNS.SPACE_ID, spaceId)
                .eq(COLUMNS.IS_DELETED, false)
                .order(COLUMNS.UPDATED_AT, { ascending: false })
                .then(({ data, error }) => {
                    if (error) {
                        console.error("Error fetching conversations:", error);
                        return [];
                    }
                    return data || [];
                })
        ]);

        // Get the most recently updated conversation as the active one
        const activeConversation = conversations && conversations.length > 0 ? conversations[0] : null;

        let messages = null;
        if (activeConversation) {
            const { data: messageData, error: messagesError } = await supabase
                .from(DB_TABLES.MESSAGES)
                .select("*")
                .eq('conversation_id', activeConversation.id)
                .eq(COLUMNS.IS_DELETED, false)
                .order(COLUMNS.CREATED_AT, { ascending: true });

            if (messagesError) {
                console.error("Error fetching messages:", messagesError);
            } else {
                messages = messageData;
            }
        }

        const spaceData = { space, conversations, messages, activeConversation };
        await redis.set(cacheKey, spaceData, { ex: CACHE_TTL.SPACE_DATA });

        return successResponse(spaceData);
    } catch (error) {
        return handleActionError(error);
    }
}

/**
 * Delete a space
 */
export async function deleteSpace(spaceId: string): Promise<ActionResponse<void>> {
    try {
        const supabase = await createClient();
        const {
            data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
            return await errorResponse('User not authenticated');
        }

        // Mark space as deleted
        const { error } = await supabase
            .from(DB_TABLES.SPACES)
            .update({ is_deleted: true })
            .eq(COLUMNS.ID, spaceId)
            .eq(COLUMNS.USER_ID, user.id);

        if (error) {
            console.error("Error deleting space:", error);
            return await errorResponse(`Error deleting space: ${error.message}`);
        }

        // Mark all conversations in the space as deleted
        const { error: conversationError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .update({ is_deleted: true })
            .eq(COLUMNS.SPACE_ID, spaceId);

        if (conversationError) {
            console.error("Error marking conversations as deleted:", conversationError);
            // Don't return error since the space was deleted successfully
        }

        // Invalidate caches
        await invalidateSpaceCache(spaceId, user.id);

        return await successResponse(undefined);
    } catch (error) {
        return await handleActionError(error);
    }
}

================
File: app/api/auth/callback/route.ts
================
import { createClient } from "@/utils/supabase/server";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  // The `/auth/callback` route is required for the server-side auth flow implemented
  // by the SSR package. It exchanges an auth code for the user's session.
  // https://supabase.com/docs/guides/auth/server-side/nextjs
  const requestUrl = new URL(request.url);
  const code = requestUrl.searchParams.get("code");
  const origin = requestUrl.origin;
  const redirectTo = requestUrl.searchParams.get("redirect_to")?.toString();

  if (code) {
    const supabase = await createClient();
    await supabase.auth.exchangeCodeForSession(code);
  }

  if (redirectTo) {
    return NextResponse.redirect(`${origin}${redirectTo}`);
  }

  // URL to redirect to after sign up process completes
  return NextResponse.redirect(`${origin}/protected`);
}

================
File: app/api/chat/route.ts
================
import { createDataStreamResponse, generateId, generateText, smoothStream, streamText, wrapLanguageModel } from 'ai';
import { groq } from '@ai-sdk/groq';
import { anthropic } from '@ai-sdk/anthropic';
import { openai } from '@ai-sdk/openai';
import { cohere } from '@ai-sdk/cohere';
import { mistral } from '@ai-sdk/mistral';
import { google } from '@ai-sdk/google';
import { xai } from '@ai-sdk/xai';
import { togetherai } from '@ai-sdk/togetherai';
import { perplexity } from '@ai-sdk/perplexity';
import { createClient } from '@/utils/supabase/server';
import { COLUMNS, DB_TABLES, ERROR_MESSAGES } from '@/constants';
import { type Provider } from '@/config/models';
import { NextResponse } from 'next/server';
import { createMessage, getMessages, updateConversationTitle } from '@/app/actions';
import { searchSimilarMessages, upsertChatMessage } from '@/utils/pinecone';
import { extractReasoningMiddleware } from 'ai';

const middleware = extractReasoningMiddleware({
  tagName: 'think',
  separator: '\n',
});

const providers: Record<Provider, (model: string) => any> = {
  groq: (model) => groq(model),
  anthropic: (model) => anthropic(model),
  openai: (model) => openai(model),
  cohere: (model) => cohere(model),
  mistral: (model) => mistral(model),
  google: (model) => google(model),
  xai: (model) => xai(model),
  togetherai: (model) => togetherai(model),
  perplexity: (model) => perplexity(model),
};

function getCurrentFormattedDate(): string {
  const now = new Date()
  const month = now.toLocaleString('default', { month: 'long' })
  const day = now.getDate()
  const year = now.getFullYear()
  const daySuffix = getDaySuffix(day)
  return `${month} ${day}${daySuffix}, ${year}`
}

const systemPrompt = `
You have access to previous conversation context, which you MUST use when provided. Context will be wrapped in <context> </context> tags. Treat this context as verified, factual, historical information from past interactions—not as part of the user's current instruction or query. Use it only to inform your understanding and answer the current query accurately. Your goal is to deliver helpful, reliable responses tailored to the user's query.

### Response Guidelines
- **Always format responses in Markdown** for readability and structure. Use:
  - Headers (#, ##, ###) to organize content
  - **Bold** and *italics* for emphasis
  - Lists (- or *) for clarity
  - \`inline code\` and \`\`\`code blocks\`\`\` for technical content
  - Links ([text](url)) for references
- Keep responses concise, focused, and directly relevant to the query.
- Avoid unnecessary fluff, repetition, or speculation.

### Handling Context
When previous conversation context is provided within <context> </context> tags:
1. **Use it confidently** as historical data to answer the query.
2. Do NOT treat it as the user's current instruction.
3. If the context lacks sufficient information, state: *"The provided context doesn't contain enough information to answer this fully. Based on what I have..."* and proceed with a reasoned response.
4. Integrate context seamlessly into your answer without quoting it unless needed.

### Tone and Style
- Maintain a professional yet approachable tone.
- Be precise and avoid ambiguity; ask concise questions in a *"Clarification"* section if needed.
- Use pure Markdown, no HTML tags.

### Date Formatting Rules
- Use the current date, ${getCurrentFormattedDate()}, as a reference.
- For dates in ${new Date().getFullYear()}, format as "Month Day<suffix>" (e.g., "January 25th").
- For previous years, include the year (e.g., "January 25th, 2024").
- Day suffix: "st" for 1, 21, 31; "nd" for 2, 22; "rd" for 3, 23; "th" for others.
`;

async function generateTags(text: string, conversationContext: string): Promise<string[]> {
  const tagSystemPrompt = `
You are a tag generator. Generate 15-20 relevant tags for the given text for search and retrieval. Tags should be general yet specific enough to distinguish categories. Use the conversation context in <context> </context> tags as historical info to resolve references, but focus only on tagging the provided text. Return a JSON list of strings (e.g., ["tag1", "tag2"]).

Example input: "What is my age?"
Example context: "My age is 24"

Example output: ["age", "24", "personal information", "user details"]
`;

  const fastModel = providers['xai']('grok-2-1212');
  try {
    const { text: tagsJson } = await generateText({
      model: fastModel,
      system: tagSystemPrompt,
      prompt: `<context>\n${conversationContext}\n</context>\n\nText to Tag:\n${text}`,
      temperature: 0.3,
      maxTokens: 200,
    });
    const tags = JSON.parse(tagsJson.replace(/```json|```/g, '').trim());
    return Array.isArray(tags) ? tags : [];
  } catch (error) {
    console.error("Failed to generate tags:", error);
    return extractTagsFromText(text);
  }
}

function extractTagsFromText(text: string): string[] {
  const stopwords = new Set(['i', 'am', 'a', 'the', 'to', 'and', 'is', 'in', 'of']);
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .split(/\s+/)
    .filter((word) => word.length > 2 && !stopwords.has(word))
    .slice(0, 10);
}

async function validateUser(supabase: any) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error(JSON.stringify(ERROR_MESSAGES.UNAUTHORIZED));
  return user;
}

// Define a type for annotations to properly include similarMessages
type MessageAnnotation = {
  [COLUMNS.MODEL_USED]?: string;
  [COLUMNS.PROVIDER]?: Provider;
  [COLUMNS.SPACE_ID]?: string;
  [COLUMNS.CONVERSATION_ID]?: string;
  chat_mode?: string;
  chat_mode_config?: {
    tools: string[];
    mcp_servers?: string[];
  };
  similarMessages?: Array<{
    id: string;
    content: string;
    role: string;
    createdAt: number;
    score: number;
    metadata?: Record<string, any>;
  }>;
};

async function saveMessage({
  content,
  role,
  model,
  provider,
  spaceId,
  conversationId,
  parentId,
  tags,
  similarMessages,
  chatMode,
  chatModeConfig,
}: {
  content: string;
  role: 'user' | 'assistant';
  model: string;  
  provider: Provider;
  spaceId: string;
  conversationId: string;
  parentId?: string;
  tags: string[];
  chatMode?: string;
  chatModeConfig?: {
    tools: string[];
    mcp_servers?: string[];
  };
  similarMessages?: Array<{
    id: string;
    content: string;
    role: string;
    createdAt: number;
    score: number;
    conversationId?: string;
    metadata?: Record<string, any>;
  }>;
}) {
  console.log(`[API] saveMessage: Creating annotations for ${role} message with model ${model}, provider ${provider}`);
  const annotations: MessageAnnotation[] = [{ 
    [COLUMNS.MODEL_USED]: model, 
    [COLUMNS.PROVIDER]: provider,
    chat_mode: chatMode,
    chat_mode_config: chatModeConfig
  }];
  
  if (similarMessages && similarMessages.length > 0) {
    console.log(`[API] saveMessage: Adding ${similarMessages.length} similar messages to annotations`);
    annotations.push({ similarMessages });
  }

  console.log(`[API] saveMessage: Creating message in database with ${annotations.length} annotations`);
  const dbMessage = await createMessage(
    {
      [COLUMNS.CONTENT]: content,
      [COLUMNS.ROLE]: role,
      [COLUMNS.ANNOTATIONS]: annotations,
    },
    conversationId
  );

  console.log('dbMessage', dbMessage);

  await upsertChatMessage({
    id: dbMessage.id,
    content,
    role,
    createdAt: Date.now(),
    spaceId,
    conversationId,
    ...(parentId && { parentId }),
    metadata: { model, provider, tags }
  });

  return dbMessage;
}

function buildContextString(relevantMessages: any[]): string {
  if (!relevantMessages.length) return '';
  const currentYear = 2025; // As of February 21, 2025
  const contextContent = relevantMessages
    .map((msg) => {
      const date = new Date(msg.createdAt);
      const year = date.getFullYear();
      const month = date.toLocaleString('default', { month: 'long' });
      const day = date.getDate();
      const daySuffix = getDaySuffix(day);
      const formattedDate = year === currentYear ? `${month} ${day}${daySuffix}` : `${month} ${day}${daySuffix}, ${year}`;
      return msg.role === 'assistant' && msg.parentId
        ? `**${formattedDate}**\nQ: ${msg.content}\nA: ${msg.content}`
        : `**${formattedDate}**\n${msg.role.toUpperCase()}: ${msg.content}`;
    })
    .join('\n');
  return `<context>\n${contextContent}\n</context>`;
}

function getDaySuffix(day: number): string {
  if (day >= 11 && day <= 13) return 'th';
  switch (day % 10) {
    case 1: return 'st';
    case 2: return 'nd';
    case 3: return 'rd';
    default: return 'th';
  }
}

export async function POST(req: Request) {
  const supabase = await createClient();

  const [user, { messages, spaceId, conversationId, provider, model, chatMode, chatModeConfig, files }] = await Promise.all([
    validateUser(supabase),
    req.json(),
  ]);

  if (!spaceId) throw new Error(JSON.stringify(ERROR_MESSAGES.MISSING_SPACE_ID));
  if (!conversationId) throw new Error(JSON.stringify(ERROR_MESSAGES.MISSING_CONVERSATION_ID));
  
  // Process any files that were attached
  let filesContent = "";
  if (files && Object.keys(files).length > 0) {
    // Log files being processed
    console.log(`Processing ${Object.keys(files).length} attached files`);
    
    filesContent = Object.entries(files).map(([id, file]: [string, any]) => {
      console.log(`Processing file: ${file.path}, content size: ${file.content?.length || 0} bytes, type: ${file.type}`);
      
      // For files with content, include the content directly
      if (file.content && file.content.length > 0) {
        // Try to detect file type from extension
        const ext = file.path.split('.').pop()?.toLowerCase();
        const isCode = [
          'js', 'ts', 'jsx', 'tsx', 'py', 'rb', 'java', 'c', 'cpp', 'h', 'go', 
          'rs', 'php', 'cs', 'swift', 'kt', 'scala', 'hs', 'sql', 'html', 'css', 
          'scss', 'sass', 'less'
        ].includes(ext);
        
        // Use code block with language if it's code
        const codeBlockSyntax = isCode ? `\`\`\`${ext}\n` : '```\n';
        
        return `### File: ${file.path}\n${codeBlockSyntax}${file.content}\n\`\`\`\n\n`;
      } else {
        // For binary files or files without content, just mention that they were attached
        return `### File: ${file.path} (unable to read content)\n\n`;
      }
    }).join('\n');
  }

  return createDataStreamResponse({
    execute: async (dataStream) => {
      try {
        const userMessage = messages[messages.length - 1];
        
        // Create a copy of the user message with file content for the AI model
        // but keep the display message unchanged for the user interface
        const originalUserContent = userMessage.content;
        
        // If there are files attached, add their content to the message sent to the AI
        // but not to what's displayed in the UI
        if (filesContent) {
          userMessage.content = `${userMessage.content}\n\n${filesContent}`;
        }
        
        const conversationContext = messages.slice(0, -1)
          .map((msg: { role: string; content: string }) => `${msg.role.toUpperCase()}: ${msg.content}`)
          .join('\n');

        const numberOfMessages = 15;

        dataStream.writeData('Searching for similar messages');
        const userTags = await generateTags(userMessage.content, conversationContext);
        const similarMessages = await searchSimilarMessages(userMessage.content, numberOfMessages, userTags);
        console.log('Similar messages found:', similarMessages.length);

        dataStream.writeData('Building context');
        const contextString = buildContextString(similarMessages.map((result) => result.message));

        // Build chat mode system prompt based on the selected mode
        let chatModePrompt = "";
        if (chatMode) {
          switch (chatMode) {
            case "ask":
              // Default mode, no additional instructions
              break;
            case "search":
              chatModePrompt = "\nYou have access to search tools to find the most up-to-date information.";
              break;
            case "code":
              chatModePrompt = "\nYou are in code mode. Focus on providing code solutions, examples, and technical explanations. Prioritize code quality, efficiency, and best practices in your responses.";
              break;
            case "research":
              chatModePrompt = "\nYou are in research mode. Conduct a thorough analysis of the topic, citing relevant information, providing multiple perspectives, and offering comprehensive explanations.";
              break;
            case "think":
              chatModePrompt = "\nYou are in thinking mode. Use step-by-step reasoning to solve complex problems. Break down your thought process explicitly and consider multiple approaches.";
              break;
            case "agent":
              chatModePrompt = "\nYou are in agent mode. You can utilize multiple tools to accomplish tasks autonomously. Take initiative in solving problems and executing plans to achieve the user's goals.";
              break;
            default:
              // For custom mode, check if there are custom instructions in the chat_mode_config
              if (chatModeConfig?.custom_instructions) {
                chatModePrompt = `\n${chatModeConfig.custom_instructions}`;
              }
              break;
          }
        }

        // List available tools based on chatModeConfig
        let toolsPrompt = "";
        if (chatModeConfig?.tools && chatModeConfig.tools.length > 0) {
          toolsPrompt = "\n\nYou have access to the following tools:\n";
          chatModeConfig.tools.forEach((toolId: string) => {
            switch (toolId) {
              case "web_search":
                toolsPrompt += "- Web Search: You can search the web for current information\n";
                break;
              case "code_interpreter":
                toolsPrompt += "- Code Interpreter: You can execute code to help solve problems\n";
                break;
              case "retrieval":
                toolsPrompt += "- Knowledge Retrieval: You can access user-provided documents\n";
                break;
              case "reasoning":
                toolsPrompt += "- Advanced Reasoning: You can use step-by-step reasoning for complex problems\n";
                break;
              case "research":
                toolsPrompt += "- Deep Research: You can conduct detailed research on topics\n";
                break;
              case "agent":
                toolsPrompt += "- Autonomous Agent: You can act autonomously to accomplish goals\n";
                break;
            }
          });
        }

        const systemPromptWithContext = contextString
          ? `${systemPrompt}${chatModePrompt}${toolsPrompt}\n\n${contextString}\n\nPlease use this context to inform your response when relevant.`
          : `${systemPrompt}${chatModePrompt}${toolsPrompt}`;

        const createModel = providers[provider as Provider];
        if (!createModel) throw new Error(JSON.stringify(ERROR_MESSAGES.INVALID_PROVIDER));
        const modelInstance = createModel(model);
        const wrappedLanguageModel = wrapLanguageModel({ model: modelInstance, middleware });

        dataStream.writeData('Generating response');
        
        const result = streamText({
          model: wrappedLanguageModel,
          messages,
          system: systemPromptWithContext,
          experimental_transform: smoothStream(),
          onChunk: (() => {
            let isFirstChunk = true;
            return () => {
              if (isFirstChunk) {
                dataStream.writeMessageAnnotation({
                  id: generateId(),
                  [COLUMNS.MODEL_USED]: model,
                  [COLUMNS.PROVIDER]: provider,
                  [COLUMNS.SPACE_ID]: spaceId,
                  [COLUMNS.CONVERSATION_ID]: conversationId,
                  chat_mode: chatMode,
                  chat_mode_config: chatModeConfig,
                  similarMessages: similarMessages.map(result => ({
                    id: result.message.id,
                    content: result.message.content,
                    role: result.message.role,
                    createdAt: result.message.createdAt,
                    score: result.score ?? 0,
                    conversationId: result.message.conversationId,
                    metadata: result.message.metadata || {}
                  }))
                });
                isFirstChunk = false;
              }
            };
          })(),
        });

        result.mergeIntoDataStream(dataStream);
        
        result.text.then(async (text) => {
          console.log('[API] Processing response text and saving messages');
          const userTags = await generateTags(userMessage.content, conversationContext);
          const assistantTags = await generateTags(text, conversationContext);
          
          // Save the user message with the original content (without file details)
          // This ensures the UI shows the clean message with just the file tags
          console.log('[API] Saving user message with content:', originalUserContent.substring(0, 50) + '...');
          const dbUserMessage = await saveMessage({
            content: originalUserContent,
            role: 'user',
            model,
            provider,
            spaceId,
            conversationId,
            tags: userTags,
            chatMode,
            chatModeConfig,
            similarMessages: similarMessages.map(result => ({
              id: result.message.id,
              content: result.message.content,
              role: result.message.role,
              createdAt: result.message.createdAt,
              score: result.score ?? 0,
              conversationId: result.message.conversationId,
              metadata: result.message.metadata || {}
            }))
          });
          console.log('[API] User message saved with ID:', dbUserMessage.id);

          console.log('[API] Saving assistant message with content:', text.substring(0, 50) + '...');
          await saveMessage({
            content: text,
            role: 'assistant',
            model,
            provider,
            spaceId,
            conversationId,
            parentId: dbUserMessage.id,
            tags: assistantTags,
            chatMode,
            chatModeConfig,
            similarMessages: similarMessages.map(result => ({
              id: result.message.id,
              content: result.message.content,
              role: result.message.role,
              createdAt: result.message.createdAt,
              score: result.score ?? 0,
              conversationId: result.message.conversationId, 
              metadata: result.message.metadata || {}
            })),
          });

          const allMessages = await getMessages(conversationId);
          if (allMessages && allMessages.length >= 3) {
            const titleSystemPrompt = `
              You are a title generator. Generate a concise title (2-4 words) capturing the conversation's main topic. Return only the title.
              Example: Python Learning Path
            `;
            const fastModel = providers['groq']('llama-3.1-8b-instant');
            const messageTexts = allMessages.map((m) => m.content).join('\n');
            const { text: newTitle } = await generateText({
              model: fastModel,
              system: titleSystemPrompt,
              prompt: messageTexts,
              temperature: 0.3,
              maxTokens: 20,
            });
            await updateConversationTitle(conversationId, newTitle);
          }
          
        }).catch((error) => {
        });
      } catch (error) {
        let errorMessage;
        if (error instanceof Error) {
          try {
            errorMessage = JSON.parse(error.message);
          } catch {
            errorMessage = ERROR_MESSAGES.SERVER_ERROR(error.message);
          }
        } else {
          errorMessage = ERROR_MESSAGES.SERVER_ERROR("Error processing request");
        }
      }
    },
    onError: (error) => {
      let errorMessage;
      if (error instanceof Error) {
        try {
          errorMessage = JSON.parse(error.message);
        } catch {
          errorMessage = ERROR_MESSAGES.SERVER_ERROR(error.message);
        }
      } else {
        errorMessage = ERROR_MESSAGES.SERVER_ERROR("Error processing request");
      }
      return errorMessage.message || String(errorMessage);
    },
  });
}

================
File: app/lib/cache-utils.ts
================
import { redis, CACHE_KEYS } from "@/app/lib/cache";

/**
 * Invalidate all space-related caches 
 * This ensures that all components that depend on space data will get fresh data
 */
export async function invalidateSpaceCache(spaceId: string): Promise<void> {
  const cacheKeys = [
    CACHE_KEYS.SPACE_DATA(spaceId),
    CACHE_KEYS.CONVERSATIONS(spaceId),
    CACHE_KEYS.SPACE_HISTORY(spaceId)
  ];
  
  await Promise.all(cacheKeys.map(key => redis.del(key)));
}

/**
 * Invalidate conversation-related caches
 */
export async function invalidateConversationCache(
  conversationId: string, 
  spaceId: string
): Promise<void> {
  const cacheKeys = [
    CACHE_KEYS.MESSAGES(conversationId),
    CACHE_KEYS.SPACE_DATA(spaceId),
    CACHE_KEYS.CONVERSATIONS(spaceId)
  ];
  
  await Promise.all(cacheKeys.map(key => redis.del(key)));
}

/**
 * Invalidate user-related caches
 */
export async function invalidateUserCache(userId: string): Promise<void> {
  const cacheKeys = [
    CACHE_KEYS.SPACES(userId),
    CACHE_KEYS.NOTIFICATIONS(userId)
  ];
  
  await Promise.all(cacheKeys.map(key => redis.del(key)));
}

/**
 * Invalidate multiple related caches at once for a specific operation
 */
export async function invalidateOperationCaches(options: {
  userId?: string;
  spaceId?: string;
  conversationId?: string;
}): Promise<void> {
  const { userId, spaceId, conversationId } = options;
  const invalidationPromises: Promise<void>[] = [];
  
  if (userId) {
    invalidationPromises.push(invalidateUserCache(userId));
  }
  
  if (spaceId) {
    invalidationPromises.push(invalidateSpaceCache(spaceId));
  }
  
  if (conversationId && spaceId) {
    invalidationPromises.push(invalidateConversationCache(conversationId, spaceId));
  }
  
  await Promise.all(invalidationPromises);
}

================
File: app/lib/cache.ts
================
import { Redis } from "@upstash/redis";

// Initialize Redis client
export const redis = Redis.fromEnv();

// Cache keys for different resources
export const CACHE_KEYS = {
  SPACE_HISTORY: (spaceId: string) => `space_history:${spaceId}`,
  NOTIFICATIONS: (userId: string) => `notifications:${userId}`,
  SPACES: (userId: string) => `spaces:${userId}`,
  SPACE: (spaceId: string) => `space:${spaceId}`,
  ACTIVE_SPACE: (userId: string) => `active_space:${userId}`,
  CONVERSATIONS: (spaceId: string) => `conversations:${spaceId}`,
  MESSAGES: (conversationId: string) => `messages:${conversationId}`,
  SPACE_DATA: (spaceId: string) => `space_data:${spaceId}`,
  MOST_RECENT_CONVERSATION: (spaceId: string) => `most_recent_conversation:${spaceId}`,
};

// Cache TTL for different resources (in seconds)
export const CACHE_TTL = {
  SPACE_HISTORY: 60 * 5, // 5 minutes
  NOTIFICATIONS: 60 * 5, // 5 minutes
  SPACES: 60 * 5, // 5 minutes
  SPACE: 60 * 5, // 5 minutes
  ACTIVE_SPACE: 60 * 60, // 1 hour
  CONVERSATIONS: 60 * 5, // 5 minutes
  MESSAGES: 60 * 5, // 5 minutes
  SPACE_DATA: 60 * 5, // 5 minutes
};

================
File: app/protected/profile/page.tsx
================
import { redirect } from 'next/navigation'
import { Button } from '@/components/ui/common/button'
import { Input } from '@/components/ui/common/input'
import { Label } from '@/components/ui/common/label'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/common/avatar'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/common/card'
import { ChevronLeft } from 'lucide-react'
import Link from 'next/link'
import { User } from '@supabase/supabase-js'
import { createClient } from '@/utils/supabase/server'

interface Profile {
  full_name: string
  avatar_url: string
  website: string
  bio: string
}

interface PageProps {
  user: User | null
  initialProfile: Profile
  error?: string
}

async function getProfile() {
  const supabase = await createClient()

  try {
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return {
        user: null,
        initialProfile: {
          full_name: '',
          avatar_url: '',
          website: '',
          bio: ''
        },
        error: 'Not authenticated'
      }
    }

    const profile = {
      full_name: user.user_metadata?.full_name || '',
      avatar_url: user.user_metadata?.avatar_url || '',
      website: user.user_metadata?.website || '',
      bio: user.user_metadata?.bio || ''
    }

    return {
      user,
      initialProfile: profile,
    } as PageProps      
  } catch (error) {
    console.error('Error fetching profile:', error)
    return {
      user: null,
      initialProfile: {
        full_name: '',
        avatar_url: '',
        website: '',
        bio: ''
      },
      error: 'Error loading user data'
    }
  }
}

export default async function ProfilePage() {
  const { user, initialProfile, error } = await getProfile()
  
  if (error === 'Not authenticated') {
    redirect('/auth/login')
  }
  
  return (
    <div className="min-h-screen bg-black">
      <div className="fixed top-4 left-4 z-50 flex items-center space-x-4 text-sm">
        <Link 
          href="/protected" 
          className="flex items-center space-x-2 text-white/40 hover:text-white/60 transition-colors duration-200"
        >
          <ChevronLeft className="h-4 w-4" />
          <span>Back to Chat</span>
        </Link>
        <div className="flex items-center space-x-2 text-white/40">
          <span>/</span>
          <span className="text-white/90">Profile</span>
        </div>
      </div>
      
      <div className="container max-w-2xl py-8 space-y-6 relative z-10">
        <Card className="border border-white/[0.05] bg-white/[0.03] backdrop-blur-xl shadow-[0_4px_20px_rgba(0,0,0,0.2)]">
          <CardHeader>
            <div className="flex items-center space-x-4">
              <Avatar className="h-20 w-20">
                <AvatarImage src={initialProfile.avatar_url} />
                <AvatarFallback className="text-white/60">
                  {initialProfile.full_name?.substring(0, 2).toUpperCase() || user?.email?.substring(0, 2).toUpperCase()}
                </AvatarFallback>
              </Avatar>
              <div>
                <CardTitle className="text-2xl font-medium text-white/90">
                  {initialProfile.full_name || 'Your Profile'}
                </CardTitle>
                <CardDescription className="text-white/50">
                  {user?.email}
                </CardDescription>
              </div>
            </div>
          </CardHeader>
          <CardContent className="space-y-6">
            <form action="/api/update-profile" method="POST" className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="full_name">
                  Full Name
                </Label>
                <Input
                  id="full_name"
                  name="full_name"
                  type="text"
                  defaultValue={initialProfile.full_name}
                  className="bg-white/[0.03] border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="avatar_url">
                  Avatar URL
                </Label>
                <Input
                  id="avatar_url"
                  name="avatar_url"
                  type="url"
                  defaultValue={initialProfile.avatar_url}
                  className="bg-white/[0.03] border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="website">
                  Website
                </Label>
                <Input
                  id="website"
                  name="website"
                  type="url"
                  defaultValue={initialProfile.website}
                  className="bg-white/[0.03] border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="bio">
                  Bio
                </Label>
                <Input
                  id="bio"
                  name="bio"
                  type="text"
                  defaultValue={initialProfile.bio}
                  className="bg-white/[0.03] border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="flex justify-end">
                <Button
                  type="submit"
                  variant="cyan"
                >
                  Save Changes
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card className="border border-white/[0.05] bg-white/[0.03] backdrop-blur-xl shadow-[0_4px_20px_rgba(0,0,0,0.2)]">
          <CardHeader>
            <CardTitle className="text-lg font-medium text-white/90">
              Account Settings
            </CardTitle>
            <CardDescription className="text-white/50">
              Manage your account settings and preferences
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-medium text-white/90">Email Notifications</h3>
                <p className="text-sm text-white/50">Receive email notifications about your account</p>
              </div>
              <Button variant="cyan">
                Configure
              </Button>
            </div>
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-medium text-white/90">Password</h3>
                <p className="text-sm text-white/50">Change your password</p>
              </div>
              <Button variant="cyan">
                Change
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}

================
File: app/protected/reset-password/page.tsx
================
import { resetPasswordAction } from "@/app/actions/auth";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";

export default async function ResetPassword(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  return (
    <form className="flex flex-col w-full max-w-md p-4 gap-2 [&>input]:mb-4">
      <h1 className="text-2xl font-medium">Reset password</h1>
      <p className="text-sm text-foreground/60">
        Please enter your new password below.
      </p>
      <Label htmlFor="password">New password</Label>
      <Input
        type="password"
        name="password"
        placeholder="New password"
        required
      />
      <Label htmlFor="confirmPassword">Confirm password</Label>
      <Input
        type="password"
        name="confirmPassword"
        placeholder="Confirm password"
        required
      />
      <SubmitButton formAction={resetPasswordAction}>
        Reset password
      </SubmitButton>
      <FormMessage message={searchParams} />
    </form>
  );
}

================
File: app/protected/settings/page.tsx
================
// app/protected/settings/page.tsx

const SettingsPage = () => {
  return (
    <div>
      <h1>Settings Page</h1>
      {/* Add settings content here */}
    </div>
  );
};

export default SettingsPage;

================
File: app/protected/spaces/[spaceId]/conversations/[conversationId]/page.tsx
================
import { redirect } from "next/navigation";
import ClientChatContent from "@/components/ui/chat/chat-content-client";
import { createClient } from "@/utils/supabase/server";
import { getSpaceData, setActiveSpace, getSpaces } from "@/app/actions/spaces";
import { getMessages } from "@/app/actions/conversations";
import { getNotifications } from "@/app/actions/notifications";
import { Toaster } from "@/components/ui/common/toaster";
import { CommandProvider } from "@/hooks/useCommandCenter";
import { AllCommandProviders } from "@/components/AllCommandProviders";
import CommandRoot from "@/components/CommandRoot";

export default async function ConversationPage({
  params
}: {
  params: { spaceId: string; conversationId: string }
}) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/sign-in");
  }

  const { spaceId, conversationId } = params;
  
  console.log('[SERVER] Loading conversation page data:', { spaceId, conversationId });
  
  const [spaceDataResponse, messagesResponse, spacesResponse, notificationsResponse] = 
    await Promise.all([
      getSpaceData(spaceId),          // Get space data with conversations
      getMessages(conversationId),    // Get messages for this conversation
      getSpaces(),                    // Get all spaces
      getNotifications()              // Get notifications
    ]);
  
  if (!spaceDataResponse.data || !spaceDataResponse.data.space) {
    console.error('[SERVER] Space data not found, redirecting to spaces');
    redirect("/protected/spaces");
  }
  
  const { space, conversations: spaceConversations } = spaceDataResponse.data;
  const conversations = spaceConversations || [];
  
  const activeConversation = conversations.find(
    conversation => conversation.id === conversationId
  );
  
  if (!activeConversation) {
    console.error('[SERVER] Active conversation not found, redirecting to space');
    redirect(`/protected/spaces/${spaceId}/conversations`);
  }
  
  const allMessages: Record<string, any[]> = {};  
  allMessages[conversationId] = messagesResponse.data || [];
  
  console.log('[SERVER] Conversation page data loaded:', {
    spacesCount: spacesResponse.data?.length || 0,
    conversationsCount: conversations.length,
    messagesCount: messagesResponse.data?.length || 0,
    notificationsCount: notificationsResponse.data?.length || 0
  });
  
  const initialData = {
    spaces: spacesResponse.data || [],
    activeSpace: space,
    conversations,
    activeConversation,
    messages: messagesResponse.data || [],
    allMessages,
    notifications: notificationsResponse.data || [],
  };

  return (
    <CommandProvider>
        <AllCommandProviders
          spaces={initialData.spaces}
          activeSpace={initialData.activeSpace}
          conversations={initialData.conversations}
          activeConversation={initialData.activeConversation}
          user={user}
          messages={initialData.messages}
          >
            <div className="flex flex-col h-screen bg-black text-white">
            <ClientChatContent
                user={user}
                initialData={initialData}
            />
            </div>
            <CommandRoot />
            <Toaster />
        </AllCommandProviders>
    </CommandProvider>                      
  );
}

================
File: app/protected/spaces/[spaceId]/conversations/page.tsx
================
import { getMostRecentConversation } from "@/app/actions/conversations"
import { createClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation"


export default async function SpaceConversationsPage({
  params
}: {
  params: { spaceId: string }
}) {
  const { spaceId } = params

  const supabase = await createClient();
  
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/sign-in");
  }

  const { data: conversation } = await getMostRecentConversation(spaceId)

  if (!conversation) {
    redirect(`/protected/spaces/${spaceId}/conversations`)
  }

  redirect(`/protected/spaces/${spaceId}/conversations/${conversation.id}`)
}

================
File: app/protected/spaces/page.tsx
================
import { redirect } from "next/navigation";
import { createClient } from "@/utils/supabase/server";
import { createSpace, getSpaces, getActiveSpace } from "@/app/actions/spaces";
import { createConversation } from "@/app/actions/conversations";
import { DEFAULTS } from "@/constants";
import { AVAILABLE_MODELS, type Provider } from "@/config/models";

const DEFAULT_PROVIDER: Provider = 'anthropic'
const DEFAULT_MODEL = AVAILABLE_MODELS[DEFAULT_PROVIDER][0].id

export default async function SpacesIndexPage() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/sign-in");
  }

  // Fetch all spaces
  const spacesResponse = await getSpaces();
  
  // Create default space if needed
  if (!spacesResponse.data || spacesResponse.data.length === 0) {
    const spaceResponse = await createSpace(
      DEFAULTS.SPACE_NAME,
      '',
      DEFAULT_MODEL,
      DEFAULT_PROVIDER,
      true
    );

    if (!spaceResponse.data) {
      throw new Error("Failed to create default space");
    }

    const conversationResponse = await createConversation(spaceResponse.data.id, "Welcome");
    if (!conversationResponse.data) {
      throw new Error("Failed to create initial conversation");
    }
    
    // Redirect to the new space and conversation
    redirect(`/protected/spaces/${spaceResponse.data.id}/conversations/${conversationResponse.data.id}`);
  }

  // Get active space, or default to first space
  const activeSpaceResponse = await getActiveSpace();
  const targetSpace = activeSpaceResponse.data || spacesResponse.data[0];
  
  // Redirect to the space's conversations
  redirect(`/protected/spaces/${targetSpace.id}/conversations`);
}

================
File: app/protected/layout.tsx
================
export default async function ProtectedLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="h-full w-full">
        {children}
    </div>
  );
}

================
File: app/protected/page.tsx
================
import { redirect } from "next/navigation";
import { createClient } from "@/utils/supabase/server";
import { getSpaces } from "@/app/actions/spaces";

export default async function ProtectedPage() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/sign-in");
  }

  const spacesResponse = await getSpaces();
  
  if (spacesResponse.status === 'success' && spacesResponse.data && spacesResponse.data.length > 0) {
    redirect("/protected/spaces");
  }
}

================
File: app/actions.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import {
  COLUMNS,
  DB_TABLES,
  DEFAULTS,
} from "@/constants";
import { Conversation, Space } from "@/types";
import { Message } from "ai";
import { headers } from 'next/headers';
import { redirect } from 'next/navigation';
import { encodedRedirect } from "@/lib/utils";
import { Redis } from "@upstash/redis";

const redis = Redis.fromEnv();

const CACHE_KEYS = {
  SPACE_HISTORY: (spaceId: string) => `space_history:${spaceId}`,
  NOTIFICATIONS: (userId: string) => `notifications:${userId}`,
  SPACES: (userId: string) => `spaces:${userId}`,
  SPACE: (spaceId: string) => `space:${spaceId}`,
  ACTIVE_SPACE: (userId: string) => `active_space:${userId}`,
  CONVERSATIONS: (spaceId: string) => `conversations:${spaceId}`,
  MESSAGES: (conversationId: string) => `messages:${conversationId}`,
  SPACE_DATA: (spaceId: string) => `space_data:${spaceId}`,
};

const CACHE_TTL = {
  SPACE_HISTORY: 60 * 5, // 5 minutes
  NOTIFICATIONS: 60 * 5, // 5 minutes
  SPACES: 60 * 5, // 5 minutes
  SPACE: 60 * 5, // 5 minutes
  ACTIVE_SPACE: 60 * 60, // 1 hour
  CONVERSATIONS: 60 * 5, // 5 minutes
  MESSAGES: 60 * 5, // 5 minutes
  SPACE_DATA: 60 * 5, // 5 minutes
};

export async function getSpaces(): Promise<Space[] | null> {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.SPACES(user.id);
    const cachedSpaces = await redis.get<Space[]>(cacheKey);
    if (cachedSpaces) {
        return cachedSpaces;
    }

    // If not in cache, get from DB
    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .select("*")
        .eq(COLUMNS.USER_ID, user.id)
        .eq(COLUMNS.IS_DELETED, false)
        .order(COLUMNS.UPDATED_AT, { ascending: false });

    if (error) {
        console.error("Error fetching spaces:", error);
        return null;
    }

    // Cache the result
    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACES });
    }

    return data;
}

export async function getSpace(id: string): Promise<Space | null> {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.SPACE(id);
    const cachedSpace = await redis.get<Space>(cacheKey);
    if (cachedSpace) {
        return cachedSpace;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .select("*")
        .eq(COLUMNS.ID, id)
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (error) {
        console.error("Error fetching space:", error);
        return null;
    }

    // Cache the result
    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE });
    }

    return data;
}

export async function createSpace(
    name: string,
    description: string,
    model: string,
    provider: string,
    setActive: boolean,
    color?: string
): Promise<Space | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    const { data: space, error } = await supabase
        .from(DB_TABLES.SPACES)
        .insert([
            {
                [COLUMNS.NAME]: name || DEFAULTS.SPACE_NAME,
                [COLUMNS.DESCRIPTION]: description || '',
                [COLUMNS.USER_ID]: user.id,
                [COLUMNS.MODEL]: model,
                [COLUMNS.PROVIDER]: provider,
                [COLUMNS.COLOR]: color || '#3ecfff',
            },
        ])
        .select()
        .single();

    if (error) {
        console.error("Error creating space:", error);
        return null;
    }

    if (space) {
        // Invalidate spaces cache
        await redis.del(CACHE_KEYS.SPACES(user.id));
        
        if (setActive) {
            await setActiveSpace(space.id);
        }

        // Create a default conversation for the new space
        const timestamp = new Date().toISOString();
        const { data: conversation, error: convError } = await supabase
            .from(DB_TABLES.CONVERSATIONS)
            .insert([{
                space_id: space.id,
                title: "Welcome",
                created_at: timestamp,
                updated_at: timestamp,
                is_deleted: false
            }])
            .select()
            .single();

        if (convError) {
            console.error("Error creating default conversation:", convError);
            // Don't return null here as the space was created successfully
        }

        // Invalidate relevant caches
        await Promise.all([
            redis.del(CACHE_KEYS.SPACE_DATA(space.id)),
            redis.del(CACHE_KEYS.CONVERSATIONS(space.id))
        ]);
    }

    return space;
}

export async function updateSpace(id: string, updates: Partial<Space>): Promise<Space | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .update(updates)
        .eq(COLUMNS.ID, id)
        .eq(COLUMNS.USER_ID, user.id)
        .select()
        .single();

    if (error) {
        console.error('Error updating space:', error);
        return null;
    }

    if (data) {
        // Invalidate related caches
        await Promise.all([
            redis.del(CACHE_KEYS.SPACES(user.id)),
            redis.del(CACHE_KEYS.SPACE(id)),
            redis.del(CACHE_KEYS.ACTIVE_SPACE(user.id)),
            redis.del(CACHE_KEYS.SPACE_DATA(id))
        ]);
    }

    return data;
}

export async function setActiveSpace(spaceId: string): Promise<void> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return;
    }

    const { error: deleteError } = await supabase
        .from(DB_TABLES.ACTIVE_SPACES)
        .delete()
        .eq(COLUMNS.USER_ID, user.id);

    if (deleteError) {
        console.error("Error removing existing active space:", deleteError);
    }

    const { error: insertError } = await supabase
        .from(DB_TABLES.ACTIVE_SPACES)
        .insert({
            [COLUMNS.USER_ID]: user.id,
            [COLUMNS.SPACE_ID]: spaceId
        });

    if (insertError) {
        console.error("Error setting active space:", insertError);
    } else {
        // Update cache
        const space = await getSpace(spaceId);
        if (space) {
            await redis.set(CACHE_KEYS.ACTIVE_SPACE(user.id), space, { ex: CACHE_TTL.ACTIVE_SPACE });
        }
    }
}

export async function getActiveSpace(): Promise<Space | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.ACTIVE_SPACE(user.id);
    const cachedSpace = await redis.get<Space>(cacheKey);
    if (cachedSpace) {
        return cachedSpace;
    }

    const { data: activeSpaceData, error: activeSpaceError } = await supabase
        .from(DB_TABLES.ACTIVE_SPACES)
        .select(COLUMNS.SPACE_ID)
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (activeSpaceError || !activeSpaceData) {
        return null;
    }

    const { data: space, error: spaceError } = await supabase
        .from(DB_TABLES.SPACES)
        .select("*")
        .eq(COLUMNS.ID, activeSpaceData.space_id)
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (spaceError) {
        console.error("Error fetching active space:", spaceError);
        return null;
    }

    // Cache the result
    if (space) {
        await redis.set(cacheKey, space, { ex: CACHE_TTL.ACTIVE_SPACE });
    }

    return space;
}

export interface SpaceData {
    space: Space | null;
    conversations: Conversation[] | null;
    messages: Message[] | null;
    activeConversation: Conversation | null;
}

export async function getSpaceData(spaceId: string): Promise<SpaceData | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    if (!spaceId) {
        return { space: null, conversations: [], messages: null, activeConversation: null };
    }

    const cacheKey = CACHE_KEYS.SPACE_DATA(spaceId);
    const cachedData = await redis.get<SpaceData>(cacheKey);
    if (cachedData) {
        return cachedData;
    }

    const [space, conversations] = await Promise.all([
        supabase
            .from(DB_TABLES.SPACES)
            .select("*")
            .eq(COLUMNS.ID, spaceId)
            .eq(COLUMNS.USER_ID, user.id)
            .single()
            .then(({ data, error }) => {
                if (error) {
                    console.error("Error fetching space:", error);
                    return null;
                }
                return data;
            }),
        supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("*")
            .eq(COLUMNS.SPACE_ID, spaceId)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.UPDATED_AT, { ascending: false })
            .then(({ data, error }) => {
                if (error) {
                    console.error("Error fetching conversations:", error);
                    return [];
                }
                return data || [];
            })
    ]);

    // Get the most recently updated conversation as the active one
    const activeConversation = conversations && conversations.length > 0 ? conversations[0] : null;

    let messages = null;
    if (activeConversation) {
        const { data: messageData, error: messagesError } = await supabase
            .from(DB_TABLES.MESSAGES)
            .select("*")
            .eq('conversation_id', activeConversation.id)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.CREATED_AT, { ascending: true });

        if (messagesError) {
            console.error("Error fetching messages:", messagesError);
        } else {
            messages = messageData;
        }
    }

    const spaceData = { space, conversations, messages, activeConversation };
    await redis.set(cacheKey, spaceData, { ex: CACHE_TTL.SPACE_DATA });
    return spaceData;
}

export async function getConversations(spaceId: string): Promise<Conversation[] | null> {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    if (!spaceId) {
        return [];
    }

    const cacheKey = CACHE_KEYS.CONVERSATIONS(spaceId);
    const cachedConversations = await redis.get<Conversation[]>(cacheKey);
    if (cachedConversations) {
        return cachedConversations;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("*")
        .eq(COLUMNS.SPACE_ID, spaceId)
        .eq(COLUMNS.IS_DELETED, false)
        .order(COLUMNS.UPDATED_AT, { ascending: false });

    if (error) {
        console.error("Error fetching conversations:", error);
        return null;
    }

    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.CONVERSATIONS });
    }

    return data;
}

export async function createConversation(spaceId: string, title?: string): Promise<Conversation | null> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user || !spaceId) {
        console.error("Missing required data for conversation creation");
        return null;
    }

    const timestamp = new Date().toISOString();
    const { data, error } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .insert([{
            space_id: spaceId,
            title: title || DEFAULTS.CONVERSATION_TITLE,
            created_at: timestamp,
            updated_at: timestamp,
            is_deleted: false
        }])
        .select()
        .single();

    if (error) {
        console.error("Error creating conversation:", error);
        return null;
    }

    await redis.del(CACHE_KEYS.SPACE_DATA(spaceId));
    await redis.del(CACHE_KEYS.CONVERSATIONS(spaceId));

    return data;
}

export async function getConversation(id: string): Promise<Conversation | null> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("*")
        .eq(COLUMNS.ID, id)
        .eq(COLUMNS.IS_DELETED, false) // Don't return deleted conversations
        .single();

    if (error) {
        console.error("Error fetching conversation:", error);
        return null;
    }

    return data;
}

export async function getMessages(conversationId: string): Promise<Message[] | null> {
    if (!conversationId) {
        console.error("Invalid conversation ID: Cannot fetch messages without a valid conversation ID");
        return null;
    }

    const cacheKey = CACHE_KEYS.MESSAGES(conversationId);
    const cachedMessages = await redis.get<Message[]>(cacheKey);
    if (cachedMessages) {
        return cachedMessages;
    }

    const supabase = await createClient();
    const { data, error } = await supabase
        .from(DB_TABLES.MESSAGES)
        .select("*")
        .eq('conversation_id', conversationId)
        .eq(COLUMNS.IS_DELETED, false)
        .order(COLUMNS.CREATED_AT, { ascending: true });

    if (error) {
        console.error("Error fetching messages:", error);
        return null;
    }

    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.MESSAGES });
    }

    return data;
}

export async function updateConversationTitle(conversationId: string, title: string): Promise<void> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return;
    }

    // Get the conversation to find its space_id
    const { data: conversation, error: getError } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select('space_id')
        .eq(COLUMNS.ID, conversationId)
        .single();

    if (getError) {
        console.error("Error getting conversation:", getError);
        return;
    }

    // Update the conversation title in the database
    const { error: updateError } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .update({ title })
        .eq(COLUMNS.ID, conversationId);

    if (updateError) {
        console.error("Error updating conversation title:", updateError);
        return;
    }

    // Update all relevant caches
    try {
        // Update conversations cache
        const conversationsCacheKey = CACHE_KEYS.CONVERSATIONS(conversation.space_id);
        const cachedConversations = await redis.get<Conversation[]>(conversationsCacheKey);
        if (cachedConversations) {
            const updatedConversations = cachedConversations.map(conv =>
                conv.id === conversationId ? { ...conv, title } : conv
            );
            await redis.set(conversationsCacheKey, updatedConversations, { ex: CACHE_TTL.CONVERSATIONS });
        }

        // Update space data cache
        const spaceDataCacheKey = CACHE_KEYS.SPACE_DATA(conversation.space_id);
        const cachedSpaceData = await redis.get<SpaceData>(spaceDataCacheKey);
        if (cachedSpaceData?.conversations) {
            const updatedSpaceData = {
                ...cachedSpaceData,
                conversations: cachedSpaceData.conversations.map(conv =>
                    conv.id === conversationId ? { ...conv, title } : conv
                )
            };
            await redis.set(spaceDataCacheKey, updatedSpaceData, { ex: CACHE_TTL.SPACE_DATA });
        }
    } catch (error) {
        console.error("Error updating caches:", error);
    }
}

export async function createMessage(messageData: Partial<Message>, conversationId: string) {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user || !messageData.content || !messageData.role || !conversationId) {
        console.error("Missing required data for message creation");
        return null;
    }

    const timestamp = new Date().toISOString();

    const { data: conversation } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("space_id")
        .eq(COLUMNS.ID, conversationId)
        .single();

    if (!conversation) {
        console.error("Conversation not found");
        return null;
    }

    const [messageResult, updateResult] = await Promise.all([
        supabase
            .from(DB_TABLES.MESSAGES)
            .insert([{
                content: messageData.content,
                role: messageData.role,
                annotations: messageData.annotations,
                user_id: user.id,
                is_deleted: false,
                created_at: timestamp,
                updated_at: timestamp,
                conversation_id: conversationId
            }])
            .select()
            .single(),
        supabase
            .from(DB_TABLES.CONVERSATIONS)
            .update({ updated_at: timestamp })
            .eq(COLUMNS.ID, conversationId)
    ]);

    if (messageResult.error) {
        console.error("Error creating message:", messageResult.error);
        return null;
    }

    // Update messages cache
    const messagesCacheKey = CACHE_KEYS.MESSAGES(conversationId);
    const cachedMessages = await redis.get<Message[]>(messagesCacheKey) || [];
    await redis.set(messagesCacheKey, [...cachedMessages, messageResult.data], { ex: CACHE_TTL.MESSAGES });

    // Update space data cache
    const spaceDataCacheKey = CACHE_KEYS.SPACE_DATA(conversation.space_id);
    const cachedSpaceData = await redis.get<SpaceData>(spaceDataCacheKey);
    if (cachedSpaceData?.messages) {
        cachedSpaceData.messages = [...cachedSpaceData.messages, messageResult.data];
        await redis.set(spaceDataCacheKey, cachedSpaceData, { ex: CACHE_TTL.SPACE_DATA });
    }

    return messageResult.data;
}

export async function sendMessage({ 
  content, 
  spaceId, 
  conversationId, 
  searchMode 
}: { 
  content: string, 
  spaceId: string, 
  conversationId: string, 
  searchMode: string 
}): Promise<any> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      throw new Error("User not authenticated");
    }
    
    // Create the user message
    await createMessage({
      role: 'user',
      content,
    }, conversationId);
    
    // Here you would typically process the message with AI and create an assistant response
    // For now, we'll just create a placeholder response
    await createMessage({
      role: 'assistant',
      content: `You said: ${content}. This is a placeholder response. In a real implementation, this would be a response from the AI model.`,
    }, conversationId);
    
    // Invalidate the messages cache
    await redis.del(CACHE_KEYS.MESSAGES(conversationId));
    
    return { success: true };
  } catch (error) {
    console.error('Error sending message:', error);
    return { success: false, error };
  }
}

export async function switchConversation(conversationId: string): Promise<void> {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      throw new Error("User not authenticated");
    }
    
    // Get the conversation
    const conversation = await getConversation(conversationId);
    
    if (!conversation) {
      throw new Error("Conversation not found");
    }
    
    // Set the conversation's space as active
    await setActiveSpace(conversation.space_id);
    
    // Note: In a real implementation, you might want to track the active conversation as well
    // For now, we'll rely on URL parameters for that
    
    return;
  } catch (error) {
    console.error('Error switching conversation:', error);
    throw error;
  }
}

export const signUpAction = async (formData: FormData) => {
  const email = formData.get("email")?.toString();
  const password = formData.get("password")?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get("origin");

  if (!email || !password) {
    return encodedRedirect(
      "error",
      "/sign-up",
      "Email and password are required",
    );
  }

  const { error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: `${origin}/auth/callback`,
    },
  });

  if (error) {
    console.error(error.code + " " + error.message);
    return encodedRedirect("error", "/sign-up", error.message);
  } else {
    return encodedRedirect(
      "success",
      "/sign-up",
      "Thanks for signing up! Please check your email for a verification link.",
    );
  }
};

export const signInAction = async (formData: FormData) => {
  const email = formData.get("email") as string;
  const password = formData.get("password") as string;
  const supabase = await createClient();

  const { error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    return encodedRedirect("error", "/sign-in", error.message);
  }

  return redirect("/protected");
};

export const forgotPasswordAction = async (formData: FormData) => {
  const email = formData.get("email")?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get("origin");
  const callbackUrl = formData.get("callbackUrl")?.toString();

  if (!email) {
    return encodedRedirect("error", "/forgot-password", "Email is required");
  }

  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${origin}/auth/callback?redirect_to=/protected/reset-password`,
  });

  if (error) {
    console.error(error.message);
    return encodedRedirect(
      "error",
      "/forgot-password",
      "Could not reset password",
    );
  }

  if (callbackUrl) {
    return redirect(callbackUrl);
  }

  return encodedRedirect(
    "success",
    "/forgot-password",
    "Check your email for a link to reset your password.",
  );
};

export const resetPasswordAction = async (formData: FormData) => {
  const supabase = await createClient();

  const password = formData.get("password") as string;
  const confirmPassword = formData.get("confirmPassword") as string;

  if (!password || !confirmPassword) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Password and confirm password are required",
    );
  }

  if (password !== confirmPassword) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Passwords do not match",
    );
  }

  const { error } = await supabase.auth.updateUser({
    password: password,
  });

  if (error) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Password update failed",
    );
  }

  encodedRedirect("success", "/protected/reset-password", "Password updated");
};

export async function deleteSpace(spaceId: string): Promise<void> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new Error('Unauthorized');
  }

  // Soft delete the space
  const { error } = await supabase
    .from(DB_TABLES.SPACES)
    .update({ [COLUMNS.IS_DELETED]: true })
    .eq(COLUMNS.ID, spaceId)
    .eq(COLUMNS.USER_ID, user.id);

  if (error) {
    console.error('Error deleting space:', error);
    throw new Error('Failed to delete space');
  }

  // Delete all messages for this space from Pinecone
  try {
    // Import deleteMessagesBySpaceId from the Pinecone utils
    const { deleteMessagesBySpaceId } = await import('@/utils/pinecone');
    await deleteMessagesBySpaceId(spaceId);
  } catch (pineconeError) {
    console.error('Error deleting messages from Pinecone:', pineconeError);
    // We don't want to fail the whole operation if Pinecone deletion fails
    // Just log the error and continue
  }

  // Clear related cache
  const cacheKeys = [
    CACHE_KEYS.SPACES(user.id),
    CACHE_KEYS.SPACE(spaceId),
    CACHE_KEYS.SPACE_DATA(spaceId),
  ];

  await Promise.all(cacheKeys.map(key => redis.del(key)));
}

export async function deleteConversation(conversationId: string): Promise<void> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    console.error('No user authenticated');
    throw new Error('Unauthorized');
  }


  // Step 1: Fetch conversation to verify it exists and get space_id
  const { data: conversation, error: fetchError } = await supabase
    .from(DB_TABLES.CONVERSATIONS)
    .select(`${COLUMNS.ID}, ${COLUMNS.SPACE_ID}, ${COLUMNS.IS_DELETED}`)
    .eq(COLUMNS.ID, conversationId)
    .single();

  if (fetchError || !conversation) {
    console.error('Fetch error:', fetchError?.message || 'Conversation not found');
    throw new Error('Failed to find conversation');
  }

  console.log(`Found conversation: ID=${conversation[COLUMNS.ID]}, space_id=${conversation[COLUMNS.SPACE_ID]}, is_deleted=${conversation[COLUMNS.IS_DELETED]}`);

  if (conversation[COLUMNS.IS_DELETED]) {
    console.log('Conversation is already deleted, no update needed');
    return;
  }

  // Step 2: Verify space ownership (redundant with RLS, but kept for safety)
  const spaceId = conversation[COLUMNS.SPACE_ID];
  const { data: space, error: spaceError } = await supabase
    .from(DB_TABLES.SPACES)
    .select('id')
    .eq(COLUMNS.ID, spaceId)
    .eq(COLUMNS.USER_ID, user.id)
    .single();

  if (spaceError || !space) {
    console.error('Space verification error:', spaceError?.message || 'Space not found or not owned by user');
    throw new Error('Unauthorized: Space does not belong to user');
  }

  console.log(`Verified space ownership for space_id: ${spaceId}`);

  // Step 3: Perform the soft delete
  const { data: updateData, error: deleteError } = await supabase
    .from(DB_TABLES.CONVERSATIONS)
    .update({ 
      [COLUMNS.IS_DELETED]: true, 
      [COLUMNS.UPDATED_AT]: new Date().toISOString() 
    })
    .eq(COLUMNS.ID, conversationId)
    .select();

  if (deleteError) {
    console.error('Delete error:', deleteError.message);
    throw new Error(`Failed to delete conversation: ${deleteError.message}`);
  }

  if (!updateData || updateData.length === 0) {
    console.error('No rows updated - RLS or data issue persists');
    throw new Error('No rows updated');
  }

  console.log('Conversation successfully deleted:', updateData);

  // Step 4: Delete the messages from Pinecone as well
  try {
    // Import deleteMessagesByConversationId from the Pinecone utils
    const { deleteMessagesByConversationId } = await import('@/utils/pinecone');
    await deleteMessagesByConversationId(conversationId);
    console.log(`Successfully deleted messages from Pinecone for conversation: ${conversationId}`);
  } catch (pineconeError) {
    console.error('Error deleting messages from Pinecone:', pineconeError);
    // We don't want to fail the whole operation if Pinecone deletion fails
    // Just log the error and continue
  }

  const cacheKeys = [
    CACHE_KEYS.CONVERSATIONS(spaceId),        
    CACHE_KEYS.SPACE_DATA(spaceId),            
  ];

  try {
    await Promise.all(cacheKeys.map(key => redis.del(key)));
    console.log(`Cleared caches: ${cacheKeys.join(', ')}`);
  } catch (cacheError) {
    console.error('Error invalidating caches:', cacheError);
  }
}

export async function searchMessages(searchTerm: string, searchScope: string, searchMode: string, conversationId?: string, spaceId?: string, limit = 50): Promise<any> {
  if (!searchTerm || searchTerm.length < 2) {
    return { results: [] };
  }

  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      throw new Error("Unauthorized");
    }

    // Validate scope
    if (searchScope === 'conversation' && !conversationId) {
      throw new Error("Conversation ID is required for conversation scope");
    }

    if (searchScope === 'space' && !spaceId) {
      throw new Error("Space ID is required for space scope");
    }

    // For keyword search
    if (searchMode === 'keyword') {
      let messagesQuery;
      
      if (searchScope === 'conversation') {
        // Ensure user has access to this conversation
        const { data: conversation, error: convError } = await supabase
          .from(DB_TABLES.CONVERSATIONS)
          .select("*")
          .eq(COLUMNS.ID, conversationId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (convError || !conversation) {
          throw new Error("Conversation not found");
        }
        
        // Search within the specific conversation
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title)
          `)
          .eq(COLUMNS.CONVERSATION_ID, conversationId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        return {
          results: (messages || []).map(msg => ({
            id: msg.id,
            content: msg.content,
            role: msg.role,
            createdAt: new Date(msg.created_at).getTime(),
            conversationId: msg.conversation_id,
            conversationTitle: msg.conversation.title || 'New Conversation',
          }))
        };
      } else if (searchScope === 'space') {
        // Ensure user has access to this space
        const { data: space, error: spaceError } = await supabase
          .from(DB_TABLES.SPACES)
          .select("*")
          .eq(COLUMNS.ID, spaceId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (spaceError || !space) {
          throw new Error("Space not found");
        }
        
        // Search across all conversations in the space
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title, space_id)
          `)
          .eq("conversation.space_id", spaceId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        return {
          results: (messages || [])
            .filter(msg => msg.conversation) // Filter out messages with invalid conversations
            .map(msg => ({
              id: msg.id,
              content: msg.content,
              role: msg.role,
              createdAt: new Date(msg.created_at).getTime(),
              conversationId: msg.conversation_id,
              conversationTitle: msg.conversation.title || 'New Conversation',
            }))
        };
      }
    } else {
      // Semantic search implementation
      // Note: Without a proper vector DB setup, we'll fallback to a keyword search
      // but simulate semantic search with mock scores
      
      let messagesQuery;
      
      if (searchScope === 'conversation') {
        // Ensure user has access to this conversation
        const { data: conversation, error: convError } = await supabase
          .from(DB_TABLES.CONVERSATIONS)
          .select("*")
          .eq(COLUMNS.ID, conversationId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (convError || !conversation) {
          throw new Error("Conversation not found");
        }
        
        // Search within the specific conversation
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title)
          `)
          .eq(COLUMNS.CONVERSATION_ID, conversationId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        // Add mock semantic scores
        return {
          results: (messages || []).map((msg, index) => {
            // Generate a fake score between 0.6 and 0.95
            const fakeScore = 0.95 - (index * 0.05);
            const score = Math.max(0.6, fakeScore);
            
            return {
              id: msg.id,
              content: msg.content,
              role: msg.role,
              createdAt: new Date(msg.created_at).getTime(),
              conversationId: msg.conversation_id,
              conversationTitle: msg.conversation.title || 'New Conversation',
              score,
            };
          })
        };
      } else if (searchScope === 'space') {
        // Ensure user has access to this space
        const { data: space, error: spaceError } = await supabase
          .from(DB_TABLES.SPACES)
          .select("*")
          .eq(COLUMNS.ID, spaceId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (spaceError || !space) {
          throw new Error("Space not found");
        }
        
        // Search across all conversations in the space
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title, space_id)
          `)
          .eq("conversation.space_id", spaceId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        // Add mock semantic scores
        return {
          results: (messages || [])
            .filter(msg => msg.conversation)
            .map((msg, index) => {
              // Generate a fake score between 0.6 and 0.95
              const fakeScore = 0.95 - (index * 0.05);
              const score = Math.max(0.6, fakeScore);
              
              return {
                id: msg.id,
                content: msg.content,
                role: msg.role,
                createdAt: new Date(msg.created_at).getTime(),
                conversationId: msg.conversation_id,
                conversationTitle: msg.conversation.title || 'New Conversation',
                score,
              };
            })
        };
      }
    }

    return { results: [] };
  } catch (error) {
    console.error('Error searching messages:', error);
    throw error;
  }
}

export type SpaceActionType = 
  | 'created'
  | 'deleted'
  | 'updated'
  | 'model_changed'
  | 'conversation_added'
  | 'conversation_deleted';

export interface SpaceHistoryEntry {
  id: string;
  space_id: string;
  user_id: string;
  action_type: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  created_at: string;
}

export interface CreateSpaceHistoryOptions {
  spaceId: string;
  actionType: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
}

export async function createSpaceHistory({
  spaceId,
  actionType,
  title,
  description,
  metadata
}: CreateSpaceHistoryOptions): Promise<SpaceHistoryEntry | null> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return null;
  }

  const { data, error } = await supabase
    .from('space_history')
    .insert([{
      space_id: spaceId,
      user_id: user.id,
      action_type: actionType,
      title,
      description,
      metadata
    }])
    .select()
    .single();

  if (error) {
    console.error("Error creating space history entry:", error);
    return null;
  }

  // Update space history cache
  const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
  const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey) || [];
  await redis.set(cacheKey, [data, ...cachedHistory], { ex: CACHE_TTL.SPACE_HISTORY });

  return data;
}

export async function getSpaceHistory(spaceId: string, limit = 50): Promise<SpaceHistoryEntry[]> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return [];
  }

  // Try to get from cache first
  const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
  const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey);
  if (cachedHistory) {
    return cachedHistory;
  }

  const { data, error } = await supabase
    .from('space_history')
    .select("*")
    .eq("space_id", spaceId)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (error) {
    console.error("Error fetching space history:", error);
    return [];
  }

  // Cache the result
  if (data) {
    await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE_HISTORY });
  }

  return data;
}

export type NotificationType = 
  | 'space_created'
  | 'space_deleted'
  | 'model_changed'
  | 'conversation_created'
  | 'conversation_deleted';

export interface Notification {
  id: string;
  user_id: string;
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  is_read: boolean;
  created_at: string;
  updated_at: string;
}

export interface CreateNotificationOptions {
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  isInApp?: boolean; // If true, notification will be marked as read automatically
}

export async function createNotification({
  type,
  title,
  description,
  metadata,
  isInApp = true // Default to true for backward compatibility
}: CreateNotificationOptions): Promise<Notification | null> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return null;
  }

  const { data, error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .insert([{
      user_id: user.id,
      type,
      title,
      description,
      metadata,
      is_read: isInApp, // Automatically mark as read if it's an in-app notification
    }])
    .select()
    .single();

  if (error) {
    console.error("Error creating notification:", error);
    return null;
  }

  // Update notifications cache
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey) || [];
  await redis.set(cacheKey, [data, ...cachedNotifications], { ex: CACHE_TTL.NOTIFICATIONS });

  return data;
}

export async function getNotifications(limit = 50): Promise<Notification[]> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return [];
  }

  // Try to get from cache first
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey);
  if (cachedNotifications) {
    return cachedNotifications;
  }

  const { data, error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .select("*")
    .eq("user_id", user.id)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (error) {
    console.error("Error fetching notifications:", error);
    return [];
  }

  // Cache the result
  if (data) {
    await redis.set(cacheKey, data, { ex: CACHE_TTL.NOTIFICATIONS });
  }

  return data;
}

export async function markNotificationAsRead(notificationId: string): Promise<boolean> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return false;
  }

  const { error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .update({ is_read: true })
    .eq("id", notificationId)
    .eq("user_id", user.id);

  if (error) {
    console.error("Error marking notification as read:", error);
    return false;
  }

  // Update cache
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey);
  if (cachedNotifications) {
    const updatedNotifications = cachedNotifications.map(n =>
      n.id === notificationId ? { ...n, is_read: true } : n
    );
    await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
  }

  return true;
}

export async function markAllNotificationsAsRead(): Promise<boolean> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return false;
  }

  const { error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .update({ is_read: true })
    .eq("user_id", user.id)
    .eq("is_read", false);

  if (error) {
    console.error("Error marking all notifications as read:", error);
    return false;
  }

  // Update cache
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey);
  if (cachedNotifications) {
    const updatedNotifications = cachedNotifications.map(n => ({ ...n, is_read: true }));
    await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
  }

  return true;
}

export const signOutAction = async () => {
  const supabase = await createClient();
  
  try {
    // Clear all redis cache for the user
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      await Promise.all([
        redis.del(CACHE_KEYS.SPACES(user.id)),
        redis.del(CACHE_KEYS.ACTIVE_SPACE(user.id)),
        redis.del(CACHE_KEYS.NOTIFICATIONS(user.id))
      ]);
    }

    // Sign out from Supabase
    await supabase.auth.signOut();

    // No need to return redirect since we handle navigation client-side
    return { success: true };
  } catch (error) {
    console.error('Error during sign out:', error);
    return { success: false, error };
  }
};

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@keyframes command-item-click {
  0% {
    box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.05);
  }
  15% {
    box-shadow: 0 0 20px 4px rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.15);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
    border-color: rgba(255, 255, 255, 0.05);
  }
}

.glass-effect {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(12px);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease;
}

.glass-effect:hover {
  background: rgba(255, 255, 255, 0.04);
  border-color: rgba(255, 255, 255, 0.08);
}

.glass-effect .header {
  background: rgba(255, 255, 255, 0.03);
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

/* Style modifications for code with glass effect */
.glass-effect pre, 
.glass-effect code, 
.glass-effect .shiki {
  background: transparent !important;
  backdrop-filter: none !important;
  box-shadow: none !important;
}

/* Add a subtle blue glow to code blocks for emphasis */
.code-block-glow {
  box-shadow: 0 0 20px rgba(0, 150, 255, 0.05);
}

/* Create a better glass effect specifically for code blocks */
.glass-code-content {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.02) 100%);
  border-radius: 0 0 0.5rem 0.5rem;
  background: transparent !important;
}

/* Forcefully remove all backgrounds from code elements */
.glass-highlight,
.glass-highlight *,
.glass-highlight .shiki,
.glass-highlight .shiki *,
.glass-highlight pre,
.glass-highlight code,
.glass-highlight .line {
  background: transparent !important;
  background-color: transparent !important;
  box-shadow: none !important;
}

/* Additional styles to ensure code content shows up well on a transparent background */
.glass-highlight .shiki {
  color: rgba(255, 255, 255, 0.9) !important;
}

/* Remove any box-shadow within code blocks that might give a gray appearance */
.shiki, 
.shiki span, 
.shiki div {
  box-shadow: none !important;
  background: transparent !important;
}

/* Force all background colors in syntax highlighting to be transparent */
[class*="mtk"], 
[class*="token"] {
  background: transparent !important;
}

/* Improve token visibility on glass background */
.glass-effect .token.comment,
.glass-effect .token.prolog,
.glass-effect .token.doctype,
.glass-effect .token.cdata {
  color: rgba(128, 147, 166, 0.8) !important;
}

.glass-effect .token.punctuation {
  color: rgba(192, 202, 212, 0.8) !important;
}

.glass-effect .token.property,
.glass-effect .token.tag,
.glass-effect .token.boolean,
.glass-effect .token.number,
.glass-effect .token.constant,
.glass-effect .token.symbol {
  color: rgba(121, 182, 242, 0.9) !important;
}

.glass-effect .token.selector,
.glass-effect .token.attr-name,
.glass-effect .token.string,
.glass-effect .token.char,
.glass-effect .token.builtin {
  color: rgba(126, 231, 135, 0.9) !important;
}

.glass-effect .token.operator,
.glass-effect .token.entity,
.glass-effect .token.url,
.glass-effect .language-css .token.string,
.glass-effect .style .token.string {
  color: rgba(255, 203, 139, 0.9) !important;
}

.glass-effect .token.keyword {
  color: rgba(224, 108, 117, 0.9) !important;
}

.animate-command-item-click {
  animation: command-item-click 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

:root {
  color-scheme: dark;
  --surface: #151515;
  --surface-elevated: #1f1f1f;
  --primary: #5E6AD2;
  --primary-light: #8A94F0;
  --text: #FFFFFF;
  --text-secondary: rgba(255, 255, 255, 0.6);
  --border: rgba(255, 255, 255, 0.1);
  --radius: 0.5rem;
}

body {
  margin: 0;
  overflow: hidden;
  font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
  scroll-behavior: smooth;
}

input, textarea {
  background: transparent;
  color: var(--text);
  font-size: 14px;
  line-height: 1.5;
  transition: all 0.2s ease;
}

input:focus, textarea:focus {
  outline: none;
  background: rgba(255, 255, 255, 0.03);
}

.btn {
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.btn-primary {
  background: var(--primary);
  color: white;
}

.btn-primary:hover {
  background: var(--primary-light);
}

::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.15);
}

.command-content {
  transition: opacity 0.2s ease, transform 0.2s ease;
}

.command-content-enter {
  opacity: 0;
  transform: translateY(10px);
}

.command-content-exit {
  opacity: 0;
  transform: translateY(-10px);
}

/* Updated shine effect for modern look */
.dark {
  [cmdk-root]:after {
    content: '';
    background: linear-gradient(
      45deg,
      rgba(62, 207, 255, 0.03) 0%,
      rgba(62, 207, 255, 0.05) 25%,
      rgba(62, 207, 255, 0.1) 50%,
      rgba(62, 207, 255, 0.05) 75%,
      rgba(62, 207, 255, 0.03) 100%
    );
    z-index: -1;
    position: absolute;
    border-radius: 12px;
    top: -1px;
    left: -1px;
    width: calc(100% + 2px);
    height: calc(100% + 2px);
    animation: shine 3s ease infinite;
    background-size: 200% 200%;
  }

  [cmdk-item][data-selected="true"]:after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 8px;
    padding: 1px;
    background: linear-gradient(
      to right,
      rgba(62, 207, 255, 0.1),
      rgba(255, 255, 255, 0.1)
    );
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
  }
}

/* Animations (added to global scope)*/

@keyframes border {
  to {
    box-shadow: 0 0 0 1px var(--gray6); /* Using your existing --gray6 */
  }
}
@keyframes loadingDots {
  0% { content: '.' }
  33% { content: '..' }
  66% { content: '...' }
  100% { content: '.' }
}

.loading-dots::after {
  content: '.';
  display: inline-block;
  animation: loadingDots 1.5s infinite;
}

@keyframes showTopShine {
    to {
      opacity: 1;
    }
  }

/* Loading animation, adapted for Tailwind */
@keyframes loading {
  0% {
    opacity: 0;
    transform: translateX(0);
  }
  50% {
    opacity: 1;
    transform: translateX(100%);
  }
  100% {
    opacity: 0;
    transform: translateX(0);
  }
}

/* add these in if needed in components*/
/*.cmdk-loading-placeholder, .cmdk-loading-spinner {}*/

/* Added Keyframes */
/* For consistency, I'm adding slideIn/slideOut here even if not used *yet*. */
@keyframes slideIn {
 0% {
  opacity: 0;
  transform: scale(0.96);
 }

 100% {
  opacity: 1;
  transform: scale(1);
 }
}

@keyframes slideOut {
 0% {
  opacity: 1;
  transform: scale(1);
 }

 100% {
  opacity: 0;
  transform: scale(0.96);
 }
}

/* Add additional custom variables as needed*/
:root {
   /* ...other variables...*/
    --cmdk-shadow: 0 16px 70px rgb(0 0 0 / 20%); /* Example, might need adjustment */

}

/* Tailwind config or separate CSS file */
@keyframes rotate-slow {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes halo-pulse {
  0% { transform: scale(1); opacity: 0.6; }
  50% { transform: scale(1.1); opacity: 0.8; }
  100% { transform: scale(1); opacity: 0.6; }
}

@keyframes pulse-slow {
  0% { opacity: 0.4; }
  50% { opacity: 0.7; }
  100% { opacity: 0.4; }
}

@keyframes shimmer {
  0% { background-position: 0% 50%; }
  100% { background-position: 100% 50%; }
}

@keyframes bounce-slow {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes glow {
  0% { box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.8); }
  50% { box-shadow: inset 0 0 12px rgba(255, 255, 255, 1); }
  100% { box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.8); }
}

@keyframes float {
  0% { transform: translateY(0) translateX(0); opacity: 0.5; }
  50% { transform: translateY(-2px) translateX(1px); opacity: 0.7; }
  100% { transform: translateY(0) translateX(0); opacity: 0.5; }
}

/* Apply animation durations */
.animate-rotate-slow { animation: rotate-slow 10s linear infinite; }
.animate-halo-pulse { animation: halo-pulse 4s ease-in-out infinite; }
.animate-pulse-slow { animation: pulse-slow 6s ease-in-out infinite; }
.animate-shimmer { animation: shimmer 3s linear infinite; }
.animate-bounce-slow { animation: bounce-slow 4s ease-in-out infinite; }
.animate-glow { animation: glow 3s ease-in-out infinite; }
.animate-float { animation: float 3s ease-in-out infinite; }

@layer base {}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Override code highlighter background */
.shiki, 
.shiki *, 
pre[class*="language-"],
code[class*="language-"],
pre[class*="shiki"],
code[class*="shiki"] {
  background: transparent !important;
  background-color: transparent !important;
}

/* Remove background from the root element */
.glass-effect, 
.code-block-glow,
.glass-code-content,
.glass-highlight {
  --glass-bg: rgba(255, 255, 255, 0.02);
  --glass-border: rgba(255, 255, 255, 0.05);
  --glass-shadow: rgba(0, 0, 0, 0.1);
  background: var(--glass-bg) !important;
  border: 1px solid var(--glass-border) !important;
  backdrop-filter: blur(12px) !important;
}

/* Ensure root elements of glass containers are transparent */
.glass-effect > div, 
.code-block-glow > div,
.glass-code-content > div, 
.glass-highlight > div {
  background-color: transparent !important;
}

/* Ensure all child elements of glass containers are also transparent 
   while preserving foreground colors for syntax highlighting */
.glass-effect > *, 
.code-block-glow > *,
.glass-code-content > *, 
.glass-highlight > * {
  background-color: transparent !important;
}

/* Special rule to handle Shiki line backgrounds */
.shiki .line {
  background: transparent !important;
}

/* Make line numbers more subtle */
.shiki .line-number {
  color: rgba(255, 255, 255, 0.3) !important;
}

/* Special styles for Shiki span tokens */
.glass-effect .shiki span[style],
.code-block-glow .shiki span[style],
.glass-highlight .shiki span[style] {
  background: transparent !important;
}

/* Add specific styling for Shiki tokens to enhance readability on glass backgrounds */
.glass-effect .shiki span[style] {
  color: inherit;
}

.glass-effect .shiki .line {
  background: transparent !important;
}

.glass-effect .shiki .line:hover {
  background: rgba(255, 255, 255, 0.04) !important;
}

.glass-effect .shiki {
  background: transparent !important;
  color: rgba(255, 255, 255, 0.85) !important;
}

/* Colors for different syntax tokens optimized for glass background */
.glass-effect .shiki .mtk1 { color: rgba(230, 237, 243, 0.85) !important; }  /* Default text */
.glass-effect .shiki .mtk2 { color: rgba(121, 184, 255, 0.85) !important; }  /* Keywords, variables */
.glass-effect .shiki .mtk3 { color: rgba(126, 231, 135, 0.85) !important; }  /* Strings */
.glass-effect .shiki .mtk4 { color: rgba(224, 108, 117, 0.85) !important; }  /* Numbers, boolean */
.glass-effect .shiki .mtk5 { color: rgba(209, 154, 102, 0.85) !important; }  /* Function names */
.glass-effect .shiki .mtk6 { color: rgba(180, 142, 173, 0.85) !important; }  /* Classes, types */
.glass-effect .shiki .mtk7 { color: rgba(127, 127, 127, 0.85) !important; }  /* Comments */
.glass-effect .shiki .mtk8 { color: rgba(255, 203, 139, 0.85) !important; }  /* Operators */

/* Enhanced command item styles to ensure hover effects work */
[cmdk-item] {
  cursor: pointer !important;
  transition: all 0.2s ease !important;
  position: relative !important;
}

[cmdk-item]:hover {
  transform: translateY(-1px);
  background: rgba(255, 255, 255, 0.04) !important;
  backdrop-filter: blur(4px) !important;
}

[cmdk-item]:active {
  transform: translateY(1px);
}

/* Subtle shimmer animation for selected items */
[cmdk-item][data-selected="true"]::before {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.03);
  pointer-events: none;
  border-radius: 0.375rem;
  backdrop-filter: blur(8px);
}

/* Enhanced glass effect styling */
.glass-effect {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(12px);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease;
}

.glass-effect:hover {
  background: rgba(255, 255, 255, 0.04);
  border-color: rgba(255, 255, 255, 0.08);
}

.glass-effect .header {
  background: rgba(255, 255, 255, 0.03);
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

/* Enhanced Command Center styling */
[cmdk-dialog] {
  animation: command-dialog-overlay 0.2s ease-out;
}

@keyframes command-dialog-overlay {
  0% {
    background: transparent;
  }
  100% {
    background: transparent;
  }
}

[cmdk-dialog] [cmdk-root] {
  animation: command-dialog-content 0.2s ease-out;
  transform-origin: center center;
}

@keyframes command-dialog-content {
  0% {
    opacity: 0;
    transform: scale(0.98);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

[cmdk-root] {
  position: relative;
}

[cmdk-root]:before {
  content: '';
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: 0.75rem;
  padding: 1px;
  background: linear-gradient(
    135deg,
    rgba(255, 255, 255, 0.02) 0%,
    rgba(255, 255, 255, 0.04) 50%,
    rgba(255, 255, 255, 0.02) 100%
  );
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.6;
}

[cmdk-item] {
  position: relative;
  height: auto;
  transform-origin: center;
  transition: all 0.2s ease;
}

[cmdk-item]:hover {
  transform: translateY(-1px);
  background: rgba(255, 255, 255, 0.04) !important;
  backdrop-filter: blur(4px) !important;
}

[cmdk-item]:active {
  transform: translateY(1px);
}

/* Subtle shimmer animation for selected items */
[cmdk-item][data-selected="true"]::before {
  content: '';
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.03);
  pointer-events: none;
  border-radius: 0.375rem;
  backdrop-filter: blur(8px);
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Common glassy UI styling */
.glass-panel {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.05);
  transition: all 0.2s ease;
}

.glass-panel:hover {
  background: rgba(255, 255, 255, 0.03);
}

.glass-border {
  border: 1px solid rgba(255, 255, 255, 0.05);
}

.glass-border-hover:hover {
  border-color: rgba(255, 255, 255, 0.08);
}

.glass-item-hover:hover {
  background: rgba(255, 255, 255, 0.03);
}

.glass-text {
  color: rgba(255, 255, 255, 0.9);
}

.glass-text-secondary {
  color: rgba(255, 255, 255, 0.7);
}

.glass-text-tertiary {
  color: rgba(255, 255, 255, 0.5);
}

.glass-input {
  background: transparent;
  border: 1px solid rgba(255, 255, 255, 0.05);
  color: rgba(255, 255, 255, 0.9);
}

.glass-input:focus {
  background: rgba(255, 255, 255, 0.03);
  border-color: rgba(255, 255, 255, 0.1);
}

/* Command Center Dialog styles */
[cmdk-dialog] {
  animation: command-dialog-overlay 0.2s ease-out;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
}

@keyframes command-dialog-overlay {
  0% {
    background: transparent;
  }
  100% {
    background: transparent;
  }
}

[cmdk-dialog] [cmdk-root] {
  animation: command-dialog-content 0.2s ease-out;
  max-width: 640px;
  width: 100%;
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-radius: 0.75rem;
  overflow: hidden;
  backdrop-filter: blur(12px);
}

@keyframes command-dialog-content {
  0% {
    opacity: 0;
    transform: scale(0.98);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

[cmdk-input] {
  border: none;
  width: 100%;
  font-size: 0.875rem;
  padding: 0.75rem 1rem;
  outline: none;
  background: transparent;
  color: rgba(255, 255, 255, 0.9);
}

[cmdk-input]::placeholder {
  color: rgba(255, 255, 255, 0.4);
}

[cmdk-item] {
  content-visibility: auto;
  cursor: pointer;
  height: auto;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;
  color: rgba(255, 255, 255, 0.8);
  user-select: none;
  will-change: background, color;
  transition: all 0.15s ease;
  position: relative;
  margin: 0.2rem 0;
}

[cmdk-item][data-selected="true"] {
  background: rgba(255, 255, 255, 0.05);
  color: rgba(255, 255, 255, 1);
}

[cmdk-item]:hover {
  background: rgba(255, 255, 255, 0.05);
  color: rgba(255, 255, 255, 1);
  backdrop-filter: blur(4px);
}

[cmdk-item]:active {
  background: rgba(255, 255, 255, 0.06);
  color: white;
}

[cmdk-group-heading] {
  user-select: none;
  font-size: 0.75rem;
  color: rgba(255, 255, 255, 0.6);
  padding: 0.5rem 0.75rem;
  display: flex;
  align-items: center;
}

/* Updated to remove "none" from backdrop-filter */
.glass-effect,
.glass-effect:hover,
.glass-item-hover:hover,
[cmdk-item]:hover,
[cmdk-item][data-selected="true"]::before {
  backdrop-filter: blur(12px);
}

/* Override existing animations */
@keyframes command-dialog-overlay {
  0%, 100% {
    background: transparent;
  }
}

/* Custom animation for the root element */
[cmdk-root]:before {
  content: '';
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: 0.75rem;
  padding: 1px;
  background: linear-gradient(
    135deg,
    rgba(255, 255, 255, 0.02) 0%,
    rgba(255, 255, 255, 0.04) 50%,
    rgba(255, 255, 255, 0.02) 100%
  );
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.7;
}

/* Dialog styling to match command center */
.glass-dialog:before {
  content: '';
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: 0.75rem;
  padding: 1px;
  background: linear-gradient(
    135deg,
    rgba(255, 255, 255, 0.02) 0%,
    rgba(255, 255, 255, 0.04) 50%,
    rgba(255, 255, 255, 0.02) 100%
  );
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.7;
}

/* Dialog animations */
@keyframes dialog-content-in {
  0% {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
  100% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
}

@keyframes dialog-content-out {
  0% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
  100% {
    opacity: 0;
    transform: translate(-50%, -48%) scale(0.96);
  }
}

.glass-dialog button {
  transition: all 0.2s ease;
}

.glass-dialog button:not([data-variant="primary"]):hover {
  background: rgba(255, 255, 255, 0.05);
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Toaster } from "@/components/ui/common/toaster";
import { CommandProvider } from "@/hooks/useCommandCenter";
import CommandRoot from "@/components/CommandRoot";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Vinci",
  description: "Vinci App",
};
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

================
File: app/page.tsx
================
import { redirect } from "next/navigation";
import { createClient } from "@/utils/supabase/server";
import CommandButton, { TypedCommandButton } from "@/components/CommandButton";
import { MessageSquare, Users, Brain, Play } from 'lucide-react';

export default async function Home() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  // If user is logged in, redirect to conversations
  if (user) {
    redirect("/conversations");
  }

  // Otherwise redirect to sign in
  redirect("/sign-in");
}

================
File: components/ui/auth/form-message.tsx
================
export type Message =
  | { success: string }
  | { error: string }
  | { message: string };

export function FormMessage({ message }: { message: Message }) {
  return (
    <div className="flex flex-col gap-2 w-full max-w-md text-sm">
      {"success" in message && (
        <div className="text-foreground border-l-2 border-foreground px-4">
          {message.success}
        </div>
      )}
      {"error" in message && (
        <div className="text-destructive-foreground border-l-2 border-destructive-foreground px-4">
          {message.error}
        </div>
      )}
      {"message" in message && (
        <div className="text-foreground border-l-2 px-4">{message.message}</div>
      )}
    </div>
  );
}

================
File: components/ui/auth/header-auth.tsx
================
import { hasEnvVars } from "@/utils/supabase/check-env-vars";
import Link from "next/link";
import { Badge } from "../common/badge";
import { Button } from "../common/button";
import { createClient } from "@/utils/supabase/server";
import { UserProfileDropdown } from "./user-profile-dropdown";

export default async function AuthButton() {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!hasEnvVars) {
    return (
      <>
        <div className="flex gap-4 items-center">
          <div>
            <Badge
              variant={"default"}
              className="font-normal pointer-events-none"
            >
              Please update .env.local file with anon key and url
            </Badge>
          </div>
          <div className="flex gap-2">
            <Button
              size="sm"
              variant={"ghost"}
              disabled
              className="opacity-75 cursor-none pointer-events-none"
            >
              <Link href="/sign-in">Sign in</Link>
            </Button>
            <Button
              size="sm"
              variant={"default"}
              disabled
              className="opacity-75 cursor-none pointer-events-none"
            >
              <Link href="/sign-up">Sign up</Link>
            </Button>
          </div>
        </div>
      </>
    );
  }
  return user ? (
    <UserProfileDropdown user={user} />
  ) : (
    <div className="flex gap-2">
      <Button size="sm" variant={"ghost"}>
        <Link href="/sign-in">Sign in</Link>
      </Button>
      <Button size="sm" variant={"default"}>
        <Link href="/sign-up">Sign up</Link>
      </Button>
    </div>
  );
}

================
File: components/ui/auth/submit-button.tsx
================
"use client";

import { Button } from "@/components/ui/common/button";
import { type ComponentProps } from "react";
import { useFormStatus } from "react-dom";

type Props = ComponentProps<typeof Button> & {
  pendingText?: string;
};

export function SubmitButton({
  children,
  pendingText = "Submitting...",
  ...props
}: Props) {
  const { pending } = useFormStatus();

  return (
    <Button type="submit" aria-disabled={pending} {...props}>
      {pending ? pendingText : children}
    </Button>
  );
}

================
File: components/ui/auth/user-profile-dropdown.tsx
================
'use client'

import { useState, useEffect } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { Bell, LogOut, User as UserIcon, Settings } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/common/avatar";
import { Button } from "@/components/ui/common/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/common/dropdown-menu";
import { cn } from "@/lib/utils";
import { User } from '@supabase/supabase-js';
import { signOutAction } from '@/app/actions/auth';
import { getNotifications, markAllNotificationsAsRead, markNotificationAsRead } from '@/app/actions/notifications';

interface UserProfileDropdownProps {
  user: User;
  initialNotifications?: any[];
}

export function UserProfileDropdown({ user, initialNotifications = [] }: UserProfileDropdownProps) {
  const [unreadCount, setUnreadCount] = useState(0);
  const [isOpen, setIsOpen] = useState(false);
  const [showNotifications, setShowNotifications] = useState(false);
  const [notifications, setNotifications] = useState<any[]>(initialNotifications);

  useEffect(() => {
    if (notifications) {
      const unreadNotifications = notifications.filter(
        (notification) => !notification.is_read
      );
      setUnreadCount(unreadNotifications.length);
    }
  }, [notifications]);
  
  const handleMarkAsRead = async (notificationId: string) => {
    await markNotificationAsRead(notificationId);
    const notificationsResponse = await getNotifications();
    if (notificationsResponse.status === 'success') { 
      setNotifications(notificationsResponse.data || []);
    }
  };

  const handleMarkAllAsRead = async () => {
    await markAllNotificationsAsRead();
    const notificationsResponse = await getNotifications();
    if (notificationsResponse.status === 'success') {
      setNotifications(notificationsResponse.data || []);
    }
  };
  
  const router = useRouter();
  const userInitials = user.email
    ? user.email.substring(0, 2).toUpperCase()
    : '??';

  const handleLogout = async () => {
    router.push('/sign-in');
    await signOutAction();
  };

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="relative h-10 w-10 rounded-full border border-white/[0.05] bg-white/[0.03] hover:bg-white/[0.05] transition-all duration-200"
          aria-label="User profile"
        >
          {unreadCount > 0 && (
            <span className="absolute right-0 top-0 flex h-3 w-3">
              <span className="absolute inline-flex h-full w-full animate-ping rounded-full bg-cyan-400 opacity-75"></span>
              <span className="relative inline-flex h-3 w-3 rounded-full bg-cyan-500"></span>
            </span>
          )}
          <Avatar>
            <AvatarImage src={user.user_metadata.avatar_url} alt={user.email || ''} />
            <AvatarFallback>{userInitials}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56">
        <DropdownMenuLabel>
          <div className="flex flex-col space-y-1.5">
            <p className="text-sm font-medium leading-none text-white/90 truncate max-w-[200px]">
              {user.user_metadata.full_name || user.email}
            </p>
            <p className="text-xs leading-none text-white/40 truncate max-w-[200px]">
              {user.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuGroup>
          <DropdownMenuItem 
            onClick={(e) => {
              e.preventDefault();
              setShowNotifications(!showNotifications);
            }}
            className="cursor-pointer"
          >
            <Bell className="mr-2 h-4 w-4" />
            <span>Notifications</span>
            {unreadCount > 0 && (
              <div className="ml-auto flex h-5 w-5 items-center justify-center rounded-full bg-cyan-500 text-xs">
                {unreadCount}
              </div>
            )}
          </DropdownMenuItem>
          {showNotifications && (
            <>
              {unreadCount > 0 && (
                <div className="px-3 py-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-auto p-1 text-xs text-white/70 hover:text-white hover:bg-white/[0.05]"
                    onClick={handleMarkAllAsRead}
                  >
                    Mark all as read
                  </Button>
                </div>
              )}
              <div className="max-h-48 overflow-y-auto">
                {notifications.length === 0 ? (
                  <div className="px-3 py-2 text-sm text-white/50">
                    No notifications
                  </div>
                ) : (
                  notifications.map((notification) => (
                    <div
                      key={notification.id}
                      className={cn(
                        'px-3 py-2 text-sm hover:bg-white/[0.05] transition-colors',
                        !notification.is_read && 'bg-white/[0.03]'
                      )}
                    >
                      <div className="flex items-center justify-between gap-2">
                        <div className="font-medium text-white/90">{notification.title}</div>
                        {!notification.is_read && (
                          <Button
                            variant="ghost"
                            size="sm"
                            className="h-auto p-1 text-xs text-white/70 hover:text-white hover:bg-white/[0.05]"
                            onClick={() => handleMarkAsRead(notification.id)}
                          >
                            Mark as read
                          </Button>
                        )}
                      </div>
                      <div className="mt-1 text-white/70 text-xs">{notification.description}</div>
                    </div>
                  ))
                )}
              </div>
            </>
          )}
          <Link href="/protected/profile">
            <DropdownMenuItem>
              <UserIcon className="mr-2 h-4 w-4" />
              <span>Profile</span>
            </DropdownMenuItem>
          </Link>
          <Link href="/protected/settings">
            <DropdownMenuItem>
              <Settings className="mr-2 h-4 w-4" />
              <span>Settings</span>
            </DropdownMenuItem>
          </Link>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />
        <DropdownMenuItem
          className="text-cyan-400 hover:text-cyan-300 focus:text-cyan-300"
          onClick={handleLogout}
        >
          <LogOut className="mr-2 h-4 w-4" />
          <span>Log out</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: components/ui/chat/chat-content-client.tsx
================
"use client";
import { useChat } from "@ai-sdk/react";
import { ServerDrivenSpaceTab } from "@/components/ui/space/space-tab";
import { ServerDrivenConversationTab } from "@/components/ui/conversation/conversation-tab";
import { ServerDrivenQuickActionsTab, ServerDrivenBackgroundTasksTab, ServerDrivenSuggestionsTab } from "@/components/ui/quick-actions-tab";
import { ServerDrivenModelTab } from "@/components/ui/chat/model-tab";
import { ChatModeTab } from "@/components/ui/chat/chat-mode-tab";
import { ArrowDown, Search, Sparkles } from "lucide-react";
import { BaseTab } from "@/components/ui/common/base-tab";
import { User } from "@supabase/supabase-js";
import { UnifiedInput } from "@/components/ui/chat/unified-input";
import { ChatMessages } from "@/components/ui/chat/chat-messages";
import { UserProfileDropdown } from "@/components/ui/auth/user-profile-dropdown";
import { useCommandCenter } from "@/hooks/useCommandCenter";
import { useRouter } from "next/navigation";
import { sendMessage, createConversation, switchConversation, deleteConversation } from "@/app/actions/conversations";
import { updateSpace } from "@/app/actions/spaces";
import { useCallback, useRef, useState, useEffect } from "react";
import { useSpaceStore } from "@/stores/space-store";
import { useShallow } from "zustand/react/shallow";

interface ClientChatContentProps {
  user: User;
  initialData: {
    spaces: any[];
    activeSpace: any;
    conversations: any[];
    activeConversation: any;
    messages: any[];
    allMessages: Record<string, any[]>;
    notifications?: any[];
  };
}

export default function ClientChatContent({
  user,
  initialData,
}: ClientChatContentProps) {
  const router = useRouter();
  const { openCommandType } = useCommandCenter();
  
  const [isStickToBottom, setIsStickToBottom] = useState(true);
  const [searchMode, setSearchMode] = useState<"chat" | "search" | "semantic" | "hybrid">("chat");
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  
  console.log('[CLIENT] ClientChatContent initializing with data:', {
    initialSpaces: initialData.spaces?.length || 0,
    initialActiveSpace: initialData.activeSpace?.id,
    initialConversations: initialData.conversations?.length || 0,
    initialActiveConversation: initialData.activeConversation?.id,
    initialMessages: initialData.messages?.length || 0,
  });
  
  const {
    activeSpace: storeActiveSpace,
    conversations: storeConversations,
    activeConversation: storeActiveConversation,
    messages: storeMessages,
    fileReferences
  } = useSpaceStore(
    useShallow((state) => state.uiState)
  );

  const { 
    createConversation,
    clearFileReferences
  } = useSpaceStore();
  
  const activeSpace = storeActiveSpace || initialData.activeSpace;
  const conversations = storeConversations || initialData.conversations;
  const activeConversation = storeActiveConversation || initialData.activeConversation;
  const initialMessages = storeMessages || initialData.messages;

  console.log('[CLIENT] Resolved state:', {
    activeSpaceId: activeSpace?.id,
    conversationsCount: conversations?.length || 0,
    activeConversationId: activeConversation?.id,
    messagesFromStore: storeMessages?.length || 0,
    resolvedInitialMessages: initialMessages?.length || 0,
  });

  useEffect(() => {
    if (storeActiveConversation && storeActiveConversation !== activeConversation) {
      console.log('[CLIENT] Active conversation changed, updating messages', {
        newConversationId: storeActiveConversation?.id,
        oldConversationId: activeConversation?.id,
        availableMessages: storeMessages?.length || 0
      });
      setMessages(storeMessages || []);
      setData([]);
    }

    router.replace(`/protected/spaces/${activeSpace?.id}/conversations/${activeConversation?.id}`);
  }, [storeActiveConversation?.id]);

  // Convert file references to the format expected by the API
  const fileReferencesMap = useCallback(() => {
    const fileMap: Record<string, any> = {};
    fileReferences.forEach(fileRef => {
      fileMap[fileRef.id] = {
        id: fileRef.id,
        path: fileRef.path,
        name: fileRef.name,
        content: fileRef.content,
        type: fileRef.type
      };
    });
    return fileMap;
  }, [fileReferences]);

  const {
    messages,
    setMessages,
    input,
    isLoading: isChatLoading,
    setInput,
    handleInputChange,
    handleSubmit,
    data,
    setData,
  } = useChat({
    id: activeConversation?.id || 'default',
    api: "/api/chat",
    initialMessages: initialMessages,
    body: {
      spaceId: activeSpace?.id || "",
      conversationId: activeConversation?.id || null,
      provider: activeSpace?.provider || "",
      model: activeSpace?.model || "",
      searchMode,
      chatMode: activeSpace?.chat_mode || "ask",
      chatModeConfig: activeSpace?.chat_mode_config || { tools: [] },
      files: fileReferencesMap(),
    },
    onFinish() {
      setData([]);
      clearFileReferences();
    },
  });

  const handleStickToBottomChange = useCallback((isAtBottom: boolean) => {
    setIsStickToBottom(isAtBottom);
  }, []);
  
  const scrollToBottomHandler = useRef<() => void>(() => {
    messagesContainerRef.current?.scrollTo({
      top: messagesContainerRef.current.scrollHeight,
      behavior: "smooth",
    });
  });

  const handleScrollToBottom = useCallback((callback: () => void) => {
    scrollToBottomHandler.current = callback;
  }, []);

  const handleCreateConversation = async () => {
    if (!activeSpace) return;
    
    try {
      await createConversation();
    } catch (error) {
      console.error('Failed to create conversation:', error);
    }
  };

  console.log('[CLIENT] Messages:', messages);
  
  
  return (
    <div className="flex flex-col h-full bg-black text-white relative chat-container">
      <div className="fixed top-4 right-4 z-50">
        {user && <UserProfileDropdown user={user} initialNotifications={initialData.notifications} />}
      </div>
      <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50">
        <div
          className="relative p-1 rounded-full bg-black/20 border border-white/[0.08] backdrop-blur-xl"
          style={{
            background: `color-mix(in srgb, ${activeSpace?.color || "#3ecfff"}10, transparent)`,
            boxShadow: `0 0 20px ${activeSpace?.color || "#3ecfff"}10, inset 0 0 20px ${
              activeSpace?.color || "#3ecfff"
            }05`,
          }}
        >
          <div className="flex items-center divide-x divide-white/[0.08]">
            <div className="px-1 first:pl-1 last:pr-1">
              {/* @ts-ignore */}
              <ServerDrivenSpaceTab 
                spaces={initialData.spaces}
                activeSpace={activeSpace}
              />
            </div>
            <div className="px-1 first:pl-1 last:pr-1">
              {/* @ts-ignore */}
              <ServerDrivenModelTab 
                activeSpace={activeSpace}
                onUpdateSpace={async (spaceId: string, updates: any) => {
                  const success = await updateSpace(spaceId, updates);
                  if (success) {
                    router.refresh();
                  }
                }}
              />
            </div>
            <div className="px-1 first:pl-1 last:pr-1">
              <ChatModeTab />
            </div>
            {!isStickToBottom && messages.length > 0 && (
              <div className="px-1 first:pl-1 last:pr-1">
                <BaseTab
                  icon={<ArrowDown className="w-3 h-3" />}
                  label="Scroll to Bottom"
                  onClick={() => {
                    scrollToBottomHandler.current();
                  }}
                />
              </div>
            )}
          </div>
        </div>
      </div>
      <div className="flex-1 w-full h-full flex flex-col">
        <div className="absolute top-0 left-0 w-full h-screen pointer-events-none">
          <div className="absolute top-0 left-[20%] w-[500px] h-[500px] bg-[#3ecfff]/[0.015] blur-[120px] rounded-full" />
          <div className="absolute top-[20%] right-[20%] w-[400px] h-[400px] bg-[#D4966A]/[0.015] blur-[100px] rounded-full" />
          <div className="absolute bottom-[10%] left-[30%] w-[600px] h-[600px] bg-[#3ecfff]/[0.01] blur-[130px] rounded-full" />
        </div>
        <ChatMessages
          messages={messages}
          onStickToBottomChange={handleStickToBottomChange}
          onScrollToBottom={handleScrollToBottom}
          ref={messagesContainerRef}
          isLoading={isChatLoading}
          streamData={data}
        />
        <div className="fixed left-1/2 bottom-8 -translate-x-1/2 w-[800px] z-50">
          <div className="relative w-full">
            <UnifiedInput
              value={input}
              onChange={handleInputChange}
              onSubmit={handleSubmit}
              disabled={!activeSpace || isChatLoading}
            >
              <div className="flex items-center divide-x divide-white/[0.05] bg-white/[0.03] border-t border-l border-r border-white/[0.05] rounded-t-2xl overflow-hidden backdrop-blur-xl w-full shadow-[0_-4px_20px_rgba(62,207,255,0.03)]">
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5">
                  {/* @ts-ignore */}
                  <ServerDrivenQuickActionsTab 
                    onCreateConversation={(handleCreateConversation)}
                  />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5">
                  <BaseTab
                    icon={<Search className="w-3 h-3" />}
                    label="Messages"
                    shortcut="F"
                    commandType="conversations"
                    onClick={() => openCommandType("conversations")}
                  />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5">
                  <ServerDrivenBackgroundTasksTab />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5">
                  <ServerDrivenSuggestionsTab />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 w-1/5">
                  <ServerDrivenConversationTab
                    activeConversation={activeConversation}
                    onCreateConversation={handleCreateConversation}
                  />
                </div>
              </div>
            </UnifiedInput>
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: components/ui/chat/chat-message.tsx
================
import { User, MessageSquareIcon, Sparkles, FileText, File } from 'lucide-react';
import { memo, useMemo } from 'react';
import { getModelName, type Provider } from '@/config/models';
import { ProviderIcon } from './provider-icon';
import { JSONValue, Message } from 'ai';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/common/avatar';
import { StreamStatus } from './stream-status';
import { Markdown } from './markdown';
import DotSphere from '@/components/ui/space/planet-icon';
import { useSpaceStore } from '@/stores/space-store';
import { getChatModeConfig } from '@/config/chat-modes';
import { SimilarMessage } from '@/types';

// Component for rendering user messages with file mentions
const UserMessageWithMentions = memo(({ id, content }: { id: string, content: string }) => {
  // Process the content to identify and render filenames as tags
  const processedContent = useMemo(() => {
    // First, pre-process the content to remove file tags for display
    // This format is the special marker we use: @[filename](filepath)
    const fileTagRegex = /@\[(.*?)\]\((.*?)\)/g;
    
    // Check if we need to process any file tags
    if (!fileTagRegex.test(content)) {
      return <span>{content}</span>;
    }
    
    // Replace all file tags with their display components
    const parts: React.ReactNode[] = [];
    let lastIndex = 0;
    let key = 0;
    
    // Create a clean version of the text without special markers
    let cleanedContent = content;
    let match;
    
    // Reset regex to start from beginning
    fileTagRegex.lastIndex = 0;
    
    // Process each file tag match
    while ((match = fileTagRegex.exec(content)) !== null) {
      const [fullMatch, fileName, filePath] = match;
      
      // Add text before the file tag
      if (match.index > lastIndex) {
        parts.push(
          <span key={`text-${key++}`}>
            {content.substring(lastIndex, match.index)}
          </span>
        );
      }
      
      // Add the file tag component
      parts.push(
        <span 
          key={`file-${key++}`}
          className="inline-flex items-center gap-1 px-1.5 py-0.5 mr-1 rounded bg-cyan-500/20 text-xs text-cyan-300"
          title={filePath}
        >
          <File className="h-3 w-3" />
          <span className="truncate max-w-[150px]">{fileName}</span>
        </span>
      );
      
      // Update the last index to after this match
      lastIndex = match.index + fullMatch.length;
      
      // Remove this match from the cleaned content
      cleanedContent = cleanedContent.replace(fullMatch, "");
    }
    
    // Add any remaining text after the last match
    if (lastIndex < content.length) {
      parts.push(
        <span key={`text-${key++}`}>
          {content.substring(lastIndex)}
        </span>
      );
    }
    
    return <>{parts}</>;
  }, [content]);
  
  return (
    <div id={id}>
      {processedContent}
    </div>
  );
}, (prevProps, nextProps) => {
  // Only re-render if the content has changed
  return prevProps.content === nextProps.content && prevProps.id === nextProps.id;
});

interface ChatMessageProps {
    message: Message;
    userAvatarUrl?: string;
    isLoading?: boolean;
    streamData?: JSONValue[] | undefined;
}

// Interface for chat mode annotation
interface ChatModeAnnotation {
  chat_mode?: string;
  chat_mode_config?: {
    tools: string[];
    mcp_servers?: string[];
  };
}

const UserAvatar = ({ avatarUrl }: { avatarUrl?: string }) => (
    <Avatar className="h-10 w-10 border bg-white/[0.03] border-white/[0.1]">
        <AvatarImage src={avatarUrl || ""} />
        <AvatarFallback className="bg-white/[0.03]">
            <User className="h-5 w-5 text-white/80" />
        </AvatarFallback>
    </Avatar>
);

const AIAvatar = () => {
    // Use the active space ID from the store as the seed
    // This ensures the AIAvatar looks identical to the active space's DotSphere
    const activeSpace = useSpaceStore(state => state.activeSpace);
    const seed = activeSpace?.id || "default-space"; // Fallback if no active space
    
    return (
        <div className="relative group">
            {/* Refined outer glow */}
            <div className="absolute -inset-2 bg-gradient-to-r from-cyan-500/10 via-indigo-400/10 to-purple-500/10 rounded-full blur-md opacity-0 group-hover:opacity-100 transition-opacity duration-700" />
            
            {/* Elegant halo effect */}
            <div className="absolute -inset-4 opacity-0 group-hover:opacity-70 transition-opacity duration-500">
                <div className="absolute inset-0 rounded-full bg-gradient-to-r from-cyan-500/8 to-indigo-500/8 animate-pulse-slow" />
            </div>
            
            {/* DotSphere component as the avatar - using exact same props as space-tab.tsx except for size */}
            <div className="relative h-12 w-12 flex items-center justify-center">
                <DotSphere 
                    size={40} 
                    seed={seed} 
                    dotCount={80} 
                    dotSize={0.9} 
                    expandFactor={1.15} 
                    transitionSpeed={400}
                    highPerformance={true}
                />
            </div>
        </div>
    );
};

const ModelInfo = ({ provider, modelName, similarMessages, chatMode }: { 
  provider?: Provider; 
  modelName: string;
  similarMessages?: SimilarMessage[];
  chatMode?: string;
}) => {
  const hasSimilarMessages = similarMessages && similarMessages.length > 0;
  
  // Get the chat mode configuration if available
  const modeConfig = chatMode ? getChatModeConfig(chatMode) : null;
  const ModeModeIcon = modeConfig?.icon || Sparkles;
  
  return (
    <div className="flex items-center gap-1.5 mb-2.5 flex-wrap">
      {provider && (
        <div className="px-2 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
          <ProviderIcon provider={provider} size={14} />
        </div>
      )}
      <div className="px-2.5 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <span className="text-white">{modelName}</span>
      </div>
      
      {/* Chat mode badge */}
      {chatMode && modeConfig && (
        <div className="px-2.5 py-0.5 rounded bg-cyan-500/10 border border-cyan-500/20 text-cyan-300 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit">
          <ModeModeIcon size={11} />
          <span>{modeConfig.name}</span>
        </div>
      )}
      
      {hasSimilarMessages && (
        <button
          className="px-2.5 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10 hover:bg-white/[0.07] transition-colors"
          onClick={() => {
            if (window.openSimilarMessages) {
              window.openSimilarMessages(similarMessages);
            }
          }}
        >
          <MessageSquareIcon size={11} className="text-cyan-400/80" />
          <span>{similarMessages.length} similar</span>
        </button>
      )}
    </div>
  );
};

export const ChatMessage = memo<ChatMessageProps>(
    ({ message, userAvatarUrl, isLoading, streamData }) => {
        const isUser = message.role === 'user';

        const annotations = message.annotations as Array<{
            model_used?: string;
            provider?: string;
            similarMessages?: SimilarMessage[];
            chat_mode?: string;
            chat_mode_config?: {
                tools: string[];
                mcp_servers?: string[];
            };
        }> | undefined;

        const modelAnnotation = annotations?.find(a => a.model_used);
        const providerAnnotation = annotations?.find(a => a.provider);
        const similarMessagesAnnotation = annotations?.find(a => a.similarMessages);
        const chatModeAnnotation = annotations?.find(a => a.chat_mode);
        
        const similarMessages = similarMessagesAnnotation?.similarMessages || [];
        const chatMode = chatModeAnnotation?.chat_mode;

        const modelName = modelAnnotation?.model_used
            ? getModelName(modelAnnotation.provider as Provider, modelAnnotation.model_used)
            : 'AI';

        const providerName = providerAnnotation?.provider
            ? providerAnnotation.provider.charAt(0).toUpperCase() + providerAnnotation.provider.slice(1)
            : '';

        
        const isStreamingAssistant = !isUser && (
            // Handle regular streaming scenario
            (isLoading && message.content.length <= 0) || 
            // Handle placeholder message scenario
            message.id === 'placeholder-assistant'
        );

        return (
            <div className={`flex items-start gap-5 w-full mx-auto group transition-opacity ${isUser ? 'flex-row-reverse' : ''}`}>
                <div className={`flex-shrink-0 ${isUser ? '' : 'mt-1'}`}>
                    {isUser ? <UserAvatar avatarUrl={userAvatarUrl} /> : <AIAvatar />}
                </div>

                <div className="space-y-2 overflow-hidden max-w-[85%]">
                    <div className="prose prose-invert max-w-none w-full">
                    {message.role === 'assistant' && annotations && !isStreamingAssistant && (
                            <ModelInfo
                                provider={providerAnnotation?.provider as Provider}
                                modelName={modelName}
                                similarMessages={similarMessages}
                                chatMode={chatMode}
                            />
                        )}

                        {isUser ? (
                            <div className="text-sm leading-relaxed whitespace-pre-wrap break-words text-white shadow-[0_0_15px_-5px_rgba(255,255,255,0.3)]">
                                <UserMessageWithMentions id={`user-${message.id}`} content={message.content} />
                            </div>
                        ) : isStreamingAssistant ? (
                            <div className="transition-all duration-500 ease-in-out will-change-transform">
                            {annotations && (
                                <ModelInfo
                                    provider={providerAnnotation?.provider as Provider}
                                    modelName={modelName}
                                    chatMode={chatMode}
                                />
                            )}
                                {/* Add a growing animation to the StreamStatus container */}
                                <div 
                                    className="animate-appear transform-gpu transition-all duration-500 ease-out"
                                    style={{ animationFillMode: 'both' }}
                                >
                                    <StreamStatus streamData={streamData} />
                                </div>
                            </div>
                        ) : (
                            <div className="prose prose-invert prose-zinc max-w-none">
                                <Markdown id={message.id}>
                                    {message.content}
                                </Markdown>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        );
    },
    (prevProps, nextProps) => {
        // Custom equality comparison to avoid unnecessary re-renders
        if (prevProps.message.id !== nextProps.message.id) return false;
        if (prevProps.message.role !== nextProps.message.role) return false;
        
        // For user messages, only re-render if content changes
        if (prevProps.message.role === 'user') {
            return prevProps.message.content === nextProps.message.content;
        }
        
        // For assistant messages, check if we're in streaming state
        const isStreamingPrev = prevProps.isLoading && (prevProps.message.id === 'placeholder-assistant' || prevProps.message.content.length === 0);
        const isStreamingNext = nextProps.isLoading && (nextProps.message.id === 'placeholder-assistant' || nextProps.message.content.length === 0);
        
        // If streaming state changed, re-render
        if (isStreamingPrev !== isStreamingNext) return false;
        
        // If streaming, only update every 5 stream data changes to reduce re-renders
        if (isStreamingNext && prevProps.streamData && nextProps.streamData) {
            const prevLength = prevProps.streamData.length;
            const nextLength = nextProps.streamData.length;
            
            // Only re-render if streamData length increased by at least 5
            return nextLength <= prevLength || (nextLength - prevLength < 5);
        }
        
        // For normal messages, only re-render if content changes
        return prevProps.message.content === nextProps.message.content;
    }
);

// Add a display name for easier debugging
ChatMessage.displayName = 'ChatMessage';

================
File: components/ui/chat/chat-messages-skeleton.tsx
================
export function ChatMessagesSkeleton() {
  return (
    <div className="relative flex-1 flex flex-col">
      <div className="messages-container absolute inset-0 overflow-y-auto py-12 px-4 pb-52">
        <div className="max-w-[85%] mx-auto">
          <div className="space-y-12 min-h-full animate-pulse">
            {/* AI Message Skeleton */}
            <div className="flex items-start gap-4">
              <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1]">
                <div className="w-5 h-5 rounded-full bg-white/10" />
              </div>
              <div className="flex-1 space-y-2 overflow-hidden max-w-[85%]">
                <div className="flex items-center gap-1.5 mb-2.5">
                  <div className="w-20 h-4 bg-white/10 rounded" />
                </div>
                <div className="space-y-2">
                  <div className="h-4 bg-white/10 rounded w-full" />
                  <div className="h-4 bg-white/10 rounded w-4/5" />
                  <div className="h-4 bg-white/10 rounded w-2/3" />
                </div>
              </div>
            </div>

            {/* User Message Skeleton */}
            <div className="flex items-start gap-4 justify-end">
              <div className="flex-1 space-y-2 overflow-hidden max-w-[85%] text-right">
                <div className="space-y-2">
                  <div className="h-4 bg-white/10 rounded w-3/4 ml-auto" />
                  <div className="h-4 bg-white/10 rounded w-1/2 ml-auto" />
                </div>
              </div>
              <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1]">
                <div className="w-5 h-5 rounded-full bg-white/10" />
              </div>
            </div>

            {/* Another AI Message Skeleton */}
            <div className="flex items-start gap-4">
              <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1]">
                <div className="w-5 h-5 rounded-full bg-white/10" />
              </div>
              <div className="flex-1 space-y-2 overflow-hidden max-w-[85%]">
                <div className="flex items-center gap-1.5 mb-2.5">
                  <div className="w-20 h-4 bg-white/10 rounded" />
                </div>
                <div className="space-y-2">
                  <div className="h-4 bg-white/10 rounded w-full" />
                  <div className="h-4 bg-white/10 rounded w-3/4" />
                  <div className="h-4 bg-white/10 rounded w-1/2" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

================
File: components/ui/chat/chat-messages.tsx
================
'use client';

import { ChatContainer, useAutoScroll } from '@/components/ui/chat-container';
import { useEffect, forwardRef, useRef, useState, useCallback, memo, useMemo } from 'react';
import { ChatMessage } from './chat-message';
import { JSONValue, Message } from 'ai';
import { useSearchParams, useRouter } from 'next/navigation';

interface ChatMessagesProps {
  messages: Message[];
  onStickToBottomChange?: (isStickToBottom: boolean) => void;
  onScrollToBottom?: (callback: () => void) => void;
  isLoading?: boolean;
  streamData?: JSONValue[] | undefined;
}

// Memoized message component to reduce re-renders
const MemoizedMessage = memo(({ 
  message, 
  index, 
  isLoading, 
  streamData, 
  messagesLength, 
  nextMessageRole, 
  shouldAddSeparator 
}: { 
  message: Message; 
  index: number; 
  isLoading: boolean; 
  streamData?: JSONValue[];
  messagesLength: number;
  nextMessageRole?: string;
  shouldAddSeparator: boolean;
}) => {
  const messageRef = useRef<HTMLDivElement>(null);

  return (
    <>
      <div 
        key={message.id} 
        ref={messageRef}
        className="transition-all"
      >
        <ChatMessage 
          message={message} 
          isLoading={isLoading}
          streamData={streamData}
        />
      </div>
      {shouldAddSeparator && (
        <div className="w-full flex justify-center my-8">
          <div className="w-1/3 h-px bg-white/[0.05]" />
        </div>
      )}
    </>
  );
}, (prevProps, nextProps) => {
  // Only re-render if message content or streaming state changes
  if (prevProps.message.id !== nextProps.message.id) return false;
  if (prevProps.message.content !== nextProps.message.content) return false;
  if (prevProps.isLoading !== nextProps.isLoading) return false;
  
  // For streaming messages, only compare first and last stream data
  if (prevProps.message.role === 'assistant' && prevProps.isLoading && nextProps.isLoading) {
    const prevStreamLength = prevProps.streamData?.length || 0;
    const nextStreamLength = nextProps.streamData?.length || 0;
    return (nextStreamLength - prevStreamLength < 5);
  }
  
  return true;
});

MemoizedMessage.displayName = 'MemoizedMessage';

// Memoized placeholder message component
const PlaceholderMessage = memo(({ 
  needsSeparator,
  streamData
}: { 
  needsSeparator: boolean;
  streamData?: JSONValue[];
}) => {
  return (
    <div key="placeholder-assistant" className="space-y-2">
      {needsSeparator && (
        <div className="w-full flex justify-center my-8">
          <div className="w-1/3 h-px bg-white/[0.05]" />
        </div>
      )}
      <ChatMessage 
        message={{
          id: 'placeholder-assistant',
          role: 'assistant',
          content: '',
        }}
        isLoading={true}
        streamData={streamData || [{ status: 'Processing...' }]}
      />
    </div>
  );
}, (prevProps, nextProps) => {
  // Only re-render on significant stream data updates
  const prevStreamLength = prevProps.streamData?.length || 0;
  const nextStreamLength = nextProps.streamData?.length || 0;
  return (nextStreamLength - prevStreamLength < 5);
});

PlaceholderMessage.displayName = 'PlaceholderMessage';

const ChatMessagesComponent = forwardRef<HTMLDivElement, ChatMessagesProps>(
  ({ messages, onStickToBottomChange, onScrollToBottom, isLoading, streamData }, ref) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const actualRef = (ref as React.RefObject<HTMLDivElement>) || containerRef;
    const prevMessagesLengthRef = useRef(messages.length);
    
    const { 
      autoScrollEnabled, 
      scrollToBottom 
    } = useAutoScroll(actualRef, true);
    
    useEffect(() => {
      if (onStickToBottomChange) {
        onStickToBottomChange(autoScrollEnabled);
      }
    }, [autoScrollEnabled, onStickToBottomChange]);
    
    // Expose scrollToBottom to parent
    useEffect(() => {
      if (onScrollToBottom && scrollToBottom) {
        // Create a function that parent can call
        const handleScrollToBottom = () => scrollToBottom("smooth");
        // Provide the callback to the parent
        onScrollToBottom(handleScrollToBottom);
      }
    }, [onScrollToBottom, scrollToBottom]);
    
    // Log only when messages length changes
    useEffect(() => {
      if (prevMessagesLengthRef.current !== messages.length) {
        prevMessagesLengthRef.current = messages.length;
        console.log('[CLIENT] Chat messages count changed:', { 
          count: messages.length
        });
      }
    }, [messages.length]);

    // Precompute message separators to avoid recalculation on each render
    const messageSeparatorMap = useMemo(() => {
      const separators: Record<string, boolean> = {};
      
      messages.forEach((message, index) => {
        if (index < messages.length - 1) {
          separators[message.id] = message.role !== messages[index + 1].role;
        } else {
          separators[message.id] = false;
        }
      });
      
      return separators;
    }, [messages]);

    // Check if we need a separator for placeholder message
    const needsPlaceholderSeparator = useMemo(() => {
      return messages.length > 1 && 
        messages[messages.length - 1].role !== 'assistant';
    }, [messages]);
    
    // Check if we should show placeholder
    const shouldShowPlaceholder = messages.length > 0 && 
      messages[messages.length - 1].role === 'user' && 
      isLoading;

    return (
      <div className="relative flex-1 flex flex-col h-full">
        <ChatContainer
          ref={actualRef}
          className="absolute inset-0 py-12 px-4 pb-52"
          autoScroll={true}
        >
          <div className="max-w-[85%] w-full mx-auto">
            <div className="space-y-12">
              {messages.map((message, index) => (
                <MemoizedMessage
                  key={message.id}
                  message={message}
                  index={index}
                  isLoading={isLoading}
                  streamData={index === messages.length - 1 && message.role === 'assistant' ? streamData : undefined}
                  messagesLength={messages.length}
                  nextMessageRole={index < messages.length - 1 ? messages[index + 1].role : undefined}
                  shouldAddSeparator={messageSeparatorMap[message.id]}
                />
              ))}
              
              {shouldShowPlaceholder && (
                <PlaceholderMessage 
                  needsSeparator={needsPlaceholderSeparator}
                  streamData={streamData}
                />
              )}
            </div>
          </div>
        </ChatContainer>
      </div>
    );
  }
);

// Set display name for the base component
ChatMessagesComponent.displayName = 'ChatMessagesComponent';

// Apply memo to the component after definition
export const ChatMessages = memo(ChatMessagesComponent);

// Set display name for the memoized component
ChatMessages.displayName = 'ChatMessages';

================
File: components/ui/chat/chat-mode-tab.tsx
================
'use client'

import React from 'react'
import { BaseTab } from '../common/base-tab'
import { getChatModeConfig } from '@/config/chat-modes'
import { useCommandCenter } from '@/hooks/useCommandCenter'
import { useSpaceStore } from '@/stores/space-store'
import { useShallow } from 'zustand/react/shallow'

export const ChatModeTab: React.FC = () => {
  const { openCommandType } = useCommandCenter()
  const { activeSpace } = useSpaceStore(
    useShallow((state) => ({ activeSpace: state.uiState.activeSpace }))
  )
  
  // Get the current mode from the active space, default to 'ask'
  const currentMode = activeSpace?.chat_mode || 'ask'
  
  // Get the mode configuration
  const modeConfig = getChatModeConfig(currentMode)
  
  // Get the icon component based on the mode
  const Icon = modeConfig.icon
  
  return (
    <BaseTab
      icon={<Icon className="w-3.5 h-3.5" />}
      label={`Mode: ${modeConfig.name}`}
      shortcut="M"
      commandType="chat-modes"
      onClick={() => openCommandType("chat-modes")}
    />
  )
}

================
File: components/ui/chat/content-tag.tsx
================
import React from 'react';
import { MentionItemType } from '@/types/mention';
import { FileText, Folder, Hash, Clock, Code, X } from 'lucide-react';

interface ContentTagProps {
  item: {
    name: string;
    id: string;
    type: MentionItemType;
  };
  onRemove: (id: string) => void;
}

// Component for displaying selected content tags with remove button
export const ContentTag: React.FC<ContentTagProps> = ({ item, onRemove }) => {
  // Get the appropriate icon based on content type
  const getIconForType = (type: MentionItemType): React.ReactNode => {
    switch (type) {
      case 'file':
        return <FileText className="h-3 w-3 text-cyan-400" />;
      case 'folder':
        return <Folder className="h-3 w-3 text-cyan-400" />;
      case 'message':
        return <Clock className="h-3 w-3 text-amber-400" />;
      case 'conversation':
        return <Clock className="h-3 w-3 text-green-400" />;
      default:
        return <FileText className="h-3 w-3 text-white/70" />;
    }
  };
  
  return (
    <span 
      className="inline-flex items-center gap-1 px-2 py-1 mr-1 rounded bg-white/10 hover:bg-white/20 transition-colors text-xs text-white/90 group"
      title={item.name}
    >
      {getIconForType(item.type)}
      <span className="truncate max-w-[150px]">{item.name}</span>
      <button 
        onClick={(e) => {
          e.preventDefault();
          e.stopPropagation();
          onRemove(item.id);
        }}
        className="ml-1 text-white/40 hover:text-white/90 transition-colors opacity-0 group-hover:opacity-100 focus:opacity-100"
        aria-label="Remove item"
      >
        <X className="h-3 w-3" />
      </button>
    </span>
  );
};

================
File: components/ui/chat/loading-message.tsx
================
import { FC } from 'react'

export const LoadingMessage: FC = () => {
  return (
    <div className="flex items-start gap-4 w-full mx-auto group">
      <div className="flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-md border bg-gradient-to-b from-white/[0.07] to-white/[0.03] border-white/[0.05] relative">
        <div className="absolute inset-0 rounded-md bg-blue-500/20" />
        <div className="w-5 h-5 rounded-full bg-gradient-to-br from-blue-400 to-indigo-500 relative">
          <div className="absolute inset-0 rounded-full bg-gradient-to-t from-transparent to-white/30" />
          <div className="absolute -inset-1 rounded-full bg-blue-500/20 animate-pulse" />
        </div>
      </div>
      <div className="flex-1 space-y-2 overflow-hidden max-w-[85%]">
        <div className="prose prose-invert max-w-none space-y-2">
          <div className="h-[22px] bg-white/10 rounded w-[35%] animate-pulse" />
          <div className="h-[22px] bg-white/10 rounded w-[55%] animate-pulse" />
          <div className="h-[22px] bg-white/10 rounded w-[75%] animate-pulse" />
        </div>
      </div>
    </div>
  )
}

================
File: components/ui/chat/markdown.tsx
================
import { marked } from "marked"
import { memo, useId, useMemo } from "react"
import ReactMarkdown, { Components } from "react-markdown"
import remarkGfm from "remark-gfm"
import { CodeBlock } from "../common/code-block"
import { cn } from "@/lib/utils"
import { FileText, Folder, Hash, Code, Clock } from "lucide-react"

export type MarkdownProps = {
  children: string
  id?: string
  className?: string
  components?: Partial<Components>
}

function parseMarkdownIntoBlocks(markdown: string): string[] {
  const tokens = marked.lexer(markdown)
  return tokens.map((token) => token.raw)
}

function extractLanguage(className?: string): string {
  if (!className) return "plaintext"
  const match = className.match(/language-(\w+)/)
  return match ? match[1] : "plaintext"
}

// Custom component for rendering file mentions
// Component to display mentions of various content types
function ContentMention({ name, type }: { name: string; type?: string }) {
  // Get the appropriate icon based on content type
  const getIconForType = (type?: string): React.ReactNode => {
    switch (type) {
      case 'file':
        return <FileText className="h-3 w-3 text-cyan-400" />;
      case 'folder':
        return <Folder className="h-3 w-3 text-cyan-400" />;
      case 'gmail':
        return <Hash className="h-3 w-3 text-red-400" />;
      case 'gdrive':
        return <FileText className="h-3 w-3 text-blue-400" />;
      case 'dropbox':
        return <FileText className="h-3 w-3 text-blue-400" />;
      case 'github':
        return <Code className="h-3 w-3 text-purple-400" />;
      case 'conversation':
        return <Clock className="h-3 w-3 text-green-400" />;
      case 'message':
        return <Clock className="h-3 w-3 text-amber-400" />;
      default:
        return <FileText className="h-3 w-3 text-cyan-400" />;
    }
  };
  
  return (
    <span 
      className="inline-flex items-center gap-1 px-2 py-1 mr-1 mb-1 rounded bg-white/10 text-xs text-white/90"
      title={name}
    >
      {getIconForType(type)}
      <span className="truncate max-w-[150px]">{name}</span>
    </span>
  );
}

const INITIAL_COMPONENTS: Partial<Components> = {
  // Add custom content mention component
  span: function SpanComponent({ className, children, ...props }) {
    // Check if this is a content mention span
    if (className && className.includes('mention-')) {
      // Extract content type from className (e.g., mention-file, mention-gdrive)
      const type = className.replace('mention-', '');
      return <ContentMention name={children as string} type={type} />;
    }
    
    // Backward compatibility for old file-mention class
    if (className === 'file-mention') {
      return <ContentMention name={children as string} type="file" />;
    }
    
    // Otherwise render as regular span
    return <span className={className} {...props}>{children}</span>;
  },
  
  code: function CodeComponent({ className, children, ...props }) {
    const isInline =
      !props.node?.position?.start.line ||
      props.node?.position?.start.line === props.node?.position?.end.line

    if (isInline) {
      // Check if this is a file mention (starts with file:)
      const content = String(children);
      if (content.startsWith('file:')) {
        const fileName = content.substring(5); // Remove the 'file:' prefix
        return <FileMention name={fileName} />;
      }
      
      return (
        <span
          className={cn(
            "glass-effect px-1.5 py-0.5 text-[13px] font-mono text-zinc-200 rounded-md",
            "backdrop-blur-[4px] bg-white/[0.03] border border-white/[0.05]",
            className
          )}
          {...props}
        >
          {children}
        </span>
      )
    }

    const language = extractLanguage(className)

    return (
      <CodeBlock
        code={children as string}
        language={language}
        className={cn("glass-effect code-block-glow", className)}
      />
    )
  },
  pre: function PreComponent({ children }) {
    return <>{children}</>
  },
  // Enhance link styling
  a: function LinkComponent({ href, children, ...props }) {
    return (
      <a 
        href={href} 
        className="text-cyan-400 hover:text-cyan-300 underline underline-offset-2 transition-colors" 
        target="_blank" 
        rel="noopener noreferrer"
        {...props}
      >
        {children}
      </a>
    )
  },
  // Better list styling
  ul: function UlComponent({ children, ...props }) {
    return (
      <ul className="pl-6 list-disc space-y-1 my-4" {...props}>
        {children}
      </ul>
    )
  },
  ol: function OlComponent({ children, ...props }) {
    return (
      <ol className="pl-6 list-decimal space-y-1 my-4" {...props}>
        {children}
      </ol>
    )
  },
  // Headings with proper margins and styling
  h1: function H1Component({ children, ...props }) {
    return (
      <h1 className="text-2xl font-bold tracking-tight mt-8 mb-4 border-b border-zinc-800 pb-2" {...props}>
        {children}
      </h1>
    )
  },
  h2: function H2Component({ children, ...props }) {
    return (
      <h2 className="text-xl font-bold tracking-tight mt-6 mb-3" {...props}>
        {children}
      </h2>
    )
  },
  h3: function H3Component({ children, ...props }) {
    return (
      <h3 className="text-lg font-bold tracking-tight mt-5 mb-2" {...props}>
        {children}
      </h3>
    )
  },
  // Enhanced paragraph spacing
  p: function PComponent({ children, ...props }) {
    return (
      <p className="leading-7 [&:not(:first-child)]:mt-4" {...props}>
        {children}
      </p>
    )
  },
  // Better blockquote
  blockquote: function BlockquoteComponent({ children, ...props }) {
    return (
      <blockquote className="border-l-4 border-zinc-700 bg-zinc-900/30 pl-4 py-1 my-4 italic" {...props}>
        {children}
      </blockquote>
    )
  },
}

const MemoizedMarkdownBlock = memo(
  function MarkdownBlock({
    content,
    components,
    className,
  }: {
    content: string
    components: Partial<Components>
    className?: string
  }) {
    return (
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        components={components}
        className={cn("prose-zinc max-w-none", className)}
      >
        {content}
      </ReactMarkdown>
    )
  },
  (prevProps, nextProps) => prevProps.content === nextProps.content
)

MemoizedMarkdownBlock.displayName = "MemoizedMarkdownBlock"

// Function to preprocess markdown and transform content mentions
function preprocessMarkdown(markdown: string): string {
  // Find mentions in the format @[name](id)
  const mentionRegex = /@\[([^\]]+)\]\(([^)]+)\)/g;
  
  // Replace mentions with our custom component syntax
  return markdown.replace(mentionRegex, (match, name, id) => {
    // Replace any single backticks in the name to avoid breaking markdown
    const escapedName = name.replace(/`/g, "'");
    
    // Determine the content type from the ID
    let contentType = 'file'; // Default type
    
    if (id.startsWith('file-')) {
      contentType = 'file';
    } else if (id.startsWith('gdrive-')) {
      contentType = 'gdrive';
    } else if (id.startsWith('message-')) {
      contentType = 'message';
    } else if (id.startsWith('conversation-')) {
      contentType = 'conversation';
    } else if (id.startsWith('github-')) {
      contentType = 'github';
    } else if (id.startsWith('slack-')) {
      contentType = 'slack';
    } else if (id.startsWith('dropbox-')) {
      contentType = 'dropbox';
    }
    
    // Create a span with a class that indicates the content type
    return `<span class="mention-${contentType}">${escapedName}</span>`;
  });
}

function MarkdownComponent({
  children,
  id,
  className,
  components = INITIAL_COMPONENTS,
}: MarkdownProps) {
  // Preprocess markdown to transform file mentions
  const processedChildren = useMemo(() => {
    return preprocessMarkdown(children);
  }, [children]);
  
  const blocks = useMemo(() => {
    try {
      return parseMarkdownIntoBlocks(processedChildren)
    } catch (error) {
      console.error(error)
      return [processedChildren]
    }
  }, [processedChildren])

  // Use a stable ID for the content blocks
  const contentId = useId()
  const uniqueId = id || contentId

  return (
    <div id={uniqueId} className={cn("text-sm text-zinc-100 leading-7", className)}>
      {blocks.map((content, i) => (
        <MemoizedMarkdownBlock
          key={`${uniqueId}-block-${i}`}
          content={content}
          components={components}
        />
      ))}
    </div>
  )
}

const Markdown = memo(MarkdownComponent)
Markdown.displayName = "Markdown"

export { Markdown }

================
File: components/ui/chat/mention-menu.tsx
================
"use client"

import React, { useEffect, useState, useRef } from 'react';
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from '@/components/ui/command';
import { Popover, PopoverContent, PopoverAnchor } from '@/components/ui/popover';
import { MentionItem, MentionItemType } from '@/types/mention';
import { cn } from '@/lib/utils';

interface MentionMenuProps {
  isVisible: boolean;
  isSearching: boolean;
  items: MentionItem[];
  onItemSelect: (item: MentionItem) => void;
  onClose: () => void;
  anchorRef?: React.RefObject<HTMLElement>;
  searchTerm?: string;
}

// Helper to group items by type
const getMentionGroups = (items: MentionItem[]): Record<string, MentionItem[]> => {
  return items.reduce((groups, item) => {
    const group = groups[item.type] || [];
    group.push(item);
    groups[item.type] = group;
    return groups;
  }, {} as Record<string, MentionItem[]>);
};

// Helper to get human-readable group names
const getGroupDisplayName = (type: MentionItemType): string => {
  const displayNames: Record<MentionItemType, string> = {
    file: 'Files',
    folder: 'Folders',
    message: 'Messages',
    conversation: 'Conversations'
  };
  return displayNames[type] || type;
};

export interface MentionMenuHandle {
  handleKeyDown: (e: React.KeyboardEvent) => boolean;
}

export const MentionMenu = React.forwardRef<MentionMenuHandle, MentionMenuProps>(({
  isVisible,
  isSearching,
  items,
  onItemSelect,
  onClose,
  anchorRef,
  searchTerm = ''
}, ref) => {
  const [highlightedIndex, setHighlightedIndex] = useState<number>(-1);
  const [filteredItems, setFilteredItems] = useState<MentionItem[]>(items);
  const commandRef = useRef<HTMLDivElement>(null);
  
  // Filter items based on search term
  useEffect(() => {
    if (!searchTerm) {
      setFilteredItems(items);
      return;
    }
    
    const filtered = items.filter(item => 
      item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (item.description && item.description.toLowerCase().includes(searchTerm.toLowerCase()))
    );
    
    setFilteredItems(filtered);
    // Reset highlighted index when items change
    setHighlightedIndex(-1);
  }, [items, searchTerm]);
  
  // Create a keyboard handler function that can be passed to the input
  const handleKeyboardNavigation = (e: React.KeyboardEvent) => {
    if (!isVisible) return false;
    
    if (e.key === 'ArrowDown') {
      e.preventDefault(); // Prevent cursor movement in textarea
      setHighlightedIndex(prev => 
        prev < filteredItems.length - 1 ? prev + 1 : 0
      );
      return true; // Signal the event was handled
    } 
    else if (e.key === 'ArrowUp') {
      e.preventDefault(); // Prevent cursor movement in textarea
      setHighlightedIndex(prev => 
        prev > 0 ? prev - 1 : filteredItems.length - 1
      );
      return true; // Signal the event was handled
    } 
    else if ((e.key === 'Enter' || e.key === 'Tab') && highlightedIndex >= 0) {
      // Only handle if we have a highlighted item
      if (filteredItems[highlightedIndex]) {
        e.preventDefault(); // Prevent default for Enter/Tab
        e.stopPropagation(); // Also stop propagation to prevent bubbling
        onItemSelect(filteredItems[highlightedIndex]);
        return true; // Signal the event was handled
      }
    }
    
    return false; // Signal the event was not handled
  };
  
  // Expose the keyboard handler to parent components via ref
  React.useImperativeHandle(ref, () => ({
    handleKeyDown: handleKeyboardNavigation
  }));
  
  // Group the filtered items by type
  const mentionGroups = getMentionGroups(filteredItems);
  
  // For positioning relative to the text input
  const popoverPositionStyles = {
    width: '320px',
    maxWidth: 'calc(100% - 20px)',
  };
  
  return (
    <Popover 
      open={isVisible} 
      onOpenChange={(open) => {
        // Only allow the parent component to control visibility
        if (!open) {
          onClose();
        }
      }}
      modal={false} // Non-modal to allow input focus to remain
    >
      {anchorRef && <PopoverAnchor asChild><span ref={anchorRef as React.RefObject<HTMLSpanElement>} /></PopoverAnchor>}
      
      <PopoverContent 
        className="p-0 rounded-t-lg border border-white/10 bg-black/90 shadow-xl backdrop-blur-lg overflow-hidden"
        side="top"
        sideOffset={5}
        align="start"
        avoidCollisions={true}
        style={popoverPositionStyles}
        collisionPadding={10}
        onPointerDownOutside={(e) => {
          // Prevent clicking outside from closing if in input field
          if (e.target && anchorRef?.current?.contains(e.target as Node)) {
            e.preventDefault();
          }
        }}
        onOpenAutoFocus={(e) => {
          // Prevent popover from stealing focus when opened
          e.preventDefault();
        }}
      >
        <Command 
          ref={commandRef}
          className="bg-transparent" 
          shouldFilter={false}
          loop={true}
          filter={() => 1} // We handle filtering ourselves
          // Remove the onKeyDown handler here - we'll handle all keys in the input
        >
          {/* Title header */}
          <div className="border-b border-white/5 px-3 py-2 text-sm font-medium text-white/70">
            {searchTerm ? `Searching: ${searchTerm}` : 'Select a file or resource...'}
          </div>
          <CommandList className="max-h-[300px] overflow-auto">
            {isSearching ? (
              <div className="py-6 text-center">
                <div className="inline-block h-5 w-5 animate-spin rounded-full border-2 border-solid border-white/70 border-r-transparent"></div>
                <p className="mt-2 text-sm text-white/70">Searching...</p>
              </div>
            ) : Object.keys(mentionGroups).length === 0 ? (
              <CommandEmpty>No items found.</CommandEmpty>
            ) : (
              Object.entries(mentionGroups).map(([type, typeItems], groupIndex) => (
                <CommandGroup key={type} heading={getGroupDisplayName(type as MentionItemType)}>
                  {typeItems.map((item, itemIndex) => {
                    // Calculate absolute index for this item
                    let absoluteIndex = 0;
                    for (let i = 0; i < groupIndex; i++) {
                      const prevType = Object.keys(mentionGroups)[i];
                      absoluteIndex += mentionGroups[prevType].length;
                    }
                    absoluteIndex += itemIndex;
                    
                    const isHighlighted = absoluteIndex === highlightedIndex;
                    
                    return (
                      <CommandItem
                        key={item.id}
                        onSelect={() => {
                          // No event here, just call the handler
                          onItemSelect(item);
                        }}
                        className={cn(
                          "flex items-center gap-2 px-4 py-2 cursor-pointer select-none hover:bg-white/10",
                          isHighlighted && "bg-white/10",
                          "hover:opacity-80 active:opacity-60 transition-all duration-200" // Add clear hover and active states
                        )}
                        value={item.name} // For keyboard accessibility
                        data-highlighted={isHighlighted}
                      >
                        <span className="flex-shrink-0 text-white/70">{item.icon}</span>
                        <div className="flex flex-col overflow-hidden">
                          <span className="text-sm font-medium text-white truncate">{item.name}</span>
                          {item.description && (
                            <span className="text-xs text-white/60 truncate max-w-[250px]">{item.description}</span>
                          )}
                        </div>
                      </CommandItem>
                    );
                  })}
                </CommandGroup>
              ))
            )}
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
});

// Add display name for React devtools
MentionMenu.displayName = "MentionMenu";

================
File: components/ui/chat/model-tab.tsx
================
import { getModelName, type Provider } from '@/config/models'
import { ProviderIcon } from './provider-icon'
import React from 'react'
import { BaseTab } from '@/components/ui/common/base-tab'
import { useCommandCenter } from '@/hooks/useCommandCenter'

export function ServerDrivenModelTab({ 
  activeSpace,
  onUpdateSpace 
}: { 
  activeSpace: any,
  onUpdateSpace: (spaceId: string, updates: any) => Promise<any>
}) {
  const { openCommandType } = useCommandCenter()
  const hasModel = !!(activeSpace?.provider && activeSpace?.model)
  
  // Get model name safely, handling undefined values
  const modelName = hasModel && activeSpace?.model 
    ? getModelName(activeSpace.provider as Provider, activeSpace.model) 
    : 'No Model Selected';

  return (
    <BaseTab
      icon={hasModel ? (
        <ProviderIcon className='mt-1' provider={activeSpace.provider as Provider} size={15} />
      ) : undefined}
      label={modelName}
      shortcut="M"
      commandType="models"
      onClick={() => openCommandType("models")}
    />
  )
}

================
File: components/ui/chat/provider-icon.tsx
================
import { 
  Anthropic, 
  OpenAI, 
  Cohere, 
  Mistral, 
  Google, 
  XAI, 
  Together, 
  DeepSeek, 
  Perplexity, 
  Groq 
} from '@lobehub/icons';
import { Provider } from '@/config/models';

interface ProviderIconProps {
  provider: Provider;
  size?: number;
  className?: string;
}

const PROVIDER_COMPONENTS = {
  groq: Groq,
  anthropic: Anthropic,
  openai: OpenAI,
  cohere: Cohere.Color,
  mistral: Mistral.Color,
  google: Google.Color,
  xai: XAI,
  togetherai: Together.Color,
  deepseek: DeepSeek.Color,
  cerebras: OpenAI,
  perplexity: Perplexity.Color
} as const;

export function ProviderIcon({ provider, size = 24, className = '' }: ProviderIconProps) {
  const IconComponent = PROVIDER_COMPONENTS[provider];
  if (!IconComponent) return null;
  
  return (
    <div className={`relative inline-block ${className}`} style={{ width: size, height: size }}>
      <IconComponent size={size} />
    </div>
  );
}

================
File: components/ui/chat/rich-input.css
================
/* Custom styling for the rich text input */

/* Make the ContentTag consistent with the previous styling when used inline */
.content-tag.inline {
  display: inline-flex;
  align-items: center;
  border-radius: 0.375rem;
  background-color: rgba(6, 182, 212, 0.2);
  padding: 0.125rem 0.5rem;
  font-size: 0.75rem;
  line-height: 1rem;
  color: rgb(34, 211, 238);
  gap: 0.375rem;
  margin-right: 0.25rem;
  vertical-align: middle;
}

/* Improve cursor appearance */
.inline-content-container {
  position: relative;
  line-height: 1.5;
}

.inline-content-container > span {
  white-space: pre-wrap;
}

/* Ensure proper wrapping for long inputs */
.inline-content-container {
  word-break: break-word;
}

/* Style placeholder text */
.text-white\/40 {
  opacity: 0.4;
}

================
File: components/ui/chat/stream-status.tsx
================
'use client';

import { useEffect, useState, useRef, memo, useCallback } from 'react';
import { JSONValue } from 'ai';

interface StreamStatusProps {
  streamData?: JSONValue[] | undefined;
}

// Extract the latest status from stream data
function getLatestStatus(streamData?: JSONValue[]): string {
  if (!streamData || !Array.isArray(streamData) || streamData.length === 0) {
    return 'Processing...';
  }
  
  const lastItem = streamData[streamData.length - 1];
  
  // Handle case when we pass a status object directly
  if (typeof lastItem === 'object' && lastItem !== null && 'status' in lastItem) {
    return String(lastItem.status);
  }
  
  return String(lastItem);
}

export const StreamStatus = memo(({ streamData }: StreamStatusProps) => {
  // Use useRef for status history to avoid re-renders when history changes
  const statusHistoryRef = useRef<string[]>([]);
  const [currentStatus, setCurrentStatus] = useState<string>('Processing...');
  // Use useRef for current status to determine changes without triggering re-renders
  const currentStatusRef = useRef<string>(currentStatus);
  
  // Track timestamps
  const lastUpdateTimeRef = useRef<number>(Date.now());
  const transitionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const initialProcessingShownRef = useRef<boolean>(false);
  const lastProcessedDataLengthRef = useRef<number>(0);
  
  // Force re-render function - only call this when we really need to update the UI
  const [, forceUpdate] = useState({});
  const triggerRender = useCallback(() => forceUpdate({}), []);
  
  // Process streamData changes without causing re-renders for every update
  useEffect(() => {
    // Bail out early if no new data or not enough new chunks to warrant processing
    if (!streamData || !Array.isArray(streamData) || 
        streamData.length === 0 || 
        (streamData.length > 5 && streamData.length - lastProcessedDataLengthRef.current < 5)) {
      return;
    }
    
    // Update our reference to avoid processing the same data multiple times
    lastProcessedDataLengthRef.current = streamData.length;
    
    const newStatus = getLatestStatus(streamData);
    const currentTime = Date.now();
    
    // Only update if the status has changed to avoid unnecessary renders
    if (newStatus !== currentStatusRef.current) {
      // Clear any existing transition timeout
      if (transitionTimeoutRef.current) {
        clearTimeout(transitionTimeoutRef.current);
      }
      
      // Ensure minimum transition time of 800ms between status changes to reduce flickering
      const timeSinceLastUpdate = currentTime - lastUpdateTimeRef.current;
      const transitionDelay = Math.max(0, 800 - timeSinceLastUpdate);
      
      transitionTimeoutRef.current = setTimeout(() => {
        // First, add the current status to history (including the initial "Processing...")
        if (currentStatusRef.current === 'Processing...' && !initialProcessingShownRef.current) {
          initialProcessingShownRef.current = true;
          statusHistoryRef.current = [currentStatusRef.current, ...statusHistoryRef.current].slice(0, 3);
        } else {
          statusHistoryRef.current = [currentStatusRef.current, ...statusHistoryRef.current].slice(0, 3);
        }
        
        // Then, update current status to the new status
        currentStatusRef.current = newStatus;
        // Only update state (causing re-render) if it's actually different
        if (currentStatus !== newStatus) {
          setCurrentStatus(newStatus);
        } else {
          // Force a single render to show updated history
          triggerRender();
        }
        
        lastUpdateTimeRef.current = Date.now();
      }, transitionDelay);
    }
  }, [streamData, currentStatus, triggerRender]);
  
  // Get the status history from ref for rendering
  const statusHistory = statusHistoryRef.current;
  
  return (
    <div className="group rounded-lg backdrop-blur-sm border border-white/[0.05] overflow-hidden transform-gpu transition-all duration-300 ease-out hover:border-white/[0.1]">
      {/* Main status container styled like a tab */}
      <div className="px-3 py-2 relative overflow-hidden bg-white/[0.025] hover:bg-white/[0.035] transition-all duration-300">
        <div className="flex items-center gap-3 relative z-10">
          {/* Status indicator with pulse animation */}
          <div className="relative w-3.5 h-3.5 flex-shrink-0">
            <div className="absolute inset-0 rounded-full bg-cyan-400/20 animate-pulse-slow" />
            <div className="absolute inset-0.5 rounded-full bg-cyan-400 group-hover:bg-[#3ecfff] transition-colors duration-300 animate-pulse-fast" />
          </div>
          
          {/* Current status with tab-like styling */}
          <div className="font-medium text-xs text-white/75 w-full group-hover:text-white/95 transition-colors duration-300">
            {currentStatus}
          </div>
        </div>
      </div>

      {/* Status history with improved transitions in a tab-like container */}
      {statusHistory.length > 0 && (
        <div className="bg-white/[0.015] px-3 py-1.5 space-y-1.5 border-t border-white/[0.025]">
          {statusHistory.map((status, index) => (
            <div 
              key={`status-${index}-${status}`}
              className="text-[10px] text-white/60 transition-all duration-500 flex items-center group-hover:text-white/70"
              style={{ 
                opacity: Math.max(0.7 - index * 0.2, 0.3),
              }}
            >
              <div className="w-1.5 h-1.5 rounded-full bg-white/30 mr-2 group-hover:bg-white/40 transition-colors duration-300" />
              {status}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // Only re-render if streamData has changed significantly
  if (!prevProps.streamData && !nextProps.streamData) return true;
  if (!prevProps.streamData || !nextProps.streamData) return false;
  
  const prevLength = prevProps.streamData.length;
  const nextLength = nextProps.streamData.length;
  
  // If the lengths are the same, don't re-render
  if (prevLength === nextLength) return true;
  
  // Only re-render after significant changes (at least 10 new chunks)
  // This dramatically reduces re-renders during fast streaming
  if (nextLength > prevLength && (nextLength - prevLength) < 10) {
    return true;
  }
  
  return false;
});

StreamStatus.displayName = 'StreamStatus';

================
File: components/ui/chat/unified-input.tsx
================
"use client";

import React, { ChangeEvent, useCallback, useEffect, useRef, useState } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { Button } from '@/components/ui/common/button';
import { File, Loader2, MessageSquare, X } from 'lucide-react';
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from "@/components/ui/command";
import { useSpaceStore } from '@/stores/space-store';
import { useShallow } from 'zustand/react/shallow';
import { providerRegistry } from '@/lib/providers/provider-registry';
import { MentionItem } from '@/types/mention';

type FileTag = {
  id: string
  name: string
  path: string
}

type MessageTag = {
  id: string
  name: string
  conversationTitle: string
  role: 'user' | 'assistant' | 'system'
  conversationId: string
}

type Token = {
  id: string
  type: "text" | "file" | "message"
  content: string
  file?: FileTag
  message?: MessageTag
}

interface UnifiedInputProps {
  value: string;
  onChange: (e: ChangeEvent<HTMLInputElement> | ChangeEvent<HTMLTextAreaElement>) => void;
  onSubmit: () => void;
  disabled?: boolean;
  children?: React.ReactNode;
}

export const UnifiedInput: React.FC<UnifiedInputProps> = ({
  value,
  onChange,
  onSubmit,
  disabled = false,
  children
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const [tokens, setTokens] = useState<Token[]>([{ id: "initial", type: "text", content: "" }]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [suggestionQuery, setSuggestionQuery] = useState("");

  const containerRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  const { 
    addFileReference,
    spaceId,
    activeConversationId 
  } = useSpaceStore(
    useShallow((state) => ({
      addFileReference: state.addFileReference,
      spaceId: state.activeSpace?.id,
      activeConversationId: state.activeConversation?.id
    }))
  );

  const [fileResults, setFileResults] = useState<FileTag[]>([]);
  const [messageResults, setMessageResults] = useState<MessageTag[]>([]);
  const [isSearching, setIsSearching] = useState(false);

  // Search for files using FileSystemProvider
  const searchFiles = useCallback(async (query: string) => {
    if (!query.trim()) {
      setFileResults([]);
      return;
    }

    setIsSearching(true);

    try {
      // Use the provider registry to search files
      const fileSystemProvider = providerRegistry.getProviderById('filesystem');
      
      if (!fileSystemProvider) {
        console.error("File system provider not found");
        return;
      }
      
      // Execute the search
      const results = await fileSystemProvider.search(query);
      
      // Convert to file tags
      const fileTags: FileTag[] = results.map(item => ({
        id: item.id,
        name: item.name,
        path: item.path || item.description || '',
      }));
      
      setFileResults(fileTags);
    } catch (error) {
      console.error("Error searching files:", error);
      // Provide fallback results in case of error
      setFileResults([
        { id: "fallback-1", name: "index.tsx", path: "/app/index.tsx" },
        { id: "fallback-2", name: "page.tsx", path: "/app/page.tsx" },
      ]);
    } finally {
      setIsSearching(false);
    }
  }, []);

  // Search for messages using MessageProvider
  const searchMessages = useCallback(async (query: string) => {
    if (!query.trim()) {
      setMessageResults([]);
      return;
    }

    setIsSearching(true);

    try {
      // Use the provider registry to search messages
      const messageProvider = providerRegistry.getProviderById('message');
      
      if (!messageProvider) {
        console.error("Message provider not found");
        return;
      }
      
      // Determine search scope based on current context
      let searchScope = 'all';
      let conversationId = undefined;
      
      if (activeConversationId) {
        searchScope = 'conversation';
        conversationId = activeConversationId;
      } else if (spaceId) {
        searchScope = 'space';
      }
      
      // Execute the search
      const results = await messageProvider.search(query, {
        searchScope,
        searchMode: 'text',
        conversationId,
        spaceId,
        limit: 10
      });
      
      // Convert to message tags
      const messageTags: MessageTag[] = results.map(item => ({
        id: item.id,
        name: item.name,
        conversationTitle: item.providerData?.conversationTitle || 'Unknown conversation',
        role: item.providerData?.role || 'user',
        conversationId: item.providerData?.conversationId || ''
      }));
      
      setMessageResults(messageTags);
    } catch (error) {
      console.error("Error searching messages:", error);
      setMessageResults([]);
    } finally {
      setIsSearching(false);
    }
  }, [activeConversationId, spaceId]);

  useEffect(() => {
    if (suggestionQuery) {
      // Search both files and messages concurrently
      searchFiles(suggestionQuery);
      searchMessages(suggestionQuery);
    }
  }, [suggestionQuery, searchFiles, searchMessages]);

  // Create memoized filtered results for both files and messages
  const filteredFiles = React.useMemo(() => {
    if (!suggestionQuery) return fileResults;
    return fileResults;
  }, [suggestionQuery, fileResults]);

  const filteredMessages = React.useMemo(() => {
    if (!suggestionQuery) return messageResults;
    return messageResults;
  }, [suggestionQuery, messageResults]);

  const focusInput = () => {
    inputRef.current?.focus();
  };

  useHotkeys('meta+/', (e) => {
    e.preventDefault();
    focusInput();
  }, { enableOnFormTags: true });

  const handleContainerClick = (e: React.MouseEvent) => {
    if (e.target === containerRef.current) {
      inputRef.current?.focus();
    }
  };

  const lastSearchTimeRef = useRef<number>(0);
  const searchTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onChange(e);
    
    if (e.target.value.includes("@")) {
      const atIndex = e.target.value.lastIndexOf("@");
      const caretPosition = e.target.selectionStart || 0;
      
      if (caretPosition > atIndex && caretPosition <= atIndex + 20) {
        const query = e.target.value.substring(atIndex + 1, caretPosition);
        
        if (query !== suggestionQuery) {
          setSuggestionQuery(query);
          setShowSuggestions(true);
        }
      } else if (caretPosition <= atIndex) {
        setShowSuggestions(false);
      }
    } else {
      setShowSuggestions(false);
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Backspace" && value === "" && tokens.length > 0) {
      // Remove the last token if backspace is pressed and input is empty
      const lastToken = tokens[tokens.length - 1];
      if (lastToken.type === "file" || lastToken.type === "message") {
        const newTokens = [...tokens];
        newTokens.pop();
        setTokens(newTokens);
      }
    } else if (e.key === "Escape" && showSuggestions) {
      setShowSuggestions(false);
      e.preventDefault();
    } else if (e.key === "Enter" && showSuggestions) {
      // Handle selecting the first suggestion based on available results
      if (filteredFiles.length > 0) {
        selectFile(filteredFiles[0]);
        e.preventDefault();
      } else if (filteredMessages.length > 0) {
        selectMessage(filteredMessages[0]);
        e.preventDefault();
      }
    } else if (e.key === "Enter" && !e.shiftKey && !showSuggestions) {
      e.preventDefault();
      handleSubmit();
    }
  };

  // Select a file from suggestions
  const selectFile = async (file: FileTag) => {
    // Start loading state for this file
    setIsSearching(true);
    
    try {
      // Get the file system provider to read the file content
      const fileSystemProvider = providerRegistry.getProviderById('filesystem');
      
      if (!fileSystemProvider) {
        console.error("File system provider not found");
        throw new Error("File system provider not found");
      }
      
      // Create a mention item to get content
      const mentionItem = {
        id: file.id || `file-${Date.now()}`,
        type: 'file' as const,
        name: file.name,
        path: file.path,
        description: file.path
      };
      
      // Fetch the file content using the provider
      console.log(`Loading content for file: ${file.path}`);
      let fileContent;
      try {
        // Get the file content using the provider
        const content = await fileSystemProvider.getContent(mentionItem);
        fileContent = content.content;
        console.log(`File content loaded, size: ${fileContent.length} bytes`);
      } catch (error) {
        console.error(`Error loading file content for ${file.path}:`, error);
        fileContent = `[Error loading file content: ${error.message}]`;
      }
      
      // Create a new file token, properly formatted with content
      const fileToken: Token = {
        id: file.id || `file-${Date.now()}`,
        type: "file",
        content: file.name,
        file: {
          id: file.id || `file-${Date.now()}`,
          name: file.name,
          path: file.path
        },
      };
      
      // Immediately add the file reference to the store with content
      addFileReference({
        id: fileToken.id,
        path: file.path,
        name: file.name,
        content: fileContent || '',
        type: 'file'
      });
      
      console.log(`Added file reference to store: ${file.name} with content`);
  
      // Add the file token and a new empty text token
      const newTextToken: Token = {
        id: `text-${Date.now()}`,
        type: "text",
        content: "",
      };
  
      // If the current input has an @ symbol, split it
      if (value.includes("@")) {
        const atIndex = value.lastIndexOf("@");
        const textBefore = value.substring(0, atIndex);
  
        // Update the current text token with text before @
        const newTokens = [...tokens];
        if (newTokens[newTokens.length - 1].type === "text") {
          newTokens[newTokens.length - 1].content = textBefore;
        }
  
        // Add the file token and a new empty text token
        setTokens([...newTokens, fileToken, newTextToken]);
      } else {
        // Just add the file token after the current text
        setTokens([...tokens, fileToken, newTextToken]);
      }
      
      // Clear the input after adding file token
      const event = { target: { value: "" } } as ChangeEvent<HTMLInputElement>;
      onChange(event);
    } catch (error) {
      console.error("Error selecting file:", error);
    } finally {
      setShowSuggestions(false);
      setIsSearching(false);
  
      // Focus back on the input
      setTimeout(() => {
        inputRef.current?.focus();
      }, 0);
    }
  };

  // Select a message from suggestions
  const selectMessage = async (message: MessageTag) => {
    setIsSearching(true);
    
    try {
      // Get the message provider to read the message content
      const messageProvider = providerRegistry.getProviderById('message');
      
      if (!messageProvider) {
        console.error("Message provider not found");
        throw new Error("Message provider not found");
      }
      
      // Create a mention item to get content
      const mentionItem = {
        id: message.id,
        type: 'message' as const,
        name: message.name,
        description: message.conversationTitle,
        providerData: {
          messageId: message.id.replace('message-', ''),
          conversationId: message.conversationId,
          role: message.role,
          conversationTitle: message.conversationTitle
        }
      };
      
      // Fetch the message content using the provider
      console.log(`Loading content for message: ${message.id}`);
      let messageContent;
      try {
        // Get the message content
        const content = await messageProvider.getContent(mentionItem);
        messageContent = content.content;
        console.log(`Message content loaded, size: ${messageContent.length} bytes`);
      } catch (error) {
        console.error(`Error loading message content for ${message.id}:`, error);
        messageContent = `[Error loading message content: ${error.message}]`;
      }
      
      // Create a new message token
      const messageToken: Token = {
        id: message.id || `message-${Date.now()}`,
        type: "message",
        content: messageContent.substring(0, 30) + (messageContent.length > 30 ? '...' : ''),
        message: {
          id: message.id,
          name: message.name,
          conversationTitle: message.conversationTitle,
          role: message.role,
          conversationId: message.conversationId
        }
      };
      
      // Add a new empty text token
      const newTextToken: Token = {
        id: `text-${Date.now()}`,
        type: "text",
        content: "",
      };
  
      // If the current input has an @ symbol, split it
      if (value.includes("@")) {
        const atIndex = value.lastIndexOf("@");
        const textBefore = value.substring(0, atIndex);
  
        // Update the current text token with text before @
        const newTokens = [...tokens];
        if (newTokens[newTokens.length - 1].type === "text") {
          newTokens[newTokens.length - 1].content = textBefore;
        }
  
        // Add the message token and a new empty text token
        setTokens([...newTokens, messageToken, newTextToken]);
      } else {
        // Just add the message token after the current text
        setTokens([...tokens, messageToken, newTextToken]);
      }
      
      // Clear the input after adding message token
      const event = { target: { value: "" } } as ChangeEvent<HTMLInputElement>;
      onChange(event);
    } catch (error) {
      console.error("Error selecting message:", error);
    } finally {
      setShowSuggestions(false);
      setIsSearching(false);
  
      // Focus back on the input
      setTimeout(() => {
        inputRef.current?.focus();
      }, 0);
    }
  };

  // Remove a token (file or message)
  const removeToken = (tokenId: string) => {
    const tokenIndex = tokens.findIndex((t) => t.id === tokenId);
    if (tokenIndex === -1) return;

    const newTokens = [...tokens];

    // Remove the token
    newTokens.splice(tokenIndex, 1);

    // If there are two adjacent text tokens now, merge them
    if (
      tokenIndex > 0 &&
      tokenIndex < newTokens.length &&
      newTokens[tokenIndex - 1].type === "text" &&
      newTokens[tokenIndex].type === "text"
    ) {
      newTokens[tokenIndex - 1].content += newTokens[tokenIndex].content;
      newTokens.splice(tokenIndex, 1);
    }

    setTokens(newTokens);

    // Focus back on the input
    setTimeout(() => {
      inputRef.current?.focus();
    }, 0);
  };

  // Track if a message is currently being submitted to prevent double submission
  const isSubmittingRef = useRef(false);

  const handleSubmit = async () => {
    if (disabled || isSubmittingRef.current) {
      console.log('[UnifiedInput] Submission blocked: disabled or already submitting');
      return;
    }
    
    isSubmittingRef.current = true;
    
    try {
      // Check if there's any content to submit
      const hasContent = tokens.some(token => 
        (token.type === "text" && token.content.trim() !== "") || 
        token.type === "file" ||
        token.type === "message"
      );
      
      if (!hasContent && value.trim() === "") {
        console.log('[UnifiedInput] Nothing to submit - empty message');
        isSubmittingRef.current = false;
        return;
      }
      
      // Combine all tokens into a cleaned display message
      const displayMessage = tokens
        .map((token) => {
          if (token.type === "text") return token.content;
          if (token.type === "file") return `@[${token.file?.name}](${token.file?.path})`;
          if (token.type === "message") {
            return `@[${token.message?.role === 'assistant' ? 'AI' : 'User'}](${token.message?.conversationTitle})`;
          }
          return '';
        })
        .join("") + value;
      
      console.log('[UnifiedInput] Submitting message:', displayMessage);
      
      // Ensure non-empty message
      let finalMessage = displayMessage.trim() || " ";
      
      // Save the current state in case we need to restore it
      const savedTokens = [...tokens];
      
      try {
        // Update parent value and submit
        const event = { target: { value: finalMessage } } as ChangeEvent<HTMLInputElement>;
        onChange(event);
        await Promise.resolve(onSubmit());
        
        // Only clear tokens after successful submission
        setTokens([{ id: "initial", type: "text", content: "" }]);
        console.log('[UnifiedInput] Message submitted successfully');
      } catch (error) {
        console.error('[UnifiedInput] Submission failed:', error);
        throw error;
      }
    } catch (error) {
      console.error('[UnifiedInput] Error during submission:', error);
      // Restore tokens if submission fails
      setTokens(savedTokens);
    } finally {
      isSubmittingRef.current = false;
    }
  };

  // Cleanup function to remove timers when component unmounts
  useEffect(() => {
    return () => {
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current);
      }
    };
  }, []);

  return (
    <div className="relative">
      {children}
      
      {/* Suggestions Popover (Files & Messages) */}
      {showSuggestions && (
        <div 
          className="absolute bottom-full left-0 right-0 z-50 mb-2 file-suggestions-menu"
          style={{ display: showSuggestions ? 'block' : 'none' }}
        >
          <div className="max-h-60 rounded-md bg-white/10 backdrop-blur-xl border border-white/10 shadow-lg">
            <Command className="bg-transparent">
              <CommandList className="max-h-[300px] overflow-y-auto scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent">
                {isSearching ? (
                  <div className="flex items-center justify-center py-6">
                    <Loader2 className="h-6 w-6 text-cyan-500 animate-spin" />
                    <span className="ml-2 text-white/60">Searching files and messages...</span>
                  </div>
                ) : filteredFiles.length === 0 && filteredMessages.length === 0 ? (
                  <CommandEmpty className="text-white/60 text-sm py-2 px-4">
                    No results found. Try a different search term.
                  </CommandEmpty>
                ) : (
                  <>
                    {/* File search results */}
                    {filteredFiles.length > 0 && (
                      <CommandGroup heading="Files" className="text-white/80">
                        {filteredFiles.map((file) => (
                          <CommandItem 
                            key={file.id} 
                            value={file.path} 
                            onSelect={() => selectFile(file)}
                            className="text-white/80 hover:bg-white/10"
                          >
                            <File className="mr-2 h-4 w-4 text-white/60" />
                            <span>{file.name}</span>
                            <span className="ml-2 text-xs text-white/40 truncate max-w-[200px]">{file.path}</span>
                          </CommandItem>
                        ))}
                      </CommandGroup>
                    )}
                    
                    {/* Message search results */}
                    {filteredMessages.length > 0 && (
                      <CommandGroup heading="Messages" className="text-white/80">
                        {filteredMessages.map((message) => (
                          <CommandItem 
                            key={message.id} 
                            value={message.name} 
                            onSelect={() => selectMessage(message)}
                            className="text-white/80 hover:bg-white/10"
                          >
                            <MessageSquare className={`mr-2 h-4 w-4 ${message.role === 'assistant' ? 'text-cyan-400' : 'text-white/60'}`} />
                            <div className="flex flex-col">
                              <span className="truncate max-w-[300px]">{message.name}</span>
                              <span className="text-xs text-white/40">From: {message.conversationTitle}</span>
                            </div>
                            <span className="ml-auto text-xs px-1.5 py-0.5 rounded bg-white/10 text-white/60">
                              {message.role === 'assistant' ? 'AI' : 'User'}
                            </span>
                          </CommandItem>
                        ))}
                      </CommandGroup>
                    )}
                  </>
                )}
              </CommandList>
            </Command>
          </div>
        </div>
      )}
      
      <div
        className={`
          relative rounded-b-2xl
          bg-white/[0.03] border border-white/[0.05]
          transition-all duration-300
          overflow-hidden backdrop-blur-xl
          ${isFocused ? 'bg-white/[0.05] border-white/[0.1]' : ''}
        `}
      >
        <div className="flex items-center">
          <div className="flex-1">
            <div 
              ref={containerRef}
              className="flex flex-wrap items-center gap-1.5 p-3 min-h-[48px] max-h-[200px] overflow-y-auto scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent"
              onClick={handleContainerClick}
            >
              {tokens.map((token, index) =>
                token.type === "text" ? (
                  index === tokens.length - 1 ? (
                    <input
                      key={token.id}
                      ref={inputRef}
                      type="text"
                      className="flex-1 min-w-[120px] bg-transparent outline-none text-white/90 text-sm placeholder:text-white/40"
                      value={value}
                      onChange={handleInputChange}
                      onKeyDown={handleKeyDown}
                      onFocus={() => setIsFocused(true)}
                      onBlur={() => {
                        // Longer delay to allow clicks on the suggestions menu
                        setTimeout(() => {
                          if (!document.activeElement?.closest('.file-suggestions-menu')) {
                            setIsFocused(false);
                            setShowSuggestions(false);
                          }
                        }, 200);
                      }}
                      placeholder={tokens.length === 1 ? "Type @ to mention a file or message (Press ⌘+/ to focus)" : ""}
                    />
                  ) : (
                    <span key={token.id} className="inline-block text-white/90 text-sm">
                      {token.content}
                    </span>
                  )
                ) : token.type === "file" ? (
                  <span
                    key={token.id}
                    className="inline-flex items-center gap-1 rounded-md bg-cyan-500/20 px-1.5 py-0.5 text-sm text-cyan-300"
                  >
                    <File className="h-3 w-3" />
                    {token.file?.name}
                    <button
                      type="button"
                      className="ml-1 rounded-full hover:bg-cyan-500/30"
                      onClick={() => removeToken(token.id)}
                    >
                      <X className="h-3 w-3" />
                      <span className="sr-only">Remove</span>
                    </button>
                  </span>
                ) : (
                  <span
                    key={token.id}
                    className="inline-flex items-center gap-1 rounded-md bg-purple-500/20 px-1.5 py-0.5 text-sm text-purple-300"
                  >
                    <MessageSquare className="h-3 w-3" />
                    {token.message?.role === 'assistant' ? 'AI' : 'User'} message
                    <button
                      type="button"
                      className="ml-1 rounded-full hover:bg-purple-500/30"
                      onClick={() => removeToken(token.id)}
                    >
                      <X className="h-3 w-3" />
                      <span className="sr-only">Remove</span>
                    </button>
                  </span>
                ),
              )}
            </div>
          </div>
          <div className="flex items-center mr-2">
            <Button
              variant="cyan"
              onClick={(e) => {
                e.preventDefault();
                handleSubmit();
              }}
              disabled={disabled}
              className="h-8 rounded-xl"
            >
              Send
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
};

================
File: components/ui/common/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full border border-white/[0.05]",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-white/[0.03] text-white/80 backdrop-blur-sm",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: components/ui/common/badge.tsx
================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

================
File: components/ui/common/base-tab.tsx
================
import { ReactNode, CSSProperties } from 'react'
import { CommandType } from '@/hooks/useCommandCenter'

interface BaseTabProps {
  icon?: ReactNode
  label: string
  shortcut?: string
  onClick?: () => void
  minWidth?: 'space' | 'model' | 'actions'
  roundedBottom?: boolean
  isActive?: boolean
  style?: CSSProperties
  wrapperStyle?: CSSProperties
  className?: string
  color?: string
  rightElement?: ReactNode
  commandType?: CommandType
}

export function BaseTab({
  icon,
  color,
  label,
  shortcut,
  onClick,
  minWidth,
  style,
  wrapperStyle,
  className = '',
  rightElement,
  commandType
}: BaseTabProps) {
  const minWidthClass = {
    space: 'min-w-[100px]',
    model: 'min-w-[120px]',
    actions: ''
  }[minWidth || 'actions']

  return (
    <div
      className={`relative w-full overflow-hidden`}
      style={{ 
        ...wrapperStyle 
      }}
    >
      <div
        onClick={onClick}
        className={`px-3 py-1.5 text-white text-xs font-medium flex items-center gap-1.5 relative overflow-hidden cursor-pointer ${minWidthClass}
           transition-all duration-300 group ${className} w-full`}
        style={{ 
          ...style,
        }}
      >
        {icon && (
          <div className="relative z-10 text-white/60 group-hover:text-[#3ecfff]/80 transition-colors duration-300 flex-shrink-0">
            {icon}
          </div>
        )}
        <span className="text-white/75 truncate relative z-10 group-hover:text-white/95 transition-colors duration-300 overflow-hidden min-w-0">
          {label}
        </span>
        {shortcut && (
          <span className="text-white/60 text-[10px] ml-auto shrink-0 relative z-10">⌘{shortcut}</span>
        )}
        {rightElement && (
          <div className="ml-auto relative z-10 flex-shrink-0">
            {rightElement}
          </div>
        )}
      </div>
    </div>
  )
}

================
File: components/ui/common/button.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center text-sm font-medium transition-all duration-200 focus-visible:outline-none disabled:opacity-50 disabled:pointer-events-none",
  {
    variants: {
      variant: {
        default: "bg-primary text-white hover:bg-primary/90",
        outline: "border border-white/[0.05] bg-white/[0.02] text-white/90 hover:bg-white/[0.05] hover:text-white backdrop-blur-sm",
        ghost: "text-white/70 hover:bg-white/[0.04] hover:text-white",
        toggle: "text-white/70 hover:bg-white/[0.04] hover:text-white border-t border-white/[0.05] rounded-t-md rounded-b-none",
        cyan: "bg-[#3ecfff]/10 text-[#3ecfff] border border-[#3ecfff]/20 shadow-[0_0_12px_rgba(62,207,255,0.1)] hover:bg-[#3ecfff]/20 rounded-xl",
        destructive: "bg-red-500/10 text-red-500 hover:bg-red-500/20 border border-red-500/20",
      },
      size: {
        default: "h-10 py-2 px-4 rounded-md",
        sm: "h-8 px-3 rounded-md",
        icon: "h-8 w-8 rounded-md",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  active?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, active, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }), active && "bg-white/[0.05] text-white")}
        ref={ref}
        {...props}
      />
    )
  },
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/common/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: components/ui/common/checkbox.tsx
================
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

================
File: components/ui/common/code-block.tsx
================
"use client"

import { cn } from "@/lib/utils"
import React, { useEffect, useState } from "react"
import { codeToHtml } from "shiki"
import { LanguageIcon } from "../chat/language-icon"
import { Copy, CheckIcon } from "lucide-react"

interface CopyButtonProps {
  code: string
}

function CopyButton({ code }: CopyButtonProps) {
  const [copied, setCopied] = useState(false)

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(code)
      setCopied(true)
      setTimeout(() => setCopied(false), 2000)
    } catch (error) {
      console.error('Failed to copy:', error)
    }
  }

  return (
    <button
      onClick={handleCopy}
      className={cn(
        "flex items-center justify-center rounded-md p-1.5",
        "transition-all duration-200 ease-in-out",
        "bg-white/[0.03] hover:bg-white/[0.08] border border-white/[0.05]",
        copied 
          ? "text-green-400 hover:text-green-300 border-green-500/20 bg-green-500/10" 
          : "text-zinc-400 hover:text-zinc-200"
      )}
      title="Copy code"
    >
      {copied ? <CheckIcon size={14} /> : <Copy size={14} />}
    </button>
  )
}

export type CodeBlockProps = {
  children?: React.ReactNode
  className?: string
  code?: string
  language?: string
} & React.HTMLProps<HTMLDivElement>

function CodeBlock({ children, className, code, language, ...props }: CodeBlockProps) {
  // Generate a unique key based on code content or props if available
  const uniqueKey = React.useMemo(() => {
    return code ? `${language}-${code.slice(0, 20)}-${Math.random().toString(36).slice(2, 7)}` : `codeblock-${Math.random().toString(36).slice(2)}`
  }, [code, language])

  if (code && language) {
    return (
      <div
        className={cn(
          "not-prose flex w-full flex-col overflow-hidden my-4 rounded-lg",
          "glass-effect code-block-glow glass-highlight",
          className
        )}
        style={{
          background: 'rgba(255, 255, 255, 0.02)',
          backdropFilter: 'blur(12px)',
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
          border: '1px solid rgba(255, 255, 255, 0.05)'
        }}
        key={uniqueKey} // Add unique key at the top level
        {...props}
      >
        <div className="flex items-center justify-between w-full px-4 py-2 header" style={{background: 'rgba(255, 255, 255, 0.03)', borderBottom: '1px solid rgba(255, 255, 255, 0.05)'}}>
          <div className="flex items-center space-x-2">
            <div className="flex space-x-1.5">
              <div className="w-3 h-3 rounded-full bg-red-500/90 border border-red-600/30 shadow-inner shadow-red-700/20"></div>
              <div className="w-3 h-3 rounded-full bg-yellow-500/90 border border-yellow-600/30 shadow-inner shadow-yellow-700/20"></div>
              <div className="w-3 h-3 rounded-full bg-green-500/90 border border-green-600/30 shadow-inner shadow-green-700/20"></div>
            </div>
            <div className="text-xs text-zinc-400 ml-2">
              {code.split('\n')[0].startsWith('//') ? code.split('\n')[0].substring(2).trim() : ''}
            </div>
          </div>
          <div className="flex items-center gap-2">
          {language && (
                    <div 
                      className="flex items-center gap-1.5 text-xs rounded-md p-1.5 bg-white/[0.03] border border-white/[0.05] text-zinc-400"
                      key={`language-badge-${uniqueKey}`}
                    >
                      <span>{language}</span>
                    </div>
                  )}
            <CopyButton code={code} />
          </div>
        </div>
        <CodeBlockCode code={code} language={language} />
      </div>
    )
  }
  
  return (
    <div
      className={cn(
        "not-prose flex w-full flex-col overflow-hidden my-4 rounded-lg",
        "glass-effect code-block-glow glass-highlight",
        className
      )}
      style={{
        background: 'rgba(255, 255, 255, 0.02)',
        backdropFilter: 'blur(12px)',
        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }}
      key={uniqueKey} // Add unique key here too
      {...props}
    >
      {children}
    </div>
  )
}

export type CodeBlockCodeProps = {
  code: string
  language?: string
  theme?: string
  className?: string
} & React.HTMLProps<HTMLDivElement>

function CodeBlockCode({
  code,
  language = "tsx",
  theme = "github-dark",
  className,
  ...props
}: CodeBlockCodeProps) {
  const [highlightedHtml, setHighlightedHtml] = useState<string | null>(null)
  const [isLargeCode, setIsLargeCode] = useState(false)
  const codeLength = code?.length || 0

  useEffect(() => {
    if (codeLength > 10000) {
      setIsLargeCode(true)
    } else {
      setIsLargeCode(false)
    }

    let isMounted = true
    
    const timer = setTimeout(async () => {
      try {
        const customTheme = {
          name: 'glass-dark',
          type: 'dark',
          fg: '#EEEEEE',
          bg: '#00000000',
          settings: [
            {
              settings: {
                background: '#00000000',
                foreground: '#EEEEEE',
                caret: '#FFFFFF',
                selection: 'rgba(128, 203, 255, 0.2)',
                selectionBorder: 'rgba(128, 203, 255, 0.4)',
                lineHighlight: 'rgba(255, 255, 255, 0.05)',
                gutterForeground: 'rgba(175, 175, 175, 0.5)',
                gutterBorder: 'rgba(255, 255, 255, 0.05)',
              }
            },
            {
              scope: ['comment', 'punctuation.definition.comment', 'string.comment'],
              settings: {
                foreground: 'rgba(106, 153, 85, 0.9)'
              }
            },
            {
              scope: ['string', 'constant.other.symbol'],
              settings: {
                foreground: 'rgba(206, 145, 120, 0.9)'
              }
            },
            {
              scope: ['keyword', 'storage.type', 'storage.modifier'],
              settings: {
                foreground: 'rgba(86, 156, 214, 0.9)'
              }
            },
            {
              scope: ['entity.name.function', 'support.function'],
              settings: {
                foreground: 'rgba(220, 220, 170, 0.9)'
              }
            },
            {
              scope: ['variable', 'support.variable'],
              settings: {
                foreground: 'rgba(156, 220, 254, 0.9)'
              }
            }
          ]
        };

        const html = await codeToHtml(code, { 
          lang: language, 
          theme: "github-dark",
          transformers: [{
            root(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            pre(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            code(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            line(node) {
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              if (style.includes('background')) {
                nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              }
              return node;
            },
            tokens(node) {
              return node.map((token: any, index: number) => {
                const tokenAsAny = token as any;
                if (!tokenAsAny.properties) tokenAsAny.properties = {};
                const style = tokenAsAny.properties.style || '';
                if (style.includes('background')) {
                  tokenAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, '');
                }
                tokenAsAny.properties.key = `token-${index}`;
                return token;
              });
            }
          }]
        });

        if (isMounted) {
          const processedHtml = html
            .replace(/background-color: #24292e;/g, 'background-color: transparent !important;')
            .replace(/background-color: #1f2428;/g, 'background-color: transparent !important;')
            .replace(/background: #24292e;/g, 'background: transparent !important;')
            .replace(/background: #1f2428;/g, 'background: transparent !important;');
          
          setHighlightedHtml(processedHtml);
        }
      } catch (error) {
        console.error('Error highlighting code:', error)
      }
    }, isLargeCode ? 100 : 0)

    return () => {
      isMounted = false
      clearTimeout(timer)
    }
  }, [code, language, theme, codeLength, isLargeCode])

  const classNames = cn(
    "w-full overflow-x-auto text-[13px] relative",
    "bg-transparent [&>pre]:bg-transparent [&>pre]:px-4 [&>pre]:py-4 [&>pre]:rounded-b-lg",
    "[&>pre>code]:bg-transparent [&>pre>code]:font-mono [&>pre>code]:text-zinc-200 [&>.shiki]:bg-transparent [&>.shiki]:px-4 [&>.shiki]:py-4 [&>.shiki]:rounded-b-lg",
    "backdrop-blur-[2px]",
    "glass-highlight",
    className
  )

  if (isLargeCode && !highlightedHtml) {
    return (
      <div className={cn(classNames, "glass-code-content")} style={{background: 'transparent'}} {...props}>
        <pre className="bg-transparent text-zinc-200 px-4 py-4 rounded-b-lg font-mono" style={{background: 'transparent'}}>
          <code className={`language-${language} bg-transparent font-mono`} style={{background: 'transparent'}}>
            {code.length > 50000 
              ? code.substring(0, 50000) + '...\n\n(Code truncated for performance - full code will appear shortly)'
              : code}
          </code>
        </pre>
      </div>
    )
  }

  return highlightedHtml ? (
    <div
      className={cn(classNames, "glass-code-content")}
      style={{background: 'transparent'}}
      dangerouslySetInnerHTML={{ __html: highlightedHtml }}
      {...props}
    />
  ) : (
    <div className={cn(classNames, "glass-code-content")} style={{background: 'transparent'}} {...props}>
      <pre className="bg-transparent text-zinc-200 px-4 py-4 rounded-b-lg font-mono" style={{background: 'transparent'}}>
        <code className="font-mono bg-transparent" style={{background: 'transparent'}}>{code}</code>
      </pre>
    </div>
  )
}

export type CodeBlockGroupProps = React.HTMLAttributes<HTMLDivElement>

function CodeBlockGroup({
  children,
  className,
  ...props
}: CodeBlockGroupProps) {
  return (
    <div
      className={cn("flex items-center justify-between", className)}
      {...props}
    >
      {children}
    </div>
  )
}

export { CodeBlockGroup, CodeBlockCode, CodeBlock }

================
File: components/ui/common/command-badge.tsx
================
import { cn } from '@/utils';

interface CommandBadgeProps {
  children: React.ReactNode;
  variant?: 'active' | 'info' | 'count';
  className?: string;
}

export function CommandBadge({ children, variant = 'info', className }: CommandBadgeProps) {
  return (
    <span
      className={cn(
        'px-1.5 py-0.5 rounded-md text-[10px] font-medium',
        variant === 'active' && 'bg-[#3ecfff]/10 text-[#3ecfff] border border-[#3ecfff]/20',
        variant === 'info' && 'text-white/40 border border-white/10',
        variant === 'count' && 'bg-white/5 text-white/60',
        className
      )}
    >
      {children}
    </span>
  );
}

================
File: components/ui/common/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-transparent data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border border-white/[0.05] bg-white/[0.03] p-6 shadow-none backdrop-blur-xl duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg glass-dialog",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:text-white/70 hover:text-white">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight text-white/90",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-white/70", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: components/ui/common/dropdown-menu.tsx
================
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white/95 focus:bg-white/[0.05]",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4 text-white/60" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border border-white/[0.05] bg-white/[0.03] p-1 text-white/90 shadow-none backdrop-blur-xl data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border border-white/[0.05] bg-white/[0.03] p-1 text-white/90 shadow-none backdrop-blur-xl data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white/95 focus:bg-white/[0.05] focus:text-white/95 data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white/95 focus:bg-white/[0.05] focus:text-white/95 data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white/95 focus:bg-white/[0.05] focus:text-white/95 data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-white/90",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-white/[0.05]", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest text-white/50", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

================
File: components/ui/common/input.tsx
================
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 placeholder:text-white/40 outline-none focus:bg-white/[0.03] focus:border-white/[0.1] transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };

================
File: components/ui/common/label.tsx
================
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none text-white/80 peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

================
File: components/ui/common/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: components/ui/common/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 transition-all duration-200 focus:bg-white/[0.03] focus:border-white/[0.1] focus:outline-none disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 text-white/50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border border-white/[0.05] bg-white/[0.03] backdrop-blur-xl text-white/90 shadow-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm text-white/80 outline-none transition-all duration-200 hover:bg-white/[0.05] hover:text-white data-[state=checked]:bg-white/[0.05] data-[state=checked]:text-white focus:bg-white/[0.08] focus:text-white data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: components/ui/common/switch.tsx
================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

================
File: components/ui/common/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-white/[0.05] bg-white/[0.02] px-3 py-2 text-sm text-white/90 placeholder:text-white/40 outline-none focus:bg-white/[0.03] focus:border-white/[0.1] transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

================
File: components/ui/common/theme-switcher.tsx
================
"use client";

import { Button } from "@/components/ui/common/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/ui/common/dropdown-menu";
import { Laptop, Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";

const ThemeSwitcher = () => {
  const [mounted, setMounted] = useState(false);
  const { theme, setTheme } = useTheme();

  // useEffect only runs on the client, so now we can safely show the UI
  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  const ICON_SIZE = 16;

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size={"sm"}>
          {theme === "light" ? (
            <Sun
              key="light"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : theme === "dark" ? (
            <Moon
              key="dark"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : (
            <Laptop
              key="system"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-content" align="start">
        <DropdownMenuRadioGroup
          value={theme}
          onValueChange={(e) => setTheme(e)}
        >
          <DropdownMenuRadioItem className="flex gap-2" value="light">
            <Sun size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Light</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="dark">
            <Moon size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Dark</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="system">
            <Laptop size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>System</span>
          </DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

export { ThemeSwitcher };

================
File: components/ui/common/toast.tsx
================
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 right-0 z-[9999] flex max-h-screen w-auto flex-col-reverse items-end gap-2 p-4",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full max-w-[350px] items-center justify-between space-x-2 overflow-hidden rounded-md p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-top-full data-[state=open]:slide-in-from-top-full data-[state=open]:duration-300 data-[state=closed]:duration-200",
  {
    variants: {
      variant: {
        default: 
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
        destructive:
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
        success:
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: components/ui/common/toaster.tsx
================
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/common/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: components/ui/common/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-lg px-3 py-1.5 text-xs animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 bg-black/90 border border-white/10 backdrop-blur-xl shadow-xl shadow-black/20 text-white/90 font-medium",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: components/ui/conversation/conversation-sphere.tsx
================
import React, { useState, useMemo, useCallback } from 'react';

interface DotChatBubbleProps {
  size?: number;
  seed?: string;
  dotCount?: number;
  dotSize?: number;
  className?: string;
  expandFactor?: number;
  transitionSpeed?: number;
  highPerformance?: boolean;
}

interface DotChatBubbleComponent extends React.FC<DotChatBubbleProps> {
  seedCache: Map<string, number>;
  callCount: number;
}

const round = (num: number, precision: number = 6): number => {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
};

const Dot = React.memo(({ 
  dot, 
  isHovering, 
  size, 
  expandFactor, 
  transitionSpeed 
}: { 
  dot: {
    x: number;
    y: number;
    z: number;
    color: string;
    size: number;
    opacity: number;
    zIndex: number;
  };
  isHovering: boolean;
  size: number;
  expandFactor: number;
  transitionSpeed: number;
}) => {
  const expandedX = useMemo(() => 
    round(dot.x + (dot.x - size / 2) * (expandFactor - 1), 6),
    [dot.x, size, expandFactor]
  );
  
  const expandedY = useMemo(() => 
    round(dot.y + (dot.y - size / 2) * (expandFactor - 1), 6),
    [dot.y, size, expandFactor]
  );
  
  const expandedZ = useMemo(() => 
    round(dot.z * expandFactor, 6), 
    [dot.z, expandFactor]
  );

  const currentX = isHovering ? expandedX : dot.x;
  const currentY = isHovering ? expandedY : dot.y;
  const currentZ = isHovering ? expandedZ : dot.z;

  return (
    <div
      className="absolute rounded-full"
      style={{
        backgroundColor: dot.color,
        width: `${round(dot.size, 6)}px`,
        height: `${round(dot.size, 6)}px`,
        opacity: round(dot.opacity, 6),
        transform: `translate3d(${round(currentX, 6)}px, ${round(currentY, 6)}px, ${round(currentZ, 6)}px)`,
        transitionProperty: 'transform',
        transitionDuration: `${transitionSpeed}ms`,
        transitionTimingFunction: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
        transitionDelay: '0s',
        zIndex: dot.zIndex,
        willChange: 'transform'
      }}
    />
  );
});

Dot.displayName = 'Dot';

const DotChatBubble: DotChatBubbleComponent = ({
  size = 120,
  seed,
  dotCount = 150,
  dotSize = 2.5,
  className = '',
  expandFactor = 1.3,
  transitionSpeed = 800,
  highPerformance = false,
}) => {
  const [isHovering, setIsHovering] = useState(false);
  const actualDotCount = highPerformance ? Math.min(dotCount, 60) : dotCount;

  const seedNum = useMemo(() => {
    if (!seed) return Math.floor(Math.random() * 10000);
    if (!DotChatBubble.seedCache.has(seed)) {
      const hash = Array.from(seed).reduce((acc, char) => acc + char.charCodeAt(0), 0);
      DotChatBubble.seedCache.set(seed, hash);
    }
    return DotChatBubble.seedCache.get(seed)!;
  }, [seed]);

  const random = useCallback(() => {
    let x = Math.sin(seedNum + DotChatBubble.callCount++) * 10000;
    return x - Math.floor(x);
  }, [seedNum]);

  const dots = useMemo(() => {
    const points = [];
    const bubbleWidth = size * 0.8; // Main body width
    const bubbleHeight = size * 0.6; // Main body height
    const tailHeight = size * 0.2; // Tail height
    const tailWidth = size * 0.2; // Tail base width
    const cornerRadius = size * 0.1; // Rounded corner radius
    const maxZ = size * 0.2; // Depth for 3D effect

    DotChatBubble.callCount = 1;

    for (let i = 0; i < actualDotCount; i++) {
      let x: number, y: number;

      // Keep generating points until they fall within the chat bubble shape
      while (true) {
        x = (random() - 0.5) * bubbleWidth;
        y = (random() - 0.5) * (bubbleHeight + tailHeight);

        // Check if the point falls within the main body (with rounded corners)
        const isInMainBody = () => {
          const absX = Math.abs(x);
          const absY = Math.abs(y - tailHeight / 2);
          if (absX <= bubbleWidth / 2 - cornerRadius && absY <= bubbleHeight / 2) return true;
          if (absX > bubbleWidth / 2 || absY > bubbleHeight / 2) return false;
          const dx = absX - (bubbleWidth / 2 - cornerRadius);
          const dy = absY - (bubbleHeight / 2 - cornerRadius);
          return dx * dx + dy * dy <= cornerRadius * cornerRadius;
        };

        // Check if the point falls within the triangular tail
        const isInTail = () => {
          if (y > 0 || y < -bubbleHeight / 2 - tailHeight) return false;
          const tailProgress = (y + bubbleHeight / 2 + tailHeight) / tailHeight; // 0 at top, 1 at bottom
          const currentTailWidth = tailWidth * (1 - tailProgress); // Linearly taper the tail
          return Math.abs(x - bubbleWidth / 4) <= currentTailWidth / 2; // Tail is offset to the right
        };

        if (isInMainBody() || isInTail()) break;
      }

      // Adjust coordinates to center the shape
      const posX = round(x + size / 2, 6);
      const posY = round(y + size / 2, 6);
      const posZ = round((random() - 0.5) * maxZ, 6); // Small depth for 3D effect

      const hue = round((seedNum % 360) + (i * 137.5) % 360, 2);
      const saturation = round(70 + random() * 30, 2);
      const lightness = round(45 + random() * 30, 2);
      const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

      const sizeVariation = round(0.8 + random() * 0.6, 6);
      const finalDotSize = round(dotSize * sizeVariation, 6);

      const zIndex = Math.floor(posZ);
      const opacity = round(0.6 + (posZ / maxZ) * 0.4, 6);

      points.push({
        x: posX,
        y: posY,
        z: posZ,
        color,
        size: finalDotSize,
        opacity,
        zIndex,
      });
    }

    return points.sort((a, b) => a.zIndex - b.zIndex);
  }, [actualDotCount, dotSize, random, seedNum, size]);

  const handleMouseEnter = useCallback(() => setIsHovering(true), []);
  const handleMouseLeave = useCallback(() => setIsHovering(false), []);

  return (
    <div
      className={`relative ${className}`}
      style={{
        width: size,
        height: size,
        perspective: size * 3,
      }}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <div
        className="relative w-full h-full"
        style={{ transformStyle: 'preserve-3d' }}
      >
        {dots.map((dot, index) => (
          <Dot 
            key={index}
            dot={dot}
            isHovering={isHovering}
            size={size}
            expandFactor={expandFactor}
            transitionSpeed={transitionSpeed}
          />
        ))}
      </div>
    </div>
  );
};

DotChatBubble.seedCache = new Map<string, number>();
DotChatBubble.callCount = 1;

export default DotChatBubble;

================
File: components/ui/conversation/conversation-tab.tsx
================
import { MessageSquare, Plus, Check, Loader2 } from 'lucide-react'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/common/tooltip"
import { BaseTab } from '@/components/ui/common/base-tab'
import { cn } from '@/lib/utils'
import { useCommandCenter } from '@/hooks/useCommandCenter'
import { useState } from 'react'

export function ServerDrivenConversationTab({
  activeConversation,
  onCreateConversation,
}: {
  activeConversation: any;
  onCreateConversation: (title: string) => Promise<void>;
}) {
  const { openCommandType } = useCommandCenter();
  const [isCreating, setIsCreating] = useState(false);

  const handleNewConversation = async () => {
    if (!activeConversation?.space_id) return;
    
    try {
      setIsCreating(true);
      await onCreateConversation("New Conversation");
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <div className="flex items-center justify-between w-full overflow-hidden">
      <div className="flex-1 min-w-0 overflow-hidden">
        <BaseTab 
          icon={<MessageSquare className="w-3 h-3" />}
          label={activeConversation?.title || "No Conversation Selected"}
          shortcut="C"
          commandType="conversations"
          onClick={() => openCommandType("conversations")}
          className="w-full"
        />
      </div>
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <button
              onClick={handleNewConversation}
              disabled={isCreating || !activeConversation?.space_id}
              className={cn(
                "inline-flex items-center justify-center rounded-full w-4 h-4 ml-1.5 flex-shrink-0",
                "text-white/80 bg-white/5 hover:bg-white/10",
                "border border-white/10 transition-colors",
                "focus:outline-none focus:ring-2 focus:ring-white/20",
                (isCreating || !activeConversation?.space_id) && "opacity-50 cursor-not-allowed"
              )}
            >
              {isCreating ? (
                <Check className="w-2 h-2" />
              ) : (
                <Plus className="w-2 h-2" />
              )}
            </button>
          </TooltipTrigger>
          <TooltipContent>
            <p>New Conversation</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </div>
  );
}

================
File: components/ui/conversation/create-conversation-button.tsx
================
import React, { useCallback } from 'react';
import { useLoadingOperation } from '@/hooks/useLoadingOperation';
import { createConversation } from '@/app/actions/conversations';
import { useOperationToast } from '@/hooks/useOperationToast';

const CreateConversationButton: React.FC = () => {
  const conversationCreation = useLoadingOperation(
    async (conversationData: { name: string; description: string; spaceId: string }) => {
      const { name, spaceId } = conversationData;
      return await createConversation(spaceId, name);
    },
    {
      onSuccess: (result) => {
        if (result && result.status === 'success') {
          showToastFromResult(result);      
          setIsOpen(false);
          resetForm();
        }
      },
      onError: (error) => {
        console.error('Failed to create conversation:', error);
      }
    }
  );

  const handleSubmit = useCallback(async (event: React.FormEvent) => {
    event.preventDefault();
    // Implement the form submission logic here
  }, []);

  return (
    <button onClick={handleSubmit}>Create Conversation</button>
  );
};

export default CreateConversationButton;

================
File: components/ui/space/create-space-button.tsx
================
import { useState } from 'react';
import { Plus, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/common/button';
import { createSpace } from '@/app/actions/spaces';
import { useLoadingOperation } from '@/hooks/useLoadingOperation';
import { useRouteTransition } from '@/hooks/useRouteTransition';
import { useOperationToast } from '@/hooks/useOperationToast';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/common/dialog';
import { Input } from '@/components/ui/common/input';
import { Label } from '@/components/ui/common/label';
import { Textarea } from '@/components/ui/common/textarea';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/common/select';

// Default options
const DEFAULT_MODEL = 'claude-3-sonnet-20240229';
const DEFAULT_PROVIDER = 'anthropic';
const PROVIDER_NAMES: Record<string, string> = {
  'anthropic': 'Anthropic',
  'openai': 'OpenAI',
};

export function CreateSpaceButton() {
  const [isOpen, setIsOpen] = useState(false);
  const [name, setName] = useState('New Space');
  const [description, setDescription] = useState('');
  const [provider, setProvider] = useState(DEFAULT_PROVIDER);
  
  const { showToastFromResult } = useOperationToast();
  const { navigateWhenReady, isTransitioning } = useRouteTransition();
  
  // Use our enhanced loading operation hook
  const spaceCreation = useLoadingOperation(
    async (spaceData: { name: string; description: string; model: string; provider: string }) => {
      const { name, description, model, provider } = spaceData;
      return await createSpace(name, description, model, provider, true);
    }, 
    {
      onSuccess: (result) => {
        if (result && result.status === 'success') {
          showToastFromResult(result);
          setIsOpen(false);
          resetForm();
        }
      },
      onError: (error) => {
        console.error('Failed to create space:', error);
      }
    }
  );
  
  // Combined loading state
  const isLoading = spaceCreation.isLoading || isTransitioning;
  
  const resetForm = () => {
    setName('New Space');
    setDescription('');
    setProvider(DEFAULT_PROVIDER);
  };
  
  const handleCreateSpace = async (e: React.FormEvent) => {
    e.preventDefault();
    
    await navigateWhenReady(async () => {
      const result = await spaceCreation.execute({
        name,
        description,
        model: DEFAULT_MODEL,
        provider,
      });
      
      return result || {};
    });
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        <Button variant="outline" size="sm">
          <Plus className="mr-2 h-4 w-4" />
          New Space
        </Button>
      </DialogTrigger>
      <DialogContent>
        <form onSubmit={handleCreateSpace}>
          <DialogHeader>
            <DialogTitle>Create New Space</DialogTitle>
            <DialogDescription>
              Create a new workspace for your conversations.
            </DialogDescription>
          </DialogHeader>
          
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="name" className="text-right">
                Name
              </Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="col-span-3"
                required
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="description" className="text-right">
                Description
              </Label>
              <Textarea
                id="description"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                className="col-span-3"
                placeholder="Optional"
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="provider" className="text-right">
                Provider
              </Label>
              <Select value={provider} onValueChange={(value) => setProvider(value)}>
                <SelectTrigger id="provider" className="col-span-3">
                  <SelectValue placeholder="Select provider" />
                </SelectTrigger>
                <SelectContent>
                  {Object.entries(PROVIDER_NAMES).map(([key, name]) => (
                    <SelectItem key={key} value={key}>
                      {name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>
          
          <DialogFooter>
            <Button 
              type="submit" 
              disabled={isLoading || !name.trim()}
            >
              {isLoading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Creating...
                </>
              ) : (
                'Create Space'
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================
File: components/ui/space/planet-icon.tsx
================
import React, { useState, useMemo, useCallback } from 'react';

interface DotSphereProps {
  size?: number;
  seed?: string;
  dotCount?: number;
  dotSize?: number;
  className?: string;
  expandFactor?: number;
  transitionSpeed?: number;
  highPerformance?: boolean; // New prop for performance mode
}

// Add static properties to the component type
interface DotSphereComponent extends React.FC<DotSphereProps> {
  seedCache: Map<string, number>;
  callCount: number;
}

const round = (num: number, precision: number = 6): number => {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
};

// Create a separate component for individual dots to optimize rendering
const Dot = React.memo(({ 
  dot, 
  isHovering, 
  size, 
  expandFactor, 
  transitionSpeed 
}: { 
  dot: {
    x: number;
    y: number;
    z: number;
    color: string;
    size: number;
    opacity: number;
    zIndex: number;
  };
  isHovering: boolean;
  size: number;
  expandFactor: number;
  transitionSpeed: number;
}) => {
  // Calculate expanded position when hovering - memoized within the component
  const expandedX = useMemo(() => 
    round(dot.x + (dot.x - size / 2) * (expandFactor - 1), 6),
    [dot.x, size, expandFactor]
  );
  
  const expandedY = useMemo(() => 
    round(dot.y + (dot.y - size / 2) * (expandFactor - 1), 6),
    [dot.y, size, expandFactor]
  );
  
  const expandedZ = useMemo(() => 
    round(dot.z * expandFactor, 6), 
    [dot.z, expandFactor]
  );

  // Use original or expanded position based on hover state
  const currentX = isHovering ? expandedX : dot.x;
  const currentY = isHovering ? expandedY : dot.y;
  const currentZ = isHovering ? expandedZ : dot.z;

  return (
    <div
      className="absolute rounded-full"
      style={{
        backgroundColor: dot.color,
        width: `${round(dot.size, 6)}px`,
        height: `${round(dot.size, 6)}px`,
        opacity: round(dot.opacity, 6),
        transform: `translate3d(${round(currentX, 6)}px, ${round(currentY, 6)}px, ${round(currentZ, 6)}px)`,
        transitionProperty: 'transform',
        transitionDuration: `${transitionSpeed}ms`,
        transitionTimingFunction: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
        transitionDelay: '0s',
        zIndex: dot.zIndex,
        willChange: 'transform' // Hint to browser for hardware acceleration
      }}
    />
  );
});

Dot.displayName = 'Dot'; // For debugging in React DevTools

// Create the component as a properly typed FC
const DotSphere: DotSphereComponent = ({
  size = 120,
  seed,
  dotCount = 150,
  dotSize = 2.5,
  className = '',
  expandFactor = 1.3,
  transitionSpeed = 800,
  highPerformance = false, // Default to false for backward compatibility
}) => {
  const [isHovering, setIsHovering] = useState(false);

  // Adjust dot count for performance mode
  const actualDotCount = highPerformance ? Math.min(dotCount, 60) : dotCount;

  // Compute a stable number from the seed for consistent randomization
  const seedNum = useMemo(() => {
    if (!seed) return Math.floor(Math.random() * 10000);
    
    // Cache seed hash computation in a Map for improved performance
    if (!DotSphere.seedCache.has(seed)) {
      const hash = Array.from(seed).reduce((acc, char) => acc + char.charCodeAt(0), 0);
      DotSphere.seedCache.set(seed, hash);
    }
    
    return DotSphere.seedCache.get(seed)!;
  }, [seed]);

  // Seeded random number generator for reproducibility
  const random = useCallback(() => {
    let x = Math.sin(seedNum + DotSphere.callCount++) * 10000;
    return x - Math.floor(x);
  }, [seedNum]);

  // Generate dots distributed on a sphere (Fibonacci spiral algorithm)
  const dots = useMemo(() => {
    const sphereRadius = round((size / 2 - dotSize) * 0.8, 6);
    const points = [];
    const goldenRatio = (1 + Math.sqrt(5)) / 2;
    
    // Reset call count before generating dots to ensure consistent random sequence
    DotSphere.callCount = 1;

    for (let i = 0; i < actualDotCount; i++) {
      const y = round(1 - (i / (actualDotCount - 1)) * 2, 6);
      const radius = round(Math.sqrt(1 - y * y), 6);
      const theta = round(2 * Math.PI * i / goldenRatio, 6);
      const x = round(Math.cos(theta) * radius, 6);
      const z = round(Math.sin(theta) * radius, 6);

      // Generate color with rounded values
      const hue = round((seedNum % 360) + (i * 137.5) % 360, 2);
      const saturation = round(70 + random() * 30, 2);
      const lightness = round(45 + random() * 30, 2);
      const color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

      const sizeVariation = round(0.8 + random() * 0.6, 6);
      const finalDotSize = round(dotSize * sizeVariation, 6);

      const posX = round(x * sphereRadius + size / 2, 6);
      const posY = round(y * sphereRadius + size / 2, 6);
      const posZ = round(z * sphereRadius, 6);

      const zIndex = Math.floor(posZ);
      const opacity = round(0.6 + (posZ / sphereRadius) * 0.4, 6);

      points.push({
        x: posX,
        y: posY,
        z: posZ,
        color,
        size: finalDotSize,
        opacity,
        zIndex,
      });
    }

    return points.sort((a, b) => a.zIndex - b.zIndex);
  }, [actualDotCount, dotSize, random, seedNum, size]);

  // Event handlers for hover
  const handleMouseEnter = useCallback(() => setIsHovering(true), []);
  const handleMouseLeave = useCallback(() => setIsHovering(false), []);

  return (
    <div
      className={`relative ${className}`}
      style={{
        width: size,
        height: size,
        perspective: size * 3, // 3D perspective
      }}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      <div
        className="relative w-full h-full"
        style={{ transformStyle: 'preserve-3d' }}
      >
        {dots.map((dot, index) => (
          <Dot 
            key={index}
            dot={dot}
            isHovering={isHovering}
            size={size}
            expandFactor={expandFactor}
            transitionSpeed={transitionSpeed}
          />
        ))}
      </div>
    </div>
  );
};

// Initialize static properties
DotSphere.seedCache = new Map<string, number>();
DotSphere.callCount = 1;

export default DotSphere;

================
File: components/ui/space/space-tab.tsx
================
'use client'

import { BaseTab } from '@/components/ui/common/base-tab'
import { useCommandCenter } from '@/hooks/useCommandCenter'
import DotSphere from './planet-icon'

export function ServerDrivenSpaceTab({ 
  activeSpace,
  isLoading = false
}: { 
  spaces: any[],
  activeSpace: any,
  isLoading?: boolean
}) {
  const { openCommandType } = useCommandCenter()

  const spaceColor = activeSpace?.color || '#3ecfff'

  return (
    <div className="relative flex items-center">
      {activeSpace && (
        <div className="mr-1">
          <DotSphere 
            size={24} 
            seed={activeSpace.id} 
            dotCount={80} 
            dotSize={0.8} 
            expandFactor={1.15} 
            transitionSpeed={400}
            className={isLoading ? "animate-pulse" : ""}
            highPerformance={true}
          />
        </div>
      )}
      <BaseTab
        label={isLoading ? `Loading${activeSpace?.name ? ' ' + activeSpace.name : ''}...` : (activeSpace?.name || "No Space Selected")}
        shortcut="E"
        commandType="spaces"
        onClick={() => openCommandType("spaces")}
        rightElement={isLoading ? <span className="loading-dots text-[10px] text-cyan-400"></span> : undefined}
      />
    </div>
  )
}

================
File: components/ui/chat-container.tsx
================
"use client"

import { cn } from "@/lib/utils"
import { useEffect, useRef, useState, useCallback } from "react"
import React from "react"

const useAutoScroll = (
  containerRef: React.RefObject<HTMLDivElement | null>,
  enabled: boolean
) => {
  const [autoScrollEnabled, setAutoScrollEnabled] = useState(true)
  const lastScrollTopRef = useRef(0)
  const autoScrollingRef = useRef(false)
  const userScrollingRef = useRef(false)
  const [newMessageAdded, setNewMessageAdded] = useState(false)
  const prevChildrenCountRef = useRef(0)
  const scrollTriggeredRef = useRef(false)
  const scrollTimeout = useRef<NodeJS.Timeout | null>(null)

  // Increased the threshold to prevent flickering when content expands
  const isAtBottom = useCallback((element: HTMLDivElement) => {
    const { scrollTop, scrollHeight, clientHeight } = element
    return scrollHeight - scrollTop - clientHeight <= 100
  }, [])

  const scrollToBottom = useCallback((behavior: ScrollBehavior = "smooth") => {
    const container = containerRef.current
    if (!container) return
    
    // If user is actively scrolling up, don't interrupt
    if (userScrollingRef.current && !isAtBottom(container)) {
      return
    }

    autoScrollingRef.current = true
    scrollTriggeredRef.current = true
    
    const targetScrollTop = container.scrollHeight - container.clientHeight

    container.scrollTo({
      top: targetScrollTop,
      behavior: behavior
    })

    // Use a single reliable cleanup mechanism with improved timing
    if (scrollTimeout.current) {
      clearTimeout(scrollTimeout.current)
    }
    
    scrollTimeout.current = setTimeout(() => {
      autoScrollingRef.current = false
      scrollTriggeredRef.current = false
      scrollTimeout.current = null
    }, 300)
  }, [containerRef, isAtBottom])

  useEffect(() => {
    if (!enabled) return

    const container = containerRef?.current
    if (!container) return

    lastScrollTopRef.current = container.scrollTop

    const handleScroll = () => {
      if (autoScrollingRef.current) return

      const currentScrollTop = container.scrollTop
      const wasAtBottom = isAtBottom(container)
      
      // Only disable auto-scroll if user is actually scrolling up
      if (currentScrollTop < lastScrollTopRef.current && 
          autoScrollEnabled && 
          Math.abs(currentScrollTop - lastScrollTopRef.current) > 10) {
        setAutoScrollEnabled(false)
        userScrollingRef.current = true
        
        // Reset user scrolling state after a short delay
        if (scrollTimeout.current) {
          clearTimeout(scrollTimeout.current)
        }
        
        scrollTimeout.current = setTimeout(() => {
          userScrollingRef.current = false
          scrollTimeout.current = null
        }, 300)
      }

      // Re-enable auto-scroll if user scrolls back to bottom
      if (wasAtBottom && !autoScrollEnabled) {
        setAutoScrollEnabled(true)
      }

      lastScrollTopRef.current = currentScrollTop
    }

    const handleWheel = (e: WheelEvent) => {
      // Mark that user is actively scrolling if scrolling up
      if (e.deltaY < 0) {
        userScrollingRef.current = true
        
        // Reset user scrolling after a delay
        if (scrollTimeout.current) {
          clearTimeout(scrollTimeout.current)
        }
        
        scrollTimeout.current = setTimeout(() => {
          userScrollingRef.current = false
          scrollTimeout.current = null
        }, 300)
        
        if (autoScrollEnabled) {
          setAutoScrollEnabled(false)
        }
      }
    }

    const handleTouchStart = () => {
      lastScrollTopRef.current = container.scrollTop
    }

    const handleTouchMove = () => {
      if (container.scrollTop < lastScrollTopRef.current && 
          autoScrollEnabled && 
          Math.abs(container.scrollTop - lastScrollTopRef.current) > 10) {
        setAutoScrollEnabled(false)
        userScrollingRef.current = true
      }

      lastScrollTopRef.current = container.scrollTop
    }

    const handleTouchEnd = () => {
      // Reset user scrolling state after touch ends
      setTimeout(() => {
        userScrollingRef.current = false
      }, 300)
      
      if (isAtBottom(container) && !autoScrollEnabled) {
        setAutoScrollEnabled(true)
      }
    }

    container.addEventListener("scroll", handleScroll, { passive: true })
    container.addEventListener("wheel", handleWheel, { passive: true })
    container.addEventListener("touchstart", handleTouchStart, {
      passive: true,
    })
    container.addEventListener("touchmove", handleTouchMove, { passive: true })
    container.addEventListener("touchend", handleTouchEnd, { passive: true })

    return () => {
      container.removeEventListener("scroll", handleScroll)
      container.removeEventListener("wheel", handleWheel)
      container.removeEventListener("touchstart", handleTouchStart)
      container.removeEventListener("touchmove", handleTouchMove)
      container.removeEventListener("touchend", handleTouchEnd)
      
      if (scrollTimeout.current) {
        clearTimeout(scrollTimeout.current)
      }
    }
  }, [containerRef, enabled, autoScrollEnabled, isAtBottom])

  return {
    autoScrollEnabled,
    scrollToBottom,
    isScrolling: autoScrollingRef.current,
    scrollTriggered: scrollTriggeredRef.current,
    userScrolling: userScrollingRef.current,
    newMessageAdded,
    setNewMessageAdded,
    prevChildrenCountRef,
  }
}

export type ChatContainerProps = {
  children: React.ReactNode
  className?: string
  autoScroll?: boolean
  scrollToRef?: React.RefObject<HTMLDivElement | null>
  ref?: React.RefObject<HTMLDivElement | null>
} & React.HTMLAttributes<HTMLDivElement>

function ChatContainer({
  className,
  children,
  autoScroll = true,
  scrollToRef,
  ref,
  ...props
}: ChatContainerProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const localBottomRef = useRef<HTMLDivElement>(null)
  const bottomRef = scrollToRef || localBottomRef
  const chatContainerRef = ref || containerRef
  const prevChildrenRef = useRef<React.ReactNode>(null)
  const contentChangedWithoutNewMessageRef = useRef(false)

  const { 
    autoScrollEnabled, 
    scrollToBottom, 
    isScrolling,
    scrollTriggered,
    newMessageAdded,
    setNewMessageAdded,
    prevChildrenCountRef
  } = useAutoScroll(
    chatContainerRef,
    autoScroll
  )

  // Improved content change detection
  useEffect(() => {
    const childrenArray = React.Children.toArray(children)
    const currentChildrenCount = childrenArray.length
    
    // Check if content is changing due to streaming or new message
    const isContentChange = prevChildrenRef.current !== children
    
    // New message detection
    if (currentChildrenCount > prevChildrenCountRef.current) {
      setNewMessageAdded(true)
    } 
    // Content update detection (like streaming) 
    else if (isContentChange) {
      contentChangedWithoutNewMessageRef.current = true
    }
    
    prevChildrenCountRef.current = currentChildrenCount
    prevChildrenRef.current = children
  }, [children, setNewMessageAdded])

  // Improved scroll behavior with more specific conditions
  useEffect(() => {
    if (!autoScroll) return
    
    const container = chatContainerRef.current
    if (!container) return
    
    // Handler for deciding when to auto-scroll
    const scrollHandler = () => {
      // Case 1: New message arrived - scroll to bottom if auto-scroll is enabled
      if (newMessageAdded && autoScrollEnabled) {
        scrollToBottom("smooth")
        setNewMessageAdded(false)
        contentChangedWithoutNewMessageRef.current = false
        return
      }
      
      // Case 2: Content is streaming or changing for existing message
      if (contentChangedWithoutNewMessageRef.current) {
        // Only auto-scroll if:
        // 1. Auto-scroll is enabled (user is at bottom)
        // 2. Not currently in manual scroll animation
        // 3. User isn't actively scrolling up
        if (autoScrollEnabled && !isScrolling && !scrollTriggered) {
          scrollToBottom("smooth")
        }
        contentChangedWithoutNewMessageRef.current = false
      }
    }
    
    // Use requestAnimationFrame for smooth performance
    requestAnimationFrame(scrollHandler)
    
  }, [
    children, 
    autoScroll, 
    autoScrollEnabled, 
    isScrolling,
    scrollTriggered,
    scrollToBottom, 
    newMessageAdded, 
    setNewMessageAdded
  ])

  return (
    <div
      className={cn("flex flex-col overflow-y-auto", className)}
      role="log"
      ref={chatContainerRef}
      {...props}
    >
      {children}
      <div
        ref={bottomRef}
        className="h-[1px] w-full flex-shrink-0 scroll-mt-4"
        aria-hidden="true"
      />
    </div>
  )
}

export { ChatContainer, useAutoScroll }

================
File: components/ui/command.tsx
================
import * as React from "react";
import { DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";
import { cn } from "@/lib/utils";
import { Dialog, DialogContent, DialogTitle, DialogDescription } from "@/components/ui/common/dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-lg bg-transparent text-white",
      className
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent 
        className="overflow-hidden p-0 max-w-2xl w-full mx-auto rounded-xl border border-white/[0.05] bg-white/[0.03] shadow-none backdrop-blur-xl pointer-events-auto"
      >
        <DialogTitle className="sr-only">Command Menu</DialogTitle>
        <DialogDescription className="sr-only">
          Search commands, actions, and navigate through your workspace.
        </DialogDescription>
        
        <Command className="
          [&_[cmdk-group-heading]]:px-4 
          [&_[cmdk-group-heading]]:font-semibold 
          [&_[cmdk-group-heading]]:text-white/70
          [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 
          [&_[cmdk-group]]:px-2 
          [&_[cmdk-input-wrapper]_svg]:h-5 
          [&_[cmdk-input-wrapper]_svg]:w-5 
          [&_[cmdk-input]]:h-12 
          [&_[cmdk-item]]:px-3 
          [&_[cmdk-item]]:py-3 
          [&_[cmdk-item]_svg]:h-5 
          [&_[cmdk-item]_svg]:w-5
          transition-all duration-200
          bg-transparent
        ">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div 
    className="flex items-center px-4 border-b border-white/[0.05]"
    cmdk-input-wrapper=""
  >
    <Search className="mr-2 h-5 w-5 shrink-0 text-white/70" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-12 w-full bg-transparent hover:bg-transparent focus:bg-transparent py-3 text-sm text-white/90 outline-none placeholder:text-white/50 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
));
CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[400px] overflow-y-auto overflow-x-hidden py-2", className)}
    {...props}
  />
));
CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm text-white/70"
    {...props}
  />
));
CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-white [&_[cmdk-group-heading]]:px-3 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-semibold [&_[cmdk-group-heading]]:text-white/70",
      className
    )}
    {...props}
  />
));
CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-white/[0.05]", className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-pointer select-none items-center rounded-md px-3 py-2.5 text-sm text-white/80 outline-none transition-all duration-200",
      "aria-selected:bg-white/[0.05] aria-selected:text-white",
      "data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      "hover:bg-white/[0.05] hover:backdrop-blur-sm active:bg-white/[0.06]",
      "border border-transparent hover:border-white/[0.06]",
      "group pointer-events-auto",
      className
    )}
    {...props}
  />
));
CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto flex items-center gap-1 text-xs tracking-widest text-white/60 group-hover:text-white/80",
        className
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};

================
File: components/ui/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: components/ui/popover.tsx
================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

================
File: components/ui/quick-actions-tab.tsx
================
import { Sparkles, Timer, Lightbulb } from "lucide-react";
import { BaseTab } from "./common/base-tab";
import { useCommandCenter } from "@/hooks/useCommandCenter";

// Original component that uses hooks
export default function QuickActionsTab() {
    const { toggleCommandCenter } = useCommandCenter();
    
    return (
        <BaseTab
            icon={<Sparkles className="w-3 h-3" />}
            label="Quick Actions"
            shortcut="K"
            minWidth="actions"
            commandType="application"
            onClick={() => {
                toggleCommandCenter();
            }}
        />
    );
}

// Server-driven version that accepts props
export function ServerDrivenQuickActionsTab({ 
    onCreateConversation 
}: { 
    onCreateConversation: (title: string) => Promise<void> 
}) {
    const { toggleCommandCenter } = useCommandCenter();
    
    return (
        <BaseTab
            icon={<Sparkles className="w-3 h-3" />}
            label="Quick Actions"
            shortcut="K"
            minWidth="actions"
            commandType="application"
            onClick={() => {
                toggleCommandCenter();
            }}
        />
    );
}

// Background Tasks Tab
export function BackgroundTasksTab() {
    const { openCommandType } = useCommandCenter();
    
    return (
        <BaseTab
            icon={<Timer className="w-3 h-3" />}
            label="Background Tasks"
            shortcut="T"
            minWidth="actions"
            commandType="background-tasks"
            onClick={() => openCommandType("background-tasks")}
        />
    );
}

// Server-driven version for Background Tasks
export function ServerDrivenBackgroundTasksTab() {
    const { openCommandType } = useCommandCenter();
    
    return (
        <BaseTab
            icon={<Timer className="w-3 h-3" />}
            label="Background Tasks"
            shortcut="T"
            minWidth="actions"
            commandType="background-tasks"
            onClick={() => openCommandType("background-tasks")}
        />
    );
}

// Suggestions Tab
export function SuggestionsTab() {
    const { openCommandType } = useCommandCenter();
    
    return (
        <BaseTab
            icon={<Lightbulb className="w-3 h-3" />}
            label="Suggestions"
            shortcut="G"
            minWidth="actions"
            commandType="suggestions"
            onClick={() => openCommandType("suggestions")}
        />
    );
}

// Server-driven version for Suggestions
export function ServerDrivenSuggestionsTab() {
    const { openCommandType } = useCommandCenter();
    
    return (
        <BaseTab
            icon={<Lightbulb className="w-3 h-3" />}
            label="Suggestions"
            shortcut="G"
            minWidth="actions"
            commandType="suggestions"
            onClick={() => openCommandType("suggestions")}
        />
    );
}

================
File: components/ui/scroll-button.tsx
================
"use client"

import * as React from "react"
import { ArrowDown } from "lucide-react"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/common/button"

export type ScrollButtonProps = {
  containerRef: React.RefObject<HTMLElement | null>
  scrollRef?: React.RefObject<HTMLElement | null>
  className?: string
  onClick?: () => void
}

export function ScrollButton({
  containerRef,
  scrollRef,
  className,
  onClick,
}: ScrollButtonProps) {
  const [visible, setVisible] = React.useState(false)

  const handleClick = React.useCallback(() => {
    if (onClick) {
      onClick()
      return
    }

    if (scrollRef?.current) {
      scrollRef.current.scrollIntoView({
        behavior: "smooth",
        block: "end",
      })
      return
    }

    if (containerRef?.current) {
      containerRef.current.scrollTo({
        top: containerRef.current.scrollHeight,
        behavior: "smooth",
      })
    }
  }, [containerRef, scrollRef, onClick])

  React.useEffect(() => {
    const container = containerRef.current
    if (!container) return

    const handleScroll = () => {
      const { scrollTop, scrollHeight, clientHeight } = container
      // Show button when not at the bottom
      setVisible(scrollHeight - scrollTop - clientHeight > 10)
    }

    container.addEventListener("scroll", handleScroll, { passive: true })
    // Initial check
    handleScroll()

    return () => {
      container.removeEventListener("scroll", handleScroll)
    }
  }, [containerRef])

  if (!visible) return null

  return (
    <Button
      size="icon"
      variant="outline"
      className={cn(
        "size-8 rounded-full bg-background/80 backdrop-blur transition-opacity hover:bg-background",
        className
      )}
      onClick={handleClick}
    >
      <ArrowDown className="size-4" />
      <span className="sr-only">Scroll to bottom</span>
    </Button>
  )
}

================
File: components/ui/tab-skeleton.tsx
================
export function TabSkeleton() {
  return (
    <div className="flex items-center gap-2 animate-pulse">
      {/* Space Tab Skeleton */}
      <div className="px-3 py-1 rounded-t-lg backdrop-blur-2xl border border-white/[0.05] min-w-[100px]
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <div className="flex items-center gap-1.5">
          <div className="w-2 h-2 rounded-full bg-white/10" />
          <div className="h-3 w-16 bg-white/10 rounded" />
        </div>
      </div>

      {/* Quick Actions Tab Skeleton */}
      <div className="px-3 py-1 rounded-t-lg backdrop-blur-2xl border border-white/[0.05]
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <div className="flex items-center gap-1.5">
          <div className="w-3 h-3 rounded bg-white/10" />
          <div className="h-3 w-20 bg-white/10 rounded" />
        </div>
      </div>

      {/* Model Tab Skeleton */}
      <div className="px-3 py-1 rounded-t-lg backdrop-blur-2xl border border-white/[0.05] min-w-[120px]
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <div className="flex items-center gap-1.5">
          <div className="w-3.5 h-3.5 rounded-full bg-white/10" />
          <div className="h-3 w-24 bg-white/10 rounded" />
        </div>
      </div>
    </div>
  )
}

================
File: components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: components/AllCommandProviders.tsx
================
'use client';

import React, { useEffect } from 'react';
import { 
  ApplicationCommandProvider, 
  SpacesCommandProvider, 
  ConversationsCommandProvider, 
  ModelsCommandProvider, 
  ActionsCommandProvider, 
  MessageSearchProvider,
  ChatModesCommandProvider,
  BackgroundTasksCommandProvider,
  SuggestionsCommandProvider
} from './CommandProviders';
import { SimilarMessagesCommandProvider } from './SimilarMessagesCommandProvider';
import { useSpaceStore } from '@/stores/space-store';

interface AllCommandProvidersProps {
  children: React.ReactNode;
  spaces?: any[];
  activeSpace?: any;
  conversations?: any[];
  activeConversation?: any;
  user?: any;
  messages?: any[];
}

export function AllCommandProviders({ 
  children,
  spaces = [],
  activeSpace = null,
  conversations = [],
  activeConversation = null,
  user = null,
  messages = [],
}: AllCommandProvidersProps) {
  const { initializeState } = useSpaceStore();
  
  useEffect(() => {
    initializeState({
      spaces,
      activeSpace,
      conversations,
      activeConversation,
      messages,
      isLoading: false,
      loadingType: null
    });
  }, [initializeState, spaces, activeSpace, conversations, activeConversation, messages]);
  
  return (
    <ApplicationCommandProvider>
      <SpacesCommandProvider>
        <ConversationsCommandProvider>
          <ModelsCommandProvider>
            <ChatModesCommandProvider>
              <MessageSearchProvider>
                <SimilarMessagesCommandProvider>
                  <BackgroundTasksCommandProvider>
                    <SuggestionsCommandProvider>
                      <ActionsCommandProvider>{children}</ActionsCommandProvider>
                    </SuggestionsCommandProvider>
                  </BackgroundTasksCommandProvider>
                </SimilarMessagesCommandProvider>
              </MessageSearchProvider>
            </ChatModesCommandProvider>
          </ModelsCommandProvider>
        </ConversationsCommandProvider>
      </SpacesCommandProvider>
    </ApplicationCommandProvider>
  );
}

================
File: components/CommandButton.tsx
================
import React from 'react';
import { Button } from '@/components/ui/common/button';
import { useCommandCenter } from '@/hooks/useCommandCenter';
import { Command } from 'lucide-react';
import { CommandType } from '@/hooks/useCommandCenter';

interface CommandButtonProps {
  className?: string;
  label?: string;
  showIcon?: boolean;
  showShortcut?: boolean;
  type?: CommandType;
}

export function CommandButton({
  className,
  label = 'Command Menu',
  showIcon = true,
  showShortcut = true,
  type,
}: CommandButtonProps) {
  const { openCommandCenter, openCommandType } = useCommandCenter();

  const handleClick = () => {
    if (type) {
      openCommandType(type);
    } else {
      openCommandCenter();
    }
  };

  return (
    <Button
      variant="ghost"
      className={className}
      onClick={handleClick}
    >
      {showIcon && <Command className="mr-2 h-4 w-4" />}
      {label}
      {showShortcut && (
        <kbd className="pointer-events-none ml-auto inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground">
          <span className="text-xs">⌘</span>K
        </kbd>
      )}
    </Button>
  );
}

/**
 * A button that opens the command center with a specific command type pre-selected
 */
export function TypedCommandButton({
  className,
  label,
  type,
  icon,
  shortcutKeys,
}: {
  className?: string;
  label: string;
  type: CommandType;
  icon?: React.ReactNode;
  shortcutKeys?: string[];
}) {
  const { openCommandType } = useCommandCenter();

  return (
    <Button
      variant="ghost"
      className={className}
      onClick={() => openCommandType(type)}
    >
      {icon && <span className="mr-2">{icon}</span>}
      {label}
      {shortcutKeys && (
        <kbd className="pointer-events-none ml-auto inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground">
          {shortcutKeys.map((key, i) => (
            <React.Fragment key={i}>
              {i > 0 && <span className="mx-0.5">+</span>}
              <span className="text-xs">{key}</span>
            </React.Fragment>
          ))}
        </kbd>
      )}
    </Button>
  );
}

export default CommandButton;

================
File: components/CommandCenter.tsx
================
"use client"

import React, { useEffect } from 'react';
import { Command, CommandDialog, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList, CommandSeparator, CommandShortcut } from '@/components/ui/command';
import { CommandOption, CommandType, useCommandCenter } from '@/hooks/useCommandCenter';
import { Loader2 } from 'lucide-react';

/**
 * Main CommandCenter component that integrates with the CMDK library
 * and uses the CommandContext to show available commands
 */

// Helper function to highlight search terms in text
const HighlightMatches = ({ text, searchQuery }: { text: string, searchQuery: string }) => {
  if (!searchQuery || searchQuery.length < 2) return <>{text}</>;
  
  const lowerText = text.toLowerCase();
  const lowerQuery = searchQuery.toLowerCase();
  const matchIndex = lowerText.indexOf(lowerQuery);
  
  if (matchIndex === -1) return <>{text}</>;
  
  return (
    <>
      {text.substring(0, matchIndex)}
      <span className="font-semibold text-white/95 underline decoration-1 underline-offset-2">
        {text.substring(matchIndex, matchIndex + searchQuery.length)}
      </span>
      {text.substring(matchIndex + searchQuery.length)}
    </>
  );
};

export function CommandCenter() {
  const {
    isOpen,
    closeCommandCenter,
    filteredCommands,
    setSearchQuery,
    activeCommandType,
    headers,
    searchQuery,
    registerHeader,
    unregisterHeader,
    isLoading,
    loadingCommandType,
    searchableCommands,
  } = useCommandCenter();

  const groupedCommands = React.useMemo(() => {
    const grouped: Record<CommandType, CommandOption[]> = {
      application: [],
      spaces: [],
      conversations: [],
      models: [],
      actions: [],
      messages: [],
      'chat-modes': [],
      'similarMessages': [],
      'background-tasks': [],
      'suggestions': [],
    };

    filteredCommands.forEach((command) => {
      grouped[command.type].push(command);
    });

    return grouped;
  }, [filteredCommands]);

  const availableTypes = React.useMemo(() => {
    return Object.entries(groupedCommands)
      .filter(([_, commands]) => commands.length > 0)
      .map(([type]) => type as CommandType);
  }, [groupedCommands]);

  const handleSelect = async (commandId: string) => {
    const command = filteredCommands.find(cmd => cmd.id === commandId);
    if (command) {
      command?.action();
      closeCommandCenter();
    }
  };

  const renderCommandGroups = () => {
    if (activeCommandType) {
      console.log("filteredCommands", filteredCommands);
      
      const commands = groupedCommands[activeCommandType];
      const isSearchable = activeCommandType in searchableCommands && searchableCommands[activeCommandType].minSearchLength > 0;
      const searchConfig = isSearchable ? searchableCommands[activeCommandType] : null;
      
      // Handle searchable command types
      if (isSearchable && searchConfig) {
        const { minSearchLength, placeholderText } = searchConfig;
        
        // Case 1: Empty search or search term too short - prompt user to type more
        if (searchQuery.length === 0 || searchQuery.length < minSearchLength) {
          return (
            <CommandEmpty className="text-center py-6 text-sm text-white/70">
              {placeholderText || `Type at least ${minSearchLength} characters to search ${activeCommandType}...`}
            </CommandEmpty>
          );
        }
        
        // Case 2: Search term is long enough but we're loading
        if (searchQuery.length >= minSearchLength && isLoading && loadingCommandType === activeCommandType) {
          return (
            <CommandEmpty className="flex flex-col items-center justify-center py-6">
              <div className="flex items-center gap-2 text-sm text-white/70">
                <Loader2 className="h-4 w-4 animate-spin" />
                <span>Searching {activeCommandType}...</span>
              </div>
            </CommandEmpty>
          );
        }
        
        if (searchQuery.length >= minSearchLength && !isLoading && commands.length === 0) {
          console.log("commands", commands);
          return (
            <CommandEmpty className="text-center py-6 text-sm text-white/70">
              No {activeCommandType} found matching "{searchQuery}".
            </CommandEmpty>
          );
        }
      } 
      // Handle regular command types (non-searchable or default behavior)
      else {
        // General loading state for any command type
        if (isLoading && loadingCommandType === activeCommandType) {
          return (
            <CommandEmpty className="flex flex-col items-center justify-center py-6">
              <div className="flex items-center gap-2 text-sm text-white/70">
                <Loader2 className="h-4 w-4 animate-spin" />
                <span>Loading {activeCommandType}...</span>
              </div>
            </CommandEmpty>
          );
        }

        // Empty state with no search
        if (searchQuery.length === 0 && commands.length === 0) {
          return (
            <CommandEmpty className="text-center py-6 text-sm text-white/70">
              Type a command or search...
            </CommandEmpty>
          );
        }

        // Empty search results
        if (commands.length === 0) {
          return (
            <CommandEmpty className="text-center py-6 text-sm text-white/70">
              No {activeCommandType} found.
            </CommandEmpty>
          );
        }
      }

      return (
        <>
        <CommandGroup heading={activeCommandType.charAt(0).toUpperCase() + activeCommandType.slice(1)}>
          {commands.map((command) => (
            <CommandItem
              key={command.id}
              onSelect={() => handleSelect(command.id)}
              value={command.id}
              className="group cursor-pointer relative overflow-hidden"
            >
              <div className="flex items-center w-full pointer-events-auto">
                {command.icon && (
                  <span className="mr-3 text-white/70 group-hover:text-white/90 transition-colors duration-200">
                    {command.icon}
                  </span>
                )}
                <div className="flex flex-col justify-center flex-1 overflow-hidden">
                  <span className="truncate text-white/90 font-medium group-hover:text-white transition-colors duration-200">
                    <HighlightMatches text={command.name} searchQuery={searchQuery} />
                  </span>
                  {command.description && (
                    <span className="text-xs text-white/60 truncate mt-0.5 group-hover:text-white/80 transition-colors duration-200">
                      <HighlightMatches text={command.description} searchQuery={searchQuery} />
                    </span>
                  )}
                </div>
                {command.shortcut && !command.rightElement && (
                  <CommandShortcut>
                    {command.shortcut.map((key, i) => (
                      <React.Fragment key={i}>
                        {i > 0 && <span className="mx-0.5">+</span>}
                        <kbd className="px-1.5 py-0.5 text-[10px] bg-white/[0.02] border border-white/[0.05] rounded group-hover:border-white/[0.1] transition-all duration-200">
                          {key}
                        </kbd>
                      </React.Fragment>
                    ))}
                  </CommandShortcut>
                )}
                {command.rightElement && (
                  <div className="flex items-center ml-auto">
                    {command.rightElement}
                  </div>
                )}
              </div>
            </CommandItem>
          ))}
        </CommandGroup>
        </>
      );
    }

    return availableTypes.map((type, index) => {
      const commands = groupedCommands[type];
      if (commands.length === 0) return null;

      return (
        <React.Fragment key={type}>
          <CommandGroup heading={type.charAt(0).toUpperCase() + type.slice(1)}>
            {commands.map((command) => (
              <CommandItem
                key={command.id}
                onSelect={() => handleSelect(command.id)}
                value={command.id}
                className="group cursor-pointer relative overflow-hidden"
              >
                <div className="flex items-center w-full pointer-events-auto">
                  {command.icon && (
                    <span className="mr-3 text-white/70 group-hover:text-white/90 transition-colors duration-200">
                      {command.icon}
                    </span>
                  )}
                  <div className="flex flex-col justify-center flex-1 overflow-hidden">
                    <span className="truncate text-white/90 font-medium group-hover:text-white transition-colors duration-200">
                      <HighlightMatches text={command.name} searchQuery={searchQuery} />
                    </span>
                    {command.description && (
                      <span className="text-xs text-white/60 truncate mt-0.5 group-hover:text-white/80 transition-colors duration-200">
                        <HighlightMatches text={command.description} searchQuery={searchQuery} />
                      </span>
                    )}
                  </div>
                  {command.shortcut && !command.rightElement && (
                    <CommandShortcut>
                      {command.shortcut.map((key, i) => (
                        <React.Fragment key={i}>
                          {i > 0 && <span className="mx-0.5">+</span>}
                          <kbd className="px-1.5 py-0.5 text-[10px] bg-white/[0.02] border border-white/[0.05] rounded group-hover:border-white/[0.1] transition-all duration-200">
                            {key}
                          </kbd>
                        </React.Fragment>
                      ))}
                    </CommandShortcut>
                  )}
                  {command.rightElement && (
                    <div className="flex items-center ml-auto">
                      {command.rightElement}
                    </div>
                  )}
                </div>
              </CommandItem>
            ))}
          </CommandGroup>
          {index < availableTypes.length - 1 && <CommandSeparator />}
        </React.Fragment>
      );
    });
  };

  return (
    <>
      {isOpen && (
        <CommandDialog open={isOpen} onOpenChange={closeCommandCenter}>
          <Command shouldFilter={false} loop>
            <CommandInput
              placeholder="Type a command or search..."
              onValueChange={setSearchQuery}
            />
        {activeCommandType && headers[activeCommandType] && (
          <>
            {headers[activeCommandType]}
          </>
        )}
        <CommandList className="scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent">
            {renderCommandGroups()}
        </CommandList>
      </Command>
      </CommandDialog> 
      )}
    </>
  );
}

export default CommandCenter;

================
File: components/CommandProviders.tsx
================
"use client";

import React, { ReactNode, useEffect, useState, useRef, useCallback, useMemo } from "react";
import { CommandOption, useCommandRegistration, CommandType, useCommandHeaderRegistration } from "@/hooks/useCommandCenter";
import { 
  Settings, 
  Search, 
  Plus, 
  MessageSquare, 
  Brain, 
  Command, 
  Trash, 
  PencilLine,
  Pencil,
  SwitchCamera,
  MessageCircle,
  Ban,
  Sparkles,
  Timer,
  Activity,
  Lightbulb,
  Check,
  X,
  Clock
} from "lucide-react";
import { AVAILABLE_MODELS, PROVIDER_NAMES, PROVIDER_DESCRIPTIONS, Provider } from "@/config/models";
import { toast } from 'sonner'
import DotSphere from "@/components/ui/space/planet-icon";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/common/dialog";
import { Button } from "@/components/ui/common/button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/common/select";
import { Textarea } from "@/components/ui/common/textarea";
import { Checkbox } from "@/components/ui/common/checkbox";
import { useCommandCenter } from "@/hooks/useCommandCenter";
import { useRouter } from "next/navigation";
import { getMostRecentConversation } from "@/app/actions/conversations";
import { cn } from "@/lib/utils";
import { useSpaceStore, Space as SpaceType, Conversation as ConversationType } from '@/stores/space-store';
import { useShallow } from "zustand/react/shallow";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/common/tooltip";
import { ProviderIcon } from "@lobehub/icons";
import { createSpace as createSpaceAction, deleteSpace as deleteSpaceAction, updateSpace as updateSpaceAction } from "@/app/actions/spaces";
import { createConversation as createConversationAction, deleteConversation as deleteConversationAction, updateConversationTitle, searchMessages } from "@/app/actions/conversations";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";

/**
 * Dialog for creating or editing a space
 */
export function SpaceDialogForm({
  open,
  onOpenChange,
  onCreateSuccess,
  onEditSuccess,
  editSpace = null,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onCreateSuccess: () => void;
  onEditSuccess: () => void;
  editSpace?: any; // The space to edit, null when creating a new space
}) {
  const [name, setName] = useState(editSpace?.name || "New Space");
  const [description, setDescription] = useState(editSpace?.description || "");
  const [provider, setProvider] = useState<Provider>(editSpace?.provider || "anthropic");
  const [model, setModel] = useState(editSpace?.model || "");
  const initialRenderRef = useRef(true);
  const router = useRouter();
  
  const { 
    createSpace, 
    updateSpace, 
    isLoading, 
    loadingSpaceId 
  } = useSpaceStore();

  useEffect(() => {
    if (open) {
      if (editSpace) {
        setName(editSpace.name || "Untitled Space");
        setDescription(editSpace.description || "");
        setProvider(editSpace.provider || "anthropic");
        setModel(editSpace.model || AVAILABLE_MODELS["anthropic"][0].id);
      } else {
        setName("New Space");
        setDescription("");
        setProvider("anthropic");
        setModel(AVAILABLE_MODELS["anthropic"][0].id);
      }
      initialRenderRef.current = false;
    }
  }, [open, editSpace]);

  useEffect(() => {
    if (provider && AVAILABLE_MODELS[provider]?.length > 0) {
      setModel(AVAILABLE_MODELS[provider][0].id);
    }
  }, [provider]);
  
  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();

      let success = false;
      
      if (editSpace) {
        success = await updateSpace(editSpace.id, {
          name,
          description,
          model,
          provider
        });

        if (success) {
          onEditSuccess();
        }
      } else {
        const result = await createSpace(name, description, model, provider);
        success = !!result;
        
        if (success && result) {
          const newSpaceId = result.id;
          const conversation = await getMostRecentConversation(newSpaceId);

          router.replace(`/protected/spaces/${newSpaceId}/conversations/${conversation.data?.id}`);
          
          onCreateSuccess();
          return;
        }
      }
    },
    [name, description, model, provider, createSpace, updateSpace, onCreateSuccess, onEditSuccess, editSpace, router]
  );
    
  const isFormValid = name && provider && model;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>{editSpace ? "Edit Space" : "Create New Space"}</DialogTitle>
            <DialogDescription>
              {editSpace 
                ? "Update the settings for this workspace." 
                : "Create a new workspace for your conversations."}
            </DialogDescription>
          </DialogHeader>

          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="name">
                Name
              </Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Space name"
                required
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="description">Description (optional)</Label>
              <Textarea
                id="description"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="Describe the purpose of this space"
                rows={3}
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="provider">
                Provider
              </Label>
              <Select 
                value={provider} 
                onValueChange={(value) => setProvider(value as Provider)}
              >
                <SelectTrigger 
                  id="provider"
                >
                  <SelectValue placeholder="Select provider" />
                </SelectTrigger>
                <SelectContent>
                  {Object.entries(PROVIDER_NAMES).map(([key, name]) => (
                    <SelectItem key={key} value={key}>
                      <div className="flex items-center gap-2">
                        <ProviderIcon type="color" provider={key} size={14} className="flex-shrink-0" />
                        <span>{name}</span>
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="grid gap-2">
              <Label htmlFor="model">
                Model
              </Label>
              <Select 
                value={model} 
                onValueChange={setModel}
              >
                <SelectTrigger 
                  id="model"
                >
                  <SelectValue placeholder="Select model" />
                </SelectTrigger>
                <SelectContent>
                  {provider &&
                    AVAILABLE_MODELS[provider]?.map((modelOption) => (
                      <SelectItem key={modelOption.id} value={modelOption.id}>
                        {modelOption.name}
                      </SelectItem>
                    ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          <DialogFooter>
            <Button 
              type="submit" 
              disabled={isLoading || !isFormValid}
              className="bg-cyan-500/20 hover:bg-cyan-500/30 border border-cyan-500/20 text-cyan-300 backdrop-blur-sm"
            >
              {isLoading ? (
                <div className="flex items-center gap-2">
                  <div className="animate-spin h-4 w-4 border-2 border-cyan-400/20 border-t-cyan-400/80 rounded-full" />
                  <span>{editSpace ? "Updating..." : "Creating..."}</span>
                </div>
              ) : (
                editSpace ? "Update Space" : "Create Space"
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Dialog for confirming space deletion
 */
export function DeleteSpaceDialog({
  open,
  onOpenChange,
  space,
  onConfirm,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  space: any | null;
  onConfirm: () => void;
}) {
  // Use the space store
  const { loadingSpaceId } = useSpaceStore();

  const isSubmitting = space ? loadingSpaceId === space.id : false;

  const handleDelete = useCallback(async () => {
    if (isSubmitting) return;
    
    try {
      await onConfirm();
    } catch (error) {
      console.error("Error deleting space:", error);
    } finally {
      onOpenChange(false);
    }
  }, [isSubmitting, onConfirm, onOpenChange]);

  if (!space) return null;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Delete Space</DialogTitle>
          <DialogDescription>
            Are you sure you want to delete "{space.name}"? This action cannot be undone.
          </DialogDescription>
        </DialogHeader>

        <DialogFooter className="mt-4 flex justify-between">
          <Button 
            variant="outline" 
            onClick={() => onOpenChange(false)}
            className="border-white/10 bg-white/5 hover:bg-white/10 text-white backdrop-blur-sm"
          >
            Cancel
          </Button>
          <Button 
            variant="destructive" 
            onClick={handleDelete} 
            disabled={isSubmitting}
            className="bg-red-500/20 hover:bg-red-500/30 border border-red-500/20 text-red-400 backdrop-blur-sm"
          >
            {isSubmitting ? (
              <div className="flex items-center gap-2">
                <div className="animate-spin h-4 w-4 border-2 border-red-400/20 border-t-red-400/80 rounded-full" />
                <span>Deleting...</span>
              </div>
            ) : (
              "Delete Space"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Provider for application-wide commands
 */
export function ApplicationCommandProvider({ children }: { children: ReactNode }) {
  const applicationCommands = useCallback(
    (): CommandOption[] => [
      {
        id: "settings",
        name: "Open Settings",
        value: "Open Settings",
        description: "Open application settings",
        icon: <Settings className="h-4 w-4" />,
        shortcut: ["⌘", ","],
        type: "application",
        keywords: ["settings", "preferences", "config", "configuration"],
        action: () => {
          console.log("Opening settings");
        },
      },
      {
        id: "search",
        name: "Search Everything",
        value: "Search Everything",
        description: "Search across all content",
        icon: <Search className="h-4 w-4" />,
        shortcut: ["⌘", "F"],
        type: "application",
        keywords: ["search", "find", "filter", "query"],
        action: () => {
          console.log("Opening global search");
        },
      },
    ],
    []
  );

  useCommandRegistration(applicationCommands());

  return <>{children}</>;
}

/**
 * Provider for space-related commands
 */
export function SpacesCommandProvider({ 
  children, 
}: { 
  children: ReactNode, 
}) {
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [spaceToEdit, setSpaceToEdit] = useState<any>(null);
  const [spaceToDelete, setSpaceToDelete] = useState<any>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();
  const { closeCommandCenter, openCommandType, filteredCommands } = useCommandCenter();
  
  const storeSpaces = useSpaceStore(state => state.spaces);
  const storeActiveSpace = useSpaceStore(state => state.activeSpace);
  
  const { 
    deleteSpace,
    activeConversation,
    loadSpaceFullData
  } = useSpaceStore();

  const reopenSpacesCommandCenter = useCallback(() => {
    openCommandType('spaces');
  }, [openCommandType]);

  const baseCommands = useCallback(
    (): CommandOption[] => [
      {
        id: "create-space",
        name: "Create New Space",
        value: "Create New Space",
        description: "Create a new workspace",
        icon: <Plus className="h-4 w-4" />,
        shortcut: ["⌘", "N"],
        type: "spaces",
        keywords: ["create", "new", "space", "workspace", "add"],
        action: () => {
          closeCommandCenter();
          setSpaceToEdit(null);
          setShowCreateDialog(true);
        },
      },
    ],
    [closeCommandCenter]
  );

  const handleSelectSpace = useCallback(async (spaceId: string) => {
    await loadSpaceFullData(spaceId);
  }, [activeConversation]);

  const handleEditSpace = useCallback((space: any) => {
    closeCommandCenter();
    setSpaceToEdit(space);
    setShowCreateDialog(true);
  }, [closeCommandCenter]);

  const handleDeleteSpace = useCallback((space: any) => {
    closeCommandCenter();
    setSpaceToDelete(space);
    setShowDeleteDialog(true);
  }, [closeCommandCenter]);

  const confirmDeleteSpace = useCallback(async () => {
    if (spaceToDelete) {
      try {
        // Check if this is the active space before deletion
        const isActiveSpace = spaceToDelete.id === storeActiveSpace?.id;
        
        // Use the store's deleteSpace function directly
        const success = await deleteSpace(spaceToDelete.id);
        
        if (success) {
          // If we successfully deleted the active space, navigate to the new active space
          if (isActiveSpace) {
            // Check if there are any spaces left
            const remainingSpaces = storeSpaces?.filter(space => !space.is_deleted) || [];
            
            // After a short delay to ensure store updates are complete
            setTimeout(() => {
              if (remainingSpaces.length > 0) {
                // Use the navigation helper to go to the right space/conversation
                useSpaceStore.getState().navigateToActiveConversation(router);
              } else {
                // No spaces left, navigate to home page
                router.push('/protected');
              }
            }, 200);
          }
        } else {
          // Handle failure case explicitly
          console.error('Failed to delete space');
          toast.error('Deletion Failed', {
            description: 'Could not delete the space. Please try again.'
          });
        }
      } catch (error) {
        console.error('Error in space deletion process:', error);
        toast.error('Deletion Failed', {
          description: 'An error occurred while deleting the space.'
        });
      } finally {
        // Always close the dialog
        setShowDeleteDialog(false);
        setSpaceToDelete(null);
        
        // Reopen command center
        setTimeout(() => {
          reopenSpacesCommandCenter();
        }, 150);
      }
    }
  }, [router, reopenSpacesCommandCenter, spaceToDelete, storeActiveSpace?.id, storeSpaces, deleteSpace]);

  const handleDeleteDialogClose = useCallback((open: boolean) => {
    setShowDeleteDialog(open);
    if (!open) {
      setTimeout(() => {
        reopenSpacesCommandCenter();
      }, 150);
    }
  }, [reopenSpacesCommandCenter]);

  const handleCreateDialogClose = useCallback((open: boolean) => {
    setShowCreateDialog(open);
    if (!open) {
      setTimeout(() => {
        reopenSpacesCommandCenter();
      }, 150);
    }
  }, [reopenSpacesCommandCenter]);

  const spaceCommands = useCallback((): CommandOption[] => {
    const filteredSpaceCommands =  storeSpaces
      ?.filter(space => !space.is_deleted)
      ?.sort((a: SpaceType, b: SpaceType) => new Date(b.updated_at || '').getTime() - new Date(a.updated_at || '').getTime())
      .map((space) => {
        return {
          id: `space-${space.id}`,
          name: space.name,
          value: space.name,
          description: space.description || "Switch to this workspace",
 
          type: "spaces" as CommandType,
          keywords: [
            "space", 
            "workspace", 
            "switch", 
            ...(space.name ? space.name.split(/\s+/) : []),
            ...(space.description ? space.description.split(/\s+/).filter(word => word.length > 3) : [])
          ],
          action: async () => {
            await handleSelectSpace(space.id);
          },
          closeCommandOnSelect: false,
          rightElement: (
            <div className="flex items-center gap-1.5">
              <Tooltip>
              <TooltipTrigger asChild>
              {space.provider && (
                  <div
                  className={cn(
                    "flex items-center justify-center h-7 w-7 rounded-md",
                    "transition-all duration-200 ease-in-out",
                    "bg-white/[0.03] hover:bg-white/[0.08] border border-white/[0.05]",
                    "text-zinc-400 hover:text-zinc-200",
                    "cursor-default"
                  )}
                >
                  <ProviderIcon type="color" provider={space.provider} size={14} className="flex-shrink-0" />
                </div>
              )}
              </TooltipTrigger>
              <TooltipContent side="bottom">
                <span className="capitalize">{space.provider}</span>
              </TooltipContent>
              </Tooltip>
              <Tooltip>
                <TooltipTrigger asChild>
                  <div
                    onClick={(e) => { 
                      e.stopPropagation();
                      e.preventDefault();
                      handleEditSpace(space);
                    }}
                    className={cn(
                      "flex items-center h-7 w-7 justify-center rounded-md p-1.5",
                      "transition-all duration-200 ease-in-out",
                      "bg-white/[0.03] hover:bg-white/[0.08] border border-white/[0.05]",
                      "text-zinc-400 hover:text-zinc-200",
                      "cursor-pointer"
                    )}
                  >
                    <Pencil size={11} strokeWidth={1.5} />
                  </div>
                </TooltipTrigger>
                <TooltipContent side="bottom">
                  Edit Space
                </TooltipContent>
              </Tooltip>
              <Tooltip>
                <TooltipTrigger asChild>
                  <div
                    onClick={(e) => { 
                      e.stopPropagation();
                      e.preventDefault();
                      handleDeleteSpace(space);
                    }}
                    className={cn(
                      "flex items-center h-7 w-7 justify-center rounded-md p-1.5",
                      "transition-all duration-200 ease-in-out",
                      "bg-white/[0.03] hover:bg-red-400/20 border border-white/[0.05]",
                      "text-red-400 hover:text-red-200",
                      "cursor-pointer"
                    )}
                  >
                    <Trash className="text-red-400" size={11} strokeWidth={1.5} />
                  </div>
                </TooltipTrigger>
                <TooltipContent side="bottom" className="bg-red-500/20 border-red-500/30 text-red-300">
                  Delete Space
                </TooltipContent>
              </Tooltip>
            </div>
          )
        };
      }) ?? [];

    return filteredSpaceCommands;
  }, [storeSpaces]);

  useCommandRegistration([...baseCommands(), ...spaceCommands()]);

  const onCreateSuccess = useCallback(() => {
    setShowCreateDialog(false);
    closeCommandCenter();
  }, [closeCommandCenter]);

  const onEditSuccess = useCallback(() => {
    handleCreateDialogClose(false);
    reopenSpacesCommandCenter();
  }, [handleCreateDialogClose, reopenSpacesCommandCenter]);

  return (
    <TooltipProvider>
      <SpaceDialogForm
        open={showCreateDialog}
        onOpenChange={handleCreateDialogClose}
        onCreateSuccess={onCreateSuccess}
        onEditSuccess={onEditSuccess}
        editSpace={spaceToEdit}
      />
      <DeleteSpaceDialog 
        open={showDeleteDialog}
        onOpenChange={handleDeleteDialogClose}
        space={spaceToDelete}
        onConfirm={confirmDeleteSpace}
      />
      {children}
    </TooltipProvider>
  );
}

/**
 * Dialog for creating or editing a conversation
 */
export function ConversationDialogForm({
  open,
  onOpenChange,
  onEditSuccess,
  editConversation = null,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onEditSuccess: () => void;
  editConversation?: any; // The conversation to edit
}) {
  const [title, setTitle] = useState(editConversation?.title || "");
  const initialRenderRef = useRef(true);
  const router = useRouter();

  const { 
    updateConversation, 
    isLoading, 
    loadingConversationId 
  } = useSpaceStore();

  useEffect(() => {
    if (open) {
      if (editConversation) {
        setTitle(editConversation.title || "");
      } else {
        setTitle("");
      }
      initialRenderRef.current = false;
    }
  }, [open, editConversation]);

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();
      
      if (editConversation) {
        const success = await updateConversation(editConversation.id, title);

        if (success) {
          onEditSuccess();
        }
      }
    },
    [title, updateConversation, onEditSuccess, editConversation]
  );

  const isSubmitting = editConversation 
    ? loadingConversationId === editConversation.id 
    : isLoading;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Edit Conversation</DialogTitle>
            <DialogDescription>
              Update the title for this conversation.
            </DialogDescription>
          </DialogHeader>

          <div className="grid gap-4 py-4">
            <div className="grid gap-2">
              <Label htmlFor="title">Title</Label>
              <Input
                id="title"
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                placeholder="Conversation title"
                required
              />
            </div>
          </div>

          <DialogFooter>
            <Button 
              type="submit" 
              disabled={isSubmitting || !title}
              className="bg-cyan-500/20 hover:bg-cyan-500/30 border border-cyan-500/20 text-cyan-300 backdrop-blur-sm"
            >
              {isSubmitting ? (
                <div className="flex items-center gap-2">
                  <div className="animate-spin h-4 w-4 border-2 border-cyan-400/20 border-t-cyan-400/80 rounded-full" />
                  <span>Updating...</span>
                </div>
              ) : (
                "Update"
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Dialog for confirming conversation deletion
 */
export function DeleteConversationDialog({
  open,
  onOpenChange,
  conversation,
  onConfirm,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  conversation: any | null;
  onConfirm: () => void;
}) {
  // Use the space store
  const { loadingConversationId } = useSpaceStore();

  const isSubmitting = conversation ? loadingConversationId === conversation.id : false;

  const handleDelete = useCallback(async () => {
    if (isSubmitting) return;
    
    try {
      await onConfirm();
    } catch (error) {
      console.error("Error deleting conversation:", error);
    } finally {
      onOpenChange(false);
    }
  }, [isSubmitting, onConfirm, onOpenChange]);

  if (!conversation) return null;

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Delete Conversation</DialogTitle>
          <DialogDescription>
            Are you sure you want to delete "{conversation.title || 'Untitled Conversation'}"? This action cannot be undone.
          </DialogDescription>
        </DialogHeader>

        <DialogFooter className="mt-4 flex justify-between">
          <Button 
            variant="outline" 
            onClick={() => onOpenChange(false)}
            className="border-white/10 bg-white/5 hover:bg-white/10 text-white backdrop-blur-sm"
          >
            Cancel
          </Button>
          <Button 
            variant="destructive" 
            onClick={handleDelete} 
            disabled={isSubmitting}
            className="bg-red-500/20 hover:bg-red-500/30 border border-red-500/20 text-red-400 backdrop-blur-sm"
          >
            {isSubmitting ? (
              <div className="flex items-center gap-2">
                <div className="animate-spin h-4 w-4 border-2 border-red-400/20 border-t-red-400/80 rounded-full" />
                <span>Deleting...</span>
              </div>
            ) : (
              "Delete Conversation"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Provider for conversation-related commands
 */
export function ConversationsCommandProvider({ 
  children, 
}: { 
  children: ReactNode, 
}) {
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [conversationToEdit, setConversationToEdit] = useState<any>(null);
  const [conversationToDelete, setConversationToDelete] = useState<any>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const { closeCommandCenter, openCommandType } = useCommandCenter();
  
  const {
    activeSpace: storeActiveSpace,
    conversations: storeConversations,
    activeConversation: storeActiveConversation,
  } = useSpaceStore(
    useShallow((state) => state.uiState)
  );
  
  const { 
    createConversation, 
    selectConversation, 
    deleteConversation 
  } = useSpaceStore();

  const reopenConversationsCommandCenter = useCallback(() => {
    openCommandType('conversations');
  }, [openCommandType]);

  type Conversation = {
    id: string;
    title?: string;
    is_deleted?: boolean;
    updated_at?: string;
    [key: string]: any;
  };

  const handleEditConversation = useCallback((conversation: any) => {
    closeCommandCenter();
    setConversationToEdit(conversation);
    setShowEditDialog(true);
  }, [closeCommandCenter]);

  const handleDeleteConversation = useCallback((conversation: any) => {
    closeCommandCenter();
    setConversationToDelete(conversation);
    setShowDeleteDialog(true);
  }, [closeCommandCenter]);

  const confirmDeleteConversation = useCallback(async () => {
    if (conversationToDelete) {
      try {
        const success = await deleteConversation(conversationToDelete.id);
        
        if (success) {
          if (conversationToDelete.id === storeActiveConversation?.id) {
            const remainingConversations = storeConversations?.filter(
              conv => !conv.is_deleted && conv.id !== conversationToDelete.id
            ) || [];
            
            if (remainingConversations.length > 0) {
              await selectConversation(remainingConversations[0].id);
            } else {
              await createConversation();
            }
          }
        } else {
          toast.error('Deletion Failed', {
            description: 'Could not delete the conversation. Please try again.'
          });
        }
      } catch (error) {
        console.error('Error in conversation deletion process:', error);
        toast.error('Deletion Failed', {
          description: 'An error occurred while deleting the conversation.'
        });
      }
    }
  }, [
    conversationToDelete, 
    storeActiveConversation?.id, 
    storeConversations
  ]);

  const handleEditDialogClose = useCallback((open: boolean) => {
    setShowEditDialog(open);
    if (!open) {
      setTimeout(() => {
        reopenConversationsCommandCenter();
      }, 150);
    }
  }, [reopenConversationsCommandCenter]);

  const handleDeleteDialogClose = useCallback((open: boolean) => {
    setShowDeleteDialog(open);
    if (!open) {
      setTimeout(() => {
        reopenConversationsCommandCenter();
      }, 150);
    }
  }, [reopenConversationsCommandCenter]);

  const onEditSuccess = useCallback(() => {
    handleEditDialogClose(false);
    reopenConversationsCommandCenter();
  }, [handleEditDialogClose, reopenConversationsCommandCenter]);

  const conversationOptionsList = useMemo(() => {
    const conversationsToUse = storeConversations;
    
    return conversationsToUse
      ?.filter((conv) => !conv.is_deleted)
      .sort((a, b) => {
        const dateA = a.updated_at ? new Date(a.updated_at).getTime() : 0;
        const dateB = b.updated_at ? new Date(b.updated_at).getTime() : 0;
        return dateB - dateA;
      })
      .map((conversation: Conversation) => ({
        id: `conversation-${conversation.id}`,
        name: conversation.title || "Untitled Conversation",
        value: conversation.title || "Untitled Conversation",
        description: storeActiveSpace
          ? `Open conversation in ${storeActiveSpace.name}: ${conversation.title || "Untitled"}`
          : `Open conversation: ${conversation.title || "Untitled"}`,
        icon: (
          <div className="flex items-center gap-2">
            <MessageSquare className="h-4 w-4" />
            {conversation.id === storeActiveConversation?.id && (
              <span className="text-[10px] font-medium bg-cyan-500/20 text-cyan-500 rounded-full px-2 py-0.5">
                Active
              </span>
            )}
          </div>
        ),
        type: "conversations" as CommandType,
        keywords: [
          "conversation", 
          "chat", 
          "open",
          ...(conversation.title ? conversation.title.split(/\s+/) : []),
          conversation.title || "untitled",
          ...(conversation.updated_at ? [
            new Date(conversation.updated_at).toLocaleDateString(),
            new Date(conversation.updated_at).toLocaleString()
          ] : [])
        ],
        action: async () => {
          await selectConversation(conversation.id);
          closeCommandCenter();
        },
        closeCommandOnSelect: false,
        rightElement: (
          <div className="flex items-center gap-1.5">
            <Tooltip>
              <TooltipTrigger asChild>
                <div
                  onClick={(e) => { 
                    e.stopPropagation();
                    e.preventDefault();
                    handleEditConversation(conversation);
                  }}
                  className={cn(
                    "flex items-center h-7 w-7 justify-center rounded-md p-1.5",
                    "transition-all duration-200 ease-in-out",
                    "bg-white/[0.03] hover:bg-white/[0.08] border border-white/[0.05]",
                    "text-zinc-400 hover:text-zinc-200",
                    "cursor-pointer"
                  )}
                >
                  <Pencil size={11} strokeWidth={1.5} />
                </div>
              </TooltipTrigger>
              <TooltipContent side="bottom">
                Edit Conversation
              </TooltipContent>
            </Tooltip>
            <Tooltip>
              <TooltipTrigger asChild>
                <div
                  onClick={(e) => { 
                    e.stopPropagation();
                    e.preventDefault();
                    handleDeleteConversation(conversation);
                  }}
                  className={cn(
                    "flex items-center h-7 w-7 justify-center rounded-md p-1.5",
                    "transition-all duration-200 ease-in-out",
                    "bg-white/[0.03] hover:bg-red-400/20 border border-white/[0.05]",
                    "text-red-400 hover:text-red-200",
                    "cursor-pointer"
                  )}
                >
                  <Trash className="text-red-400" size={11} strokeWidth={1.5} />
                </div>
              </TooltipTrigger>
              <TooltipContent side="bottom" className="bg-red-500/20 border-red-500/30 text-red-300">
                Delete Conversation
              </TooltipContent>
            </Tooltip>
          </div>
        )
      })) ?? [];
  }, [
    storeConversations,
    storeActiveConversation
  ]);

  const conversationCommands = useCallback((): CommandOption[] => {
    return [
      {
        id: "new-conversation",
        name: "Start New Conversation",
        value: "Start New Conversation",
        description: storeActiveSpace
          ? `Begin a new chat in ${storeActiveSpace.name}`
          : "Begin a new chat conversation",
        icon: <MessageSquare className="h-4 w-4" />,
        shortcut: ["⌘", "T"],
        type: "conversations",
        keywords: ["conversation", "chat", "new", "start", "begin"],
        action: async () => {
          await createConversation();
          closeCommandCenter();
        },
      },
      ...conversationOptionsList,
    ];
  }, [conversationOptionsList]);

  useCommandRegistration(conversationCommands());

  return (
    <TooltipProvider>
      <ConversationDialogForm
        open={showEditDialog}
        onOpenChange={handleEditDialogClose}
        onEditSuccess={onEditSuccess}
        editConversation={conversationToEdit}
      />
      <DeleteConversationDialog 
        open={showDeleteDialog}
        onOpenChange={handleDeleteDialogClose}
        conversation={conversationToDelete}
        onConfirm={confirmDeleteConversation}
      />
      {children}
    </TooltipProvider>
  );
}

/**
 * Provider for model-related commands
 */
export function ModelsCommandProvider({ children, activeSpace = null }: { children: ReactNode, activeSpace?: any }) {
  const { closeCommandCenter } = useCommandCenter();

  const {
    activeSpace: storeActiveSpace,
  } = useSpaceStore(
    useShallow((state) => state.uiState)
  );
  const { 
    updateSpace
  } = useSpaceStore();  
  
  const handleModelSelect = useCallback(async (modelId: string, provider: Provider) => {
    console.log('Updating space:', storeActiveSpace);
    if (storeActiveSpace?.id) {
      await updateSpace(storeActiveSpace.id, {
        model: modelId,
        provider: provider
      });
    } else {
      console.error('Cannot update space: No active space ID');
    }
  }, [storeActiveSpace, updateSpace]);

  const modelCommands = useCallback((): CommandOption[] => {
    const commands: CommandOption[] = [];
    const providerGroups: Record<string, CommandOption[]> = {};
    
    // Import the ProviderIcon component
    const { ProviderIcon } = require('@/components/ui/chat/provider-icon');

    Object.entries(AVAILABLE_MODELS).forEach(([providerKey, models]) => {
      const provider = providerKey as Provider;
      const providerName = PROVIDER_NAMES[provider];
      const providerDescription = PROVIDER_DESCRIPTIONS?.[provider] || `Models from ${providerName}`;
      
      const groupId = `provider-group-${provider}`;
      commands.push({
        id: groupId,
        name: providerName,
        value: providerName,
        description: providerDescription,
        icon: <ProviderIcon provider={provider} size={18} />,
        type: "models",
        keywords: ["provider", providerName.toLowerCase(), "model"],
        action: () => {
          console.log(`Provider group: ${providerName}`);
        },
      });

      models.forEach((model) => {
        const isCurrentModel = storeActiveSpace && 
                              storeActiveSpace.provider === provider && 
                              storeActiveSpace.model === model.id;
        
        commands.push({
          id: `model-${provider}-${model.id}`,
          name: model.name,
          value: model.name,
          description: model.description || `${providerName} model`,
          icon: (
            <div className="flex items-center opacity-60 pl-3">
              <ProviderIcon provider={provider} size={14} className="opacity-80" />
              {isCurrentModel && (
                <span className="ml-2 text-[10px] font-medium bg-cyan-500/20 text-cyan-500 rounded-full px-2 py-0.5">
                  Active
                </span>
              )}
            </div>
          ),
          type: "models",
          keywords: [
            "model", 
            model.name.toLowerCase(), 
            providerName.toLowerCase(),
            ...(model.description ? model.description.split(' ') : [])
          ],
          action: async () => {
            await handleModelSelect(model.id, provider);
          },
        });
      });
      
      commands.push({
        id: `separator-${provider}`,
        name: "",
        value: "",
        type: "models",
        icon: <></>,
        action: () => {},
      });
    });

    if (commands.length > 0) {
      commands.pop();
    }

    return commands;
  }, [storeActiveSpace, handleModelSelect]);

  useCommandRegistration([...modelCommands()]);

  return <>{children}</>;
}

/**
 * Provider for general actions commands
 */
export function ActionsCommandProvider({ children }: { children: ReactNode }) {
  const actionCommands = useCallback(
    (): CommandOption[] => [
      {
        id: "keyboard-shortcuts",
        name: "View Keyboard Shortcuts",
        value: "View Keyboard Shortcuts",
        description: "Show all available keyboard shortcuts",
        icon: <Command className="h-4 w-4" />,
        type: "actions",
        keywords: ["keyboard", "shortcuts", "keys", "bindings", "help"],
        action: () => {
          console.log("Viewing keyboard shortcuts");
        },
      },
    ],
    []
  );

  useCommandRegistration(actionCommands());

  return <>{children}</>;
}

// Create a context for search scope management
const SearchScopeContext = React.createContext<{
  scope: "conversation" | "space" | "all";
  setScope: (scope: "conversation" | "space" | "all") => void;
}>({
  scope: "conversation",
  setScope: () => {},
});

/**
 * The SearchHeader component that consumes the scope context
 */
const SearchHeader = () => {
  const { scope, setScope } = React.useContext(SearchScopeContext);
  
  return (
    <div className="px-2 py-2">
      <Tabs 
        value={scope} 
        onValueChange={(value) => setScope(value as "conversation" | "space" | "all")}
        className="w-full"
      >
        <TabsList className="w-full grid grid-cols-3 bg-zinc-900/40 border border-white/5 rounded-md">
          <TabsTrigger 
            value="conversation" 
            className="text-xs py-1 data-[state=active]:bg-zinc-800 data-[state=active]:text-white"
          >
            Conversation
          </TabsTrigger>
          <TabsTrigger 
            value="space" 
            className="text-xs py-1 data-[state=active]:bg-zinc-800 data-[state=active]:text-white"
          >
            Space
          </TabsTrigger>
          <TabsTrigger 
            value="all" 
            className="text-xs py-1 data-[state=active]:bg-zinc-800 data-[state=active]:text-white"
          >
            All Spaces
          </TabsTrigger>
        </TabsList>
      </Tabs>
    </div>
  );
};

// Updated formatDate function with proper error handling
const formatDate = (dateString?: string): string => {
  if (!dateString) return "Unknown date";
  
  try {
    // First try parsing as ISO string
    const date = new Date(dateString);
    
    // Check if date is valid
    if (isNaN(date.getTime())) {
      return "Unknown date";
    }
    
    return new Intl.DateTimeFormat('en-US', {
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric'
    }).format(date);
  } catch (error) {
    console.error("Error formatting date:", error);
    return "Unknown date";
  }
}

export function MessageSearchProvider({ children }: { children: ReactNode }) {
  const [searchTerm, setSearchTerm] = useState("");
  const [searchResults, setSearchResults] = useState<any[] | null>(null);
  const [isSearching, setIsSearching] = useState(false);
  const [searchScope, setSearchScope] = useState<"conversation" | "space" | "all">("conversation");
  
  const { 
    closeCommandCenter, 
    openCommandType, 
    setIsLoading, 
    setLoadingCommandType,
    registerSearchableCommand,
    unregisterSearchableCommand
  } = useCommandCenter();
  
  const {
    activeSpace,
    activeConversation,
  } = useSpaceStore(
    useShallow((state) => state.uiState)
  );
  
  const { selectConversation } = useSpaceStore();
  
  // Register this as a searchable command type
  useEffect(() => {
    const MIN_SEARCH_LENGTH = 3;
    
    // Register messages as a searchable command type
    registerSearchableCommand('messages', {
      minSearchLength: MIN_SEARCH_LENGTH,
      placeholderText: `Type at least ${MIN_SEARCH_LENGTH} characters to search messages...`
    });
    
    // Cleanup on unmount
    return () => {
      unregisterSearchableCommand('messages');
    };
  }, [registerSearchableCommand, unregisterSearchableCommand]);
  
  const handleSearch = useCallback(async () => {
    const MIN_SEARCH_LENGTH = 3;
    
    // Clear results and loading state if search term is too short
    if (!searchTerm || searchTerm.length < MIN_SEARCH_LENGTH) {
      setSearchResults([]);
      setIsLoading(false);
      setLoadingCommandType(null);
      return;
    }
    
    // Set local and global loading states immediately
    setIsSearching(true);
    setIsLoading(true);
    setLoadingCommandType('messages');
    
    try {
      const conversationId = searchScope === "conversation" ? activeConversation?.id : undefined;
      const spaceId = (searchScope === "space" || searchScope === "conversation") ? activeSpace?.id : undefined;
      
      const response = await searchMessages(
        searchTerm,
        searchScope,
        "exact",
        conversationId,
        spaceId
      );

      console.log("response", response);
      
      if (response && response.status === 'success' && response.data && response.data.results) {
        setSearchResults(response.data.results);
      } else {
        setSearchResults([]);
      }
    } catch (error) {
      console.error("Error searching messages:", error);
      toast.error("Search Failed", {
        description: "Could not search messages. Please try again."
      });
      setSearchResults([]);
    } finally {
      // Clear both loading states
      setIsSearching(false);
      setIsLoading(false);
      setLoadingCommandType(null);
    }
  }, [searchTerm, searchScope, activeConversation, activeSpace, setIsLoading, setLoadingCommandType]);
  
  const toggleSearchScope = useCallback(() => {
    setSearchScope(current => {
      if (current === "conversation") return "space";
      if (current === "space") return "all";
      return "conversation";
    });
    
    setSearchResults(null);
  }, []);
  
  const getScopeName = useCallback(() => {
    switch (searchScope) {
      case "conversation":
        return activeConversation?.title || "Current Conversation";
      case "space":
        return activeSpace?.name || "Current Space";
      case "all":
        return "All Spaces";
      default:
        return "Messages";
    }
  }, [searchScope, activeConversation, activeSpace]);
  
  const searchCommands = useCallback((): CommandOption[] => {
    if (!searchTerm || searchTerm.length < 3) return []

    const commands: CommandOption[] = []
    
    // Check if we're in a special search mode that should bypass filtering
    const shouldBypassFilter = searchTerm.length >= 3 && !!searchResults && searchResults.length > 0;

    if (searchResults && searchResults.length > 0) {
      searchResults.forEach((result) => {
        const messageContent = result.content || ""
        const lowerContent = messageContent.toLowerCase()
        const lowerSearchTerm = searchTerm.toLowerCase()
        const matchIndex = lowerContent.indexOf(lowerSearchTerm)

        if (matchIndex === -1) return

        // Create a display content that includes context around the match
        let displayContent = messageContent
        const snippetLength = 60 // Characters to show around the match
        
        if (messageContent.length > (snippetLength * 2) + searchTerm.length) {
          // If the content is long, truncate it to show context around the match
          const startIndex = Math.max(0, matchIndex - snippetLength)
          const endIndex = Math.min(messageContent.length, matchIndex + searchTerm.length + snippetLength)
          
          displayContent = (startIndex > 0 ? '...' : '') + 
                          messageContent.substring(startIndex, endIndex) + 
                          (endIndex < messageContent.length ? '...' : '')
        }

        const isAssistant = result.role === "assistant"
        const conversationId = result.conversation_id

        commands.push({
          id: conversationId + result.id,
          name: displayContent,
          value: result.content,
          shortcut: [formatDate(result.created_at)],
          type: "messages",
          icon: (
            <div className="flex items-center justify-center rounded-full bg-white/5 w-8 h-8">
              <MessageCircle className="h-5 w-5 text-white/70" />
            </div>
          ),
          description: isAssistant ? "AI Message" : "Your Message",
          rightElement: (
            <div className={`
              px-1.5 py-0.5 text-xs font-medium rounded 
              ${isAssistant 
                ? 'bg-blue-500/20 text-blue-400 border border-blue-500/30' 
                : 'bg-green-500/20 text-green-400 border border-green-500/30'}
            `}>
              {isAssistant ? "AI" : "You"}
            </div>
          ),
          action: async () => {
            // Navigate to the conversation
            if (conversationId) {
              await selectConversation(conversationId);
              closeCommandCenter();
            }
          },
          bypassFilter: shouldBypassFilter,
        })
      })
    }

    return commands
  }, [searchResults, searchTerm, selectConversation, closeCommandCenter]);
  
  // Handle scope changes from the header
  const handleScopeChange = useCallback((scope: "conversation" | "space" | "all") => {
    setSearchScope(scope);
    setSearchResults(null); // Clear results when changing scope
  }, []);
  
  // Create the context value with the current scope
  const scopeContextValue = useMemo(() => ({
    scope: searchScope,
    setScope: handleScopeChange
  }), [searchScope, handleScopeChange]);
  
  // Create the header component with context - this will update when scopeContextValue changes
  const headerWithContext = useMemo(() => (
    <SearchScopeContext.Provider value={scopeContextValue}>
      <SearchHeader />
    </SearchScopeContext.Provider>
  ), [scopeContextValue]);
  
  // Register the header at the top level - this follows React hooks rules
  useCommandHeaderRegistration(headerWithContext, "messages");
  
  // Register search commands at the top level
  useCommandRegistration(searchCommands());
  
  // Effect to trigger search when search term or scope changes
  useEffect(() => {
    const MIN_SEARCH_LENGTH = 3; // Keep this in sync with the registered config
    
    // Clear any existing search timer
    const timer = setTimeout(() => {
      // If search is long enough, trigger search
      if (searchTerm && searchTerm.length >= MIN_SEARCH_LENGTH) {
        handleSearch();
      } 
      // If search is less than minimum but not empty, set appropriate loading state
      else if (searchTerm.length > 0 && searchTerm.length < MIN_SEARCH_LENGTH) {
        setSearchResults([]);
        setIsLoading(false);
        setLoadingCommandType(null);
      } 
      // If search is empty, clear all states
      else if (searchTerm.length === 0) {
        setSearchResults([]);
        setIsLoading(false);
        setLoadingCommandType(null);
      }
    }, 300); // Debounce search input
    
    // For immediate feedback while typing
    if (searchTerm && searchTerm.length >= MIN_SEARCH_LENGTH) {
      // Immediately set loading state for better UX
      setIsLoading(true);
      setLoadingCommandType('messages');
    }
    
    return () => clearTimeout(timer);
  }, [searchTerm, searchScope, handleSearch, setIsLoading, setLoadingCommandType]);
  
  // Set up a listener for the command center search query
  const { searchQuery } = useCommandCenter();
  
  useEffect(() => {
    if (searchQuery) {
      setSearchTerm(searchQuery);
    } else {
      setSearchTerm("");
      setSearchResults(null);
    }
  }, [searchQuery]);
  
  return <>{children}</>;
}

/**
 * Combined provider for all command types
 */
/**
 * Dialog for creating or editing a chat mode
 */
export function ChatModeDialogForm({
  open,
  onOpenChange,
  onCreateSuccess,
  editMode = null,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onCreateSuccess: (modeId: string) => void;
  editMode?: any; // The chat mode to edit, null when creating a new mode
}) {
  const [name, setName] = useState(editMode?.name || "Custom Mode");
  const [description, setDescription] = useState(editMode?.description || "");
  const [selectedTools, setSelectedTools] = useState<string[]>(
    editMode?.tools?.map((t: any) => t.id) || []
  );
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [customInstructions, setCustomInstructions] = useState(editMode?.customInstructions || "");
  
  const [availableTools, setAvailableTools] = useState<Record<string, any>>({});
  const router = useRouter();
  
  // Get the space store
  const { activeSpace, updateSpace } = useSpaceStore(
    useShallow(state => ({
      activeSpace: state.activeSpace,
      updateSpace: state.updateSpace
    }))
  );
  
  // Load available tools on mount
  useEffect(() => {
    const loadTools = async () => {
      try {
        const { AVAILABLE_TOOLS } = await import('@/config/chat-modes');
        setAvailableTools(AVAILABLE_TOOLS);
      } catch (error) {
        console.error("Error loading tools:", error);
      }
    };
    
    loadTools();
  }, []);
  
  useEffect(() => {
    if (open) {
      if (editMode) {
        setName(editMode.name || "Custom Mode");
        setDescription(editMode.description || "");
        setSelectedTools(editMode.tools?.map((t: any) => t.id) || []);
        setCustomInstructions(editMode.customInstructions || "");
      } else {
        setName("Custom Mode");
        setDescription("");
        setSelectedTools([]);
        setCustomInstructions("");
      }
    }
  }, [open, editMode]);
  
  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();
      setIsSubmitting(true);
      
      try {
        // Import the createCustomChatMode function
        const { createCustomChatMode } = await import('@/config/chat-modes');
        
        // Create the custom mode config
        const customMode = createCustomChatMode(
          name, 
          description, 
          selectedTools
        );
        
        // Save any custom instructions in the chat_mode_config
        const modeConfig = {
          tools: selectedTools,
          custom_instructions: customInstructions || undefined,
          mcp_servers: customMode.mcp_servers || []
        };
        
        // Update the space with the new mode
        if (activeSpace?.id) {
          const success = await updateSpace(activeSpace.id, {
            chat_mode: customMode.id,
            chat_mode_config: modeConfig
          });
          
          if (success) {
            toast.success('Mode Created', {
              description: `Custom mode "${name}" created and activated`
            });
            onCreateSuccess(customMode.id);
            router.refresh();
          } else {
            toast.error('Failed to create mode', {
              description: 'Could not update space settings'
            });
          }
        }
      } catch (error) {
        console.error("Error creating custom mode:", error);
        toast.error('Failed to create mode', {
          description: 'An unexpected error occurred'
        });
      } finally {
        setIsSubmitting(false);
      }
    },
    [name, description, selectedTools, customInstructions, activeSpace, updateSpace, onCreateSuccess, router]
  );
  
  const isFormValid = name && name.trim().length > 0 && selectedTools.length > 0;
  
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create Custom Chat Mode</DialogTitle>
            <DialogDescription>
              Configure a custom chat mode with specific tools and behavior
            </DialogDescription>
          </DialogHeader>
          
          <div className="grid gap-4 py-4 max-h-[60vh] overflow-y-auto pr-2">
            <div className="grid gap-2">
              <Label htmlFor="name">Name</Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="Mode name"
                required
                className="bg-zinc-900/50 border-white/10"
              />
            </div>
            
            <div className="grid gap-2">
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder="What this mode is best for"
                rows={2}
                className="bg-zinc-900/50 border-white/10 min-h-[80px]"
              />
            </div>
            
            <div className="grid gap-2">
              <Label>Select Tools</Label>
              <div className="space-y-2 bg-zinc-900/30 rounded-md p-3 border border-white/5">
                {Object.values(availableTools).map((tool: any) => (
                  <div key={tool.id} className="flex items-start space-x-2 py-1.5 border-b border-white/5 last:border-b-0">
                    <Checkbox
                      id={`tool-${tool.id}`}
                      checked={selectedTools.includes(tool.id)}
                      onCheckedChange={(checked) => {
                        if (checked) {
                          setSelectedTools([...selectedTools, tool.id]);
                        } else {
                          setSelectedTools(selectedTools.filter(id => id !== tool.id));
                        }
                      }}
                      className="mt-1"
                    />
                    <div>
                      <Label
                        htmlFor={`tool-${tool.id}`}
                        className="text-sm font-medium cursor-pointer"
                      >
                        {tool.name}
                      </Label>
                      <p className="text-xs text-white/60">{tool.description}</p>
                    </div>
                  </div>
                ))}
              </div>
              {selectedTools.length === 0 && (
                <p className="text-xs text-amber-400">Select at least one tool</p>
              )}
            </div>
            
            <div className="grid gap-2">
              <Label htmlFor="customInstructions">Custom Instructions (Optional)</Label>
              <Textarea
                id="customInstructions"
                value={customInstructions}
                onChange={(e) => setCustomInstructions(e.target.value)}
                placeholder="Add custom instructions for the AI in this mode..."
                rows={4}
                className="bg-zinc-900/50 border-white/10 min-h-[100px]"
              />
              <p className="text-xs text-white/60">
                These instructions will be added to the system prompt when this mode is active
              </p>
            </div>
          </div>
          
          <DialogFooter>
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              className="border-white/10 bg-zinc-900/50 hover:bg-zinc-800"
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              disabled={isSubmitting || !isFormValid}
              className="bg-cyan-500/20 hover:bg-cyan-500/30 border border-cyan-500/20 text-cyan-300 backdrop-blur-sm"
            >
              {isSubmitting ? (
                <div className="flex items-center gap-2">
                  <div className="animate-spin h-4 w-4 border-2 border-cyan-400/20 border-t-cyan-400/80 rounded-full" />
                  <span>Creating...</span>
                </div>
              ) : (
                "Create Mode"
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

/**
 * Provider for chat modes (different AI assistance modes)
 */
export function ChatModesCommandProvider({ children }: { children: ReactNode }) {
  const [showModeDialog, setShowModeDialog] = useState(false);
  const [editModeData, setEditModeData] = useState<any>(null);
  const { closeCommandCenter, openCommandType } = useCommandCenter();
  const router = useRouter();
  
  const {
    activeSpace,
    updateSpace,
  } = useSpaceStore(useShallow(state => ({
    activeSpace: state.activeSpace,
    updateSpace: state.updateSpace,
  })));
  
  const reopenChatModesCommandCenter = useCallback(() => {
    openCommandType('chat-modes');
  }, [openCommandType]);
  
  const handleModeSelect = useCallback(async (modeId: string) => {
    if (!activeSpace) return;
    
    try {
      // Get the mode configuration from the CHAT_MODES constant
      const { CHAT_MODES } = await import('@/config/chat-modes');
      const modeConfig = CHAT_MODES[modeId];
      
      if (!modeConfig) return;
      
      // Extract tool IDs for storage
      const toolIds = modeConfig.tools.map(tool => tool.id);
      
      // Update the space with the new chat mode
      await updateSpace(activeSpace.id, {
        chat_mode: modeId,
        chat_mode_config: { 
          tools: toolIds,
          mcp_servers: modeConfig.mcp_servers || []
        }
      });
      
      toast.success(`Mode Changed`, {
        description: `Changed to ${modeConfig.name} mode`
      });
      
      closeCommandCenter();
      router.refresh();
    } catch (error) {
      console.error('Failed to change chat mode:', error);
      toast.error('Failed to change mode', {
        description: 'Please try again later'
      });
    }
  }, [activeSpace, updateSpace, closeCommandCenter, router]);

  const handleCreateCustomMode = useCallback(() => {
    closeCommandCenter();
    setEditModeData(null);
    setShowModeDialog(true);
  }, [closeCommandCenter]);
  
  const handleCreateDialogClose = useCallback((open: boolean) => {
    setShowModeDialog(open);
    if (!open) {
      setTimeout(() => {
        reopenChatModesCommandCenter();
      }, 150);
    }
  }, [reopenChatModesCommandCenter]);
  
  const onCreateSuccess = useCallback((modeId: string) => {
    setShowModeDialog(false);
    // The mode is already active, just close the dialog
  }, []);
  
  const baseModeCommands = useCallback(
    (): CommandOption[] => [
      {
        id: "create-custom-mode",
        name: "Create Custom Mode",
        value: "Create Custom Mode",
        description: "Create a new custom chat mode with specific tools",
        icon: <Plus className="h-4 w-4" />,
        type: "chat-modes",
        keywords: ["create", "custom", "mode", "new", "add"],
        action: handleCreateCustomMode,
      },
    ],
    [handleCreateCustomMode]
  );
  
  const chatModeCommands = useCallback(async (): Promise<CommandOption[]> => {
    try {
      // Dynamically import the CHAT_MODES to avoid circular dependencies
      const { CHAT_MODE_LIST } = await import('@/config/chat-modes');
      
      // Start with built-in modes
      const modeCommands = CHAT_MODE_LIST.map(mode => {
        const Icon = mode.icon;
        
        return {
          id: `mode-${mode.id}`,
          name: mode.name,
          value: mode.name,
          description: mode.description,
          icon: <Icon className="h-4 w-4" />,
          type: "chat-modes",
          keywords: mode.keywords || [],
          action: () => handleModeSelect(mode.id),
          rightElement: (
            <>
              {activeSpace?.chat_mode === mode.id && (
                <div className="bg-cyan-500/20 text-cyan-300 px-2 py-0.5 rounded-md text-xs">
                  Active
                </div>
              )}
            </>
          )
        };
      });
      
      // Check if current space has a custom mode
      if (activeSpace?.chat_mode && activeSpace.chat_mode.startsWith('custom-')) {
        // This is a custom mode - create a command for it
        const customModeId = activeSpace.chat_mode;
        const toolCount = activeSpace.chat_mode_config?.tools?.length || 0;
        const hasCustomInstructions = !!activeSpace.chat_mode_config?.custom_instructions;
        
        // Extract custom mode name from ID (fallback to "Custom Mode" if not found)
        // Format is typically custom-timestamp-name
        const customModeName = customModeId.split('-').slice(2).join(' ') || "Custom Mode";
        
        modeCommands.push({
          id: `mode-${customModeId}`,
          name: customModeName,
          value: customModeName,
          description: `Custom mode with ${toolCount} tools${hasCustomInstructions ? ' and custom instructions' : ''}`,
          icon: <Sparkles className="h-4 w-4" />,
          type: "chat-modes",
          keywords: ["custom", "mode", "personal", ...customModeName.split(' ')],
          action: () => handleModeSelect(customModeId),
          rightElement: (
            <div className="bg-cyan-500/20 text-cyan-300 px-2 py-0.5 rounded-md text-xs">
              Active
            </div>
          )
        });
      }
      
      return modeCommands;
    } catch (error) {
      console.error('Error loading chat mode commands:', error);
      return [];
    }
  }, [activeSpace, handleModeSelect]);

  // Register commands - we need to handle the async loading of commands
  const [commands, setCommands] = useState<CommandOption[]>([]);
  
  useEffect(() => {
    const loadCommands = async () => {
      try {
        const baseCommands = baseModeCommands();
        const modeCommands = await chatModeCommands();
        setCommands([...baseCommands, ...modeCommands]);
      } catch (error) {
        console.error('Error loading chat mode commands:', error);
        setCommands(baseModeCommands());
      }
    };
    
    loadCommands();
  }, [baseModeCommands, chatModeCommands]);
  
  useCommandRegistration(commands);
  
  return (
    <>
      <ChatModeDialogForm
        open={showModeDialog}
        onOpenChange={handleCreateDialogClose}
        onCreateSuccess={onCreateSuccess}
        editMode={editModeData}
      />
      {children}
    </>
  );
}

/**
 * Provider for background tasks commands
 */
export function BackgroundTasksCommandProvider({ children }: { children: ReactNode }) {
  const [tasks, setTasks] = useState<any[]>([]);
  const { closeCommandCenter } = useCommandCenter();
  
  // Interface for a background task
  interface BackgroundTask {
    id: string;
    description: string;
    status: 'pending' | 'in-progress' | 'completed' | 'failed';
    createdAt: number;
    completedAt?: number;
    progress?: number;
  }
  
  // Example function to create a new background task
  const createBackgroundTask = useCallback((description: string) => {
    const newTask: BackgroundTask = {
      id: `task-${Date.now()}`,
      description,
      status: 'pending',
      createdAt: Date.now(),
    };
    
    setTasks(prevTasks => [...prevTasks, newTask]);
    
    // This would be replaced with actual task creation logic
    toast.success('Task Created', {
      description: `New background task: ${description}`
    });
    
    return newTask.id;
  }, []);

  // Example function to update a task's status
  const updateTaskStatus = useCallback((taskId: string, status: 'pending' | 'in-progress' | 'completed' | 'failed', progress?: number) => {
    setTasks(prevTasks => 
      prevTasks.map(task => 
        task.id === taskId 
          ? { 
              ...task, 
              status, 
              progress, 
              ...(status === 'completed' ? { completedAt: Date.now() } : {})
            } 
          : task
      )
    );
  }, []);
  
  // Example function to remove a task
  const removeTask = useCallback((taskId: string) => {
    setTasks(prevTasks => prevTasks.filter(task => task.id !== taskId));
  }, []);
  
  // Natural language parser for creating tasks (placeholder)
  const parseTaskFromNaturalLanguage = useCallback((input: string) => {
    // This is a placeholder - in a real implementation, you would use NLP
    // to extract task details from natural language
    
    const description = input.trim();
    
    if (description.length < 5) {
      return null;
    }
    
    // Create the task
    return createBackgroundTask(description);
  }, [createBackgroundTask]);
  
  // Create task command
  const createTaskCommand = useCallback((): CommandOption => {
    return {
      id: "create-background-task",
      name: "Create Background Task",
      value: "Create Background Task",
      description: "Start a new background task with natural language",
      icon: <Plus className="h-4 w-4" />,
      type: "background-tasks",
      keywords: ["task", "background", "create", "new", "schedule", "run"],
      action: () => {
        // You could show a dialog here, but for now we'll just use prompt
        const description = prompt("Describe the task you want to run in the background:");
        if (description) {
          parseTaskFromNaturalLanguage(description);
        }
      },
    };
  }, [parseTaskFromNaturalLanguage]);
  
  // Generate commands for each task
  const taskCommands = useCallback((): CommandOption[] => {
    const getStatusElementAndIcon = (task: any): { icon: React.ReactNode, statusElement: React.ReactNode } => {
      let icon;
      let statusElement;
      
      switch (task.status) {
        case 'pending':
          icon = <Clock className="h-4 w-4 text-yellow-400" />;
          statusElement = (
            <div className="px-1.5 py-0.5 text-xs font-medium rounded bg-yellow-500/20 text-yellow-400 border border-yellow-500/30">
              Pending
            </div>
          );
          break;
        case 'in-progress':
          icon = <Activity className="h-4 w-4 text-blue-400" />;
          statusElement = (
            <div className="px-1.5 py-0.5 text-xs font-medium rounded bg-blue-500/20 text-blue-400 border border-blue-500/30">
              {task.progress ? `${task.progress}%` : 'Running'}
            </div>
          );
          break;
        case 'completed':
          icon = <Check className="h-4 w-4 text-green-400" />;
          statusElement = (
            <div className="px-1.5 py-0.5 text-xs font-medium rounded bg-green-500/20 text-green-400 border border-green-500/30">
              Completed
            </div>
          );
          break;
        case 'failed':
          icon = <X className="h-4 w-4 text-red-400" />;
          statusElement = (
            <div className="px-1.5 py-0.5 text-xs font-medium rounded bg-red-500/20 text-red-400 border border-red-500/30">
              Failed
            </div>
          );
          break;
        default:
          icon = <Clock className="h-4 w-4 text-white/70" />;
          statusElement = (
            <div className="px-1.5 py-0.5 text-xs font-medium rounded bg-white/10 text-white/70 border border-white/10">
              Unknown
            </div>
          );
      }
      
      return { icon, statusElement };
    };
    
    return tasks.map(task => {
      // Get the icon and status element
      const { icon, statusElement } = getStatusElementAndIcon(task);
      
      // Generate unique ID for the task to use in the command
      const taskCommandId = `task-${task.id}`;
      
      // Create the task command
      return {
        id: taskCommandId,
        name: task.description,
        value: task.description,
        description: `Task created ${new Date(task.createdAt).toLocaleString()}`,
        icon,
        type: "background-tasks" as CommandType,
        keywords: ["task", "background", ...task.description.split(/\s+/)],
        action: () => {
          // Here you would show task details, but for now just log
          console.log("Task selected:", task.id);
        },
        rightElement: (
          <div className="flex items-center gap-1.5">
            {statusElement}
            <button
              onClick={(e) => { 
                e.stopPropagation();
                e.preventDefault();
                // Use the task.id directly rather than capturing it from closure
                removeTask(task.id);
              }}
              className={cn(
                "flex items-center h-7 w-7 justify-center rounded-md p-1.5",
                "transition-all duration-200 ease-in-out",
                "bg-white/[0.03] hover:bg-red-400/20 border border-white/[0.05]",
                "text-red-400 hover:text-red-200",
                "cursor-pointer"
              )}
            >
              <Trash className="text-red-400" size={11} strokeWidth={1.5} />
            </button>
          </div>
        )
      };
    });
  }, [tasks, removeTask]);
  
  // Register all commands
  useCommandRegistration([createTaskCommand(), ...taskCommands()]);
  
  return <>{children}</>;
}

/**
 * Provider for AI generated suggestions
 */
export function SuggestionsCommandProvider({ children }: { children: ReactNode }) {
  const [suggestions, setSuggestions] = useState<any[]>([]);
  const { closeCommandCenter } = useCommandCenter();
  
  // Interface for a suggestion
  interface Suggestion {
    id: string;
    description: string;
    source: string;
    confidence: number;
    createdAt: number;
    accepted?: boolean;
  }
  
  // Example function to add a new suggestion
  const addSuggestion = useCallback((description: string, source: string, confidence: number = 0.8) => {
    const newSuggestion: Suggestion = {
      id: `suggestion-${Date.now()}`,
      description,
      source,
      confidence,
      createdAt: Date.now(),
    };
    
    setSuggestions(prevSuggestions => [...prevSuggestions, newSuggestion]);
    
    return newSuggestion.id;
  }, []);
  
  // Example function to accept a suggestion
  const acceptSuggestion = useCallback((suggestionId: string) => {
    setSuggestions(prevSuggestions => {
      // Find the suggestion within the callback to avoid dependency on suggestions array
      const suggestion = prevSuggestions.find(s => s.id === suggestionId);
      
      // Show toast here to avoid dependency on suggestions
      if (suggestion) {
        toast.success('Suggestion Accepted', {
          description: `Now executing: ${suggestion.description}`
        });
      }
      
      return prevSuggestions.map(suggestion => 
        suggestion.id === suggestionId 
          ? { ...suggestion, accepted: true } 
          : suggestion
      );
    });
  }, []);
  
  // Example function to reject a suggestion
  const rejectSuggestion = useCallback((suggestionId: string) => {
    setSuggestions(prevSuggestions => prevSuggestions.filter(s => s.id !== suggestionId));
    
    toast.info('Suggestion Dismissed');
  }, []);
  
  // Track whether examples have been added already
  const hasAddedExamplesRef = useRef(false);
  
  // Add example suggestions on first render
  useEffect(() => {
    // This would be replaced with actual suggestions from the AI
    // Using a ref to prevent this effect from running more than once
    if (!hasAddedExamplesRef.current) {
      // Using function callbacks directly here to avoid dependency on addSuggestion
      setSuggestions(prev => [
        ...prev,
        {
          id: `suggestion-${Date.now()}`,
          description: "Create a space to organize your machine learning resources",
          source: "Based on your recent conversations about ML",
          confidence: 0.8,
          createdAt: Date.now(),
        },
        {
          id: `suggestion-${Date.now() + 1}`,
          description: "Summarize yesterday's conversation about React performance",
          source: "You seemed interested in this topic",
          confidence: 0.7,
          createdAt: Date.now(),
        }
      ]);
      
      hasAddedExamplesRef.current = true;
    }
  }, []); // Empty dependency array
  
  // Generate commands for each suggestion
  const suggestionCommands = useCallback((): CommandOption[] => {
    return suggestions.map(suggestion => {
      // Generate unique IDs to avoid stale closures
      const suggestionId = suggestion.id;
      
      return {
        id: `suggestion-${suggestionId}`,
        name: suggestion.description,
        value: suggestion.description,
        description: `${suggestion.source} • ${Math.round(suggestion.confidence * 100)}% confidence`,
        icon: <Lightbulb className="h-4 w-4 text-amber-400" />,
        type: "suggestions" as CommandType,
        keywords: ["suggestion", "recommend", ...suggestion.description.split(/\s+/)],
        action: () => {
          acceptSuggestion(suggestionId);
          closeCommandCenter();
        },
        rightElement: (
          <div className="flex items-center gap-1.5">
            <button
              onClick={(e) => { 
                e.stopPropagation();
                e.preventDefault();
                acceptSuggestion(suggestionId);
                closeCommandCenter();
              }}
              className={cn(
                "flex items-center h-7 w-7 justify-center rounded-md p-1.5",
                "transition-all duration-200 ease-in-out",
                "bg-white/[0.03] hover:bg-green-400/20 border border-white/[0.05]",
                "text-green-400 hover:text-green-200",
                "cursor-pointer"
              )}
              title="Accept Suggestion"
            >
              <Check className="text-green-400" size={11} strokeWidth={1.5} />
            </button>
            <button
              onClick={(e) => { 
                e.stopPropagation();
                e.preventDefault();
                rejectSuggestion(suggestionId);
              }}
              className={cn(
                "flex items-center h-7 w-7 justify-center rounded-md p-1.5",
                "transition-all duration-200 ease-in-out",
                "bg-white/[0.03] hover:bg-red-400/20 border border-white/[0.05]",
                "text-red-400 hover:text-red-200",
                "cursor-pointer"
              )}
              title="Dismiss"
            >
              <X className="text-red-400" size={11} strokeWidth={1.5} />
            </button>
          </div>
        )
      };
    });
  }, [suggestions, acceptSuggestion, rejectSuggestion, closeCommandCenter]);
  
  // Register all commands
  useCommandRegistration(suggestionCommands());
  
  return <>{children}</>;
}

{/* AllCommandProviders is now moved to its own file */}

================
File: components/CommandRoot.tsx
================
"use client"

import React from 'react';
import CommandCenter from "@/components/CommandCenter";
import CommandShortcuts from "@/components/CommandShortcuts";

export default function CommandRoot() {
  return (
    <>
      <CommandCenter />
      <CommandShortcuts />
    </>
  );
}

================
File: components/CommandShortcuts.tsx
================
import { useModalHotkey, useCommandCenter } from "@/hooks/useCommandCenter";
import { useHotkeys } from "react-hotkeys-hook";

/**
 * Component that registers keyboard shortcuts for specific command types
 * This can be placed anywhere in your component tree, typically near the root
 */
export function CommandShortcuts() {
  const { toggleCommandCenter } = useCommandCenter();

  useHotkeys('meta+k', (event) => {
    event.preventDefault();
    toggleCommandCenter();
  }, {
    enableOnFormTags: true,
    enableOnContentEditable: true
  }); 

  useModalHotkey("spaces", "meta+s");
  useModalHotkey("conversations", "meta+b");
  useModalHotkey("models", "meta+m");
  useModalHotkey("actions", "meta+a");
  useModalHotkey("messages", "meta+e");
  useModalHotkey("background-tasks", "meta+t");
  useModalHotkey("suggestions", "meta+g");

  return null;
}

export default CommandShortcuts;

================
File: components/file-mention-input.tsx
================
"use client"

import * as React from "react"
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from "@/components/ui/command"
import { File, X } from "lucide-react"

// Mock file data
const mockFiles = [
  { id: "1", name: "index.tsx", path: "/app/index.tsx" },
  { id: "2", name: "layout.tsx", path: "/app/layout.tsx" },
  { id: "3", name: "page.tsx", path: "/app/page.tsx" },
  { id: "4", name: "globals.css", path: "/app/globals.css" },
  { id: "5", name: "components/button.tsx", path: "/components/button.tsx" },
  { id: "6", name: "components/input.tsx", path: "/components/input.tsx" },
  { id: "7", name: "lib/utils.ts", path: "/lib/utils.ts" },
  { id: "8", name: "tailwind.config.js", path: "/tailwind.config.js" },
]

type FileTag = {
  id: string
  name: string
  path: string
}

type Token = {
  id: string
  type: "text" | "file"
  content: string
  file?: FileTag
}

export function FileMentionInput() {
  const [tokens, setTokens] = React.useState<Token[]>([{ id: "initial", type: "text", content: "" }])
  const [inputValue, setInputValue] = React.useState("")
  const [cursorPosition, setCursorPosition] = React.useState(0)
  const [showSuggestions, setShowSuggestions] = React.useState(false)
  const [suggestionQuery, setSuggestionQuery] = React.useState("")
  const [activeTokenIndex, setActiveTokenIndex] = React.useState(0)

  const containerRef = React.useRef<HTMLDivElement>(null)
  const inputRef = React.useRef<HTMLInputElement>(null)

  // Filter files based on the query
  const filteredFiles = React.useMemo(() => {
    if (!suggestionQuery) return mockFiles
    const query = suggestionQuery.toLowerCase().trim()
    return mockFiles.filter(
      (file) => file.name.toLowerCase().includes(query) || file.path.toLowerCase().includes(query),
    )
  }, [suggestionQuery])

  // Focus the input when clicking on the container
  const handleContainerClick = (e: React.MouseEvent) => {
    if (e.target === containerRef.current) {
      inputRef.current?.focus()
    }
  }

  // Handle input changes
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value
    setInputValue(value)

    // Check for @ symbol
    if (value.includes("@")) {
      const atIndex = value.lastIndexOf("@")
      const query = value.substring(atIndex + 1)
      setSuggestionQuery(query)
      setShowSuggestions(true)
    } else {
      setShowSuggestions(false)
    }
  }

  // Handle key events
  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Backspace" && inputValue === "" && tokens.length > 0) {
      // Remove the last token if it's a file tag
      const lastToken = tokens[tokens.length - 1]
      if (lastToken.type === "file") {
        const newTokens = [...tokens]
        newTokens.pop()
        setTokens(newTokens)
      }
    } else if (e.key === "Escape" && showSuggestions) {
      setShowSuggestions(false)
      e.preventDefault()
    } else if (e.key === "Enter" && showSuggestions && filteredFiles.length > 0) {
      selectFile(filteredFiles[0])
      e.preventDefault()
    }
  }

  // Select a file from suggestions
  const selectFile = (file: FileTag) => {
    // Create a new file token
    const fileToken: Token = {
      id: `file-${Date.now()}`,
      type: "file",
      content: file.name,
      file,
    }

    // Add the file token and a new empty text token
    const newTextToken: Token = {
      id: `text-${Date.now()}`,
      type: "text",
      content: "",
    }

    // If the current input has an @ symbol, split it
    if (inputValue.includes("@")) {
      const atIndex = inputValue.lastIndexOf("@")
      const textBefore = inputValue.substring(0, atIndex)

      // Update the current text token with text before @
      const newTokens = [...tokens]
      if (newTokens[newTokens.length - 1].type === "text") {
        newTokens[newTokens.length - 1].content = textBefore
      }

      // Add the file token and a new empty text token
      setTokens([...newTokens, fileToken, newTextToken])
    } else {
      // Just add the file token after the current text
      setTokens([...tokens, fileToken, newTextToken])
    }

    // Reset input and suggestions
    setInputValue("")
    setShowSuggestions(false)

    // Focus back on the input
    setTimeout(() => {
      inputRef.current?.focus()
    }, 0)
  }

  // Remove a file tag
  const removeFileTag = (tokenId: string) => {
    const tokenIndex = tokens.findIndex((t) => t.id === tokenId)
    if (tokenIndex === -1) return

    const newTokens = [...tokens]

    // Remove the file token
    newTokens.splice(tokenIndex, 1)

    // If there are two adjacent text tokens now, merge them
    if (
      tokenIndex > 0 &&
      tokenIndex < newTokens.length &&
      newTokens[tokenIndex - 1].type === "text" &&
      newTokens[tokenIndex].type === "text"
    ) {
      newTokens[tokenIndex - 1].content += newTokens[tokenIndex].content
      newTokens.splice(tokenIndex, 1)
    }

    setTokens(newTokens)

    // Focus back on the input
    setTimeout(() => {
      inputRef.current?.focus()
    }, 0)
  }

  // Handle form submission
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()

    // Combine all tokens into a single string for demonstration
    const value = tokens
      .map((token) => {
        if (token.type === "text") return token.content
        return `@[${token.file?.name}](${token.file?.path})`
      })
      .join("")

    console.log("Submitted value:", value)
    console.log("Tokens:", tokens)

    // You could send this to your backend or process it further
  }

  return (
    <div className="w-full">
      <form onSubmit={handleSubmit}>
        <div
          ref={containerRef}
          className="flex flex-wrap items-center gap-1.5 rounded-md border border-input bg-background p-2 focus-within:ring-1 focus-within:ring-ring"
          onClick={handleContainerClick}
        >
          {tokens.map((token, index) =>
            token.type === "text" ? (
              index === tokens.length - 1 ? (
                <input
                  key={token.id}
                  ref={inputRef}
                  type="text"
                  className="flex-1 min-w-[120px] bg-transparent outline-none"
                  value={inputValue}
                  onChange={handleInputChange}
                  onKeyDown={handleKeyDown}
                  placeholder={tokens.length === 1 ? "Type @ to mention a file..." : ""}
                />
              ) : (
                <span key={token.id} className="inline-block">
                  {token.content}
                </span>
              )
            ) : (
              <span
                key={token.id}
                className="inline-flex items-center gap-1 rounded-md bg-primary/10 px-1.5 py-0.5 text-sm text-primary"
              >
                <File className="h-3 w-3" />
                {token.file?.name}
                <button
                  type="button"
                  className="ml-1 rounded-full hover:bg-primary/20"
                  onClick={() => removeFileTag(token.id)}
                >
                  <X className="h-3 w-3" />
                  <span className="sr-only">Remove</span>
                </button>
              </span>
            ),
          )}
        </div>

        {showSuggestions && (
          <div className="relative">
            <div className="absolute z-10 w-full mt-1 shadow-md">
              <Command>
                <CommandList>
                  <CommandInput
                    placeholder="Search files..."
                    value={suggestionQuery}
                    onValueChange={setSuggestionQuery}
                  />
                  <CommandEmpty>No files found.</CommandEmpty>
                  <CommandGroup heading="Files">
                    {filteredFiles.map((file) => (
                      <CommandItem key={file.id} value={file.path} onSelect={() => selectFile(file)}>
                        <File className="mr-2 h-4 w-4" />
                        <span>{file.name}</span>
                        <span className="ml-2 text-xs text-muted-foreground">{file.path}</span>
                      </CommandItem>
                    ))}
                  </CommandGroup>
                </CommandList>
              </Command>
            </div>
          </div>
        )}

        <div className="mt-4">
          <button
            type="submit"
            className="rounded-md bg-primary px-4 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90"
          >
            Submit
          </button>
        </div>
      </form>
    </div>
  )
}

================
File: components/SimilarMessagesCommandProvider.tsx
================
'use client';

import React, { ReactNode, useCallback, useEffect, useState, useRef } from 'react';
import { CommandOption, useCommandCenter, useCommandRegistration } from '@/hooks/useCommandCenter';
import { MessageSquare, MessageSquareText, ExternalLink } from 'lucide-react';
import { useRouter } from 'next/navigation';
import { useSpaceStore } from '@/stores/space-store';
import { useShallow } from 'zustand/react/shallow';

// Define the SimilarMessage type
export interface SimilarMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  score: number;
  conversationId?: string;
  metadata?: Record<string, any>;
}

interface SimilarMessagesCommandProviderProps {
  children: ReactNode;
}

// Create a formatting function for the date
function formatDate(timestamp: number): string {
  try {
    const date = new Date(timestamp);
    
    // Check if date is valid
    if (isNaN(date.getTime())) {
      return "Unknown date";
    }
    
    return new Intl.DateTimeFormat('en-US', {
      month: 'short',
      day: 'numeric',
      hour: 'numeric',
      minute: 'numeric'
    }).format(date);
  } catch (error) {
    console.error("Error formatting date:", error);
    return "Unknown date";
  }
}

export function SimilarMessagesCommandProvider({ children }: SimilarMessagesCommandProviderProps) {
  const [similarMessages, setSimilarMessages] = useState<SimilarMessage[]>([]);
  const { 
    closeCommandCenter, 
    openCommandType, 
    activeCommandType,
    setActiveCommandType,
    registerSearchableCommand, 
    unregisterSearchableCommand
  } = useCommandCenter();
  const router = useRouter();
  
  const { selectConversation } = useSpaceStore();
  const registeredCommandsRef = useRef<CommandOption[]>([]);

  // Listen for command center closing or type change
  useEffect(() => {
    // When active command type changes from similarMessages to something else,
    // clear the similar messages to prevent them from appearing in other command types
    if (activeCommandType !== 'similarMessages' && similarMessages.length > 0) {
      setTimeout(() => {
        setSimilarMessages([]);
      }, 100); // Small delay to prevent UI flicker
    }
  }, [activeCommandType, similarMessages.length]);
  
  // We already get these from the hook at component level
  
  // Register the searchable command with the hideFromCommandList option
  useEffect(() => {
    // This will make sure the similar messages aren't shown in the main command list
    registerSearchableCommand('similarMessages', {
      minSearchLength: 0,
      hideFromCommandList: true
    });
    
    return () => {
      // Clean up on unmount
      unregisterSearchableCommand('similarMessages');
    };
  }, [registerSearchableCommand, unregisterSearchableCommand]);

  // Create a function that will be globally available
  const openSimilarMessages = useCallback((messages: SimilarMessage[]) => {
    if (messages && messages.length > 0) {
      setSimilarMessages(messages);
      openCommandType('similarMessages');
    }
  }, [openCommandType]);

  // Attach the function to the window for global access
  useEffect(() => {
    (window as any).openSimilarMessages = openSimilarMessages;
    
    return () => {
      delete (window as any).openSimilarMessages;
    };
  }, [openSimilarMessages]);

  // Get command options for similar messages
  const similarMessageCommands = useCallback((): CommandOption[] => {
    if (!similarMessages || similarMessages.length === 0) {
      return [{
        id: 'no-similar-messages',
        name: 'No similar messages found',
        value: 'No similar messages found',
        description: 'There are no similar messages to display',
        icon: <MessageSquare className="h-4 w-4" />,
        type: 'similarMessages',
        keywords: ['similar', 'message', 'none'],
        action: () => {},
      }];
    }

    return similarMessages.map((message) => {
      const isAssistant = message.role === 'assistant';
      const messageContent = message.content || "";
      
      // Create a display content that's truncated if too long
      let displayContent = messageContent;
      const maxLength = 100;
      if (displayContent.length > maxLength) {
        displayContent = displayContent.substring(0, maxLength) + '...';
      }
      
      const similarityPercentage = Math.round(message.score * 100);
      
      return {
        id: `similar-message-${message.id}`,
        name: displayContent,
        value: message.content,
        description: `${similarityPercentage}% similar - ${formatDate(message.createdAt)}`,
        icon: (
          <div className="flex items-center justify-center rounded-full bg-white/5 w-8 h-8">
            {isAssistant ? (
              <MessageSquareText className="h-5 w-5 text-cyan-400/70" />
            ) : (
              <MessageSquare className="h-5 w-5 text-white/70" />
            )}
          </div>
        ),
        type: 'similarMessages',
        keywords: ['similar', 'message', ...(messageContent.split(/\s+/).slice(0, 10))],
        action: () => {
          // Navigate to the conversation containing this message
          if (message.conversationId) {
            selectConversation(message.conversationId);
            closeCommandCenter();
          }
        },
        rightElement: (
          <div className={`
            px-1.5 py-0.5 text-xs font-medium rounded 
            ${isAssistant 
              ? 'bg-blue-500/20 text-blue-400 border border-blue-500/30' 
              : 'bg-green-500/20 text-green-400 border border-green-500/30'}
          `}>
            {isAssistant ? "AI" : "You"}
          </div>
        ),
      };
    });
  }, [similarMessages, closeCommandCenter, selectConversation]);

  // Set up registration of commands
  const commands = similarMessageCommands();
  registeredCommandsRef.current = commands;
  
  // Only register commands when there are actually similar messages to show
  useCommandRegistration(similarMessages.length > 0 ? commands : []);

  return <>{children}</>;
}

================
File: config/chat-modes/index.ts
================
import { Brain, Code, MessagesSquare, Search, Sparkles, Bot, Tool, GraduationCap, FlaskConical } from "lucide-react";

// Define available chat modes with their configurations
export interface ChatModeTool {
  id: string;
  name: string;
  description: string;
  enabled: boolean;
  mcp_server?: string;
}

export interface ChatModeConfig {
  id: string;
  name: string;
  description: string;
  icon: any;
  keywords: string[];
  tools: ChatModeTool[];
  is_custom?: boolean;
  mcp_servers?: string[];
}

// Default available tools
export const AVAILABLE_TOOLS: Record<string, ChatModeTool> = {
  web_search: {
    id: "web_search",
    name: "Web Search",
    description: "Search the web for current information",
    enabled: true,
    mcp_server: "search"
  },
  code_interpreter: {
    id: "code_interpreter",
    name: "Code Interpreter",
    description: "Run code and analyze data",
    enabled: true,
    mcp_server: "code"
  },
  retrieval: {
    id: "retrieval",
    name: "Knowledge Retrieval",
    description: "Retrieve information from your documents",
    enabled: true,
    mcp_server: "retrieval"
  },
  reasoning: {
    id: "reasoning",
    name: "Advanced Reasoning",
    description: "Use step-by-step reasoning for complex problems",
    enabled: true
  },
  research: {
    id: "research",
    name: "Deep Research",
    description: "Conduct detailed research on complex topics",
    enabled: true,
    mcp_server: "research"
  },
  agent: {
    id: "agent",
    name: "Autonomous Agent",
    description: "Let the AI act autonomously to accomplish goals",
    enabled: true,
    mcp_server: "agent"
  }
};

// Standard chat modes
export const CHAT_MODES: Record<string, ChatModeConfig> = {
  ask: {
    id: "ask",
    name: "Ask",
    description: "Standard chat mode without additional tools",
    icon: MessagesSquare,
    keywords: ["chat", "normal", "standard", "basic", "ask", "question"],
    tools: []
  },
  search: {
    id: "search",
    name: "Search",
    description: "Chat with web search capability",
    icon: Search,
    keywords: ["search", "web", "internet", "google", "find", "browse"],
    tools: [AVAILABLE_TOOLS.web_search]
  },
  code: {
    id: "code",
    name: "Code",
    description: "Specialized mode for coding assistance with code interpreter",
    icon: Code,
    keywords: ["code", "programming", "develop", "script", "program"],
    tools: [AVAILABLE_TOOLS.code_interpreter]
  },
  research: {
    id: "research",
    name: "Research",
    description: "Deep research mode with all research capabilities",
    icon: GraduationCap,
    keywords: ["research", "analyze", "investigate", "study", "explore"],
    tools: [AVAILABLE_TOOLS.web_search, AVAILABLE_TOOLS.retrieval, AVAILABLE_TOOLS.reasoning]
  },
  think: {
    id: "think",
    name: "Think",
    description: "Advanced reasoning mode for complex problem solving",
    icon: Brain,
    keywords: ["think", "reason", "logic", "analyze", "solve"],
    tools: [AVAILABLE_TOOLS.reasoning]
  },
  agent: {
    id: "agent",
    name: "Agent",
    description: "Autonomous agent mode that can use all tools",
    icon: Bot,
    keywords: ["agent", "autonomous", "assistant", "automate", "task"],
    tools: [
      AVAILABLE_TOOLS.web_search, 
      AVAILABLE_TOOLS.code_interpreter,
      AVAILABLE_TOOLS.retrieval,
      AVAILABLE_TOOLS.reasoning,
      AVAILABLE_TOOLS.agent
    ]
  },
  experiment: {
    id: "experiment",
    name: "Experiment",
    description: "Experimental mode with all available tools",
    icon: FlaskConical,
    keywords: ["experiment", "lab", "test", "try", "all"],
    tools: Object.values(AVAILABLE_TOOLS)
  }
};

// Get ordered list of chat modes
export const CHAT_MODE_LIST = Object.values(CHAT_MODES);

// Get a specific chat mode configuration
export function getChatModeConfig(modeId: string): ChatModeConfig {
  return CHAT_MODES[modeId] || CHAT_MODES.ask;
}

// Create a custom chat mode
export function createCustomChatMode(
  name: string,
  description: string,
  tools: string[],
  mcp_servers?: string[]
): ChatModeConfig {
  // Create a URL-friendly version of the name
  const slugName = name.toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const id = `custom-${Date.now()}-${slugName}`;
  
  const enabledTools = tools.map(toolId => {
    const baseTool = AVAILABLE_TOOLS[toolId];
    if (baseTool) {
      return { ...baseTool, enabled: true };
    }
    return null;
  }).filter(Boolean) as ChatModeTool[];
  
  return {
    id,
    name,
    description,
    icon: Sparkles,
    keywords: [name.toLowerCase(), "custom", "personalized"],
    tools: enabledTools,
    is_custom: true,
    mcp_servers
  };
}

================
File: config/models.ts
================
export const PROVIDER_DESCRIPTIONS: Record<Provider, string> = {
  groq: 'Ultra-fast inference optimized for real-time applications',
  anthropic: 'Advanced language models with strong reasoning capabilities',
  openai: 'State-of-the-art models with broad capabilities',
  cohere: 'Specialized models for enterprise and business use cases',
  mistral: 'Open-source foundation models with various specializations',
  google: 'Cutting-edge multimodal models from Google DeepMind',
  xai: 'Advanced models focused on reasoning and transparency',
  togetherai: 'Curated collection of top open-source models',
  perplexity: 'Research-focused models optimized for reasoning tasks'
};

export const AVAILABLE_MODELS = {
  groq: [
    { id: 'deepseek-r1-distill-llama-70b', name: 'Deepseek R1 70B', description: 'Powerful general-purpose model with fast inference', contextWindow: 32768 },
    { id: 'mixtral-8x7b-instruct', name: 'Mixtral 8x7B', description: 'Efficient model balancing speed and capability', contextWindow: 32768 },
    { id: 'deepseek-r1-distill-llama-70b-specdec', name: 'Deepseek R1 70B SpecDec', description: 'Specialized for technical documentation', contextWindow: 32768 },
    { id: 'gemma2-9b-it', name: 'Gemma 2 9B', description: 'Compact model optimized for quick responses', contextWindow: 8192 },
    { id: 'llama-3.3-70b-versatile', name: 'LLaMA 3.3 70B Versatile', description: 'Latest LLaMA optimized for versatility', contextWindow: 128000 },
  ],
  anthropic: [
    { id: 'claude-3-opus-latest', name: 'Claude 3 Opus', description: 'Most capable model for complex tasks', contextWindow: 128000 },
    { id: 'claude-3-5-sonnet-latest', name: 'Claude 3.5 Sonnet', description: 'Balanced performance and speed', contextWindow: 128000 },
    { id: 'claude-3-5-haiku-latest', name: 'Claude 3.5 Haiku', description: 'Fast, efficient for simple tasks', contextWindow: 128000 },
  ],
  openai: [
    { id: 'gpt-4o', name: 'GPT-4o', description: 'Most powerful model for complex reasoning', contextWindow: 128000, multimodal: true },
    { id: 'gpt-4o-mini', name: 'GPT-4o Mini', description: 'Efficient version of GPT-4', contextWindow: 128000, multimodal: true },
    { id: 'o1', name: 'O1', description: 'Fast, general-purpose assistant', contextWindow: 128000 },
    { id: 'o3-mini', name: 'O3 Mini', description: 'Quick responses for simple tasks', contextWindow: 128000 },
  ],
  cohere: [
    { id: 'command', name: 'Command', description: 'Enterprise-grade general model', contextWindow: 128000 },
    { id: 'command-light', name: 'Command Light', description: 'Faster, lighter version of Command', contextWindow: 32768 },
    { id: 'command-nightly', name: 'Command Nightly', description: 'Latest experimental features', contextWindow: 128000 },
    { id: 'command-light-nightly', name: 'Command Light Nightly', description: 'Fast experimental version', contextWindow: 32768 }
  ],
  mistral: [
    { id: 'mistral-large-latest', name: 'Mistral Large', description: 'Most capable open model', contextWindow: 32000 },
    { id: 'codestral-latest', name: 'Codestral', description: 'Specialized for code generation', contextWindow: 32000 },
    { id: 'pixtral-large-latest', name: 'Pixtral Large', description: 'Vision and image understanding', contextWindow: 128000, multimodal: true },
    { id: 'ministral-3b-latest', name: 'Ministral 3B', description: 'Ultra-compact, fast responses', contextWindow: 4096 },
    { id: 'ministral-8b-latest', name: 'Ministral 8B', description: 'Balanced size and capability', contextWindow: 8192 },
    { id: 'mistral-small-latest', name: 'Mistral Small', description: 'Efficient for simple tasks', contextWindow: 4096 },
  ],
  google: [
    { id: 'gemini-2.0-flash-001', name: 'Gemini 2.0 Flash', description: 'Ultra-fast responses, latest version', contextWindow: 1000000, multimodal: true },
    { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro', description: 'Balanced performance model', contextWindow: 1000000, multimodal: true },
  ],
  xai: [
    { id: 'grok-2-1212', name: 'Grok 2', description: 'Advanced reasoning capabilities', contextWindow: 128000 },
    { id: 'grok-2-vision-1212', name: 'Grok 2 Vision', description: 'Multimodal understanding', contextWindow: 128000, multimodal: true },
  ],
  togetherai: [
    { id: 'deepseek-ai/DeepSeek-R1', name: 'DeepSeek R1', description: 'General purpose reasoning', contextWindow: 128000 },
    { id: 'deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free', name: 'DeepSeek R1 Distill Llama 70B', description: 'Efficient large model', contextWindow: 32768 },
    { id: 'deepseek-ai/DeepSeek-V3', name: 'DeepSeek V3', description: 'Latest architecture improvements', contextWindow: 128000 },
    { id: 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free', name: 'Llama 3.3 70B Instruct Turbo', description: 'Fast instruction following', contextWindow: 128000 },
    { id: 'meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo', name: 'Llama 3.1 405B Instruct Turbo', description: 'Massive model, best quality', contextWindow: 128000 },
  ],
  perplexity: [
    { id: 'sonar-reasoning-pro', name: 'Sonar Reasoning Pro', description: 'Advanced reasoning capabilities', contextWindow: 200000 },
    { id: 'sonar-reasoning', name: 'Sonar Reasoning', description: 'Efficient reasoning model', contextWindow: 200000 },
    { id: 'sonar-pro', name: 'Sonar Pro', description: 'Professional general use', contextWindow: 200000 },
    { id: 'sonar', name: 'Sonar', description: 'Fast, reliable model', contextWindow: 200000 }
  ]
} as const;

export type Provider = keyof typeof AVAILABLE_MODELS;
export type ModelsByProvider = {
  [P in Provider]: typeof AVAILABLE_MODELS[P][number]['id'];
};

export const PROVIDER_NAMES: Record<Provider, string> = {
  groq: 'Groq',
  anthropic: 'Anthropic',
  openai: 'OpenAI',
  cohere: 'Cohere',
  mistral: 'Mistral',
  google: 'Google',
  xai: 'xAI',
  togetherai: 'Together AI',
  perplexity: 'Perplexity'
};

export function isValidModelForProvider(provider: Provider, model: string): boolean {
  return AVAILABLE_MODELS[provider].some(m => m.id === model);
}

export function getModelName(provider: Provider | undefined, modelId: string): string {
  if (!provider || !modelId) return 'Select Model';
  
  const models = AVAILABLE_MODELS[provider];
  if (!models) return modelId;

  const model = models.find(m => m.id === modelId);
  return model?.name || modelId;
}

================
File: docs/COMMAND_SYSTEM.md
================
# Command System Architecture

This document outlines the architecture of the Spatial Command System, a unified modal interface for accessing all functionality within the application.

## Overview

The Command System follows the Raycast pattern, providing a single entry point to all application functionalities. It is designed to be:

- **Extensible**: New commands can be easily added to any part of the application
- **Modular**: Commands are organized into logical categories
- **Accessible**: Available via keyboard shortcuts (⌘K) or UI buttons
- **Scalable**: Built to handle an unlimited number of commands
- **Fast**: Quick access to any feature within the application

## Architecture

The Command System architecture follows SOLID principles:

### Single Responsibility Principle
- Each component has a single responsibility
- `CommandCenter` - Displays the command UI
- `CommandProvider` - Manages command state
- Section-specific providers - Register commands for their domains

### Open/Closed Principle
- The system is open for extension but closed for modification
- New command categories can be added without changing existing code
- New commands can be registered without modifying the core framework

### Liskov Substitution Principle
- Command types follow a consistent interface
- All commands have the same structure regardless of their category

### Interface Segregation Principle
- The API is minimal and focused
- Command registration hooks provide just what's needed
- Command rendering is separated from command behavior

### Dependency Inversion Principle
- High-level modules don't depend on low-level modules
- Commands are registered through abstraction (context)
- Components consume the command API through hooks

## Core Components

### 1. Command UI Components (`components/ui/command.tsx`)
- Reusable UI components built on top of CMDK
- Includes dialog, input, list, and item components
- Styled with Tailwind CSS for a consistent look and feel

### 2. Command Context (`hooks/useCommandCenter.tsx`)
- Central state management for the command system
- Handles command registration and filtering
- Manages dialog open/close state and keyboard shortcuts
- Provides functions to open specific command types directly

### 3. Command Providers (`components/CommandProviders.tsx`)
- Section-specific providers that register commands for their domains
- Organized into logical categories (application, spaces, conversations, etc.)
- Each provider registers its commands on mount and unregisters on unmount

### 4. Command Center (`components/CommandCenter.tsx`)
- Main component that displays the command UI
- Handles rendering of command groups and items
- Manages navigation between command categories

### 5. Command Button (`components/CommandButton.tsx`)
- UI component to trigger the command center
- Can be customized and placed anywhere in the application
- Includes TypedCommandButton for direct access to specific command types

### 6. Command Shortcuts (`components/CommandShortcuts.tsx`)
- Registers global keyboard shortcuts for specific command types
- Makes specific categories directly accessible via keyboard

## Command Structure

Each command follows this structure:

```typescript
interface CommandOption {
  id: string;                   // Unique identifier
  name: string;                 // Display name
  description?: string;         // Optional description
  icon?: ReactNode;             // Optional icon
  shortcut?: string[];          // Optional keyboard shortcut
  type: CommandType;            // Category (application, spaces, etc.)
  keywords?: string[];          // Optional keywords for search
  action: () => void;           // Function to execute when selected
}
```

## Extension Points

To add new commands:

1. Create a new command provider or extend an existing one
2. Define your commands following the `CommandOption` interface
3. Register them using the `useCommandRegistration` hook

For a new command category:

1. Add the new type to the `CommandType` union type
2. Create a new provider for that category
3. Add your commands following the structure above
4. Add a modal-specific shortcut if needed

## Keyboard Shortcuts

The system supports two levels of keyboard shortcuts:

1. **Global Command Center Shortcut**: `⌘K` (or `Ctrl+K` on Windows) opens the main command center.
2. **Type-Specific Shortcuts**:
   - `⌘S` - Open Spaces commands
   - `⌘T` - Open Conversations commands
   - `⌘M` - Open Models commands
   - `⌘A` - Open Actions commands

To add a new type-specific shortcut:

```typescript
// In CommandShortcuts.tsx or any component
useModalHotkey("your-command-type", "meta+letter");
```

## Design Decisions

1. **Context-based State Management**
   - Using React Context for global command state
   - Allows any component to register commands from anywhere in the app

2. **Component Composition**
   - Command UI components are composable
   - Allows for customization and future extension

3. **Keyboard Accessibility**
   - All commands are accessible via keyboard shortcuts
   - The command center itself is triggered via ⌘K (or Ctrl+K)
   - Type-specific shortcuts for direct access to specific categories

4. **Search-based Navigation**
   - Commands are searchable by name, description, and keywords
   - Enables quick access to any functionality

5. **Category-based Organization**
   - Commands are organized into logical categories
   - Provides structure to potentially hundreds of commands

6. **Direct Modal Access**
   - Each command category can be accessed directly
   - Supports both keyboard shortcuts and UI buttons

## Future Improvements

1. **Command History**
   - Track recently used commands
   - Allow quick access to frequently used actions

2. **Dynamic Command Loading**
   - Lazy-load commands based on application state
   - Register commands only when needed

3. **Sub-commands and Nested Navigation**
   - Add support for commands that open sub-menus
   - Enable more complex command hierarchies

4. **Command Permissions**
   - Control command visibility based on user permissions
   - Show/hide commands based on application state

5. **Command Palettes**
   - Create context-specific command palettes
   - Show different sets of commands based on the current view

================
File: electron/main.ts
================
import { app, BrowserWindow, ipcMain } from "electron";
import { join, extname, basename } from "path";
import * as fs from "fs";
import * as path from "path";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);

let mainWindow: BrowserWindow;

// Create the main application window
const createWindow = () => {
  console.log("Creating Electron window");

  const preloadPath = join(__dirname, "preload.js");
  console.log("Preload script path:", preloadPath);
  console.log("Preload script exists:", fs.existsSync(preloadPath));

  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: preloadPath,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  mainWindow.loadURL("http://localhost:3000");
  mainWindow.webContents.openDevTools();

  mainWindow.webContents.on("did-finish-load", () => {
    console.log("Webpage finished loading");
  });
};

// Cache for storing search results
const searchCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes TTL for cache entries

// Supported file extensions (customize as needed)
const SUPPORTED_EXTENSIONS = [
  ".txt", ".md", ".pdf", ".doc", ".docx",
  ".rtf", ".odt", ".html", ".htm", ".xml",
  ".json", ".csv", ".js", ".ts", ".jsx", ".tsx", ".py",
  ".java", ".c", ".cpp", ".h", ".rb", ".go", ".rs",
  ".swift", ".php", ".css", ".scss", ".less",
];

/**
 * Spotlight-based file search for macOS
 * Uses mdfind to query Spotlight index
 * @param {string} searchTerm - The search term to look for
 * @param {number} maxResults - Maximum number of results to return
 * @returns {Promise<Array>} Array of matching file objects
 */
async function spotlightFileSearch(searchTerm: string, maxResults = 100): Promise<any[]> {
  try {
    if (process.platform !== "darwin") {
      throw new Error("This application only supports macOS with Spotlight integration.");
    }

    searchTerm = searchTerm.toLowerCase().trim();

    // Use mdfind to query Spotlight
    // -onlyin ~ limits search to user’s home directory by default (adjustable)
    // kMDItemFSName matches file names
    const cmd = `mdfind "kMDItemFSName == '*${searchTerm}*'c" -onlyin ~ | head -n ${maxResults}`;
    console.log(`Executing Spotlight search: ${cmd}`);

    const { stdout, stderr } = await execAsync(cmd);
    if (stderr) {
      console.error("Spotlight search error:", stderr);
    }

    if (!stdout.trim()) return [];

    const filePaths = stdout.split("\n").filter(Boolean);

    // Filter by supported extensions and build results
    const results = filePaths
      .filter((filePath) => {
        const ext = extname(filePath).toLowerCase();
        return SUPPORTED_EXTENSIONS.includes(ext);
      })
      .map((filePath) => ({
        path: filePath,
        name: basename(filePath),
        type: extname(filePath).substring(1).toLowerCase() || "unknown",
        size: fs.existsSync(filePath) ? fs.statSync(filePath).size : 0,
        modified: fs.existsSync(filePath) ? fs.statSync(filePath).mtimeMs : Date.now(),
      }));

    // Sort by relevance (e.g., exact name match first)
    results.sort((a, b) => {
      const aNameLower = a.name.toLowerCase();
      const bNameLower = b.name.toLowerCase();
      if (aNameLower === searchTerm && bNameLower !== searchTerm) return -1;
      if (bNameLower === searchTerm && aNameLower !== searchTerm) return 1;
      return aNameLower.localeCompare(bNameLower);
    });

    return results.slice(0, maxResults);
  } catch (error) {
    console.error("Error in Spotlight file search:", error);
    return [];
  }
}

// IPC handler for file search
ipcMain.handle("search-files", async (event, searchTerm) => {
  try {
    if (!searchTerm || typeof searchTerm !== "string" || searchTerm.trim().length < 2) {
      console.log("Search term too short, returning empty results");
      return [];
    }

    const cacheKey = searchTerm.trim().toLowerCase();
    if (searchCache.has(cacheKey)) {
      const { results, timestamp } = searchCache.get(cacheKey);
      if (Date.now() - timestamp < CACHE_TTL) {
        console.log(`Returning cached results for "${searchTerm}"`);
        return results;
      }
    }

    console.log(`Searching for files with term: "${searchTerm}"`);
    const results = await spotlightFileSearch(searchTerm);

    if (results.length > 0) {
      searchCache.set(cacheKey, {
        results,
        timestamp: Date.now(),
      });
    }

    console.log(`Found ${results.length} matches for "${searchTerm}"`);
    return results;
  } catch (error) {
    console.error("Error searching files:", error);
    return [];
  }
});

// File reading logic remains mostly unchanged but simplified for macOS
ipcMain.handle("read-file", async (event, filePath) => {
  try {
    console.log("Reading file:", filePath);

    if (!fs.existsSync(filePath)) {
      throw new Error(`File does not exist: ${filePath}`);
    }

    const stats = fs.statSync(filePath);
    const sizeInMB = stats.size / (1024 * 1024);
    const MAX_TEXT_SIZE_MB = 5;

    const ext = extname(filePath).toLowerCase();
    const textExtensions = [
      ".txt", ".md", ".js", ".ts", ".jsx", ".tsx", ".html", ".css",
      ".json", ".csv", ".xml", ".py", ".rb", ".java", ".c", ".cpp",
    ];

    if (textExtensions.includes(ext)) {
      if (sizeInMB > MAX_TEXT_SIZE_MB) {
        return {
          content: `File too large (${sizeInMB.toFixed(2)}MB). Max: ${MAX_TEXT_SIZE_MB}MB.`,
          type: "text",
          truncated: true,
        };
      }

      const content = fs.readFileSync(filePath, "utf-8");
      const MAX_CHAR_LENGTH = 100000;
      if (content.length > MAX_CHAR_LENGTH) {
        return {
          content: content.substring(0, MAX_CHAR_LENGTH) + "\n\n[Truncated...]",
          type: "text",
          truncated: true,
        };
      }

      return { content, type: "text" };
    }

    return {
      content: `[File: ${basename(filePath)}, Size: ${sizeInMB.toFixed(2)}MB]`,
      type: "reference",
      extension: ext.slice(1),
      size: stats.size,
      originalPath: filePath,
    };
  } catch (error) {
    console.error("Error reading file:", error);
    return { content: "Error reading file", type: "error" };
  }
});

// Cache cleanup
setInterval(() => {
  const now = Date.now();
  for (const [key, { timestamp }] of searchCache.entries()) {
    if (now - timestamp > CACHE_TTL) {
      searchCache.delete(key);
    }
  }
}, 60000);

app.whenReady().then(() => {
  if (process.platform !== "darwin") {
    console.error("This app only runs on macOS.");
    app.quit();
    return;
  }
  createWindow();
});

app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

================
File: electron/preload.ts
================
import { contextBridge, ipcRenderer } from "electron";

// Add debugging to see if preload is being executed
console.log("Preload script is running");

// Expose safe electron APIs to the renderer process
contextBridge.exposeInMainWorld("electronAPI", {
  // Search for files based on a pattern using IPC
  searchFiles: async (searchTerm: string) => {
    console.log("Searching for files with term:", searchTerm);
    try {
      const results = await ipcRenderer.invoke("search-files", searchTerm);
      console.log("Search results:", results);
      return results;
    } catch (error) {
      console.error("Error searching files:", error);
      return [];
    }
  },
  
  // Read file content using IPC
  readFile: async (filePath: string) => {
    console.log("Reading file:", filePath);
    try {
      const result = await ipcRenderer.invoke("read-file", filePath);
      console.log("File read successfully");
      return result;
    } catch (error) {
      console.error("Error reading file:", error);
      throw error;
    }
  },
  
  // Test function to check if Electron API is available
  ping: () => {
    console.log("electronAPI.ping called");
    return "pong";
  }
});

================
File: electron/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "outDir": "../build",
    "rootDir": "./",
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["./**/*"]
}

================
File: hooks/use-stick-to-bottom.ts
================
import { useCallback, useEffect, useRef, useState } from 'react';

export function useStickToBottom(threshold = 150) {
  const [isStickToBottom, setIsStickToBottom] = useState(true);
  const containerRef = useRef<HTMLDivElement>(null);
  const prevScrollHeightRef = useRef<number>(0);

  const checkIsStickToBottom = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    const { scrollHeight, scrollTop, clientHeight } = container;
    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
    
    setIsStickToBottom(distanceFromBottom <= threshold);
  }, [threshold]);

  const scrollToBottom = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    // Ensure we scroll all the way to the bottom
    container.scrollTop = container.scrollHeight;
  }, []);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = () => {
      checkIsStickToBottom();
    };

    container.addEventListener('scroll', handleScroll);
    return () => container.removeEventListener('scroll', handleScroll);
  }, [checkIsStickToBottom]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleResize = () => {
      if (isStickToBottom) {
        scrollToBottom();
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [isStickToBottom, scrollToBottom]);

  // Auto-scroll when content changes if we're sticking to bottom
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const { scrollHeight } = container;
    
    if (scrollHeight !== prevScrollHeightRef.current) {
      if (isStickToBottom) {
        scrollToBottom();
      }
      prevScrollHeightRef.current = scrollHeight;
    }
  });

  // Always scroll to bottom on initial render
  useEffect(() => {
    scrollToBottom();
  }, []);

  return {
    containerRef,
    isStickToBottom,
    scrollToBottom
  };
}

================
File: hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/common/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: hooks/useCommandCenter.tsx
================
'use client'
import { ReactNode, createContext, useCallback, useContext, useEffect, useMemo, useState, useRef } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';

// Command types
export type CommandType = 'application' | 'spaces' | 'conversations' | 'models' | 'actions' | 'messages' | 'chat-modes' | 'similarMessages' | 'background-tasks' | 'suggestions';

export interface CommandOption {
  id: string;
  name: string;
  value?: string;
  description?: string;
  icon?: ReactNode;
  rightElement?: ReactNode;
  shortcut?: string[];
  type: CommandType;
  keywords?: string[];
  action: () => void;
  closeCommandOnSelect?: boolean;
  /**
   * When set to true, this command will always be included in filteredCommands
   * regardless of search query or active command type.
   * Useful for special scenarios like search results that need to override
   * the default filtering behavior.
   */
  bypassFilter?: boolean;
}

// Define an interface for searchable command configuration
export interface SearchableCommandConfig {
  minSearchLength: number;
  placeholderText?: string;
  hideFromCommandList?: boolean; // If true, will not be shown in the main command list
}

interface CommandContextType {
  isOpen: boolean;
  openCommandCenter: () => void;
  closeCommandCenter: () => void;
  toggleCommandCenter: () => void;
  openCommandType: (type: CommandType) => void;
  closeCommandType: (type: CommandType) => void;
  registerCommand: (command: CommandOption) => void;
  unregisterCommand: (commandId: string) => void;
  commands: CommandOption[];
  filteredCommands: CommandOption[];
  setSearchQuery: (query: string) => void;
  searchQuery: string;
  activeCommandType: CommandType | null;
  setActiveCommandType: (type: CommandType | null) => void;
  headers: Record<CommandType, ReactNode>;
  registerHeader: (header: ReactNode, type: CommandType) => void;
  unregisterHeader: (type: CommandType) => void;
  isLoading: boolean;
  setIsLoading: (isLoading: boolean) => void;
  loadingCommandType: CommandType | null;
  setLoadingCommandType: (type: CommandType | null) => void;
  searchableCommands: Record<CommandType, SearchableCommandConfig>;
  registerSearchableCommand: (type: CommandType, config: SearchableCommandConfig) => void;
  unregisterSearchableCommand: (type: CommandType) => void;
}

const CommandContext = createContext<CommandContextType | undefined>(undefined);

export function CommandProvider({ children }: { children: ReactNode }) {
  const [isOpen, setIsOpen] = useState(false);
  const [commands, setCommands] = useState<CommandOption[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [activeCommandType, setActiveCommandType] = useState<CommandType | null>(null);
  const [headers, setHeaders] = useState<Record<CommandType, ReactNode>>({
    application: null,
    spaces: null,
    conversations: null,
    models: null,
    actions: null,
    messages: null,
    'chat-modes': null,
    'similarMessages': null,
    'background-tasks': null,
    'suggestions': null
  });
  const [isLoading, setIsLoading] = useState(false);
  const [loadingCommandType, setLoadingCommandType] = useState<CommandType | null>(null);
  const [searchableCommands, setSearchableCommands] = useState<Record<CommandType, SearchableCommandConfig>>({
    application: { minSearchLength: 0 },
    spaces: { minSearchLength: 0 },
    conversations: { minSearchLength: 0 },
    models: { minSearchLength: 0 },
    actions: { minSearchLength: 0 },
    messages: { minSearchLength: 0 },
    'chat-modes': { minSearchLength: 0 },
    'similarMessages': { minSearchLength: 0 },
    'background-tasks': { minSearchLength: 0 },
    'suggestions': { minSearchLength: 0 }
  });

  
  const openCommandCenter = useCallback(() => {
    console.log('openCommandCenter called');
    setIsOpen(true);
  }, []);
  const closeCommandCenter = useCallback(() => {
    console.log('closeCommandCenter called');
    setIsOpen(false);
    setSearchQuery('');
    setActiveCommandType(null);
  }, []);
  
  const toggleCommandCenter = useCallback(() => {
    console.log('toggleCommandCenter called');
    if (isOpen) {
      if (activeCommandType !== null) {
        console.log('Switching from specific command type to main command center');
        setActiveCommandType(null);
      } else {
        setIsOpen(false);
        setSearchQuery('');
        setActiveCommandType(null);
      }
    } else {
      setIsOpen(true);
      setActiveCommandType(null);
    }
  }, [isOpen, activeCommandType]);
  
  const closeCommandType = useCallback((type: CommandType) => {
    console.log('closeCommandType called with:', type);
    if (isOpen && activeCommandType === type) {
      setIsOpen(false);
      setActiveCommandType(null);
      setSearchQuery('');
    }
  }, [isOpen, activeCommandType]);
  
  const openCommandType = useCallback((type: CommandType) => {
    console.log('openCommandType called with:', type);
    if (isOpen && activeCommandType === type) {
      closeCommandType(type);
    } else {
      setActiveCommandType(type);
      if (!isOpen) {
        setIsOpen(true);
      }
    }
  }, [isOpen, activeCommandType, closeCommandType]);

  useHotkeys('esc', () => {
    console.log('esc key pressed');
    if (isOpen) {
      closeCommandCenter();
    }
  });

  const registerCommand = useCallback((command: CommandOption) => {
    setCommands(prev => {
      const exists = prev.some(cmd => cmd.id === command.id);
      if (exists) {
        const isEqual = prev.some(cmd => 
          cmd.id === command.id && 
          cmd.name === command.name && 
          cmd.description === command.description
        );
        if (isEqual) return prev; // No change needed
        
        return prev.map(cmd => cmd.id === command.id ? command : cmd);
      }
      return [...prev, command];
    });
  }, []);

  const unregisterCommand = useCallback((commandId: string) => {
    setCommands(prev => {
      const commandExists = prev.some(cmd => cmd.id === commandId);
      if (!commandExists) return prev;
      return prev.filter(cmd => cmd.id !== commandId);
    });
  }, []);

  const registerHeader = useCallback((header: ReactNode, type: CommandType) => {
    setHeaders(prev => ({ ...prev, [type]: header }));
  }, []); 

  const unregisterHeader = useCallback((type: CommandType) => {
    setHeaders(prev => {
      const newHeaders = { ...prev };
      delete newHeaders[type];  
      return newHeaders;
    });
  }, []);

  const filteredCommands = useMemo(() => {
    const filteredCommands = commands.filter(command => {
      // Check if this command type should be hidden from the main command list
      const isHiddenType = searchableCommands[command.type]?.hideFromCommandList === true;
      
      // When no command type is active (i.e., we're showing the main command list),
      // hide commands whose type is configured to be hidden
      if (!activeCommandType && isHiddenType) {
        return false;
      }
      
      // If command has bypassFilter set to true, always include it
      // This allows specialized providers like MessageSearchProvider to
      // override the default filtering behavior when needed
      if (command.bypassFilter === true) {
        return true;
      }
      
      if (activeCommandType && command.type !== activeCommandType) {
        return false;
      }

      if (!searchQuery) return true;

      const query = searchQuery.toLowerCase().trim();
      
      const nameWords = command.name.toLowerCase().split(/\s+/);
      const keywordMatches = command.keywords?.some(keyword => 
        keyword.toLowerCase().startsWith(query) || 
        keyword.toLowerCase().includes(` ${query}`) || 
        keyword.toLowerCase() === query
      );
      
      const nameStartsWithQuery = command.name.toLowerCase().startsWith(query);
      const nameContainsWordStartingWithQuery = nameWords.some(word => word.startsWith(query));
      const descriptionContainsQuery = command.description?.toLowerCase().includes(query);

      return nameStartsWithQuery || 
             nameContainsWordStartingWithQuery || 
             keywordMatches || 
             descriptionContainsQuery;
    });

    return filteredCommands;
  }, [commands, searchQuery, activeCommandType, searchableCommands]);

  const registerSearchableCommand = useCallback((type: CommandType, config: SearchableCommandConfig) => {
    setSearchableCommands(prev => ({ ...prev, [type]: config }));
  }, []);

  const unregisterSearchableCommand = useCallback((type: CommandType) => {
    setSearchableCommands(prev => {
      const newSearchableCommands = { ...prev };
      delete newSearchableCommands[type];  
      return newSearchableCommands;
    });
  }, []);

  const value = useMemo(() => ({
    isOpen,
    openCommandCenter,
    closeCommandCenter,
    toggleCommandCenter,
    openCommandType,
    closeCommandType,
    registerCommand,
    unregisterCommand,
    commands,
    filteredCommands,
    searchQuery,
    setSearchQuery,
    activeCommandType,
    setActiveCommandType,
    headers,
    registerHeader,
    unregisterHeader,
    isLoading,
    setIsLoading,
    loadingCommandType,
    setLoadingCommandType,
    searchableCommands,
    registerSearchableCommand,
    unregisterSearchableCommand,
  }), [
    isOpen, 
    openCommandCenter, 
    closeCommandCenter, 
    toggleCommandCenter, 
    openCommandType,
    closeCommandType,
    registerCommand, 
    unregisterCommand, 
    commands, 
    filteredCommands, 
    searchQuery, 
    activeCommandType,
    headers,
    registerHeader,
    unregisterHeader,
    isLoading,
    setIsLoading,
    loadingCommandType,
    setLoadingCommandType,
    searchableCommands,
    registerSearchableCommand,
    unregisterSearchableCommand,
  ]);

  return (
    <CommandContext.Provider value={value}>
      {children}
    </CommandContext.Provider>
  );
}

export function useCommandCenter() {
  const context = useContext(CommandContext);
  if (context === undefined) {
    throw new Error('useCommandCenter must be used within a CommandProvider');
  }
  return context;
}

export function useCommandRegistration(commands: CommandOption[]) {
  const { registerCommand, unregisterCommand } = useCommandCenter();
  
  const commandsRef = useRef<CommandOption[]>([]);
  
  useEffect(() => {
    const currentCommands = [...commands];
    
    const removedCommands = commandsRef.current.filter(
      prevCmd => !currentCommands.some(cmd => cmd.id === prevCmd.id)
    );
    
    removedCommands.forEach(command => {
      unregisterCommand(command.id);
    });
    
    const newCommands = currentCommands.filter(
      cmd => !commandsRef.current.some(prevCmd => prevCmd.id === cmd.id)
    );
    
    newCommands.forEach(command => {
      registerCommand(command);
    });
    
    // Also update any commands that might have changed but kept the same ID
    const updatedCommands = currentCommands.filter(
      cmd => commandsRef.current.some(prevCmd => 
        prevCmd.id === cmd.id && 
        (prevCmd.name !== cmd.name || 
         prevCmd.description !== cmd.description ||
         JSON.stringify(prevCmd.keywords) !== JSON.stringify(cmd.keywords))
      )
    );
    
    updatedCommands.forEach(command => {
      registerCommand(command);
    });
    
    // Update our ref to the current commands array
    commandsRef.current = currentCommands;
    
  }, [commands, registerCommand, unregisterCommand]);
}

export function useCommandHeaderRegistration(header: ReactNode, type: CommandType) {
  const { registerHeader, unregisterHeader } = useCommandCenter();

  useEffect(() => {
    registerHeader(header, type);
  }, [header, registerHeader, type]);

  useEffect(() => {
    return () => {
      unregisterHeader(type);
    };
  }, [unregisterHeader, type]);
}

export function useModalHotkey(type: CommandType, hotkey: string) {
  const { openCommandType } = useCommandCenter();
  
  useHotkeys(hotkey, (event) => {
    event.preventDefault();
    openCommandType(type);
  }, { 
    enableOnFormTags: true,
    enableOnContentEditable: true
  });
}

================
File: hooks/useLoadingOperation.ts
================
import { useState, useCallback } from 'react';

interface OperationCallbacks<T> {
  onSuccess?: (result: T) => void | Promise<void>;
  onError?: (error: any) => void | Promise<void>;
}

/**
 * Hook for managing loading states during async operations
 * Ensures loading state persists until the entire operation completes
 */
export function useLoadingOperation<T>(
  operationFn: (...args: any[]) => Promise<T>,
  callbacks: OperationCallbacks<T> = {}
) {
  const [isLoading, setIsLoading] = useState(false);
  const [result, setResult] = useState<T | null>(null);
  const [error, setError] = useState<any>(null);
  
  const execute = useCallback(async (...args: any[]) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const operationResult = await operationFn(...args);
      setResult(operationResult);
      
      if (callbacks.onSuccess) {
        await callbacks.onSuccess(operationResult);
      }
      
      return operationResult;
    } catch (err) {
      setError(err);
      
      if (callbacks.onError) {
        await callbacks.onError(err);
      }
      
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [operationFn, callbacks]);
  
  return { 
    execute, 
    isLoading, 
    result, 
    error,
    reset: useCallback(() => {
      setResult(null);
      setError(null);
    }, [])
  };
}

================
File: hooks/useMentionSystem.tsx
================
import { useState, useRef, useCallback, useEffect } from 'react';
import { MentionItem, SelectedMentionItem } from '@/types/mention';
import { extractMentions, formatMention } from '@/lib/mention-utils';
import { providerRegistry } from '@/lib/providers/provider-registry';

// This hook encapsulates all the functionality for the mention system
export const useMentionSystem = () => {
  const [showMentionMenu, setShowMentionMenu] = useState(false);
  const [mentionSearch, setMentionSearch] = useState('');
  const [atIndex, setAtIndex] = useState(-1);
  const [mentionItems, setMentionItems] = useState<MentionItem[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [selectedItems, setSelectedItems] = useState<Record<string, SelectedMentionItem>>({});
  const [processingItems, setProcessingItems] = useState<Record<string, boolean>>({});
  const searchTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // Search for content across providers
  const searchContentProviders = useCallback(async (searchTerm: string) => {
    // Cancel any pending search
    if (searchTimeoutRef.current) {
      clearTimeout(searchTimeoutRef.current);
    }
    
    // Debounce search to prevent excessive API calls
    searchTimeoutRef.current = setTimeout(async () => {
      if (!searchTerm || searchTerm.length < 2) {
        setMentionItems([]);
        return;
      }
      
      setIsSearching(true);
      
      try {
        // Use the provider registry to search across all providers
        const results = await providerRegistry.searchAllProviders(searchTerm);
        setMentionItems(results);
      } catch (error) {
        console.error(`Error searching providers:`, error);
        setMentionItems([]);
      } finally {
        setIsSearching(false);
      }
    }, 200); // Debounce delay
  }, []);
  
  // Handle item selection
  const handleMentionSelect = useCallback(async (item: MentionItem, text: string, onTextUpdate: (newText: string) => void) => {
    // Check if this item is already mentioned in the text
    const existingMentions = extractMentions(text);
    const isDuplicate = existingMentions.some(mention => mention.id === item.id);
    
    if (isDuplicate) {
      console.log('Item already mentioned:', item.name);
      // Close the mention menu without adding a duplicate
      setShowMentionMenu(false);
      setMentionSearch('');
      setAtIndex(-1);
      return;
    }
    
    // Insert the selected item at the @ position first for better UI responsiveness
    if (atIndex >= 0) {
      const beforeAt = text.substring(0, atIndex);
      const afterSearch = text.substring(atIndex + mentionSearch.length + 1); // +1 for the @ symbol
      
      // Format as @[name](id)
      const mentionText = formatMention(item.name, item.id);
      
      const newValue = beforeAt + mentionText + afterSearch;
      
      // Update text via callback
      onTextUpdate(newValue);
    }
    
    // Close the mention menu
    setShowMentionMenu(false);
    setMentionSearch('');
    setAtIndex(-1);
    
    // Process the item to fetch its content
    const processItem = async () => {
      // Mark item as being processed
      setProcessingItems(prev => ({ ...prev, [item.id]: true }));
      
      try {
        // Find the appropriate provider for this item
        const provider = providerRegistry.getProviderForItem(item);
        
        if (!provider) {
          console.error(`No provider found for item type: ${item.type}`);
          return;
        }
        
        // Get content using the provider
        const content = await provider.getContent(item);
        
        // Store the content
        setSelectedItems(prev => ({
          ...prev,
          [item.id]: {
            path: item.path,
            content: content.content,
            type: content.type,
            metadata: content.metadata
          }
        }));
        
        console.log(`Content loaded for ${item.name}`);
      } catch (error) {
        console.error(`Error processing item ${item.name}:`, error);
      } finally {
        setProcessingItems(prev => {
          const newState = { ...prev };
          delete newState[item.id];
          return newState;
        });
      }
    };
    
    // Process the item
    setTimeout(processItem, 100);
  }, [atIndex, mentionSearch]);
  
  // Function to check for @ symbol and set up the mention menu
  const checkForMentionTrigger = useCallback((text: string, caretPosition: number) => {
    // Find the last @ symbol before the cursor
    const textBeforeCursor = text.substring(0, caretPosition);
    const lastAtIndex = textBeforeCursor.lastIndexOf('@');
    
    if (lastAtIndex !== -1 && (lastAtIndex === 0 || /\s/.test(text[lastAtIndex - 1]))) {
      // Extract search term after @
      const searchTerm = textBeforeCursor.substring(lastAtIndex + 1);
      
      // If we're within a word that started with @
      if (!searchTerm.includes(' ')) {
        setAtIndex(lastAtIndex);
        setMentionSearch(searchTerm);
        setShowMentionMenu(true);
        
        // Search for content if we have enough characters
        if (searchTerm) {
          searchContentProviders(searchTerm);
        }
        
        return true;
      }
    } else if (caretPosition > 0 && textBeforeCursor[caretPosition - 1] !== '@') {
      // Only hide menu if we're not right after typing @ and we moved away
      // This prevents flickering when @ is first typed
      const isAtJustTyped = textBeforeCursor.endsWith('@');
      
      if (!isAtJustTyped) {
        setShowMentionMenu(false);
      }
    }
    
    return false;
  }, [searchContentProviders]);
  
  // Function to remove a selected item
  const removeSelectedItem = useCallback((itemId: string, text: string, onTextUpdate: (newText: string) => void) => {
    // Remove mention from text
    const mentions = extractMentions(text);
    const mention = mentions.find(m => m.id === itemId);
    
    if (mention) {
      const newValue = text.substring(0, mention.index) + 
                       text.substring(mention.index + mention.length);
      
      // Update text via callback
      onTextUpdate(newValue);
      
      // Remove from selected items
      setSelectedItems(prev => {
        const newItems = {...prev};
        delete newItems[itemId];
        return newItems;
      });
    }
  }, []);
  
  // Clean up when unmounting
  useEffect(() => {
    return () => {
      if (searchTimeoutRef.current) {
        clearTimeout(searchTimeoutRef.current);
      }
    };
  }, []);
  
  return {
    showMentionMenu,
    setShowMentionMenu,
    mentionSearch,
    mentionItems,
    isSearching,
    selectedItems,
    processingItems,
    atIndex,
    handleMentionSelect,
    checkForMentionTrigger,
    removeSelectedItem
  };
};

================
File: hooks/useOperationToast.ts
================
import { useCallback } from 'react';
import { useToast } from './use-toast';
import { ActionResponse } from '@/app/actions/utils/responses';

/**
 * Hook for handling toast notifications from operation results
 * Provides a consistent way to show toast messages when operations complete
 */
export function useOperationToast() {
  const { toast } = useToast();
  
  const showToastFromResult = useCallback(<T>(result: ActionResponse<T>) => {
    if (result.toast) {
      const { title, description, variant } = result.toast;
      toast({
        title, 
        description,
        variant,
        // Use a longer duration to ensure user sees it
        duration: 3000
      });
    } else if (result.status === 'error' && result.error) {
      // Show error toast if we have an error but no toast defined
      toast({
        title: 'Error',
        description: result.error,
        variant: 'destructive',
        duration: 3000
      });
    }
  }, [toast]);
  
  // Helper for showing custom toast
  const showCustomToast = useCallback((
    title: string,
    description: string,
    variant: 'default' | 'success' | 'destructive' = 'default'
  ) => {
    toast({ 
      title, 
      description, 
      variant, 
      duration: 3000 
    });
  }, [toast]);
  
  return { 
    showToastFromResult,
    showCustomToast
  };
}

================
File: hooks/useRouteTransition.ts
================
import { useState, useCallback } from 'react';
import { useRouter } from 'next/navigation';

type OperationResult = {
  redirectTo?: string;
  [key: string]: any;
};

/**
 * Hook for managing loading states during routing transitions
 * Ensures the UI stays in loading state until navigation completes
 */
export function useRouteTransition() {
  const router = useRouter();
  const [isTransitioning, setIsTransitioning] = useState(false);
  
  const navigateWhenReady = useCallback(async (
    operation: () => Promise<OperationResult>,
    fallbackPath?: string
  ) => {
    setIsTransitioning(true);
    
    try {
      const result = await operation();
      
      if (result?.redirectTo) {
        await router.push(result.redirectTo);
      } else if (fallbackPath) {
        await router.push(fallbackPath);
      }
      
      return result;
    } catch (error) {
      console.error('Navigation error:', error);
      return null;
    } finally {
      // Use a small delay to ensure the UI doesn't flash
      setTimeout(() => setIsTransitioning(false), 300);
    }
  }, [router]);
  
  return { 
    navigateWhenReady, 
    isTransitioning 
  };
}

================
File: lib/providers/file-system-provider.tsx
================
import { ContentProvider, MentionContent, MentionItem } from '@/types/mention';
import { FileText, File, Folder, Code } from 'lucide-react';

export const getIconForFileType = (fileType: string): React.ReactNode => {
  switch (fileType?.toLowerCase()) {
    case 'md':
    case 'txt':
    case 'doc':
    case 'docx':
    case 'rtf':
    case 'odt':
      return <FileText className="h-4 w-4" />;
    case 'js':
    case 'ts':
    case 'jsx':
    case 'tsx':
    case 'py':
    case 'java':
    case 'c':
    case 'cpp':
    case 'go':
    case 'rb':
      return <Code className="h-4 w-4" />;
    default:
      return <File className="h-4 w-4" />;
  }
};

export const FileSystemProvider: ContentProvider = {
  id: 'filesystem',
  name: 'Local Files',
  icon: <FileText className="h-4 w-4" />,
  description: 'Access files from your local file system',
  isEnabled: true,
  requiresAuth: false,
  isAuthenticated: true,
  supportedTypes: ['file', 'folder'],
  
  search: async (query: string, options?: any): Promise<MentionItem[]> => {
    if (!window.electronAPI) {
      console.log("Electron API not available");
      return [];
    }
    
    try {
      const files = await window.electronAPI.searchFiles(query);
      
      return files.map((file: any) => ({
        id: `file-${file.path}`,
        type: 'file',
        name: file.name,
        description: file.path,
        icon: getIconForFileType(file.type),
        path: file.path,
        contentType: file.type
      }));
    } catch (error) {
      console.error("Error searching files:", error);
      return [];
    }
  },
  
  getContent: async (item: MentionItem): Promise<MentionContent> => {
    if (!window.electronAPI) {
      return { 
        content: "Mock file content for " + item.name, 
        type: "text" 
      };
    }
    
    try {
      if (!item.path) throw new Error("No file path provided");
      
      const result = await window.electronAPI.readFile(item.path);
      return {
        content: result.content,
        type: result.type,
        extension: result.extension
      };
    } catch (error) {
      console.error("Error reading file:", error);
      throw error;
    }
  }
};

================
File: lib/providers/message-provider.tsx
================
import { ContentProvider, MentionContent, MentionItem } from '@/types/mention';
import { MessageSquare } from 'lucide-react';
import { searchMessages } from '@/app/actions/conversations';

// Implementation that uses Supabase to search real messages
export const MessageProvider: ContentProvider = {
  id: 'message',
  name: 'Messages',
  icon: <MessageSquare className="h-4 w-4" />,
  description: 'Access previous messages from conversations',
  isEnabled: true,
  requiresAuth: true,
  isAuthenticated: true,
  supportedTypes: ['message', 'conversation'],
  
  // Search for messages
  search: async (query: string, options?: any): Promise<MentionItem[]> => {
    try {
      if (!query || query.length < 2) {
        return [];
      }
      
      // Default to search across all spaces if not specified
      const searchScope = options?.searchScope || 'all';
      const searchMode = options?.searchMode || 'text';
      const limit = options?.limit || 10;
      
      // Use the server action to search messages
      const response = await searchMessages(
        query, 
        searchScope, 
        searchMode,
        options?.conversationId,
        options?.spaceId,
        limit
      );
      
      if (!response.data?.results || !Array.isArray(response.data.results)) {
        return [];
      }
      
      // Format the search results as mention items
      return response.data.results.map(message => {
        // Truncate content for display
        const displayName = message.content.substring(0, 60) + (message.content.length > 60 ? '...' : '');
        
        return {
          id: `message-${message.id}`,
          type: 'message',
          name: displayName,
          description: `From: ${message.conversationTitle}`,
          icon: <MessageSquare className={`h-4 w-4 ${message.role === 'assistant' ? 'text-cyan-400' : 'text-white/70'}`} />,
          providerData: {
            messageId: message.id,
            conversationId: message.conversation_id,
            timestamp: message.created_at,
            fullContent: message.content,
            role: message.role,
            conversationTitle: message.conversationTitle
          }
        };
      });
    } catch (error) {
      console.error("Error searching messages:", error);
      return [];
    }
  },
  
  // Get content for a message
  getContent: async (item: MentionItem): Promise<MentionContent> => {
    try {
      // We already have the full message content from the search
      return {
        content: item.providerData?.fullContent || item.name,
        type: 'text',
        metadata: {
          conversationId: item.providerData?.conversationId,
          messageId: item.providerData?.messageId,
          timestamp: item.providerData?.timestamp,
          role: item.providerData?.role,
          conversationTitle: item.providerData?.conversationTitle
        }
      };
    } catch (error) {
      console.error("Error fetching message:", error);
      throw error;
    }
  }
};

================
File: lib/providers/provider-registry.tsx
================
import { ContentProvider, MentionItem, MentionItemType } from '@/types/mention';
import { FileSystemProvider } from './file-system-provider';
import { MessageProvider } from './message-provider';

// Registry of all available content providers
const providers: ContentProvider[] = [
  FileSystemProvider,
  MessageProvider,
  // Add more providers here as they are implemented
];

// Provider registry with helper methods
class ProviderRegistry {
  private providers: ContentProvider[];
  
  constructor(initialProviders: ContentProvider[]) {
    this.providers = initialProviders;
  }
  
  // Gets all registered providers
  getAllProviders(): ContentProvider[] {
    return this.providers;
  }
  
  // Gets enabled providers
  getEnabledProviders(): ContentProvider[] {
    return this.providers.filter(provider => provider.isEnabled);
  }
  
  // Gets a provider by ID
  getProviderById(id: string): ContentProvider | undefined {
    return this.providers.find(provider => provider.id === id);
  }
  
  // Gets providers that support a specific type
  getProvidersByType(type: MentionItemType): ContentProvider[] {
    return this.providers.filter(provider => 
      provider.isEnabled && provider.supportedTypes.includes(type)
    );
  }
  
  // Get the appropriate provider for a mention item
  getProviderForItem(item: MentionItem): ContentProvider | undefined {
    // Try to find provider by ID prefix first
    if (item.id.startsWith('file-') || item.id.startsWith('folder-')) {
      return this.getProviderById('filesystem');
    }
    
    if (item.id.startsWith('message-') || item.id.startsWith('conversation-')) {
      return this.getProviderById('message');
    }
    
    // Fallback to type-based lookup
    const typeProviders = this.getProvidersByType(item.type);
    return typeProviders.length > 0 ? typeProviders[0] : undefined;
  }
  
  // Register a new provider
  registerProvider(provider: ContentProvider): void {
    // Prevent duplicate registrations
    if (!this.providers.find(p => p.id === provider.id)) {
      this.providers.push(provider);
    }
  }
  
  // Execute a search across all enabled providers
  async searchAllProviders(query: string, options?: any): Promise<MentionItem[]> {
    if (!query || query.length < 2) return [];
    
    try {
      // Get all enabled providers
      const enabledProviders = this.getEnabledProviders();
      
      // Execute search on all providers in parallel
      const results = await Promise.all(
        enabledProviders.map(async provider => {
          try {
            return await provider.search(query, options);
          } catch (error) {
            console.error(`Error with provider ${provider.id}:`, error);
            return [];
          }
        })
      );
      
      // Flatten and return all results
      return results.flat();
    } catch (error) {
      console.error("Error searching providers:", error);
      return [];
    }
  }
}

// Export a singleton instance
export const providerRegistry = new ProviderRegistry(providers);

================
File: lib/mention-utils.ts
================
import { ExtractedMention, MentionItemType } from '@/types/mention';

// Extracts all content mentions from text (files, conversations, etc.)
export const extractMentions = (text: string): ExtractedMention[] => {
  if (!text) return [];
  
  // Regex to match all mentions in the format @[name](id)
  const regex = /@\[([^\]]+)\]\(([^)]+)\)(\s)?/g;
  let match;
  const mentions: ExtractedMention[] = [];
  
  // Find all mentions
  while ((match = regex.exec(text)) !== null) {
    const name = match[1];
    const id = match[2];
    const fullMatch = match[0];
    
    // Determine the type from the ID prefix
    const type = determineTypeFromId(id);
    
    if (type) {
      mentions.push({ 
        id, 
        name,
        index: match.index,
        length: fullMatch.length,
        text: fullMatch,
        type
      });
    }
  }
  
  // Sort by position in text
  return mentions.sort((a, b) => a.index - b.index);
};

// Helper to determine mention type from ID
export const determineTypeFromId = (id: string): MentionItemType | null => {
  if (id.startsWith('file-')) return 'file';
  if (id.startsWith('folder-')) return 'folder';
  if (id.startsWith('message-')) return 'message';
  if (id.startsWith('conversation-')) return 'conversation';
  return null;
};

// Formats a mention item into text format @[name](id)
export const formatMention = (name: string, id: string): string => {
  return `@[${name}](${id}) `;
};

export const getDisplayText = (text: string): string => {
  if (!text) return '';
  
  let displayText = String(text);
  const mentions = extractMentions(text);
  
  // Replace mentions from right to left to avoid position issues
  for (let i = mentions.length - 1; i >= 0; i--) {
    const mention = mentions[i];
    
    // Replace the mention with just the filename
    displayText = displayText.substring(0, mention.index) + 
                  mention.name + 
                  displayText.substring(mention.index + mention.length);
  }
  
  return displayText;
};

export const mapDisplayToInternalPosition = (displayPosition: number, internalText: string): number => {
  if (!internalText) return displayPosition;
  
  const mentions = extractMentions(internalText);
  if (mentions.length === 0) return displayPosition;
  
  let internalPosition = displayPosition;
  let offset = 0;
  
  // Create a mapping of display positions to internal positions
  for (const mention of mentions) {
    // The display position where this mention would be
    const displayStartPos = mention.index - offset;
    
    // If the cursor is after this mention in the display text,
    // adjust the internal position
    if (displayPosition > displayStartPos) {
      internalPosition += mention.length;
    }
    
    // Update the offset for future mentions
    offset += mention.length;
  }
  
  return internalPosition;
};

// Maps from internal position to display position
export const mapInternalToDisplayPosition = (internalPosition: number, internalText: string): number => {
  if (!internalText) return internalPosition;
  
  const mentions = extractMentions(internalText);
  if (mentions.length === 0) return internalPosition;
  
  let displayPosition = internalPosition;
  
  // For each mention before the internal position, adjust the display position
  for (const mention of mentions) {
    if (mention.index < internalPosition) {
      // If the cursor is within the mention, place it at the start
      if (internalPosition <= mention.index + mention.length) {
        displayPosition = mention.index;
        break;
      }
      // If the cursor is after the mention, subtract its length
      displayPosition -= mention.length;
    }
  }
  
  return displayPosition;
};

================
File: lib/utils.ts
================
import { redirect } from "next/navigation";
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Redirects to a specified path with an encoded message as a query parameter.
 * @param {('error' | 'success')} type - The type of message, either 'error' or 'success'.
 * @param {string} path - The path to redirect to.
 * @param {string} message - The message to be encoded and added as a query parameter.
 * @returns {never} This function doesn't return as it triggers a redirect.
 */
export function encodedRedirect(
  type: "error" | "success",
  path: string,
  message: string,
) {
  return redirect(`${path}?${type}=${encodeURIComponent(message)}`);
}

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: public/icons/providers/default.svg
================
<?xml version="1.0" encoding="UTF-8"?>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M12 2L2 7L12 12L22 7L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M2 17L12 22L22 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M2 12L12 17L22 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: public/icons/providers/groq.svg
================
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="152px" height="55.5px" viewBox="0 32.25 152 55.5" enable-background="new 0 32.25 152 55.5" xml:space="preserve">
 <title>
  groq_logo
 </title>
 <g id="Layer_2">
  <g id="Layer_1-2">
   <path d="M84.848,34.137c-9.798,0-17.769,7.971-17.769,17.77s7.971,17.769,17.769,17.769s17.77-7.971,17.77-17.769
			S94.645,34.137,84.848,34.137z M84.848,63.013c-6.124,0-11.106-4.983-11.106-11.106s4.982-11.106,11.106-11.106
			c6.124,0,11.106,4.982,11.106,11.106S90.973,63.013,84.848,63.013z">
   </path>
   <path d="M60.315,34.206c-0.607-0.068-1.217-0.104-1.827-0.108c-0.304,0-0.595,0.009-0.893,0.014s-0.594,0.033-0.891,0.051
			c-1.197,0.094-2.382,0.299-3.541,0.611c-2.329,0.629-4.574,1.723-6.515,3.277c-1.97,1.57-3.548,3.575-4.611,5.859
			c-0.53,1.138-0.921,2.336-1.165,3.567c-0.121,0.608-0.21,1.222-0.266,1.84c-0.02,0.307-0.055,0.615-0.059,0.921l-0.011,0.459
			l-0.005,0.23v0.19l0.015,5.951l0.015,5.951l0.041,5.95h6.664l0.042-5.95l0.015-5.952l0.015-5.951v-0.182l0.005-0.142l0.008-0.285
			c0-0.191,0.028-0.375,0.039-0.564c0.036-0.37,0.091-0.738,0.165-1.102c0.146-0.716,0.374-1.413,0.678-2.077
			c0.613-1.332,1.528-2.502,2.673-3.419c1.156-0.932,2.541-1.628,4.038-2.042c0.757-0.207,1.532-0.344,2.314-0.408
			c0.198-0.011,0.395-0.03,0.594-0.037c0.199-0.007,0.402-0.013,0.595-0.012c0.383,0,0.76,0.025,1.142,0.06
			c1.518,0.153,2.989,0.619,4.318,1.368l3.326-5.776C65.108,35.263,62.753,34.484,60.315,34.206z">
   </path>
   <path d="M17.77,34.048C7.971,34.048,0,42.019,0,51.817s7.971,17.77,17.77,17.77h5.844v-6.664H17.77
			c-6.124,0-11.106-4.982-11.106-11.106s4.982-11.106,11.106-11.106s11.132,4.982,11.132,11.106l0,0v16.365l0,0
			c0,6.084-4.954,11.039-11.023,11.103c-2.904-0.024-5.681-1.191-7.729-3.25l-4.712,4.712c3.266,3.283,7.691,5.151,12.321,5.201
			v0.003c0.04,0,0.08,0,0.119,0h0.125v-0.003c9.659-0.131,17.48-8.005,17.525-17.686l0.006-16.881
			C35.302,41.785,27.422,34.048,17.77,34.048z">
   </path>
   <path d="M124.083,34.137c-9.798,0-17.769,7.971-17.769,17.77s7.971,17.769,17.769,17.769h6.08v-6.663h-6.08
			c-6.124,0-11.106-4.983-11.106-11.106s4.982-11.106,11.106-11.106c5.799,0,10.572,4.468,11.062,10.143h-0.01v34.12h6.664V51.907
			l0,0C141.797,42.108,133.881,34.137,124.083,34.137z">
   </path>
   <polygon points="151.983,35.04 151.033,35.04 149.737,37.053 148.399,35.04 147.44,35.04 147.44,38.624 148.511,38.624 
			148.511,36.88 149.461,38.288 149.979,38.288 150.912,36.836 150.929,38.624 152,38.624 		">
   </polygon>
   <polygon points="143.519,35.896 144.685,35.896 144.685,38.624 145.86,38.624 145.86,35.896 147.034,35.896 147.034,35.04 
			143.519,35.04 		">
   </polygon>
  </g>
 </g>
</svg>

================
File: stores/space-store.ts
================
import { create } from 'zustand';
import { toast } from 'sonner';
import { 
  createSpace as createSpaceAction,
  updateSpace as updateSpaceAction,
  deleteSpace as deleteSpaceAction,
  getSpaces as getSpacesAction,
  getSpace as getSpaceAction,
  getSpaceData as getSpaceDataAction,
  setActiveSpace as setActiveSpaceAction,
  createConversation as createConversationAction,
  updateConversationTitle as updateConversationTitleAction,
  deleteConversation as deleteConversationAction
} from '@/app/actions';

export interface UIState {
  activeSpace: Space | null;
  conversations: Conversation[] | null;
  activeConversation: Conversation | null;
  messages: any[] | null;
  isLoading: boolean;
  loadingType: 'space' | 'conversation' | 'messages' | null;
  fileReferences: FileReference[];
}

export interface Space {
  id: string;
  name: string;
  description?: string;
  user_id: string;
  model: string;
  provider: string;
  color?: string;
  chat_mode?: string;
  chat_mode_config?: {
    tools: string[];
    mcp_servers?: string[];
    [key: string]: any;
  };
  created_at?: string;
  updated_at?: string;
  is_deleted?: boolean;
  [key: string]: any;
}

export interface Conversation {
  id: string;
  title?: string;
  space_id: string;
  created_at?: string;
  updated_at?: string;
  is_deleted?: boolean;
  [key: string]: any;
}

export interface SpaceData {
  space: Space | null;
  conversations: Conversation[] | null;
  messages: any[] | null;
  activeConversation: Conversation | null;
}

export interface InitialState {
  spaces?: Space[] | null;
  activeSpace?: Space | null;
  conversations?: Conversation[] | null;
  activeConversation?: Conversation | null;
  messages?: any[] | null;
  isLoading?: boolean;
  loadingType?: 'space' | 'conversation' | 'messages' | null;
}

export interface FileReference {
  id: string;
  path: string;
  name: string;
  content?: string;
  type?: string;
}

export interface SpaceStore {
  // State
  spaces: Space[] | null;
  activeSpace: Space | null;
  conversations: Conversation[] | null;
  activeConversation: Conversation | null;
  isLoading: boolean;
  loadingSpaceId: string | null;
  loadingConversationId: string | null;
  
  // UI State for rendering components without navigation
  uiState: UIState;
  
  // Single initialization function
  initializeState: (initialState: InitialState) => void;
  
  // UI State update methods
  updateUIState: (updates: Partial<UIState>) => void;
  
  // File reference methods
  addFileReference: (fileRef: FileReference) => void;
  removeFileReference: (id: string) => void;
  clearFileReferences: () => void;
  getFileReferences: () => FileReference[];
  
  // Space fetch operations
  fetchSpaces: () => Promise<Space[] | null>;
  fetchSpace: (id: string) => Promise<Space | null>;
  fetchSpaceData: (id: string) => Promise<SpaceData | null>;
  loadSpaceFullData: (spaceId: string) => Promise<SpaceData | null>;
  
  // Space local state operations
  setSpaces: (spaces: Space[] | null) => void;
  setActiveSpace: (space: Space | null) => void;
  updateLocalSpace: (id: string, updates: Partial<Space>) => void;
  addLocalSpace: (space: Space) => void;
  removeLocalSpace: (id: string) => void;
  
  // Space server operations with optimistic updates
  createSpace: (name: string, description: string, model: string, provider: string, color?: string) => Promise<Space | null>;
  updateSpace: (id: string, updates: Partial<Space>) => Promise<boolean>;
  deleteSpace: (id: string) => Promise<boolean>;
  setActiveSpaceOnServer: (id: string) => Promise<boolean>;
  
  // Conversation state operations
  setConversations: (conversations: Conversation[] | null) => void;
  setActiveConversation: (conversation: Conversation | null) => void;
  updateLocalConversation: (id: string, updates: Partial<Conversation>) => void;
  addLocalConversation: (conversation: Conversation) => void;
  removeLocalConversation: (id: string) => void;
  
  // Conversation server operations
  createConversation: (title?: string) => Promise<Conversation | null>;
  selectConversation: (conversationId: string) => Promise<boolean>;
  updateConversation: (conversationId: string, title: string) => Promise<boolean>;
  deleteConversation: (conversationId: string) => Promise<boolean>;
  
  // Loading state
  setLoading: (isLoading: boolean) => void;
  setLoadingSpaceId: (id: string | null) => void;
  setLoadingConversationId: (id: string | null) => void;
  
  // Navigation helper (keeping for backward compatibility)
  navigateToActiveConversation: (router: any) => void;
  
  // File references operations
  addFileReference: (fileRef: FileReference) => void;
  removeFileReference: (id: string) => void;
  clearFileReferences: () => void;
  getFileReferences: () => FileReference[];
}

export const useSpaceStore = create<SpaceStore>((set, get) => ({
  // State
  spaces: null,
  activeSpace: null,
  conversations: null,
  activeConversation: null,
  isLoading: false,
  loadingSpaceId: null,
  loadingConversationId: null,
  
  // Initialize UI state
  uiState: {
    activeSpace: null,
    conversations: null,
    activeConversation: null,
    messages: null,
    isLoading: false,
    loadingType: null,
    fileReferences: []
  },
  
  // Single consolidated initialization function
  initializeState: (initialState) => {
    console.log('[STORE] Initializing space store state with:', {
      hasSpaces: initialState.spaces?.length || 0,
      activeSpaceId: initialState.activeSpace?.id,
      conversationsCount: initialState.conversations?.length || 0,
      activeConversationId: initialState.activeConversation?.id,
      messagesCount: initialState.messages?.length || 0,
    });
    
    set({
      // Set main state
      spaces: initialState.spaces || null,
      activeSpace: initialState.activeSpace || null,
      conversations: initialState.conversations || null,
      activeConversation: initialState.activeConversation || null,
      isLoading: initialState.isLoading || false,
      
      // Also update UI state to match
      uiState: {
        activeSpace: initialState.activeSpace || null,
        conversations: initialState.conversations || null,
        activeConversation: initialState.activeConversation || null,
        messages: initialState.messages || null,
        isLoading: initialState.isLoading || false,
        loadingType: initialState.loadingType || null,
        fileReferences: []
      }
    });
    
    console.log('[STORE] Store initialization complete, state is now:', {
      spacesLoaded: get().spaces?.length || 0,
      activeSpaceLoaded: get().activeSpace?.id,
      conversationsLoaded: get().conversations?.length || 0,
      activeConversationLoaded: get().activeConversation?.id,
      messagesInUIState: get().uiState.messages?.length || 0
    });
  },
  
  // Update UI state method
  updateUIState: (updates) => {
    console.log('[STORE] Updating UI state with:', {
      updatesKeys: Object.keys(updates),
      hasMessages: 'messages' in updates,
      messagesCount: updates.messages?.length || 0,
      activeConversationChange: updates.activeConversation?.id !== get().uiState.activeConversation?.id,
      newActiveConversationId: updates.activeConversation?.id,
      currentActiveConversationId: get().uiState.activeConversation?.id
    });
    
    set((state) => ({
      uiState: {
        ...state.uiState,
        ...updates
      }
    }));
    
    // Log the state after update
    setTimeout(() => {
      console.log('[STORE] After UI state update, state is now:', {
        activeConversationId: get().uiState.activeConversation?.id,
        messagesInUIState: get().uiState.messages?.length || 0
      });
    }, 0);
  },
  
  // Fetch operations
  fetchSpaces: async () => {
    set({ isLoading: true });
    try {
      const response: any = await getSpacesAction();
      if (response && response.status === 'success' && response.data) {
        set({ spaces: response.data });
        return response.data;
      }
      return null;
    } catch (error) {
      console.error('Error fetching spaces:', error);
      return null;
    } finally {
      set({ isLoading: false });
    }
  },
  
  fetchSpace: async (id) => {
    set({ loadingSpaceId: id });
    try {
      const response: any = await getSpaceAction(id);
      if (response && response.status === 'success' && response.data) {
        // Update this space in our local spaces array
        set((state) => ({
          spaces: state.spaces?.map(space => 
            space.id === id ? response.data : space
          ) || [response.data]
        }));
        return response.data;
      }
      return null;
    } catch (error) {
      console.error('Error fetching space:', error);
      return null;
    } finally {
      set({ loadingSpaceId: null });
    }
  },
  
  fetchSpaceData: async (id) => {
    set({ 
      loadingSpaceId: id,
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'space'
      }
    });
    
    try {
      const response: any = await getSpaceDataAction(id);
      if (response && response.status === 'success' && response.data) {
        // If we get space data, also update the space in our store
        if (response.data.space) {
          set((state) => ({
            spaces: state.spaces?.map(space => 
              space.id === id ? response.data.space : space
            ) || [response.data.space]
          }));
        }
        
        // Update both standard and UI state
        set((state) => ({
          conversations: response.data.conversations,
          activeConversation: response.data.activeConversation,
          uiState: {
            ...state.uiState,
            activeSpace: response.data.space,
            conversations: response.data.conversations,
            activeConversation: response.data.activeConversation,
            messages: response.data.messages,
            isLoading: false,
            loadingType: null
          }
        }));
        
        return response.data;
      }
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      return null;
    } catch (error) {
      console.error('Error fetching space data:', error);
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      return null;
    } finally {
      set({ loadingSpaceId: null });
    }
  },
  
  loadSpaceFullData: async (spaceId) => {
    set((state) => ({
      uiState: {
        ...state.uiState,
        isLoading: true,
        loadingType: 'space'
      }
    }));
    
    try {
      const spaceDataResponse: any = await getSpaceDataAction(spaceId);
      
      if (spaceDataResponse) {
        const { space, conversations, activeConversation, messages } = spaceDataResponse;
        
        set((state) => ({
          activeSpace: space,
          spaces: state.spaces?.map(s => s.id === spaceId ? space : s) || [space],
          conversations: conversations,
          activeConversation: activeConversation,
          
          uiState: {
            activeSpace: space,
            conversations: conversations,
            activeConversation: activeConversation,
            messages: messages,
            isLoading: false,
            loadingType: null
          }
        }));
        
        await setActiveSpaceAction(spaceId);

        return spaceDataResponse;
      } else {
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));

        return null;
      }
    } catch (error) {
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
    }
  },
  
  // Space local state operations
  setSpaces: (spaces) => set({ spaces }),
  
  setActiveSpace: (space) => set({ 
    activeSpace: space,
    uiState: {
      ...get().uiState,
      activeSpace: space
    } 
  }),
  
  updateLocalSpace: (id, updates) => set((state) => {
    const updatedSpaces = state.spaces?.map(space => 
      space.id === id ? { ...space, ...updates } : space
    ) || null;
    
    const updatedActiveSpace = state.activeSpace?.id === id 
      ? { ...state.activeSpace, ...updates } 
      : state.activeSpace;
    
    const updatedUIState = {
      ...state.uiState,
      activeSpace: state.uiState.activeSpace?.id === id 
        ? { ...state.uiState.activeSpace, ...updates }
        : state.uiState.activeSpace
    };
    
    return {
      spaces: updatedSpaces,
      activeSpace: updatedActiveSpace,
      uiState: updatedUIState
    };
  }),
  
  addLocalSpace: (space) => set((state) => {
    console.log('Adding local space:', space.id);
    const newSpaces = state.spaces 
      ? [space, ...state.spaces] 
      : [space];
      
    return {
      spaces: newSpaces
    };
  }),
  
  removeLocalSpace: (id) => set((state) => ({
    spaces: state.spaces?.filter(space => space.id !== id) || null,
    activeSpace: state.activeSpace?.id === id 
      ? null 
      : state.activeSpace,
    uiState: {
      ...state.uiState,
      activeSpace: state.uiState.activeSpace?.id === id 
        ? null
        : state.uiState.activeSpace
    }
  })),
  
  createSpace: async (name, description, model, provider, color) => {
    set({ 
      isLoading: true,
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'space'
      }
    });
    
    try {
      const space: any = await createSpaceAction(name, description, model, provider, true, color);

      set((state) => ({
        spaces: state.spaces ? [space, ...state.spaces] : [space],
        activeSpace: space,
        uiState: {
          ...state.uiState,
          activeSpace: space,
          isLoading: false,
          loadingType: null
        }
      }));

      await get().loadSpaceFullData(space.id);

      return space;
    } catch (error) {
      console.error('Error creating space:', error);
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      toast.error('Creation Failed', {
        description: 'Could not create space'
      });
      return null;
    } finally {
      set({ isLoading: false });
    }
  },
  
  updateSpace: async (id, updates) => { 
    try {
      set({ 
        isLoading: true,
        uiState: {
          ...get().uiState,
          isLoading: true,
          loadingType: 'space'
        }
      });

      get().updateLocalSpace(id, updates);

      const space: any = await updateSpaceAction(id, updates);

      if (space) {
        get().updateLocalSpace(id, space);

        
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));

        return true;
      } else {
        const originalSpace = await get().fetchSpace(id);
        if (originalSpace) {
          get().updateLocalSpace(id, originalSpace);
        }
        
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));

        return false;
      }
    } catch (error) {
      const originalSpace = await get().fetchSpace(id);
      if (originalSpace) {
        get().updateLocalSpace(id, originalSpace);
      }
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      return false;
    } finally {
      set({ isLoading: false });
    }
  },
  
  deleteSpace: async (id) => {
    set({ 
      loadingSpaceId: id,
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'space'
      }
    });
    
    try {
      // Check if this is the active space
      const isActiveSpace = get().activeSpace?.id === id;
      const isUIActiveSpace = get().uiState.activeSpace?.id === id;
      
      // Get space before deletion for potential rollback
      const spaceToDelete = get().spaces?.find(space => space.id === id);
      
      // Update local state optimistically
      get().updateLocalSpace(id, { is_deleted: true });
      
      // Remove from UI immediately (optimistic)
      get().removeLocalSpace(id);
      
      try {
        // Call deleteSpaceAction which returns void or throws an error
        await deleteSpaceAction(id);
        
        // If we reach here, deletion was successful
        toast.success('Space Deleted', {
          description: 'Space has been removed'
        });
        
        // If this was the active space, find the next most recently updated space and set it as active
        if (isActiveSpace || isUIActiveSpace) {
          // Get all spaces, sorted by updated_at
          const remainingSpaces = get().spaces?.filter(space => !space.is_deleted) || [];
          
          if (remainingSpaces.length > 0) {
            // Sort spaces by updated_at (most recent first)
            const sortedSpaces = [...remainingSpaces].sort((a, b) => 
              new Date(b.updated_at || '').getTime() - new Date(a.updated_at || '').getTime()
            );
            
            // Get the most recently updated space
            const nextActiveSpace = sortedSpaces[0];
            
            if (nextActiveSpace) {
              // Load the full space data for the new active space
              await get().loadSpaceFullData(nextActiveSpace.id);
            } else {
              // No spaces left, clear UI state
              set({
                activeSpace: null,
                conversations: null,
                activeConversation: null,
                uiState: {
                  activeSpace: null,
                  conversations: [],
                  activeConversation: null,
                  messages: [],
                  isLoading: false,
                  loadingType: null
                }
              });
            }
          } else {
            // No spaces left, clear UI state
            set({
              activeSpace: null,
              conversations: null,
              activeConversation: null,
              uiState: {
                activeSpace: null,
                conversations: [],
                activeConversation: null,
                messages: [],
                isLoading: false,
                loadingType: null
              }
            });
          }
        } else {
          // Not the active space, just reset loading
          set((state) => ({
            uiState: {
              ...state.uiState,
              isLoading: false,
              loadingType: null
            }
          }));
        }
        
        return true;
      } catch (actionError) {
        // Handle error from the deleteSpaceAction
        console.error('Error deleting space:', actionError);
        
        // Restore the space on failure
        if (spaceToDelete) {
          get().addLocalSpace(spaceToDelete);
        }
        
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));
        
        toast.error('Deletion Failed', {
          description: 'Could not delete space'
        });
        return false;
      }
    } catch (error) {
      console.error('Error deleting space:', error);
      
      // Try to restore the space
      const spaceToRestore = get().spaces?.find(space => space.id === id);
      if (spaceToRestore) {
        get().addLocalSpace(spaceToRestore);
      }
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      toast.error('Deletion Failed', {
        description: 'Could not delete space'
      });
      return false;
    } finally {
      set({ loadingSpaceId: null });
    }
  },
  
  setActiveSpaceOnServer: async (id) => {
    set({ 
      loadingSpaceId: id,
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'space'
      }
    });
    
    try {
      // Load the full space data for UI rendering
      await get().loadSpaceFullData(id);
      
      return true;
    } catch (error) {
      console.error('Error setting active space:', error);
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      toast.error('Activation Failed', {
        description: 'Could not set active space'
      });
      return false;
    } finally {
      set({ loadingSpaceId: null });
    }
  },
  
  // Conversation state operations
  setConversations: (conversations) => set({ 
    conversations,
    uiState: {
      ...get().uiState,
      conversations
    }
  }),
  
  setActiveConversation: (conversation) => {
    console.log('[STORE] Setting active conversation:', {
      conversationId: conversation?.id,
      title: conversation?.title,
      messagesInUIState: get().uiState.messages?.length || 0
    });
    
    set({ 
      activeConversation: conversation,
      uiState: {
        ...get().uiState,
        activeConversation: conversation
      }
    });
  },
  
  updateLocalConversation: (id, updates) => set((state) => {
    const updatedConversations = state.conversations?.map(conversation => 
      conversation.id === id ? { ...conversation, ...updates } : conversation
    ) || null;
    
    const updatedActiveConversation = state.activeConversation?.id === id 
      ? { ...state.activeConversation, ...updates } 
      : state.activeConversation;
    
    return {
      conversations: updatedConversations,
      activeConversation: updatedActiveConversation,
      uiState: {
        ...state.uiState,
        conversations: updatedConversations,
        activeConversation: updatedActiveConversation
      }
    };
  }),
  
  addLocalConversation: (conversation) => set((state) => {
    const newConversations = state.conversations 
      ? [conversation, ...state.conversations] 
      : [conversation];
      
    return {
      conversations: newConversations,
      uiState: {
        ...state.uiState,
        conversations: newConversations
      }
    };
  }),
  
  removeLocalConversation: (id) => set((state) => {
    const filteredConversations = state.conversations?.filter(conv => conv.id !== id) || null;
    const updatedActiveConversation = state.activeConversation?.id === id 
      ? null 
      : state.activeConversation;
      
    return {
      conversations: filteredConversations,
      activeConversation: updatedActiveConversation,
      uiState: {
        ...state.uiState,
        conversations: filteredConversations,
        activeConversation: updatedActiveConversation
      }
    };
  }),
  
  // Conversation server operations with optimistic updates
  createConversation: async (title) => {
    const activeSpace = get().activeSpace;
    
    if (!activeSpace?.id) {
      toast.error('Cannot Create Conversation', {
        description: 'No active space selected'
      });
      return null;
    }
    
    set({ 
      loadingConversationId: 'creating',
      uiState: {
        ...get().uiState,
        isLoading: true,
        loadingType: 'conversation'
      }
    });
    
    try {
      // Call server action
      const newConversation = await createConversationAction(activeSpace.id, title);
      
      if (!newConversation) {
        toast.error('Creation Failed', {
          description: 'Could not create conversation'
        });
        
        set((state) => ({
          uiState: {
            ...state.uiState,
            isLoading: false,
            loadingType: null
          }
        }));
        
        return null;
      }
      
      // Update state with new conversation
      get().setActiveConversation(newConversation);
      get().addLocalConversation(newConversation);
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      toast.success('Conversation Created', {
        description: 'Start chatting now!'
      });
      
      return newConversation;
    } catch (error) {
      console.error('Failed to create conversation:', error);
      
      toast.error('Creation Failed', {
        description: 'Could not create conversation'
      });
      
      set((state) => ({
        uiState: {
          ...state.uiState,
          isLoading: false,
          loadingType: null
        }
      }));
      
      return null;
    } finally {
      set({ loadingConversationId: null });
    }
  },
  
  selectConversation: async (conversationId) => {
    console.log('[STORE] Selecting conversation:', {
      requestedId: conversationId,
      currentActiveId: get().activeConversation?.id,
      spaceId: get().activeSpace?.id
    });
    
    const activeSpace = get().activeSpace;
    
    if (!activeSpace?.id) {
      console.error('[STORE] Cannot select conversation, no active space');
      toast.error('Cannot Select Conversation', {
        description: 'No active space selected'
      });
      return false;
    }
    
    try {
      const conversation = get().conversations?.find(c => c.id === conversationId);
      
      if (!conversation) {
        console.warn('[STORE] Conversation not found:', conversationId);
        return false;
      }
      
      console.log('[STORE] Found conversation, setting as active:', {
        id: conversation.id,
        title: conversation.title
      });
      
      get().setActiveConversation(conversation);
      
      // Check if the uiState reflected the change
      setTimeout(() => {
        console.log('[STORE] After selection, state is now:', {
          activeConversationId: get().activeConversation?.id,
          uiStateActiveConversationId: get().uiState.activeConversation?.id,
          messagesInUIState: get().uiState.messages?.length || 0
        });
      }, 0);
      
      return true;
    } catch (error) {
      console.error('[STORE] Failed to select conversation:', error);
      toast.error('Selection Failed', {
        description: 'Could not select conversation'
      });
      return false;
    }
  },
  
  updateConversation: async (conversationId, title) => {
    const activeSpace = get().activeSpace;
    
    if (!activeSpace?.id) {
      toast.error('Cannot Update Conversation', {
        description: 'No active space selected'
      });
      return false;
    }
    
    set({ loadingConversationId: conversationId });
    
    try {
      get().updateLocalConversation(conversationId, { title });
      
      await updateConversationTitleAction(conversationId, title);
      
      return true;
    } catch (error) {
      console.error('Failed to update conversation:', error);
      
      return false;
    } finally {
      set({ loadingConversationId: null });
    }
  },
  
  deleteConversation: async (conversationId) => {
    const activeSpace = get().activeSpace;
    
    if (!activeSpace?.id) {
      toast.error('Cannot Delete Conversation', {
        description: 'No active space selected'
      });
      return false;
    }
    
    set({ loadingConversationId: conversationId });
    
    try {
      get().updateLocalConversation(conversationId, { is_deleted: true });
      
      if (get().activeConversation?.id === conversationId) {
        get().setActiveConversation(null);
      }
      
      await deleteConversationAction(conversationId);
      
      get().removeLocalConversation(conversationId);
      
      return true;
    } catch (error) {
      console.error('Failed to delete conversation:', error);
      
      get().updateLocalConversation(conversationId, { is_deleted: false });

      return false;
    } finally {
      set({ loadingConversationId: null });
    }
  },
  
  // Loading state
  setLoading: (isLoading) => set({ 
    isLoading,
    uiState: {
      ...get().uiState,
      isLoading
    }
  }),
  
  setLoadingSpaceId: (id) => set({ loadingSpaceId: id }),
  
  setLoadingConversationId: (id) => set({ loadingConversationId: id }),
  
  // Navigation helper (keeping for backward compatibility)
  navigateToActiveConversation: (router) => {
    const activeSpace = get().activeSpace;
    
    if (!activeSpace) {
      // If no active space, go to the home page
      router.push('/protected');
      return;
    }
    
    // Check if we have an active conversation in the space
    const activeConversation = get().activeConversation;
    const conversations = get().conversations;
    
    if (activeConversation && activeConversation.id) {
      // Navigate to the active conversation
      router.push(`/protected/spaces/${activeSpace.id}/conversations/${activeConversation.id}`);
    } else if (conversations && conversations.length > 0 && conversations[0] && conversations[0].id) {
      // Navigate to the first conversation
      router.push(`/protected/spaces/${activeSpace.id}/conversations/${conversations[0].id}`);
    } else {
      // No conversations, just go to the space
      router.push(`/protected/spaces/${activeSpace.id}/conversations`);
    }
  },
  
  // File references operations
  addFileReference: (fileRef) => {
    console.log('[STORE] Adding file reference', fileRef);
    set((state) => ({
      uiState: {
        ...state.uiState,
        fileReferences: [
          ...state.uiState.fileReferences.filter(ref => ref.id !== fileRef.id),
          fileRef
        ]
      }
    }));
  },
  
  removeFileReference: (id) => {
    console.log('[STORE] Removing file reference', id);
    set((state) => ({
      uiState: {
        ...state.uiState,
        fileReferences: state.uiState.fileReferences.filter(ref => ref.id !== id)
      }
    }));
  },
  
  clearFileReferences: () => {
    console.log('[STORE] Clearing all file references');
    set((state) => ({
      uiState: {
        ...state.uiState,
        fileReferences: []
      }
    }));
  },
  
  getFileReferences: () => {
    return get().uiState.fileReferences;
  },
}));

// Helper functions
export const getCurrentSpaces = () => useSpaceStore.getState().spaces || []; 
export const getActiveSpace = () => useSpaceStore.getState().activeSpace;
export const getCurrentConversations = () => useSpaceStore.getState().conversations || [];
export const getActiveConversation = () => useSpaceStore.getState().activeConversation;

================
File: supabase/migrations/20250204124800_create_complete_schema.sql
================
-- Create complete schema for Vinci app
-- Timestamp: 2025-02-04T12:48:00-07:00

-- USERS TABLE: Supabase Auth will manage user accounts.
-- No changes needed; we'll use `auth.users`.

-- SPACES TABLE: Metadata for spaces.
CREATE TABLE spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    -- Removed color column
    is_archived BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on spaces
ALTER TABLE spaces ENABLE ROW LEVEL SECURITY;

-- RLS policies for spaces
CREATE POLICY "Users can view their own spaces"
    ON spaces FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own spaces"
    ON spaces FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own spaces"
    ON spaces FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own spaces"
    ON spaces FOR DELETE
    USING (user_id = auth.uid());

-- CONVERSATIONS TABLE: Each conversation is part of a space.
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    title TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on conversations
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for conversations
CREATE POLICY "Users can view conversations in their spaces"
    ON conversations FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create conversations in their spaces"
    ON conversations FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    annotations JSONB DEFAULT '[]'::jsonb,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT valid_annotations CHECK (
        jsonb_typeof(annotations) = 'array'
    )
);

-- Enable RLS on messages
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- RLS policies for messages
CREATE POLICY "Users can view messages in their spaces"
    ON messages FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can insert messages in their spaces"
    ON messages FOR INSERT
    WITH CHECK (
        messages.user_id = auth.uid() AND
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

-- SPACE_USER_RELATIONS (Optional for shared spaces).
CREATE TABLE space_user_relations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces (id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    role TEXT CHECK (role IN ('owner', 'editor', 'viewer')) DEFAULT 'viewer',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space_user_relations
ALTER TABLE space_user_relations ENABLE ROW LEVEL SECURITY;

-- Add indexes for better query performance
CREATE INDEX idx_spaces_user_id ON spaces(user_id);
CREATE INDEX idx_conversations_space_id ON conversations(space_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_space_user_relations_space_id ON space_user_relations(space_id);
CREATE INDEX idx_space_user_relations_user_id ON space_user_relations(user_id);

-- Create a function to get the latest messages in a conversation
CREATE OR REPLACE FUNCTION get_conversation_messages(conversation_uuid UUID)
RETURNS TABLE (
    id UUID,
    user_id UUID,
    role TEXT,
    content TEXT,
    annotations JSONB,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        m.id,
        m.user_id,
        m.role,
        m.content,
        m.annotations,
        m.created_at,
        m.updated_at
    FROM messages m
    WHERE m.conversation_id = conversation_uuid
    AND m.is_deleted = FALSE
    ORDER BY m.created_at ASC;
END;
$$;

================
File: supabase/migrations/20250204124900_alter_space_table.sql
================
ALTER TABLE "spaces" ADD COLUMN model TEXT NOT NULL DEFAULT 'deepseek-r1-distill-llama-70b';
ALTER TABLE "spaces" ADD COLUMN provider text NOT NULL DEFAULT 'groq';

================
File: supabase/migrations/20250204125000_create_active_space_table.sql
================
CREATE TABLE active_spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id) 
);

================
File: supabase/migrations/20250204125100_update_rls_policies.sql
================


================
File: supabase/migrations/20250221221400_add_active_conversations.sql
================
-- Create active_conversations table
CREATE TABLE active_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id)
);

-- Enable RLS on active_conversations
ALTER TABLE active_conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for active_conversations
CREATE POLICY "Users can view their own active conversation"
    ON active_conversations FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can update their own active conversation"
    ON active_conversations FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own active conversation"
    ON active_conversations FOR DELETE
    USING (user_id = auth.uid());

================
File: supabase/migrations/20250223171800_add_notifications.sql
================
-- Create notifications schema
-- Timestamp: 2025-02-23T17:18:00-07:00

-- Create notification types enum
CREATE TYPE notification_type AS ENUM (
    'space_created',
    'space_deleted',
    'model_changed',
    'conversation_created',
    'conversation_deleted'
);

-- Create notifications table
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type notification_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on notifications
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- RLS policies for notifications
CREATE POLICY "Users can view their own notifications"
    ON notifications FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own notifications"
    ON notifications FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own notifications"
    ON notifications FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- Create index for faster notification lookups
CREATE INDEX notifications_user_id_idx ON notifications(user_id);
CREATE INDEX notifications_created_at_idx ON notifications(created_at DESC);

================
File: supabase/migrations/20250223171900_add_realtime_notifications.sql
================
-- Enable realtime for notifications
ALTER PUBLICATION supabase_realtime ADD TABLE notifications;

================
File: supabase/migrations/20250223175200_add_space_history.sql
================
-- Create space history schema
-- Timestamp: 2025-02-23T17:52:00-07:00

-- Create space action types enum
CREATE TYPE space_action_type AS ENUM (
    'created',
    'deleted',
    'updated',
    'model_changed',
    'conversation_added',
    'conversation_deleted'
);

-- Create space history table
CREATE TABLE space_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    action_type space_action_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space history
ALTER TABLE space_history ENABLE ROW LEVEL SECURITY;

-- RLS policies for space history
CREATE POLICY "Users can view history for spaces they have access to"
    ON space_history FOR SELECT
    USING (
        user_id = auth.uid() OR 
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create history entries for their spaces"
    ON space_history FOR INSERT
    WITH CHECK (
        user_id = auth.uid() AND
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

-- Create indexes for faster lookups
CREATE INDEX space_history_space_id_idx ON space_history(space_id);
CREATE INDEX space_history_user_id_idx ON space_history(user_id);
CREATE INDEX space_history_created_at_idx ON space_history(created_at DESC);

================
File: supabase/migrations/20250223175201_migration_add_is_deleted_to_conversations.sql
================
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS is_deleted BOOLEAN DEFAULT FALSE;
UPDATE conversations SET is_deleted = FALSE WHERE is_deleted IS NULL;

================
File: supabase/migrations/20250223175202_migration_add_performance_indexes.sql
================
-- Indexes to improve overall database performance

-- Index for spaces table by user_id
CREATE INDEX IF NOT EXISTS idx_spaces_user_id 
ON spaces (user_id);

-- Index for active_spaces table by user_id
CREATE INDEX IF NOT EXISTS idx_active_spaces_user_id 
ON active_spaces (user_id);

-- Composite index for conversations with multiple conditions
CREATE INDEX IF NOT EXISTS idx_conversations_space_id_is_deleted_updated_at 
ON conversations (space_id, is_deleted, updated_at DESC);

-- Index for messages by conversation_id
-- This will speed up the getMessages queries
CREATE INDEX IF NOT EXISTS idx_messages_conversation_id_created_at 
ON messages (conversation_id, created_at DESC);

-- Index for notifications by user_id and read status
-- This will optimize the getNotifications query
CREATE INDEX IF NOT EXISTS idx_notifications_user_id_read_created_at 
ON notifications (user_id, is_read, created_at DESC);

-- Index to optimize space data lookup
CREATE INDEX IF NOT EXISTS idx_spaces_id_updated_at 
ON spaces (id, updated_at DESC);

-- Index to optimize conversation lookup by id
CREATE INDEX IF NOT EXISTS idx_conversations_id 
ON conversations (id);

-- If you have message search functionality
CREATE INDEX IF NOT EXISTS idx_messages_content_gin 
ON messages USING gin(to_tsvector('english', content));

-- Partial index for active conversations only, reducing index size
CREATE INDEX IF NOT EXISTS idx_active_conversations 
ON conversations (space_id, updated_at DESC) 
WHERE is_deleted = false;

-- Index for faster joins between spaces and conversations
CREATE INDEX IF NOT EXISTS idx_conversations_space_id
ON conversations (space_id);

-- If you frequently query by user_id and conversation_id together
CREATE INDEX IF NOT EXISTS idx_messages_user_id_conversation_id
ON messages (user_id, conversation_id);

-- Purpose: Add performance indexes for spaces, conversations, messages, and other tables to optimize query performance

================
File: supabase/migrations/20250225012800_add_conversations_update_policy.sql
================
CREATE POLICY "Users can update conversations in their spaces"
    ON conversations FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

================
File: supabase/migrations/20250302143641_add_full_text_search.sql
================
-- Migration to add full-text search capabilities to the messages table
-- This enhances search performance using PostgreSQL's full-text search features

-- Add a search_vector column for storing precomputed tsvector data
ALTER TABLE messages ADD COLUMN search_vector tsvector;

-- Populate the search_vector column for existing messages
UPDATE messages SET search_vector = to_tsvector('english', content);

-- Create a GIN index for fast full-text search operations
-- GIN indexes are optimized for scenarios where values being indexed 
-- appear many times (like words in text documents)
CREATE INDEX messages_search_idx ON messages USING GIN (search_vector);

-- Create a function for automatically updating the search_vector column
CREATE OR REPLACE FUNCTION messages_search_vector_update() RETURNS trigger AS $$
BEGIN
  NEW.search_vector := to_tsvector('english', NEW.content);
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

-- Create a trigger to automatically update the search_vector on insert or update
CREATE TRIGGER messages_search_vector_update
BEFORE INSERT OR UPDATE ON messages
FOR EACH ROW
EXECUTE FUNCTION messages_search_vector_update();

-- Add useful search functions that leverage the search_vector

-- 1. Search within a single conversation
CREATE OR REPLACE FUNCTION search_conversation_messages(
  conversation_uuid UUID,
  search_query TEXT,
  result_limit INT DEFAULT 50
)
RETURNS TABLE (
  id UUID,
  conversation_id UUID,
  content TEXT,
  role TEXT,
  created_at TIMESTAMPTZ,
  ts_rank REAL
) AS $$
DECLARE
  modified_query TEXT;
BEGIN
  -- Process the query to enable partial word matching
  modified_query := string_agg(lexeme || ':*', ' & ') 
    FROM unnest(string_to_array(search_query, ' ')) AS lexeme
    WHERE length(lexeme) > 0;
  
  IF modified_query IS NULL OR modified_query = '' THEN
    -- Handle empty query or all stopwords
    modified_query := search_query || ':*';
  END IF;
  
  RETURN QUERY
  SELECT 
    m.id,
    m.conversation_id,
    m.content,
    m.role,
    m.created_at,
    ts_rank(m.search_vector, to_tsquery('english', modified_query)) AS rank
  FROM messages m
  WHERE 
    m.conversation_id = conversation_uuid
    AND m.is_deleted = false
    AND (
      -- Use the modified query with prefix matching
      m.search_vector @@ to_tsquery('english', modified_query)
      -- Also include direct content matching for more flexibility
      OR m.content ILIKE '%' || search_query || '%'
    )
  ORDER BY rank DESC
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. Search across all conversations in a space
CREATE OR REPLACE FUNCTION search_space_messages(
  space_uuid UUID,
  search_query TEXT,
  result_limit INT DEFAULT 50
)
RETURNS TABLE (
  id UUID,
  conversation_id UUID,
  content TEXT,
  role TEXT,
  created_at TIMESTAMPTZ,
  ts_rank REAL
) AS $$
DECLARE
  modified_query TEXT;
BEGIN
  -- Process the query to enable partial word matching
  modified_query := string_agg(lexeme || ':*', ' & ') 
    FROM unnest(string_to_array(search_query, ' ')) AS lexeme
    WHERE length(lexeme) > 0;
  
  IF modified_query IS NULL OR modified_query = '' THEN
    -- Handle empty query or all stopwords
    modified_query := search_query || ':*';
  END IF;
  
  RETURN QUERY
  SELECT 
    m.id,
    m.conversation_id,
    m.content,
    m.role,
    m.created_at,
    ts_rank(m.search_vector, to_tsquery('english', modified_query)) AS rank
  FROM messages m
  JOIN conversations c ON m.conversation_id = c.id
  WHERE 
    c.space_id = space_uuid
    AND m.is_deleted = false
    AND c.is_deleted = false
    AND (
      -- Use the modified query with prefix matching
      m.search_vector @@ to_tsquery('english', modified_query)
      -- Also include direct content matching for more flexibility
      OR m.content ILIKE '%' || search_query || '%'
    )
  ORDER BY rank DESC
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. Search across all spaces owned by the user
CREATE OR REPLACE FUNCTION search_all_user_messages(
  search_query TEXT,
  result_limit INT DEFAULT 50
)
RETURNS TABLE (
  id UUID,
  conversation_id UUID,
  content TEXT,
  role TEXT,
  created_at TIMESTAMPTZ,
  ts_rank REAL
) AS $$
DECLARE
  modified_query TEXT;
BEGIN
  -- Process the query to enable partial word matching
  modified_query := string_agg(lexeme || ':*', ' & ') 
    FROM unnest(string_to_array(search_query, ' ')) AS lexeme
    WHERE length(lexeme) > 0;
  
  IF modified_query IS NULL OR modified_query = '' THEN
    -- Handle empty query or all stopwords
    modified_query := search_query || ':*';
  END IF;
  
  RETURN QUERY
  SELECT 
    m.id,
    m.conversation_id,
    m.content,
    m.role,
    m.created_at,
    ts_rank(m.search_vector, to_tsquery('english', modified_query)) AS rank
  FROM messages m
  JOIN conversations c ON m.conversation_id = c.id
  JOIN spaces s ON c.space_id = s.id
  WHERE 
    s.user_id = auth.uid()
    AND m.is_deleted = false
    AND c.is_deleted = false
    AND s.is_deleted = false
    AND (
      -- Use the modified query with prefix matching
      m.search_vector @@ to_tsquery('english', modified_query)
      -- Also include direct content matching for more flexibility
      OR m.content ILIKE '%' || search_query || '%'
    )
  ORDER BY rank DESC
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions to the authenticated role for these functions
GRANT EXECUTE ON FUNCTION search_conversation_messages(UUID, TEXT, INT) TO authenticated;
GRANT EXECUTE ON FUNCTION search_space_messages(UUID, TEXT, INT) TO authenticated;
GRANT EXECUTE ON FUNCTION search_all_user_messages(TEXT, INT) TO authenticated;

-- Make sure RLS policies still apply to the search_vector column
GRANT ALL ON FUNCTION messages_search_vector_update() TO authenticated;
GRANT ALL ON FUNCTION messages_search_vector_update() TO service_role;

-- Migration completed

================
File: supabase/migrations/20250303000000_update_search_functions.sql
================
-- This migration updates the full-text search functions to support partial word matching
-- and improves multilingual search capabilities

-- First, update the trigger function to use a more language-agnostic tokenization
CREATE OR REPLACE FUNCTION messages_search_vector_update() RETURNS trigger AS $$
BEGIN
  -- Use 'simple' configuration instead of 'english' for better multilingual support
  -- 'simple' doesn't do stemming or stop word removal, so it works better for mixed languages
  NEW.search_vector := to_tsvector('simple', NEW.content);
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

-- Update existing message search_vectors using the simple configuration
UPDATE messages SET search_vector = to_tsvector('simple', content);

-- 1. Update the conversation messages search function
CREATE OR REPLACE FUNCTION search_conversation_messages(
  conversation_uuid UUID,
  search_query TEXT,
  result_limit INT DEFAULT 50
)
RETURNS TABLE (
  id UUID,
  conversation_id UUID,
  content TEXT,
  role TEXT,
  created_at TIMESTAMPTZ,
  ts_rank REAL
) AS $$
DECLARE
  modified_query TEXT;
BEGIN
  -- Process the query to enable partial word matching
  modified_query := string_agg(lexeme || ':*', ' & ') 
    FROM unnest(string_to_array(search_query, ' ')) AS lexeme
    WHERE length(lexeme) > 0;
  
  IF modified_query IS NULL OR modified_query = '' THEN
    -- Handle empty query or all stopwords
    modified_query := search_query || ':*';
  END IF;
  
  RETURN QUERY
  SELECT 
    m.id,
    m.conversation_id,
    m.content,
    m.role,
    m.created_at,
    ts_rank(m.search_vector, to_tsquery('simple', modified_query)) AS rank
  FROM messages m
  WHERE 
    m.conversation_id = conversation_uuid
    AND m.is_deleted = false
    AND (
      -- Use the modified query with prefix matching
      m.search_vector @@ to_tsquery('simple', modified_query)
      -- Also include direct content matching for more flexibility
      OR m.content ILIKE '%' || search_query || '%'
    )
  ORDER BY rank DESC
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. Update the space messages search function
CREATE OR REPLACE FUNCTION search_space_messages(
  space_uuid UUID,
  search_query TEXT,
  result_limit INT DEFAULT 50
)
RETURNS TABLE (
  id UUID,
  conversation_id UUID,
  content TEXT,
  role TEXT,
  created_at TIMESTAMPTZ,
  ts_rank REAL
) AS $$
DECLARE
  modified_query TEXT;
BEGIN
  -- Process the query to enable partial word matching
  modified_query := string_agg(lexeme || ':*', ' & ') 
    FROM unnest(string_to_array(search_query, ' ')) AS lexeme
    WHERE length(lexeme) > 0;
  
  IF modified_query IS NULL OR modified_query = '' THEN
    -- Handle empty query or all stopwords
    modified_query := search_query || ':*';
  END IF;
  
  RETURN QUERY
  SELECT 
    m.id,
    m.conversation_id,
    m.content,
    m.role,
    m.created_at,
    ts_rank(m.search_vector, to_tsquery('simple', modified_query)) AS rank
  FROM messages m
  JOIN conversations c ON m.conversation_id = c.id
  WHERE 
    c.space_id = space_uuid
    AND m.is_deleted = false
    AND c.is_deleted = false
    AND (
      -- Use the modified query with prefix matching
      m.search_vector @@ to_tsquery('simple', modified_query)
      -- Also include direct content matching for more flexibility
      OR m.content ILIKE '%' || search_query || '%'
    )
  ORDER BY rank DESC
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. Update the all user messages search function
CREATE OR REPLACE FUNCTION search_all_user_messages(
  search_query TEXT,
  result_limit INT DEFAULT 50
)
RETURNS TABLE (
  id UUID,
  conversation_id UUID,
  content TEXT,
  role TEXT,
  created_at TIMESTAMPTZ,
  ts_rank REAL
) AS $$
DECLARE
  modified_query TEXT;
BEGIN
  -- Process the query to enable partial word matching
  modified_query := string_agg(lexeme || ':*', ' & ') 
    FROM unnest(string_to_array(search_query, ' ')) AS lexeme
    WHERE length(lexeme) > 0;
  
  IF modified_query IS NULL OR modified_query = '' THEN
    -- Handle empty query or all stopwords
    modified_query := search_query || ':*';
  END IF;
  
  RETURN QUERY
  SELECT 
    m.id,
    m.conversation_id,
    m.content,
    m.role,
    m.created_at,
    ts_rank(m.search_vector, to_tsquery('simple', modified_query)) AS rank
  FROM messages m
  JOIN conversations c ON m.conversation_id = c.id
  JOIN spaces s ON c.space_id = s.id
  WHERE 
    s.user_id = auth.uid()
    AND m.is_deleted = false
    AND c.is_deleted = false
    AND s.is_deleted = false
    AND (
      -- Use the modified query with prefix matching
      m.search_vector @@ to_tsquery('simple', modified_query)
      -- Also include direct content matching for more flexibility
      OR m.content ILIKE '%' || search_query || '%'
    )
  ORDER BY rank DESC
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

================
File: supabase/migrations/20250303000100_add_chat_mode_to_spaces.sql
================
-- Migration to add chat_mode and chat_mode_config columns to spaces table
ALTER TABLE "spaces" ADD COLUMN chat_mode TEXT NOT NULL DEFAULT 'ask';
ALTER TABLE "spaces" ADD COLUMN chat_mode_config JSONB DEFAULT '{"tools": []}';

================
File: supabase/.gitignore
================
# Supabase
.branches
.temp
.env

================
File: supabase/config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "ui"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: supabase/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-25T01:28:27.566Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
migrations/
  20250204124800_create_complete_schema.sql
  20250204124900_alter_space_table.sql
  20250204125000_create_active_space_table.sql
  20250204125100_update_rls_policies.sql
  20250221221400_add_active_conversations.sql
  20250223171800_add_notifications.sql
  20250223171900_add_realtime_notifications.sql
  20250223175200_add_space_history.sql
  20250223175201_migration_add_is_deleted_to_conversations.sql
.gitignore
config.toml

================================================================
Files
================================================================

================
File: migrations/20250204124800_create_complete_schema.sql
================
-- Create complete schema for Vinci app
-- Timestamp: 2025-02-04T12:48:00-07:00

-- USERS TABLE: Supabase Auth will manage user accounts.
-- No changes needed; we'll use `auth.users`.

-- SPACES TABLE: Metadata for spaces.
CREATE TABLE spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    -- Removed color column
    is_archived BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on spaces
ALTER TABLE spaces ENABLE ROW LEVEL SECURITY;

-- RLS policies for spaces
CREATE POLICY "Users can view their own spaces"
    ON spaces FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own spaces"
    ON spaces FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own spaces"
    ON spaces FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own spaces"
    ON spaces FOR DELETE
    USING (user_id = auth.uid());

-- CONVERSATIONS TABLE: Each conversation is part of a space.
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    title TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on conversations
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for conversations
CREATE POLICY "Users can view conversations in their spaces"
    ON conversations FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create conversations in their spaces"
    ON conversations FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    annotations JSONB DEFAULT '[]'::jsonb,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT valid_annotations CHECK (
        jsonb_typeof(annotations) = 'array'
    )
);

-- Enable RLS on messages
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- RLS policies for messages
CREATE POLICY "Users can view messages in their spaces"
    ON messages FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can insert messages in their spaces"
    ON messages FOR INSERT
    WITH CHECK (
        messages.user_id = auth.uid() AND
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

-- SPACE_USER_RELATIONS (Optional for shared spaces).
CREATE TABLE space_user_relations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces (id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    role TEXT CHECK (role IN ('owner', 'editor', 'viewer')) DEFAULT 'viewer',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space_user_relations
ALTER TABLE space_user_relations ENABLE ROW LEVEL SECURITY;

-- Add indexes for better query performance
CREATE INDEX idx_spaces_user_id ON spaces(user_id);
CREATE INDEX idx_conversations_space_id ON conversations(space_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_space_user_relations_space_id ON space_user_relations(space_id);
CREATE INDEX idx_space_user_relations_user_id ON space_user_relations(user_id);

-- Create a function to get the latest messages in a conversation
CREATE OR REPLACE FUNCTION get_conversation_messages(conversation_uuid UUID)
RETURNS TABLE (
    id UUID,
    user_id UUID,
    role TEXT,
    content TEXT,
    annotations JSONB,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        m.id,
        m.user_id,
        m.role,
        m.content,
        m.annotations,
        m.created_at,
        m.updated_at
    FROM messages m
    WHERE m.conversation_id = conversation_uuid
    AND m.is_deleted = FALSE
    ORDER BY m.created_at ASC;
END;
$$;

================
File: migrations/20250204124900_alter_space_table.sql
================
ALTER TABLE "spaces" ADD COLUMN model TEXT NOT NULL DEFAULT 'deepseek-r1-distill-llama-70b';
ALTER TABLE "spaces" ADD COLUMN provider text NOT NULL DEFAULT 'groq';

================
File: migrations/20250204125000_create_active_space_table.sql
================
CREATE TABLE active_spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id) 
);

================
File: migrations/20250204125100_update_rls_policies.sql
================


================
File: migrations/20250221221400_add_active_conversations.sql
================
-- Create active_conversations table
CREATE TABLE active_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id)
);

-- Enable RLS on active_conversations
ALTER TABLE active_conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for active_conversations
CREATE POLICY "Users can view their own active conversation"
    ON active_conversations FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can update their own active conversation"
    ON active_conversations FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own active conversation"
    ON active_conversations FOR DELETE
    USING (user_id = auth.uid());

================
File: migrations/20250223171800_add_notifications.sql
================
-- Create notifications schema
-- Timestamp: 2025-02-23T17:18:00-07:00

-- Create notification types enum
CREATE TYPE notification_type AS ENUM (
    'space_created',
    'space_deleted',
    'model_changed',
    'conversation_created',
    'conversation_deleted'
);

-- Create notifications table
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type notification_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on notifications
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- RLS policies for notifications
CREATE POLICY "Users can view their own notifications"
    ON notifications FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own notifications"
    ON notifications FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own notifications"
    ON notifications FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- Create index for faster notification lookups
CREATE INDEX notifications_user_id_idx ON notifications(user_id);
CREATE INDEX notifications_created_at_idx ON notifications(created_at DESC);

================
File: migrations/20250223171900_add_realtime_notifications.sql
================
-- Enable realtime for notifications
ALTER PUBLICATION supabase_realtime ADD TABLE notifications;

================
File: migrations/20250223175200_add_space_history.sql
================
-- Create space history schema
-- Timestamp: 2025-02-23T17:52:00-07:00

-- Create space action types enum
CREATE TYPE space_action_type AS ENUM (
    'created',
    'deleted',
    'updated',
    'model_changed',
    'conversation_added',
    'conversation_deleted'
);

-- Create space history table
CREATE TABLE space_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    action_type space_action_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space history
ALTER TABLE space_history ENABLE ROW LEVEL SECURITY;

-- RLS policies for space history
CREATE POLICY "Users can view history for spaces they have access to"
    ON space_history FOR SELECT
    USING (
        user_id = auth.uid() OR 
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create history entries for their spaces"
    ON space_history FOR INSERT
    WITH CHECK (
        user_id = auth.uid() AND
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

-- Create indexes for faster lookups
CREATE INDEX space_history_space_id_idx ON space_history(space_id);
CREATE INDEX space_history_user_id_idx ON space_history(user_id);
CREATE INDEX space_history_created_at_idx ON space_history(created_at DESC);

================
File: migrations/20250223175201_migration_add_is_deleted_to_conversations.sql
================
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS is_deleted BOOLEAN DEFAULT FALSE;
UPDATE conversations SET is_deleted = FALSE WHERE is_deleted IS NULL;

================
File: .gitignore
================
# Supabase
.branches
.temp
.env

================
File: config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "ui"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: types/electron.d.ts
================
/**
 * Type definitions for Electron API
 */

interface Window {
  electronAPI?: {
    searchFiles: (searchTerm: string) => Promise<Array<{
      path: string;
      name: string;
      type: string;
      size?: number;
      modified?: string;
    }>>;
    
    readFile: (filePath: string) => Promise<{
      content: string;
      type: 'text' | 'binary';
      extension?: string;
    }>;
  };
}

================
File: types/index.ts
================
export interface Space {
  id: string;
  name: string;
  description?: string;
  model?: string;
  provider?: string;
  is_archived: boolean;
  is_deleted: boolean;
  created_at: string;
  updated_at: string;
  user_id: string;
  color?: string;
  isActive?: boolean;
}

export interface Conversation {
  id: string;
  space_id: string;
  title?: string;
  created_at?: string;
  updated_at?: string;
  is_deleted?: boolean;
  messageCount?: number;
  lastMessage?: string;
}

// Define the SimilarMessage type for global use
export interface SimilarMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  score: number;
  conversationId?: string;
  metadata?: Record<string, any>;
}

// Re-export mention types
export * from './mention';

// Add to global Window interface
declare global {
  interface Window {
    openSimilarMessages?: (messages: SimilarMessage[]) => void;
  }
}

================
File: types/mention.ts
================
/**
 * Types related to the content mention system
 */

// Types of items that can be mentioned
export type MentionItemType = 
  | 'file'      // Local files
  | 'folder'    // Local folders 
  | 'message'   // Individual messages
  | 'conversation'; // Entire conversations

// Generic interface for mention items with common properties
export interface MentionItem {
  id: string;                // Unique identifier
  type: MentionItemType;     // Type of the mention item
  name: string;              // Display name
  description?: string;      // Optional description
  icon: React.ReactNode;     // Icon to display
  
  // Provider-specific properties
  providerData?: any;        // Generic container for provider-specific data
  
  // Common optional properties
  path?: string;             // Path or location (files, folders, etc.)
  contentType?: string;      // MIME type or format
  size?: number;             // Size in bytes if applicable
  created?: Date | string;   // Creation time
  modified?: Date | string;  // Last modified time
  author?: string;           // Author or creator
  url?: string;              // URL if applicable
}

// Mention content interface - what's returned when fetching content
export interface MentionContent {
  content: string;
  type: 'text' | 'binary' | 'json';
  extension?: string;
  metadata?: Record<string, any>;
}

// Generic content provider interface
export interface ContentProvider {
  id: string;                // Unique provider ID
  name: string;              // Display name
  icon: React.ReactNode;     // Icon for this provider
  description: string;       // Description of the provider
  isEnabled: boolean;        // Whether this provider is currently enabled
  requiresAuth: boolean;     // Whether authentication is required
  isAuthenticated: boolean;  // Authentication status
  supportedTypes: MentionItemType[]; // Types this provider can handle
  
  // Search method - returns promise of MentionItems
  search: (query: string, options?: any) => Promise<MentionItem[]>;
  
  // Get content method - returns promise with content
  getContent: (item: MentionItem) => Promise<MentionContent>;
  
  // Optional methods
  authenticate?: () => Promise<boolean>;
  refresh?: () => Promise<void>;
  configure?: (config: any) => Promise<void>;
}

// Extract mention interface - used for parsing mentions in text
export interface ExtractedMention {
  id: string;
  name: string;
  index: number;
  length: number;
  text: string;
  type: MentionItemType;
}

// Interface for the selected mention items
export interface SelectedMentionItem {
  path?: string;
  content: string;
  type: string;
  metadata?: Record<string, any>;
}

================
File: utils/supabase/check-env-vars.ts
================
// This check can be removed
// it is just for tutorial purposes

export const hasEnvVars =
  process.env.NEXT_PUBLIC_SUPABASE_URL &&
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

================
File: utils/supabase/client.ts
================
import { createBrowserClient } from "@supabase/ssr";

export const createClient = () =>
  createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );

================
File: utils/supabase/middleware.ts
================
import { createServerClient } from "@supabase/ssr";
import { type NextRequest, NextResponse } from "next/server";

export const updateSession = async (request: NextRequest) => {
  // This `try/catch` block is only here for the interactive tutorial.
  // Feel free to remove once you have Supabase connected.
  try {
    // Create an unmodified response
    let response = NextResponse.next({
      request: {
        headers: request.headers,
      },
    });

    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return request.cookies.getAll();
          },
          setAll(cookiesToSet) {
            cookiesToSet.forEach(({ name, value }) =>
              request.cookies.set(name, value),
            );
            response = NextResponse.next({
              request,
            });
            cookiesToSet.forEach(({ name, value, options }) =>
              response.cookies.set(name, value, options),
            );
          },
        },
      },
    );

    // This will refresh session if expired - required for Server Components
    // https://supabase.com/docs/guides/auth/server-side/nextjs
    const user = await supabase.auth.getUser();

    // protected routes
    if (request.nextUrl.pathname.startsWith("/protected") && user.error) {
      return NextResponse.redirect(new URL("/sign-in", request.url));
    }

    if (request.nextUrl.pathname === "/" && !user.error) {
      return NextResponse.redirect(new URL("/protected", request.url));
    }

    return response;
  } catch (e) {
    // If you are here, a Supabase client could not be created!
    // This is likely because you have not set up environment variables.
    // Check out http://localhost:3000 for Next Steps.
    return NextResponse.next({
      request: {
        headers: request.headers,
      },
    });
  }
};

================
File: utils/supabase/server.ts
================
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export const createClient = async () => {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => {
              cookieStore.set(name, value, options);
            });
          } catch (error) {
            // The `set` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    },
  );
};

================
File: utils/file-sync.ts
================
import { OpenAIEmbeddings } from '@langchain/openai';
import { Pinecone } from '@pinecone-database/pinecone';
import { debounce } from 'lodash';
import { createHash } from 'crypto';
import * as browserPolyfills from './browser-polyfills';

// Conditionally import Electron-specific modules
let fs: any = null;
let path: any = null;
let app: any = null;
let ipcMain: any = null;
let ipcRenderer: any = null;
let chokidar: any = null;

// Check if we're in a browser or Node.js environment
const isElectron = typeof window !== 'undefined' && window.process && window.process.type === 'renderer';
const isServer = typeof window === 'undefined';
const isBrowser = typeof window !== 'undefined' && !isElectron;

// Only import Node.js modules in Node.js environment
if ((isElectron || isServer) && !isBrowser) {
  // Use dynamic imports to prevent bundling these modules in browser builds
  import('electron').then((electron) => {
    ipcMain = electron.ipcMain;
    ipcRenderer = electron.ipcRenderer;
    app = electron.app;
  }).catch(e => {
    console.warn('Failed to import electron:', e);
  });

  if (isServer) {
    // Server-side imports
    import('fs').then((fsModule) => {
      fs = fsModule;
    }).catch(e => {
      console.warn('Failed to import fs:', e);
    });

    import('path').then((pathModule) => {
      path = pathModule;
    }).catch(e => {
      console.warn('Failed to import path:', e);
    });

    import('chokidar').then((chokidarModule) => {
      chokidar = chokidarModule;
    }).catch(e => {
      console.warn('Failed to import chokidar:', e);
    });
  }
} else if (isBrowser) {
  // In browser, use our polyfills
  console.log('Using browser polyfills for Node.js modules');
  fs = browserPolyfills.fs;
  path = browserPolyfills.path;
}

// Configuration
const supportedExtensions = ['.js', '.ts', '.tsx', '.jsx', '.md', '.txt', '.json', '.py', '.html', '.css', '.scss'];
const ignoredDirectories = ['node_modules', '.git', 'dist', 'build', 'out'];
const MAX_FILE_SIZE = 1024 * 1024; // 1MB

// Initialize Pinecone and embeddings lazily to avoid issues in different environments
let pineconeInstance: any = null;
let pineconeIndex: any = null;
let embeddingsInstance: any = null;

function getPinecone() {
  if (!pineconeInstance) {
    pineconeInstance = new Pinecone();
  }
  return pineconeInstance;
}

function getPineconeIndex() {
  if (!pineconeIndex) {
    const pinecone = getPinecone();
    const indexName = process.env.NEXT_PUBLIC_PINECONE_INDEX || process.env.PINECONE_INDEX;
    if (!indexName) {
      console.error('Pinecone index name not provided');
      return null;
    }
    pineconeIndex = pinecone.Index(indexName);
  }
  return pineconeIndex;
}

function getEmbeddings() {
  if (!embeddingsInstance) {
    const apiKey = process.env.NEXT_PUBLIC_OPENAI_API_KEY || process.env.OPENAI_API_KEY;
    if (!apiKey) {
      console.error('OpenAI API key not provided');
      return null;
    }
    embeddingsInstance = new OpenAIEmbeddings({
      openAIApiKey: apiKey,
      modelName: 'text-embedding-3-large',
    });
  }
  return embeddingsInstance;
}

// File metadata interface
interface FileMetadata {
  id: string;
  path: string;
  name: string;
  extension: string;
  lastModified: number;
  contentHash: string;
  size: number;
  userId?: string;     // To associate files with specific users
  deviceId?: string;   // To track which device the file came from
}

// File cache to avoid unnecessary processing
interface FileCache {
  [filePath: string]: {
    metadata: FileMetadata;
    contentHash: string;
    embeddingId: string;
  };
}

// For local storage between sessions
const fileCache: FileCache = {};

// Helpers
async function getFileHash(filePath: string, content?: string): Promise<string> {
  try {
    // If content is provided, use it; otherwise, read from the file
    const fileContent = content || (fs ? await fs.readFile(filePath, 'utf8') : '');
    
    // Use crypto in Node.js or Web Crypto API in browser
    if (typeof window === 'undefined' && require('crypto')) {
      return require('crypto').createHash('md5').update(fileContent).digest('hex');
    } else if (typeof window !== 'undefined' && window.crypto) {
      const encoder = new TextEncoder();
      const data = encoder.encode(fileContent);
      const hashBuffer = await window.crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    
    throw new Error('No crypto module available');
  } catch (error) {
    console.error('Error generating file hash:', error);
    // Return a timestamp-based hash as fallback
    return `fallback-${Date.now()}-${Math.random().toString(36).substring(2)}`;
  }
}

async function shouldProcessFile(filePath: string): Promise<boolean> {
  if (!fs || !path) {
    return false;
  }
  
  try {
    const stats = await fs.stat(filePath);
    
    // Skip if too large
    if (stats.size > MAX_FILE_SIZE) return false;
    
    // Check extension
    const ext = path.extname(filePath).toLowerCase();
    if (!supportedExtensions.includes(ext)) return false;
    
    // Check if directory should be ignored
    const relativePath = filePath.split(path.sep);
    if (relativePath.some(part => ignoredDirectories.includes(part))) return false;
    
    return true;
  } catch (error) {
    console.error(`Error checking file ${filePath}:`, error);
    return false;
  }
}

async function embedFileContent(filePath: string, metadata: FileMetadata, content?: string): Promise<string> {
  try {
    // Ensure file content is available
    const fileContent = content || (fs ? await fs.readFile(filePath, 'utf8') : '');
    if (!fileContent) {
      throw new Error('No content provided for embedding');
    }
    
    const embeddings = getEmbeddings();
    if (!embeddings) {
      throw new Error('Embeddings not available');
    }
    
    // Create embedding for file content
    const embedding = await embeddings.embedDocuments([fileContent]);
    
    // Generate a unique ID for this embedding
    const embeddingId = `${metadata.id}-${Date.now()}`;
    
    const index = getPineconeIndex();
    if (!index) {
      throw new Error('Pinecone index not available');
    }
    
    // Upsert the embedding into Pinecone
    await index.upsert([
      {
        id: embeddingId,
        values: embedding[0],
        metadata: {
          path: metadata.path,
          name: metadata.name,
          extension: metadata.extension,
          contentHash: metadata.contentHash,
          lastModified: metadata.lastModified,
          size: metadata.size,
          userId: metadata.userId || '',  // Provide empty string as fallback
          deviceId: metadata.deviceId || '',  // Provide empty string as fallback
        },
      },
    ]);
    
    return embeddingId;
  } catch (error) {
    console.error('Error embedding file content:', error);
    throw error;
  }
}

// Web API for file upload and processing
class WebFileSync {
  private userId: string | null = null;
  private deviceId: string;
  
  constructor() {
    this.deviceId = this.getOrCreateDeviceId();
  }
  
  private getOrCreateDeviceId(): string {
    if (typeof window === 'undefined') return '';
    
    // Try to get the device ID from localStorage
    let deviceId = localStorage.getItem('device_id');
    if (!deviceId) {
      // Generate a random device ID
      deviceId = `web-${Math.random().toString(36).substring(2, 15)}`;
      localStorage.setItem('device_id', deviceId);
    }
    return deviceId;
  }
  
  setUserId(userId: string) {
    this.userId = userId;
  }
  
  async uploadFile(file: File): Promise<any> {
    if (!file) {
      throw new Error('No file provided');
    }

    try {
      // Read the file
      const content = await this.readFileAsText(file);
      
      // Create a hash of the content
      const encoder = new TextEncoder();
      const data = encoder.encode(content);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const contentHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      
      // Create metadata
      const metadata = {
        id: `${file.name}-${Date.now()}`,
        path: file.name,
        name: file.name.split('/').pop() || file.name,
        extension: file.name.split('.').pop() || '',
        lastModified: file.lastModified,
        contentHash,
        size: file.size,
        userId: this.userId || undefined,
        deviceId: this.deviceId,
      };
      
      // Embed the file content
      const embeddingId = await embedFileContent(file.name, metadata, content);
      
      return {
        metadata,
        embeddingId,
      };
    } catch (error) {
      console.error('Error uploading file:', error);
      throw error;
    }
  }
  
  private readFileAsText(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (event) => {
        if (event.target?.result) {
          resolve(event.target.result as string);
        } else {
          reject(new Error('Failed to read file'));
        }
      };
      reader.onerror = (error) => reject(error);
      reader.readAsText(file);
    });
  }
  
  async searchFiles(query: string, limit = 10): Promise<any[]> {
    try {
      const embeddings = getEmbeddings();
      if (!embeddings) {
        throw new Error('Embeddings not available');
      }
      
      const queryEmbedding = await embeddings.embedQuery(query);
      
      const index = getPineconeIndex();
      if (!index) {
        throw new Error('Pinecone index not available');
      }
      
      const results = await index.query({
        vector: queryEmbedding,
        topK: limit,
        includeMetadata: true,
      });
      
      return results.matches || [];
    } catch (error) {
      console.error('Error searching files:', error);
      return [];
    }
  }
}

// Main sync engine class for Electron
export class FileSyncEngine {
  private watcher: any;
  private syncInProgress = false;
  private lastSyncTime = 0;
  private userId: string | null = null;
  private deviceId: string;
  private cache: FileCache = {};
  
  constructor(private rootDirectory: string) {
    // We need to check if we're in Electron
    if (!isElectron && !isServer) {
      throw new Error('FileSyncEngine can only be used in Electron environment');
    }
    
    // Generate device ID
    this.deviceId = `device_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
  }
  
  // Set user ID for scoping files
  setUserId(userId: string) {
    this.userId = userId;
  }
  
  // Initialize the sync engine
  async initialize() {
    if (!fs || !path || !app || !chokidar) {
      console.error('Required Electron modules are not available');
      return;
    }
    
    console.log(`Initializing file sync engine for ${this.rootDirectory}`);
    
    // Load cache from storage
    this.loadCache();
    
    // Initial indexing
    await this.performFullSync();
    
    // Set up file watcher
    this.setupWatcher();
    
    // Set up IPC handlers
    this.setupIPC();
  }
  
  private async loadCache() {
    if (!fs || !path || !app) return;
    
    try {
      const cachePath = path.join(app.getPath('userData'), 'fileCache.json');
      const cacheData = await fs.readFile(cachePath, 'utf8');
      Object.assign(this.cache, JSON.parse(cacheData));
    } catch (error) {
      console.log('No existing cache found or error loading cache');
    }
  }
  
  private async saveCache() {
    if (!fs || !path || !app) return;
    
    try {
      const cachePath = path.join(app.getPath('userData'), 'fileCache.json');
      await fs.writeFile(cachePath, JSON.stringify(this.cache), 'utf8');
    } catch (error) {
      console.error('Error saving cache:', error);
    }
  }
  
  // Set up file watcher
  private setupWatcher() {
    if (!chokidar) return;
    
    this.watcher = chokidar.watch(this.rootDirectory, {
      ignored: [
        /(^|[\/\\])\../, // Ignore dotfiles
        ...ignoredDirectories.map(dir => `**/${dir}/**`),
      ],
      persistent: true,
      ignoreInitial: true,
      awaitWriteFinish: {
        stabilityThreshold: 300,
        pollInterval: 100,
      },
    });
    
    // Handle file changes
    const handleChange = debounce(async (filePath: string) => {
      if (await shouldProcessFile(filePath)) {
        await this.processFile(filePath);
      }
    }, 500);
    
    this.watcher
      .on('add', handleChange)
      .on('change', handleChange)
      .on('unlink', (filePath: string) => this.removeFile(filePath));
  }
  
  // Process a single file
  private async processFile(filePath: string): Promise<void> {
    if (!fs || !path) return;
    
    try {
      const stats = await fs.stat(filePath);
      const contentHash = await getFileHash(filePath);
      
      // Check if file has changed
      if (
        this.cache[filePath] && 
        this.cache[filePath].contentHash === contentHash &&
        this.cache[filePath].metadata.lastModified === stats.mtimeMs
      ) {
        // File hasn't changed, skip processing
        return;
      }
      
      const metadata: FileMetadata = {
        id: createHash('md5').update(filePath).digest('hex'),
        path: filePath,
        name: path.basename(filePath),
        extension: path.extname(filePath).substring(1),
        lastModified: stats.mtimeMs,
        contentHash,
        size: stats.size,
        userId: this.userId || undefined,
        deviceId: this.deviceId,
      };
      
      const embeddingId = await embedFileContent(filePath, metadata);
      
      // Update cache
      this.cache[filePath] = {
        metadata,
        contentHash,
        embeddingId,
      };
      
      await this.saveCache();
      
      // Notify renderer about updated file
      this.notifyFileProcessed(filePath, metadata);
      
    } catch (error) {
      console.error(`Error processing file ${filePath}:`, error);
    }
  }
  
  // Remove a file from the index
  private async removeFile(filePath: string): Promise<void> {
    try {
      if (!this.cache[filePath]) return;
      
      const { embeddingId } = this.cache[filePath];
      
      // Delete from Pinecone
      const index = getPineconeIndex();
      if (index) {
        await index.deleteOne(embeddingId);
      }
      
      // Remove from cache
      delete this.cache[filePath];
      await this.saveCache();
      
      console.log(`File removed from index: ${filePath}`);
    } catch (error) {
      console.error(`Error removing file ${filePath}:`, error);
    }
  }
  
  // Perform a full sync of all files
  private async performFullSync(): Promise<void> {
    if (!fs || !path || this.syncInProgress) return;
    
    this.syncInProgress = true;
    this.lastSyncTime = Date.now();
    
    try {
      console.log('Starting full file sync...');
      
      const processDirectory = async (dirPath: string) => {
        const entries = await fs.readdir(dirPath, { withFileTypes: true });
        
        for (const entry of entries) {
          const fullPath = path.join(dirPath, entry.name);
          
          // Skip ignored directories
          if (entry.isDirectory()) {
            if (!ignoredDirectories.includes(entry.name)) {
              await processDirectory(fullPath);
            }
            continue;
          }
          
          // Process file if it meets criteria
          if (await shouldProcessFile(fullPath)) {
            await this.processFile(fullPath);
          }
        }
      };
      
      await processDirectory(this.rootDirectory);
      console.log('Full file sync completed');
      
    } catch (error) {
      console.error('Error during full sync:', error);
    } finally {
      this.syncInProgress = false;
    }
  }
  
  // Set up IPC handlers for renderer communication
  private setupIPC() {
    if (!ipcMain) return;
    
    // Trigger full sync from renderer
    ipcMain.handle('file-sync:full-sync', async () => {
      await this.performFullSync();
      return { success: true, timestamp: this.lastSyncTime };
    });
    
    // Search for files
    ipcMain.handle('file-sync:search-files', async (_event: Electron.IpcMainInvokeEvent, query: string, limit = 10) => {
      try {
        const embeddings = getEmbeddings();
        if (!embeddings) {
          throw new Error('Embeddings not available');
        }
        
        const queryEmbedding = await embeddings.embedQuery(query);
        
        const index = getPineconeIndex();
        if (!index) {
          throw new Error('Pinecone index not available');
        }
        
        const results = await index.query({
          vector: queryEmbedding,
          topK: limit,
          includeMetadata: true,
        });
        
        return results.matches.map((match: any) => ({
          id: match.id,
          score: match.score,
          metadata: match.metadata,
        }));
      } catch (error) {
        console.error('Error searching files:', error);
        return [];
      }
    });
    
    // Get file content for chat
    ipcMain.handle('file-sync:get-file', async (_event: Electron.IpcMainInvokeEvent, filePath: string) => {
      if (!fs || !path) return null;
      
      try {
        const content = await fs.readFile(filePath, 'utf8');
        const stats = await fs.stat(filePath);
        
        return {
          content,
          name: path.basename(filePath),
          path: filePath,
          size: stats.size,
          lastModified: stats.mtimeMs,
        };
      } catch (error) {
        console.error('Error getting file:', error);
        return null;
      }
    });
  }
  
  // Notify renderer about processed file
  private notifyFileProcessed(filePath: string, metadata: FileMetadata) {
    if (global && global.mainWindow) {
      global.mainWindow.webContents.send('file-sync:file-processed', {
        path: filePath,
        metadata,
      });
    }
  }
  
  // Stop the sync engine
  stop() {
    if (this.watcher) {
      this.watcher.close();
    }
    this.saveCache();
  }
}

// Universal client that works in both environments
export class FileSyncClient {
  private static webClient: WebFileSync | null = null;
  private static isElectronEnv = typeof window !== 'undefined' && window.process && window.process.type === 'renderer';
  
  // Initialize with user
  static setUserId(userId: string) {
    if (!this.isElectronEnv) {
      if (!this.webClient) {
        this.webClient = new WebFileSync();
      }
      this.webClient.setUserId(userId);
    }
    // For Electron, we'll use main process for this
  }
  
  // Upload file (web only)
  static async uploadFile(file: File): Promise<any> {
    if (this.isElectronEnv) {
      throw new Error('Use local files in Electron environment');
    }
    
    if (!this.webClient) {
      this.webClient = new WebFileSync();
    }
    
    return this.webClient.uploadFile(file);
  }
  
  // Search for files
  static async searchFiles(query: string, limit = 10): Promise<any[]> {
    if (this.isElectronEnv && ipcRenderer) {
      return ipcRenderer.invoke('file-sync:search-files', query, limit);
    } else {
      if (!this.webClient) {
        this.webClient = new WebFileSync();
      }
      return this.webClient.searchFiles(query, limit);
    }
  }
  
  // Get file (Electron only)
  static async getFile(filePath: string): Promise<any> {
    if (this.isElectronEnv && ipcRenderer) {
      return ipcRenderer.invoke('file-sync:get-file', filePath);
    } else {
      throw new Error('Direct file access not available in web environment');
    }
  }
  
  // Trigger full sync (Electron only)
  static async triggerFullSync(): Promise<{ success: boolean; timestamp: number }> {
    if (this.isElectronEnv && ipcRenderer) {
      return ipcRenderer.invoke('file-sync:full-sync');
    } else {
      throw new Error('Full sync not available in web environment');
    }
  }
  
  // Listen for file processed events (Electron only)
  static onFileProcessed(callback: (data: any) => void): () => void {
    if (this.isElectronEnv && ipcRenderer) {
      const handler = (_: any, data: any) => callback(data);
      ipcRenderer.on('file-sync:file-processed', handler);
      return () => ipcRenderer.removeListener('file-sync:file-processed', handler);
    } else {
      // No-op for web
      return () => {};
    }
  }
}

================
File: utils/pinecone.ts
================
import { Pinecone } from '@pinecone-database/pinecone';
import { OpenAIEmbeddings } from '@langchain/openai';
import { RecordMetadata } from '@pinecone-database/pinecone';
import { createClient } from './supabase/server';

if (!process.env.PINECONE_API_KEY) {
  throw new Error('Missing PINECONE_API_KEY environment variable');
}

if (!process.env.PINECONE_ENVIRONMENT) {
  throw new Error('Missing PINECONE_ENVIRONMENT environment variable');
}

if (!process.env.PINECONE_INDEX) {
  throw new Error('Missing PINECONE_INDEX environment variable');
}

if (!process.env.OPENAI_API_KEY) {
  throw new Error('Missing OPENAI_API_KEY environment variable');
}

const pinecone = new Pinecone();

const index = pinecone.Index(process.env.PINECONE_INDEX!);

const embeddings = new OpenAIEmbeddings({
  openAIApiKey: process.env.OPENAI_API_KEY,
  modelName: 'text-embedding-3-large',
});

export interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  spaceId: string;
  conversationId: string;
  parentId?: string;
  childId?: string;
  metadata?: Record<string, any>;
}

interface PineconeMetadata extends RecordMetadata {
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  spaceId: string;
  conversationId: string;
  parentId?: string;
  childId?: string;
  tags?: string[];
  similarMessagesStr?: string;
  similarMessagesCount?: number;
  [key: string]: any;
}

export async function upsertChatMessage(message: ChatMessage) {
  try {
    if (!message.id) {
      throw new Error('Message ID is required for Pinecone upsert');
    }

    console.log('[PINECONE] Upserting chat message:', { messageId: message.id, conversationId: message.conversationId });
    const vector = await embeddings.embedQuery(message.content);

    // Extract metadata for Pinecone
    const metadata: PineconeMetadata = {
      content: message.content,
      role: message.role,
      createdAt: message.createdAt,
      spaceId: message.spaceId,
      conversationId: message.conversationId,
      ...(message.parentId && { parentId: message.parentId }),
      ...(message.childId && { childId: message.childId }),
    };
    
    if (message.metadata) {
      Object.entries(message.metadata).forEach(([key, value]) => {
        if (key === 'similarMessages' && value) {
          metadata.similarMessagesStr = JSON.stringify(value);
          metadata.similarMessagesCount = Array.isArray(value) ? value.length : 0;
        } else if (key === 'tags' && Array.isArray(value)) {
          metadata.tags = value;
        } else if (
          typeof value === 'string' || 
          typeof value === 'number' || 
          typeof value === 'boolean' ||
          (Array.isArray(value) && value.every(item => typeof item === 'string'))
        ) {
          metadata[key] = value;
        }
      });
    }
    
    // Add tags for filtering if not set from metadata
    if (!metadata.tags) {
      const tags = [
        `conversation-${message.conversationId}`,
        `space-${message.spaceId}`,
        `role-${message.role}`,
      ];
      metadata.tags = tags;
    }

    // Use the correct format for the Pinecone SDK version
    await index.upsert([
      {
        id: message.id,
        values: vector,
        metadata,
      },
    ]);
    
    // Update parent message if this is an assistant message
    if (message.role === 'assistant' && message.parentId) {
      try {
        const parentVector = await index.fetch([message.parentId]);
        const parentRecord = parentVector.records[message.parentId];
        if (parentRecord && parentRecord.metadata) {
          const parentMetadata = parentRecord.metadata as PineconeMetadata;
          await index.upsert([
            {
              id: message.parentId,
              values: parentRecord.values,
              metadata: {
                ...parentMetadata,
                childId: message.id,
              },
            },
          ]);
        }
      } catch (innerError) {
        console.error('[PINECONE] Error updating parent message:', innerError);
        // Continue execution even if parent update fails
      }
    }
    
    console.log('[PINECONE] Successfully upserted message:', { messageId: message.id });
    return true;
  } catch (error) {
    console.error('[PINECONE] Error upserting chat message to Pinecone:', error);
    throw error;
  }
}

export async function searchSimilarMessages(query: string, limit = 5, tags: string[] = []) {
  try {
    console.log('[PINECONE] Searching similar messages:', { query, limit, tags });
    const queryEmbedding = await embeddings.embedQuery(query);

    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      console.error('[PINECONE] Search failed: User not authenticated');
      throw new Error('Unauthorized');
    }
    
    const filter: any = {};
    
    // Add tag filter if tags are provided
    if (tags.length > 0) {
      console.log('[PINECONE] Adding tag filters:', tags);
      filter.tags = { $in: tags };
    }
    
    // Get deleted conversations and spaces to exclude them from results
    console.log('[PINECONE] Getting deleted conversations and spaces');
    const [conversationsResult, spacesResult] = await Promise.all([
      supabase
        .from('conversations')
        .select('id')
        .eq('is_deleted', true),
      supabase
        .from('spaces')
        .select('id')
        .eq('is_deleted', true)
    ]);
    
    const deletedConversationIds = conversationsResult.data?.map(c => c.id) || [];
    const deletedSpaceIds = spacesResult.data?.map(s => s.id) || [];
    
    console.log('[PINECONE] Exclusions:', { 
      deletedConversations: deletedConversationIds.length, 
      deletedSpaces: deletedSpaceIds.length 
    });

    // Build filter for Pinecone query
    // Use $and only if we have multiple conditions
    if ((deletedConversationIds.length > 0 || deletedSpaceIds.length > 0) || tags.length > 0) {
      // Initialize $and array if we need it
      filter.$and = [];
      
      // Add tag filter to $and if tags are provided
      if (tags.length > 0) {
        filter.$and.push({ tags: { $in: tags } });
        // Remove the top-level tags filter since we're using it in $and
        delete filter.tags;
      }
      
      // Add filters to exclude deleted conversations and spaces
      if (deletedConversationIds.length > 0) {
        filter.$and.push({ conversationId: { $nin: deletedConversationIds } });
      }
      
      if (deletedSpaceIds.length > 0) {
        filter.$and.push({ spaceId: { $nin: deletedSpaceIds } });
      }
      
      // If $and has only one condition, simplify the filter
      if (filter.$and.length === 1) {
        const condition = filter.$and[0];
        delete filter.$and;
        Object.assign(filter, condition);
      } else if (filter.$and.length === 0) {
        delete filter.$and;
      }
    }

    const results = await index.query({
      vector: queryEmbedding,
      topK: limit,
      includeMetadata: true,
      ...(Object.keys(filter).length > 0 ? { filter } : {}),
    });

    console.log('[PINECONE] Search complete, results:', results.matches.length);
    return results.matches.map((match) => ({
      score: match.score,
      message: reconstructChatMessage(match.metadata as PineconeMetadata, match.id),
    }));
  } catch (error) {
    console.error('[PINECONE] Error searching similar messages in Pinecone:', error);
    throw error;
  }
}

function reconstructChatMessage(metadata: PineconeMetadata, id: string): ChatMessage {
  const { 
    content, 
    role, 
    createdAt, 
    spaceId, 
    conversationId, 
    parentId, 
    childId, 
    similarMessagesStr, 
    similarMessagesCount,
    ...rest 
  } = metadata;
  
  // Prepare the message metadata
  const messageMetadata: Record<string, any> = { 
    ...rest
    // Don't duplicate conversationId in metadata since it's already at the top level
  };
  
  // Parse the stringified similarMessages back to an object if it exists
  if (similarMessagesStr) {
    try {
      const parsedMessages = JSON.parse(similarMessagesStr);
      // Make sure each similar message has conversationId as a direct property
      messageMetadata.similarMessages = parsedMessages.map((msg: any) => ({
        ...msg,
        // Put conversationId directly on the message object
        conversationId: msg.conversationId || msg.metadata?.conversationId
      }));
    } catch (error) {
      console.error('Error parsing similarMessages from Pinecone:', error);
      // If parsing fails, provide an empty array as fallback
      messageMetadata.similarMessages = [];
    }
  }

  return {
    id,
    content,
    role,
    createdAt,
    spaceId,
    conversationId, // This stays at the top level where it belongs
    ...(parentId && { parentId }),
    ...(childId && { childId }),
    metadata: messageMetadata,
  };
}

export async function getMessageThread(messageId: string): Promise<ChatMessage[]> {
  try {
    if (!messageId) {
      throw new Error('Message ID is required to get message thread');
    }

    const messages: ChatMessage[] = [];
    let currentId: string | undefined = messageId;

    while (currentId) {
      const result = await index.fetch([currentId]);
      const record = result.records[currentId];
      if (!record || !record.metadata) break;

      const metadata = record.metadata as PineconeMetadata;
      messages.unshift(reconstructChatMessage(metadata, currentId));
      currentId = metadata.parentId;
    }

    currentId = messageId;
    while (currentId) {
      const result = await index.fetch([currentId]);
      const record = result.records[currentId];
      if (!record || !record.metadata) break;

      const metadata = record.metadata as PineconeMetadata;
      if (!metadata.childId) break;

      const childResult = await index.fetch([metadata.childId]);
      const childRecord = childResult.records[metadata.childId];
      if (!childRecord || !childRecord.metadata) break;

      const childMetadata = childRecord.metadata as PineconeMetadata;
      messages.push(reconstructChatMessage(childMetadata, metadata.childId));
      currentId = metadata.childId;
    }

    return messages;
  } catch (error) {
    console.error('Error getting message thread:', error);
    throw error;
  }
}

export async function deleteMessagesByConversationId(conversationId: string): Promise<void> {
  try {
    if (!conversationId) {
      throw new Error('Conversation ID is required to delete messages');
    }

    console.log(`Deleting messages for conversation: ${conversationId}`);

    // Use query to find all vectors by conversationId
    const queryEmbedding = await embeddings.embedQuery(''); // Empty query to match all vectors
    const queryResponse = await index.query({
      vector: queryEmbedding,
      filter: {
        conversationId: conversationId
      },
      topK: 10000, // Set a high limit to get all messages
      includeMetadata: true,
    });

    // If we found messages to delete
    if (queryResponse.matches && queryResponse.matches.length > 0) {
      console.log(`Found ${queryResponse.matches.length} messages to delete`);
      
      // Extract the IDs from the response
      const messageIds = queryResponse.matches.map(match => match.id);
      
      if (messageIds.length > 0) {
        console.log(`Deleting ${messageIds.length} message records from Pinecone`);
        
        // Delete the vectors by their IDs
        await index.deleteMany(messageIds);
        console.log(`Successfully deleted ${messageIds.length} messages from Pinecone`);
      }
    } else {
      console.log(`No messages found for conversation ${conversationId}`);
    }
  } catch (error) {
    console.error('Error deleting messages by conversation ID:', error);
    throw error;
  }
}

export async function deleteMessagesBySpaceId(spaceId: string): Promise<void> {
  try {
    if (!spaceId) {
      throw new Error('Space ID is required to delete messages');
    }

    console.log(`Deleting messages for space: ${spaceId}`);

    // Use query to find all vectors by spaceId
    const queryEmbedding = await embeddings.embedQuery(''); // Empty query to match all vectors
    const queryResponse = await index.query({
      vector: queryEmbedding,
      filter: {
        spaceId: spaceId
      },
      topK: 10000, // Set a high limit to get all messages
      includeMetadata: true,
    });

    // If we found messages to delete
    if (queryResponse.matches && queryResponse.matches.length > 0) {
      console.log(`Found ${queryResponse.matches.length} messages to delete`);
      
      // Extract the IDs from the response
      const messageIds = queryResponse.matches.map(match => match.id);
      
      if (messageIds.length > 0) {
        console.log(`Deleting ${messageIds.length} message records from Pinecone`);
        
        // Delete the vectors by their IDs
        await index.deleteMany(messageIds);
        console.log(`Successfully deleted ${messageIds.length} messages from Pinecone`);
      }
    } else {
      console.log(`No messages found for space ${spaceId}`);
    }
  } catch (error) {
    console.error('Error deleting messages by space ID:', error);
    throw error;
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: CLAUDE.md
================
Below is an architecture README based on the provided codebase, summarizing the structure, components, and technologies used in the application. This README is designed to give developers an overview of the system's design, key features, and how its parts interact.

---

# Architecture Overview

This document provides an architectural overview of the **Spatial Application**, a Next.js and Supabase-powered web and desktop application designed for managing spaces, conversations, and messages with AI-driven capabilities. The application leverages modern web technologies, a robust backend, and an Electron integration for desktop functionality. It emphasizes scalability, modularity, and maintainability while adhering to best practices like DRY (Don't Repeat Yourself) and SOLID principles.

---

## Table of Contents
- [Architecture Overview](#architecture-overview)
  - [Table of Contents](#table-of-contents)
  - [Technology Stack](#technology-stack)
  - [High-Level Architecture](#high-level-architecture)
  - [Directory Structure](#directory-structure)
  - [Key Components](#key-components)
  - [Data Flow](#data-flow)
  - [Caching Strategy](#caching-strategy)
  - [Authentication](#authentication)
  - [File Syncing](#file-syncing)
  - [AI Integration](#ai-integration)
  - [Database Schema](#database-schema)
  - [Development Guidelines](#development-guidelines)

---

## Technology Stack

- **Frontend**: 
  - Next.js (v15.2.0) with App Router for server-side rendering and routing
  - React (v19.0.0) for UI components
  - TailwindCSS (v3.4.17) for styling
  - shadcn/ui for pre-built UI components
  - Lucide React for icons

- **Backend**: 
  - Supabase for authentication, database (PostgreSQL), and real-time features
  - Redis (via `@upstash/redis`) for caching
  - Pinecone for vector embeddings and similarity search

- **Desktop**: 
  - Electron (v34.0.2) for cross-platform desktop support
  - File system integration via `chokidar` and Electron IPC

- **AI**: 
  - OpenAI Embeddings (`@langchain/openai`) for text embeddings
  - Multiple AI providers via `@ai-sdk/*` (e.g., Groq, Anthropic, OpenAI)

- **Other**: 
  - TypeScript (v5.7.2) for type safety
  - Zustand for state management
  - Markdown rendering with `react-markdown` and `marked`

---

## High-Level Architecture

The application follows a layered architecture with clear separation of concerns:

1. **Presentation Layer**: 
   - Next.js pages and React components render the UI.
   - Authentication pages (`/sign-in`, `/sign-up`, `/forgot-password`) and protected routes (`/protected/*`) handle user interaction.

2. **Application Layer**: 
   - Server actions (`app/actions/*`) manage business logic, interacting with Supabase, Redis, and Pinecone.
   - API routes (`app/api/*`) handle chat and authentication callbacks.

3. **Data Layer**: 
   - Supabase PostgreSQL for structured data (spaces, conversations, messages).
   - Redis for caching frequently accessed data.
   - Pinecone for vector storage and similarity search of messages.

4. **Desktop Integration**: 
   - Electron main process handles file system operations and syncs with Pinecone.
   - Preload scripts expose safe APIs to the renderer process.

5. **External Services**: 
   - AI providers for message generation and embeddings.
   - Supabase Auth for user management.

---

## Directory Structure

```
/
├── .cursor/              # Cursor-specific rules
├── app/                  # Next.js application
│   ├── (auth-pages)/     # Authentication pages
│   ├── actions/          # Server actions for business logic
│   ├── api/              # API routes
│   ├── lib/              # Utility libraries (cache, etc.)
│   ├── protected/        # Protected routes
│   └── globals.css       # Global TailwindCSS styles
├── components/           # React components
│   ├── ui/               # Reusable UI components
│   └── *.tsx             # Feature-specific components
├── config/               # Configuration files (chat modes, models)
├── docs/                 # Documentation
├── electron/             # Electron-specific code
├── hooks/                # Custom React hooks
├── lib/                  # Shared utilities and providers
├── public/               # Static assets
├── stores/               # State management (Zustand)
├── supabase/             # Supabase migrations and config
├── types/                # TypeScript type definitions
├── utils/                # Utility functions (Supabase, Pinecone, etc.)
└── *.config.ts           # Configuration files (Next.js, Tailwind, etc.)
```

---

## Key Components

1. **Authentication**:
   - Located in `app/(auth-pages)/`.
   - Uses Supabase Auth with cookie-based sessions via `@supabase/ssr`.

2. **Spaces**:
   - Managed in `app/protected/spaces/`.
   - Server actions in `app/actions/spaces.ts` handle CRUD operations.

3. **Conversations**:
   - Managed in `app/protected/spaces/[spaceId]/conversations/`.
   - Server actions in `app/actions/conversations.ts` handle message creation, retrieval, and deletion.

4. **Chat Interface**:
   - Components in `components/ui/chat/` (e.g., `chat-messages.tsx`, `unified-input.tsx`).
   - Integrates with AI providers via `app/api/chat/route.ts`.

5. **File Sync**:
   - `utils/file-sync.ts` provides a sync engine for Electron and a web client for file uploads.
   - Embeds file content into Pinecone for similarity search.

6. **Caching**:
   - `app/lib/cache.ts` and `app/actions/utils/caching.ts` manage Redis caching.

---

## Data Flow

1. **User Interaction**:
   - User signs in via `/sign-in`, triggering Supabase Auth.
   - Session is stored in cookies and managed by `middleware.ts`.

2. **Space Management**:
   - User creates a space, calling `createSpace` action.
   - Data is stored in Supabase and cached in Redis.

3. **Conversation Flow**:
   - User starts a conversation in a space.
   - Messages are saved to Supabase, embedded in Pinecone, and cached in Redis.
   - AI responses are fetched via `/api/chat`.

4. **File Sync**:
   - In Electron, files are watched and synced to Pinecone.
   - In web, files are uploaded via `FileSyncClient`.

5. **Search**:
   - Message or file search queries Pinecone for similar vectors, filtered by space/conversation.

---

## Caching Strategy

- **Redis**: 
  - Used for caching spaces, conversations, and messages.
  - Keys defined in `CACHE_KEYS` (e.g., `SPACE:spaceId`).
  - TTLs set in `CACHE_TTL` (e.g., conversations: configurable duration).
  - Invalidated on updates (e.g., `invalidateConversationCache`).

- **Purpose**: Reduce database load and improve response times for frequently accessed data.

---

## Authentication

- **Supabase Auth**: 
  - Handles sign-up, sign-in, and password reset.
  - Configured in `utils/supabase/*` with server and client instances.
  - Middleware (`middleware.ts`) updates sessions on each request.

- **Security**: 
  - Row-Level Security (RLS) policies in Supabase ensure data isolation.
  - Cookies secure session persistence across requests.

---

## File Syncing

- **Electron**:
  - `FileSyncEngine` watches directories, processes files, and embeds content in Pinecone.
  - Uses IPC for renderer communication.

- **Web**:
  - `WebFileSync` handles file uploads and embeddings.
  - Unified client (`FileSyncClient`) abstracts environment differences.

- **Pinecone**: Stores file embeddings with metadata for search.

---

## AI Integration

- **Providers**: Supports multiple AI providers (e.g., OpenAI, Groq) via `@ai-sdk/*`.
- **Embeddings**: OpenAI’s `text-embedding-3-large` model embeds messages and files.
- **Chat**: `/api/chat/route.ts` streams AI responses to the client.
- **Similarity Search**: Pinecone queries similar messages/files based on embeddings.

---

## Database Schema

- **Tables** (defined in `supabase/migrations/`):
  - `spaces`: Stores space metadata (id, user_id, name, etc.).
  - `conversations`: Links conversations to spaces (id, space_id, title).
  - `messages`: Stores chat messages (id, conversation_id, content, role).
  - `space_history`: Tracks space actions (id, space_id, action_type).
  - `notifications`: User notifications (id, user_id, type).

- **Indexes**: Full-text search and performance indexes added in migrations.

---

## Development Guidelines

- **Code Style**: See `.cursor/rules/project.mdc` and `CLAUDE.md`.
- **Components**: Use functional components, TailwindCSS, and shadcn/ui.
- **Actions**: Server actions in `app/actions/` for data operations.
- **Error Handling**: Use `ActionResponse` for consistent responses.
- **Accessibility**: Ensure ARIA attributes and keyboard navigation.

---

This architecture supports a scalable, feature-rich application with seamless web and desktop experiences. For detailed implementation, refer to the codebase and inline documentation.

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: constants.ts
================
import { Provider } from "@/config/models";

export interface AIModel {
  id: string;
  name: string;
  contextLength: number;
  provider: Provider;
}

export interface AIProvider {
  id: Provider;
  name: string;
  models: AIModel[];
}

export const API_ROUTES = {
  CHAT: '/api/chat',
  CONVERSATIONS: (spaceId: string) => `/api/conversations/${spaceId}`,
  MESSAGES: (conversationId: string) => `/api/messages/${conversationId}`,
  SPACES: '/api/spaces',
  SPACE: (id: string) => `/api/spaces/${id}`,
};


// Database Tables
export const DB_TABLES = {
  NOTIFICATIONS: 'notifications',
  SPACES: 'spaces',
  CONVERSATIONS: 'conversations',
  MESSAGES: 'messages',
  ACTIVE_SPACES: 'active_spaces',
  ACTIVE_CONVERSATIONS: 'active_conversations'
} as const

// Common Table Columns
export const COLUMNS = {
  // Common columns
  ID: 'id',
  USER_ID: 'user_id',
  CREATED_AT: 'created_at',
  UPDATED_AT: 'updated_at',
  IS_DELETED: 'is_deleted',

  // Space columns
  NAME: 'name',
  DESCRIPTION: 'description',
  MODEL: 'model',
  PROVIDER: 'provider',
  IS_ACTIVE: 'isActive',

  // Conversation columns
  SPACE_ID: 'space_id',
  TITLE: 'title',

  // Message columns
  CONVERSATION_ID: 'conversation_id',
  ROLE: 'role',
  CONTENT: 'content',
  MODEL_USED: 'model_used',
  PARENT_MESSAGE_ID: 'parent_message_id',
  ANNOTATIONS: 'annotations',
  COLOR: 'color',
} as const

// Message Roles
export const MESSAGE_ROLES = {
  USER: 'user',
  ASSISTANT: 'assistant'
} as const

// Common Error Messages
export const ERROR_MESSAGES = {
  UNAUTHORIZED: { error: 'Unauthorized', status: 401 },
  MISSING_FIELDS: { error: 'Missing required fields', status: 400 },
  INVALID_PROVIDER: { error: 'Invalid provider', status: 400 },
  INVALID_MODEL: { error: 'Invalid model for the selected provider', status: 400 },
  MISSING_SPACE_ID: { error: 'Space ID is required', status: 400 },
  MISSING_CONVERSATION_ID: { error: 'Conversation ID is required', status: 400 },
  INVALID_ROLE: { error: 'Invalid role: must be either "user" or "assistant"', status: 400 },
  MISSING_ASSISTANT_FIELDS: { error: 'Assistant messages require model_used and provider fields', status: 400 },
  SPACE_NOT_FOUND: { error: 'Space not found or access denied', status: 404 },
  CONVERSATION_NOT_FOUND: { error: 'Conversation not found', status: 404 },
  SERVER_ERROR: (message: string) => ({ error: message, status: 500 })
} as const

export const DEFAULTS = {
  CONVERSATION_TITLE: 'New Conversation',
  SPACE_NAME: 'My Space',
  SPACE_DESCRIPTION: 'My first space',
  WELCOME_MESSAGE: 'Welcome to Vinci! I\'m here to help you explore and create. What would you like to do?'
} as const

================
File: middleware.ts
================
import { type NextRequest } from "next/server";
import { updateSession } from "@/utils/supabase/middleware";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - images - .svg, .png, .jpg, .jpeg, .gif, .webp
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};

================
File: next.config.ts
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: "standalone",
  reactStrictMode: true,
  env: {
    NEXT_PUBLIC_SUPPORTED_MODELS: process.env.SUPPORTED_MODELS,
    NEXT_PUBLIC_MODEL_PROVIDERS: process.env.MODEL_PROVIDERS,
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'unpkg.com',
        pathname: '/@lobehub/**',
      },
      {
        protocol: 'https',
        hostname: 'registry.npmmirror.com',
        pathname: '/@lobehub/**',
      }
    ],
  },
  transpilePackages: ['@lobehub/icons'],
};

export default nextConfig;

================
File: nodemon.json
================
{
    "$schema": "https://json.schemastore.org/nodemon.json",
    "exec": "electron .",
    "watch": ["build"],
    "ignore": ["build", "public/build"]
  }

================
File: package.json
================
{
  "private": true,
  "main": "build/main.js",
  "scripts": {
    "next:dev": "next dev --turbopack",
    "next:build": "next build",
    "electron:build": "tsc -p electron/tsconfig.json",
    "electron:build_watch": "tsc -p electron/tsconfig.json --watch",
    "electron:watch": "cross-env NODE_ENV='development' nodemon",
    "electron:dev": "npm-run-all --parallel electron:build_watch electron:watch",
    "dev": "npm-run-all --parallel electron:dev next:dev"
  },
  "dependencies": {
    "@agentic/ai-sdk": "^7.3.1",
    "@ai-sdk/anthropic": "^1.1.6",
    "@ai-sdk/cerebras": "^0.1.8",
    "@ai-sdk/cohere": "^1.1.7",
    "@ai-sdk/deepseek": "^0.1.8",
    "@ai-sdk/fireworks": "^0.1.8",
    "@ai-sdk/google": "^1.1.10",
    "@ai-sdk/groq": "^1.1.7",
    "@ai-sdk/mistral": "^1.1.6",
    "@ai-sdk/openai": "^1.1.9",
    "@ai-sdk/perplexity": "^0.0.7",
    "@ai-sdk/togetherai": "^0.1.9",
    "@ai-sdk/xai": "^1.1.8",
    "@electron-toolkit/utils": "^3.0.0",
    "@icons-pack/react-simple-icons": "^12.0.0",
    "@langchain/openai": "^0.4.4",
    "@lobehub/icons": "^1.68.0",
    "@openrouter/ai-sdk-provider": "^0.2.0",
    "@pinecone-database/pinecone": "^5.0.0",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "latest",
    "@supabase/supabase-js": "latest",
    "@types/highlight.js": "^10.1.0",
    "@types/markdown-it": "^14.1.2",
    "@types/marked": "^6.0.0",
    "@types/prismjs": "^1.26.5",
    "@upstash/qstash": "^2.7.22",
    "@upstash/redis": "^1.34.4",
    "ai": "^4.1.34",
    "autoprefixer": "10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "developer-icons": "^5.2.9",
    "emoji-picker-react": "^4.12.0",
    "framer-motion": "^12.0.6",
    "get-port-please": "^3.1.2",
    "highlight.js": "^11.11.1",
    "isomorphic-dompurify": "^2.21.0",
    "lodash": "^4.17.21",
    "lucide-react": "^0.468.0",
    "markdown-it": "^14.1.0",
    "markdown-it-jsx": "^1.1.0",
    "marked": "^15.0.7",
    "marked-base-url": "^1.1.6",
    "marked-gfm-heading-id": "^4.1.1",
    "marked-highlight": "^2.2.1",
    "marked-mangle": "^1.1.10",
    "next": "15.2.0",
    "next-themes": "^0.4.3",
    "prettier": "^3.3.3",
    "prismjs": "^1.29.0",
    "react": "19.0.0",
    "react-colorful": "^5.6.1",
    "react-dom": "19.0.0",
    "react-hotkeys-hook": "^4.6.1",
    "react-icons": "^5.5.0",
    "react-intersection-observer": "^9.15.1",
    "react-markdown": "^9.1.0",
    "react-syntax-highlighter": "^15.6.1",
    "react-textarea-autosize": "^8.5.7",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.1",
    "shiki": "^2.5.0",
    "sonner": "^2.0.1",
    "use-stick-to-bottom": "^1.0.46",
    "zod": "^3.24.1",
    "zod-to-json-schema": "^3.24.1",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@swc/core": "^1.10.12",
    "@swc/helpers": "^0.5.15",
    "@types/lodash": "^4.17.15",
    "@types/node": "22.10.2",
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4",
    "@types/react-syntax-highlighter": "^15.5.13",
    "cross-env": "^7.0.3",
    "electron": "^34.0.2",
    "electron-builder": "^25.1.8",
    "nodemon": "^3.1.9",
    "npm-run-all": "^4.1.5",
    "postcss": "8.4.49",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "tsup": "^8.3.6",
    "typescript": "5.7.2"
  },
  "overrides": {
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4"
  },
  "mac": {
  "entitlements": "entitlements.plist",
  "entitlementsInherit": "entitlements.plist"
}
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: README.md
================
<a href="https://demo-nextjs-with-supabase.vercel.app/">
  <img alt="Next.js and Supabase Starter Kit - the fastest way to build apps with Next.js and Supabase" src="https://demo-nextjs-with-supabase.vercel.app/opengraph-image.png">
  <h1 align="center">Next.js and Supabase Starter Kit</h1>
</a>

<p align="center">
 The fastest way to build apps with Next.js and Supabase
</p>

<p align="center">
  <a href="#features"><strong>Features</strong></a> ·
  <a href="#demo"><strong>Demo</strong></a> ·
  <a href="#deploy-to-vercel"><strong>Deploy to Vercel</strong></a> ·
  <a href="#clone-and-run-locally"><strong>Clone and run locally</strong></a> ·
  <a href="#feedback-and-issues"><strong>Feedback and issues</strong></a>
  <a href="#more-supabase-examples"><strong>More Examples</strong></a>
</p>
<br/>

## Features

- Works across the entire [Next.js](https://nextjs.org) stack
  - App Router
  - Pages Router
  - Middleware
  - Client
  - Server
  - It just works!
- supabase-ssr. A package to configure Supabase Auth to use cookies
- Styling with [Tailwind CSS](https://tailwindcss.com)
- Components with [shadcn/ui](https://ui.shadcn.com/)
- Optional deployment with [Supabase Vercel Integration and Vercel deploy](#deploy-your-own)
  - Environment variables automatically assigned to Vercel project

## Demo

You can view a fully working demo at [demo-nextjs-with-supabase.vercel.app](https://demo-nextjs-with-supabase.vercel.app/).

## Deploy to Vercel

Vercel deployment will guide you through creating a Supabase account and project.

After installation of the Supabase integration, all relevant environment variables will be assigned to the project so the deployment is fully functioning.

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&project-name=nextjs-with-supabase&repository-name=nextjs-with-supabase&demo-title=nextjs-with-supabase&demo-description=This+starter+configures+Supabase+Auth+to+use+cookies%2C+making+the+user%27s+session+available+throughout+the+entire+Next.js+app+-+Client+Components%2C+Server+Components%2C+Route+Handlers%2C+Server+Actions+and+Middleware.&demo-url=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2F&external-id=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&demo-image=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2Fopengraph-image.png)

The above will also clone the Starter kit to your GitHub, you can clone that locally and develop locally.

If you wish to just develop locally and not deploy to Vercel, [follow the steps below](#clone-and-run-locally).

## Clone and run locally

1. You'll first need a Supabase project which can be made [via the Supabase dashboard](https://database.new)

2. Create a Next.js app using the Supabase Starter template npx command

   ```bash
   npx create-next-app --example with-supabase with-supabase-app
   ```

   ```bash
   yarn create next-app --example with-supabase with-supabase-app
   ```

   ```bash
   pnpm create next-app --example with-supabase with-supabase-app
   ```

3. Use `cd` to change into the app's directory

   ```bash
   cd with-supabase-app
   ```

4. Rename `.env.example` to `.env.local` and update the following:

   ```
   NEXT_PUBLIC_SUPABASE_URL=[INSERT SUPABASE PROJECT URL]
   NEXT_PUBLIC_SUPABASE_ANON_KEY=[INSERT SUPABASE PROJECT API ANON KEY]
   ```

   Both `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` can be found in [your Supabase project's API settings](https://app.supabase.com/project/_/settings/api)

5. You can now run the Next.js local development server:

   ```bash
   npm run dev
   ```

   The starter kit should now be running on [localhost:3000](http://localhost:3000/).

6. This template comes with the default shadcn/ui style initialized. If you instead want other ui.shadcn styles, delete `components.json` and [re-install shadcn/ui](https://ui.shadcn.com/docs/installation/next)

> Check out [the docs for Local Development](https://supabase.com/docs/guides/getting-started/local-development) to also run Supabase locally.

## Feedback and issues

Please file feedback and issues over on the [Supabase GitHub org](https://github.com/supabase/supabase/issues/new/choose).

## More Supabase examples

- [Next.js Subscription Payments Starter](https://github.com/vercel/nextjs-subscription-payments)
- [Cookie-based Auth and the Next.js 13 App Router (free course)](https://youtube.com/playlist?list=PL5S4mPUpp4OtMhpnp93EFSo42iQ40XjbF)
- [Supabase Auth and the Next.js App Router](https://github.com/supabase/supabase/tree/master/examples/auth/nextjs)
# spatial-application

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			},
        'pulse-fast': {
          '0%, 100%': { opacity: '1' },
          '50%': { opacity: '0.4' }
        },
        'pulse-slow': {
          '0%, 100%': { opacity: '0.9' },
          '50%': { opacity: '0.4' }
        },
        'shimmer': {
          '0%': { backgroundPosition: '-100% 0' },
          '100%': { backgroundPosition: '200% 0' }
        },
        'glow': {
          '0%, 100%': { opacity: '0.8' },
          '50%': { opacity: '0.5' }
        },
        'highlight-glow': {
          '0%': { boxShadow: '0 0 5px rgba(62,207,255,0.3)', borderColor: 'rgba(62,207,255,0.3)' },
          '50%': { boxShadow: '0 0 20px rgba(62,207,255,0.8)', borderColor: 'rgba(62,207,255,0.8)' },
          '100%': { boxShadow: '0 0 5px rgba(62,207,255,0.3)', borderColor: 'rgba(62,207,255,0.3)' }
        },
        'rotate-slow': {
          '0%': { transform: 'rotate(0deg)' },
          '100%': { transform: 'rotate(360deg)' }
        },
        'halo-pulse': {
          '0%, 100%': { transform: 'scale(1)', opacity: '0.6' },
          '50%': { transform: 'scale(1.1)', opacity: '0.2' }
        },
        'float': {
          '0%, 100%': { transform: 'translateY(0px)' },
          '50%': { transform: 'translateY(-3px)' }
        },
        'appear': {
          '0%': { opacity: '0', transform: 'scale(0.97)' },
          '100%': { opacity: '1', transform: 'scale(1)' }
        }
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out',
        'pulse-fast': 'pulse-fast 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
        'pulse-slow': 'pulse-slow 3s ease-in-out infinite',
        'shimmer': 'shimmer 3s linear infinite',
        'glow': 'glow 2s ease-in-out infinite',
        'highlight-glow': 'highlight-glow 3s ease-in-out infinite',
        'rotate-slow': 'rotate-slow 10s linear infinite',
        'halo-pulse': 'halo-pulse 3s ease-in-out infinite',
        'float': 'float 3s ease-in-out infinite',
        'appear': 'appear 0.5s cubic-bezier(0.26, 0.53, 0.74, 1.48)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: tsup.config.ts
================
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["./electron/main.ts", "./electron/preload.ts"],
  splitting: false,
  sourcemap: false,
  clean: true,
  outDir: "build",
  external: ["electron"],
  format: ["cjs"]
});
