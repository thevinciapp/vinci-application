This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-08T22:27:29.572Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    add-architectural-decision.mdc
    nextjs.mdc
app/
  (auth-pages)/
    forgot-password/
      page.tsx
    sign-in/
      page.tsx
    sign-up/
      page.tsx
    layout.tsx
    smtp-message.tsx
  api/
    chat/
      route.ts
    conversations/
      [spaceId]/
        route.ts
      route.ts
    messages/
      [conversationId]/
        route.ts
      route.ts
    spaces/
      [id]/
        route.ts
      route.ts
  auth/
    callback/
      route.ts
  hooks/
    chat-provider.tsx
  protected/
    reset-password/
      page.tsx
    page.tsx
  actions.ts
  globals.css
  layout.tsx
  page.tsx
components/
  ui/
    badge.tsx
    button.tsx
    chat-content-client.tsx
    chat-message.tsx
    chat-messages.tsx
    checkbox.tsx
    command-modal.tsx
    command-state-provider.tsx
    dropdown-menu.tsx
    input.tsx
    label.tsx
    model-tab.tsx
    provider-icon.tsx
    quick-actions-command-provider.tsx
    quick-actions-command.tsx
    quick-actions-tab.tsx
    space-tab.tsx
    status-tab.tsx
    unified-input.tsx
  deploy-button.tsx
  env-var-warning.tsx
  form-message.tsx
  header-auth.tsx
  hero.tsx
  next-logo.tsx
  submit-button.tsx
  supabase-logo.tsx
  theme-switcher.tsx
config/
  models.ts
electron/
  main.ts
hooks/
  chat-provider.tsx
  chat-state-provider.tsx
  conversations-provider.tsx
  messages-provider.tsx
  spaces-provider.tsx
  use-stick-to-bottom.ts
lib/
  constants.ts
  utils.ts
public/
  icons/
    providers/
      default.svg
      groq.svg
store/
  chatStateStore.ts
  chatStore.ts
  spaceStore.ts
supabase/
  migrations/
    20250204124800_create_complete_schema.sql
    20250204124900_alter_space_table.sql
    20250204125000_create_active_space_table.sql
  .gitignore
  config.toml
types/
  index.ts
utils/
  supabase/
    check-env-vars.ts
    client.ts
    middleware.ts
    server.ts
  redis.ts
  utils.ts
.cursorrules
.gitignore
changelog.md
components.json
middleware.ts
next.config.ts
nodemon.json
package.json
postcss.config.js
README.md
tailwind.config.ts
tsconfig.json
tsup.config.ts

================================================================
Files
================================================================

================
File: .cursor/rules/add-architectural-decision.mdc
================
---
description: 
globs: *
---

After each composer completion, you must add what we have done to a file called changelog.md at the rootlevel.

================
File: .cursor/rules/nextjs.mdc
================
---
description: 
globs: 
---

  You are an expert in JavaScript, React, Node.js, Next.js App Router, Zustand, Shadcn UI, Radix UI, Tailwind, and Stylus.

  Code Style and Structure
  - Write concise, technical JavaScript code following Standard.js rules.
  - Use functional and declarative programming patterns; avoid classes.
  - Prefer iteration and modularization over code duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
  - Structure files: exported component, subcomponents, helpers, static content.

  Standard.js Rules
  - Use 2 space indentation.
  - Use single quotes for strings except to avoid escaping.
  - No semicolons (unless required to disambiguate statements).
  - No unused variables.
  - Add a space after keywords.
  - Add a space before a function declaration's parentheses.
  - Always use === instead of ==.
  - Infix operators must be spaced.
  - Commas should have a space after them.
  - Keep else statements on the same line as their curly braces.
  - For multi-line if statements, use curly braces.
  - Always handle the err function parameter.
  - Use camelcase for variables and functions.
  - Use PascalCase for constructors and React components.

  Naming Conventions
  - Use lowercase with dashes for directories (e.g., components/auth-wizard).
  - Favor named exports for components.

  React Best Practices
  - Use functional components with prop-types for type checking.
  - Use the "function" keyword for component definitions.
  - Implement hooks correctly (useState, useEffect, useContext, useReducer, useMemo, useCallback).
  - Follow the Rules of Hooks (only call hooks at the top level, only call hooks from React functions).
  - Create custom hooks to extract reusable component logic.
  - Use React.memo() for component memoization when appropriate.
  - Implement useCallback for memoizing functions passed as props.
  - Use useMemo for expensive computations.
  - Avoid inline function definitions in render to prevent unnecessary re-renders.
  - Prefer composition over inheritance.
  - Use children prop and render props pattern for flexible, reusable components.
  - Implement React.lazy() and Suspense for code splitting.
  - Use refs sparingly and mainly for DOM access.
  - Prefer controlled components over uncontrolled components.
  - Implement error boundaries to catch and handle errors gracefully.
  - Use cleanup functions in useEffect to prevent memory leaks.
  - Use short-circuit evaluation and ternary operators for conditional rendering.

  State Management
  - Use Zustand for global state management.
  - Lift state up when needed to share state between components.
  - Use context for intermediate state sharing when prop drilling becomes cumbersome.

  UI and Styling
  - Use Shadcn UI and Radix UI for component foundations.
  - Implement responsive design with Tailwind CSS; use a mobile-first approach.
  - Use Stylus as CSS Modules for component-specific styles:
    - Create a .module.styl file for each component that needs custom styling.
    - Use camelCase for class names in Stylus files.
    - Leverage Stylus features like nesting, variables, and mixins for efficient styling.
  - Implement a consistent naming convention for CSS classes (e.g., BEM) within Stylus modules.
  - Use Tailwind for utility classes and rapid prototyping.
  - Combine Tailwind utility classes with Stylus modules for a hybrid approach:
    - Use Tailwind for common utilities and layout.
    - Use Stylus modules for complex, component-specific styles.
    - Never use the @apply directive

  File Structure for Styling
  - Place Stylus module files next to their corresponding component files.
  - Example structure:
    components/
      Button/
        Button.js
        Button.module.styl
      Card/
        Card.js
        Card.module.styl

  Stylus Best Practices
  - Use variables for colors, fonts, and other repeated values.
  - Create mixins for commonly used style patterns.
  - Utilize Stylus' parent selector (&) for nesting and pseudo-classes.
  - Keep specificity low by avoiding deep nesting.

  Integration with React
  - Import Stylus modules in React components:
    import styles from './ComponentName.module.styl'
  - Apply classes using the styles object:
    <div className={styles.containerClass}>

  Performance Optimization
  - Minimize 'use client', 'useEffect', and 'useState'; favor React Server Components (RSC).
  - Wrap client components in Suspense with fallback.
  - Use dynamic loading for non-critical components.
  - Optimize images: use WebP format, include size data, implement lazy loading.
  - Implement route-based code splitting in Next.js.
  - Minimize the use of global styles; prefer modular, scoped styles.
  - Use PurgeCSS with Tailwind to remove unused styles in production.

  Forms and Validation
  - Use controlled components for form inputs.
  - Implement form validation (client-side and server-side).
  - Consider using libraries like react-hook-form for complex forms.
  - Use Zod or Joi for schema validation.

  Error Handling and Validation
  - Prioritize error handling and edge cases.
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging and user-friendly error messages.
  - Model expected errors as return values in Server Actions.

  Accessibility (a11y)
  - Use semantic HTML elements.
  - Implement proper ARIA attributes.
  - Ensure keyboard navigation support.

  Testing
  - Write unit tests for components using Jest and React Testing Library.
  - Implement integration tests for critical user flows.
  - Use snapshot testing judiciously.

  Security
  - Sanitize user inputs to prevent XSS attacks.
  - Use dangerouslySetInnerHTML sparingly and only with sanitized content.

  Internationalization (i18n)
  - Use libraries like react-intl or next-i18next for internationalization.

  Key Conventions
  - Use 'nuqs' for URL search parameter state management.
  - Optimize Web Vitals (LCP, CLS, FID).
  - Limit 'use client':
    - Favor server components and Next.js SSR.
    - Use only for Web API access in small components.
    - Avoid for data fetching or state management.
  - Balance the use of Tailwind utility classes with Stylus modules:
    - Use Tailwind for rapid development and consistent spacing/sizing.
    - Use Stylus modules for complex, unique component styles.

  Follow Next.js docs for Data Fetching, Rendering, and Routing.

================
File: app/(auth-pages)/forgot-password/page.tsx
================
import { forgotPasswordAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/form-message";
import { SubmitButton } from "@/components/submit-button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import Link from "next/link";
import { SmtpMessage } from "../smtp-message";

export default async function ForgotPassword(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  return (
    <>
      <form className="flex-1 flex flex-col w-full gap-2 text-foreground [&>input]:mb-6 min-w-64 max-w-64 mx-auto">
        <div>
          <h1 className="text-2xl font-medium">Reset Password</h1>
          <p className="text-sm text-secondary-foreground">
            Already have an account?{" "}
            <Link className="text-primary underline" href="/sign-in">
              Sign in
            </Link>
          </p>
        </div>
        <div className="flex flex-col gap-2 [&>input]:mb-3 mt-8">
          <Label htmlFor="email">Email</Label>
          <Input name="email" placeholder="you@example.com" required />
          <SubmitButton formAction={forgotPasswordAction}>
            Reset Password
          </SubmitButton>
          <FormMessage message={searchParams} />
        </div>
      </form>
      <SmtpMessage />
    </>
  );
}

================
File: app/(auth-pages)/sign-in/page.tsx
================
import { signInAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/form-message";
import { SubmitButton } from "@/components/submit-button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import Link from "next/link";

export default async function Login(props: { searchParams: Promise<Message> }) {
  const searchParams = await props.searchParams;
  return (
    <form className="flex-1 flex flex-col min-w-64">
      <h1 className="text-2xl font-medium">Sign in</h1>
      <p className="text-sm text-foreground">
        Don't have an account?{" "}
        <Link className="text-foreground font-medium underline" href="/sign-up">
          Sign up
        </Link>
      </p>
      <div className="flex flex-col gap-2 [&>input]:mb-3 mt-8">
        <Label htmlFor="email">Email</Label>
        <Input name="email" placeholder="you@example.com" required />
        <div className="flex justify-between items-center">
          <Label htmlFor="password">Password</Label>
          <Link
            className="text-xs text-foreground underline"
            href="/forgot-password"
          >
            Forgot Password?
          </Link>
        </div>
        <Input
          type="password"
          name="password"
          placeholder="Your password"
          required
        />
        <SubmitButton pendingText="Signing In..." formAction={signInAction}>
          Sign in
        </SubmitButton>
        <FormMessage message={searchParams} />
      </div>
    </form>
  );
}

================
File: app/(auth-pages)/sign-up/page.tsx
================
import { signUpAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/form-message";
import { SubmitButton } from "@/components/submit-button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import Link from "next/link";
import { SmtpMessage } from "../smtp-message";

export default async function Signup(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  if ("message" in searchParams) {
    return (
      <div className="w-full flex-1 flex items-center h-screen sm:max-w-md justify-center gap-2 p-4">
        <FormMessage message={searchParams} />
      </div>
    );
  }

  return (
    <>
      <form className="flex flex-col min-w-64 max-w-64 mx-auto">
        <h1 className="text-2xl font-medium">Sign up</h1>
        <p className="text-sm text text-foreground">
          Already have an account?{" "}
          <Link className="text-primary font-medium underline" href="/sign-in">
            Sign in
          </Link>
        </p>
        <div className="flex flex-col gap-2 [&>input]:mb-3 mt-8">
          <Label htmlFor="email">Email</Label>
          <Input name="email" placeholder="you@example.com" required />
          <Label htmlFor="password">Password</Label>
          <Input
            type="password"
            name="password"
            placeholder="Your password"
            minLength={6}
            required
          />
          <SubmitButton formAction={signUpAction} pendingText="Signing up...">
            Sign up
          </SubmitButton>
          <FormMessage message={searchParams} />
        </div>
      </form>
      <SmtpMessage />
    </>
  );
}

================
File: app/(auth-pages)/layout.tsx
================
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="max-w-7xl flex flex-col gap-12 items-start">{children}</div>
  );
}

================
File: app/(auth-pages)/smtp-message.tsx
================
import { ArrowUpRight, InfoIcon } from "lucide-react";
import Link from "next/link";

export function SmtpMessage() {
  return (
    <div className="bg-muted/50 px-5 py-3 border rounded-md flex gap-4">
      <InfoIcon size={16} className="mt-0.5" />
      <div className="flex flex-col gap-1">
        <small className="text-sm text-secondary-foreground">
          <strong> Note:</strong> Emails are rate limited. Enable Custom SMTP to
          increase the rate limit.
        </small>
        <div>
          <Link
            href="https://supabase.com/docs/guides/auth/auth-smtp"
            target="_blank"
            className="text-primary/50 hover:text-primary flex items-center text-sm gap-1"
          >
            Learn more <ArrowUpRight size={14} />
          </Link>
        </div>
      </div>
    </div>
  );
}

================
File: app/api/chat/route.ts
================
import { streamText } from 'ai';
import { groq } from '@ai-sdk/groq';
import { anthropic } from '@ai-sdk/anthropic';
import { openai } from '@ai-sdk/openai';
import { cohere } from '@ai-sdk/cohere';
import { mistral } from '@ai-sdk/mistral';
import { google } from '@ai-sdk/google';
import { xai } from '@ai-sdk/xai';
import { togetherai } from '@ai-sdk/togetherai';
import { deepseek } from '@ai-sdk/deepseek';
import { cerebras } from '@ai-sdk/cerebras';
import { perplexity } from '@ai-sdk/perplexity';
import { createOpenRouter } from '@openrouter/ai-sdk-provider';
import { createClient } from '@/utils/supabase/server';

export const maxDuration = 60;
export const dynamic = 'force-dynamic'
export const runtime = 'edge'

type Provider = keyof typeof providers;

const providers = {
  groq: (model: string, messages: any[]) => {
    return streamText({
      model: groq(model),
      messages,
    });
  },
  anthropic: (model: string, messages: any[]) => {
    return streamText({
      model: anthropic(model),
      messages,
    });
  },
  openai: (model: string, messages: any[]) => {
    return streamText({
      model: openai(model),
      messages,
    });
  },
  cohere: (model: string, messages: any[]) => {
    return streamText({
      model: cohere(model),
      messages,
    });
  },
  mistral: (model: string, messages: any[]) => {
    return streamText({
      model: mistral(model),
      messages,
    });
  },
  google: (model: string, messages: any[]) => {
    return streamText({
      model: google(model),
      messages,
    });
  },
  xai: (model: string, messages: any[]) => {
    return streamText({
      model: xai(model),
      messages,
    });
  },
  togetherai: (model: string, messages: any[]) => {
    return streamText({
      model: togetherai(model),
      messages,
    });
  },
  deepseek: (model: string, messages: any[]) => {
    return streamText({
      model: deepseek(model),
      messages,
    });
  },
  cerebras: (model: string, messages: any[]) => {
    return streamText({
      model: cerebras(model),
      messages,
    });
  },
  perplexity: (model: string, messages: any[]) => {
    return streamText({
      model: perplexity(model),
      messages,
    });
  }
};

export async function POST(req: Request) {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) return new Response('Unauthorized', { status: 401 });

  const { messages, spaceId } = await req.json();
  
  if (!spaceId) return new Response('Space ID required', { status: 400 });
  
  const { data: spaceData } = await supabase
    .from('spaces')
    .select('model, provider')
    .eq('id', spaceId)
    .single();

  if (!spaceData?.provider || !providers[spaceData.provider as Provider]) {
    return new Response('Invalid provider', { status: 400 });
  }

  try {
    const result = providers[spaceData.provider as Provider](spaceData?.model, messages);
    return await result.toDataStreamResponse({});
  } catch (error) {
    console.error('Error in chat route:', error);
    return new Response('Error processing request', { status: 500 });
  }
}

================
File: app/api/conversations/[spaceId]/route.ts
================
import { createClient } from '@/utils/supabase/server';
import { NextResponse } from 'next/server';
import redis, { CACHE_KEYS, CACHE_TTL, setCache, getCache, deleteCache } from '@/utils/redis';

export async function GET(
  request: Request,
  context: { params: Promise<{ spaceId: string }> }
) {
  try {
    const { spaceId } = await context.params;
    const supabase = await createClient();

    const { 
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    // Try to get conversations from cache first
    const cachedConversations = await getCache(CACHE_KEYS.conversations(spaceId));
    if (cachedConversations) {
      return NextResponse.json(cachedConversations);
    }

    const { data: conversations, error } = await supabase
      .from('conversations')
      .select('*')
      .eq('space_id', spaceId)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching conversations:', error);
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    // Cache the conversations
    await setCache(
      CACHE_KEYS.conversations(spaceId),
      conversations,
      CACHE_TTL.CONVERSATIONS
    );

    return NextResponse.json(conversations);
  } catch (error: any) {
    console.error('Error in conversations fetch:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

// Add POST method to handle conversation creation
export async function POST(
  request: Request,
  context: { params: Promise<{ spaceId: string }> }
) {
  try {
    const { spaceId } = await context.params;
    const body = await request.json();
    const supabase = await createClient();

    const { 
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    const { data: conversation, error } = await supabase
      .from('conversations')
      .insert({
        space_id: spaceId,
        title: body.title || 'New Conversation'
      })
      .select()
      .single();

    if (error) {
      console.error('Error creating conversation:', error);
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    // Invalidate conversations cache for this space
    await deleteCache(CACHE_KEYS.conversations(spaceId));

    return NextResponse.json(conversation);
  } catch (error: any) {
    console.error('Error in conversation creation:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

================
File: app/api/conversations/route.ts
================
import { NextResponse } from 'next/server';
import { createClient } from "@/utils/supabase/server";
import redis, { CACHE_KEYS, CACHE_TTL, setCache, getCache, deleteCache } from '@/utils/redis';

/**
 * GET /api/conversation
 * Retrieves conversations for a space.
 * Expects query parameter: spaceId
 */
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const spaceId = searchParams.get('spaceId');

    if (!spaceId) {
      return NextResponse.json({ error: 'Space ID is required' }, { status: 400 });
    }

    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Try to get conversations from cache first
    const cachedConversations = await getCache(CACHE_KEYS.conversations(spaceId));
    if (cachedConversations) {
      return NextResponse.json(cachedConversations);
    }

    // If not in cache, fetch from database
    const { data: conversations, error } = await supabase
      .from('conversations')
      .select('*')
      .eq('space_id', spaceId)
      .eq('is_deleted', false)
      .order('created_at', { ascending: false });

    if (error) {
      console.error('Error fetching conversations:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Cache the conversations
    await setCache(
      CACHE_KEYS.conversations(spaceId),
      conversations,
      CACHE_TTL.CONVERSATIONS
    );

    return NextResponse.json(conversations);
  } catch (err: any) {
    console.error('Error in conversation fetch:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

/**
 * POST /api/conversation
 * Creates a new conversation within a space.
 * Expects JSON body: { space_id: string, title?: string }
 */
export async function POST(request: Request) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { spaceId, name } = body;

    if (!spaceId) {
      return NextResponse.json({ error: 'Space ID is required' }, { status: 400 });
    }

    const { data: conversation, error } = await supabase
      .from('conversations')
      .insert([
        {
          space_id: spaceId,
          name: name || 'New Conversation',
          user_id: user.id
        }
      ])
      .select()
      .single();

    if (error) {
      console.error('Error creating conversation:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Invalidate conversations cache for this space
    await deleteCache(CACHE_KEYS.conversations(spaceId));

    return NextResponse.json(conversation);
  } catch (err: any) {
    console.error('Error in conversation creation:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

================
File: app/api/messages/[conversationId]/route.ts
================
import { createClient } from '@/utils/supabase/server';
import { NextResponse } from 'next/server';
import redis, { CACHE_KEYS, CACHE_TTL, setCache, getCache, deleteCache } from '@/utils/redis';
import { Message } from '@/types';

export async function GET(
  request: Request,
  context: { params: Promise<{ conversationId: string }> }
) {
  try {
    const { conversationId } = await context.params;
    const supabase = await createClient();

    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    const cachedMessages = await getCache(CACHE_KEYS.messages(conversationId));
    if (cachedMessages) {
      return NextResponse.json(cachedMessages);
    }

    const { data: messages, error } = await supabase
      .from('messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .eq('is_deleted', false)
      .order('created_at', { ascending: true });

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    await setCache(
      CACHE_KEYS.messages(conversationId),
      messages,
      CACHE_TTL.MESSAGES
    );

    return NextResponse.json(messages);
  } catch (error: any) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}

export async function POST(
  request: Request,
  context: { params: Promise<{ conversationId: string }> }
) {
  try {
    const { conversationId } = await context.params;
    const body = await request.json();
    const supabase = await createClient();

    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    // Validate required fields
    const { content, role, model_used, provider } = body;
    if (!content || !role) {
      return NextResponse.json({ 
        error: 'Missing required fields: content and role are required' 
      }, { status: 400 });
    }

    // Validate role is either 'user' or 'assistant'
    if (!['user', 'assistant'].includes(role)) {
      return NextResponse.json({ 
        error: 'Invalid role: must be either "user" or "assistant"' 
      }, { status: 400 });
    }

    // For assistant messages, require model_used and provider
    if (role === 'assistant' && (!model_used || !provider)) {
      return NextResponse.json({ 
        error: 'Assistant messages require model_used and provider fields' 
      }, { status: 400 });
    }

    // Prepare message data with required fields
    const messageData: Partial<Message> = {
      conversation_id: conversationId,
      user_id: user.id,
      role,
      content,
      model_used,
      provider,
      is_deleted: false,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    // Add optional fields if present
    if (body.parent_message_id) {
      // Validate parent_message_id exists if provided
      const { data: parentMessage } = await supabase
        .from('messages')
        .select('id')
        .eq('id', body.parent_message_id)
        .single();

      if (parentMessage) {
        messageData.parent_message_id = body.parent_message_id;
      } else {
        console.warn('Invalid parent_message_id provided:', body.parent_message_id);
      }
    }

    const { data: message, error } = await supabase
      .from('messages')
      .insert(messageData)
      .select()
      .single();

    if (error) {
      console.error('Error creating message:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Invalidate messages cache for this conversation
    await deleteCache(CACHE_KEYS.messages(conversationId));

    return NextResponse.json(message);
  } catch (error: any) {
    console.error('Error in message creation:', error);
    return NextResponse.json({ 
      error: 'Failed to create message: ' + error.message 
    }, { status: 500 });
  }
}

================
File: app/api/messages/route.ts
================
import { NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import redis, { CACHE_KEYS, CACHE_TTL, setCache, getCache, deleteCache } from '@/utils/redis';
import { Message } from '@/types';

/**
 * GET /api/message
 * Retrieves messages for a specific conversation.
 * Expects query parameter: conversationId
 */
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const conversationId = searchParams.get('conversationId');

    if (!conversationId) {
      return NextResponse.json({ error: 'Conversation ID is required' }, { status: 400 });
    }

    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Try to get messages from cache first
    const cachedMessages = await getCache(CACHE_KEYS.messages(conversationId));
    if (cachedMessages) {
      return NextResponse.json(cachedMessages);
    }

    // If not in cache, fetch from database
    const { data: messages, error } = await supabase
      .from('messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .eq('is_deleted', false)
      .order('created_at', { ascending: true });

    if (error) {
      console.error('Error fetching messages:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Cache the messages
    await setCache(
      CACHE_KEYS.messages(conversationId),
      messages,
      CACHE_TTL.MESSAGES
    );

    return NextResponse.json(messages);
  } catch (err: any) {
    console.error('Error in message fetch:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

/**
 * POST /api/message
 * Saves a chat message.
 * Required fields: conversation_id, role ('user' | 'assistant'), content
 * Optional fields: model_used, provider, parent_message_id
 */
export async function POST(request: Request) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    
    // Validate required fields
    const { conversation_id, content, role } = body;
    if (!conversation_id || !content || !role) {
      return NextResponse.json({ 
        error: 'Missing required fields: conversation_id, content, and role are required' 
      }, { status: 400 });
    }

    // Validate role
    if (!['user', 'assistant'].includes(role)) {
      return NextResponse.json({ 
        error: 'Invalid role: must be either "user" or "assistant"' 
      }, { status: 400 });
    }

    // Prepare message data with required fields
    const messageData: Partial<Message> = {
      conversation_id,
      user_id: user.id,
      role,
      content,
      is_deleted: false,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    // Add optional fields if present
    if (body.model_used) messageData.model_used = body.model_used;
    if (body.provider) messageData.provider = body.provider;
    if (body.parent_message_id) {
      // Validate parent_message_id exists if provided
      const { data: parentMessage } = await supabase
        .from('messages')
        .select('id')
        .eq('id', body.parent_message_id)
        .single();

      if (parentMessage) {
        messageData.parent_message_id = body.parent_message_id;
      } else {
        console.warn('Invalid parent_message_id provided:', body.parent_message_id);
      }
    }

    const { data: message, error } = await supabase
      .from('messages')
      .insert(messageData)
      .select()
      .single();

    if (error) {
      console.error('Error creating message:', error);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    // Invalidate messages cache for this conversation
    await deleteCache(CACHE_KEYS.messages(conversation_id));

    return NextResponse.json(message);
  } catch (err: any) {
    console.error('Error in message creation:', err);
    return NextResponse.json({ 
      error: 'Failed to create message: ' + err.message 
    }, { status: 500 });
  }
}

================
File: app/api/spaces/[id]/route.ts
================
import { NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import redis, { CACHE_KEYS, CACHE_TTL, setCache, getCache, deleteCache } from '@/utils/redis';

export async function PATCH(
  request: Request,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const { name, description, model, provider, setActive } = await request.json();
    const { id: spaceId } = await context.params;

    const supabase = await createClient();
    
    const {
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    // First, verify the space exists and belongs to the user
    const { data: existingSpace, error: fetchError } = await supabase
      .from('spaces')
      .select('*')
      .eq('id', spaceId)
      .eq('user_id', user.id)
      .eq('is_deleted', false)
      .single();

    if (fetchError || !existingSpace) {
      console.error('Space not found or access denied:', fetchError);
      return NextResponse.json({ 
        error: 'Space not found or access denied' 
      }, { status: 404 });
    }

    // Prepare update data
    const updateData: any = {
      updated_at: new Date().toISOString()
    };
    if (name) updateData.name = name;
    if (description) updateData.description = description;
    if (model) updateData.model = model;
    if (provider) updateData.provider = provider;

    // Update the space
    const { data: updatedSpace, error: updateError } = await supabase
      .from('spaces')
      .update(updateData)
      .eq('id', spaceId)
      .eq('user_id', user.id)
      .eq('is_deleted', false)
      .select()
      .single();

    if (updateError) {
      console.error('Error updating space:', updateError);
      return NextResponse.json({ error: updateError.message }, { status: 400 });
    }

    // If model or provider changed, invalidate related caches
    if (model || provider) {
      // Get all conversations for this space
      const { data: conversations } = await supabase
        .from('conversations')
        .select('id')
        .eq('space_id', spaceId);

      // Invalidate cache for each conversation's messages
      if (conversations) {
        await Promise.all(conversations.map(conv => 
          deleteCache(CACHE_KEYS.messages(conv.id))
        ));
      }

      // Invalidate conversations cache for this space
      await deleteCache(CACHE_KEYS.conversations(spaceId));
    }

    // Handle setting active space if requested
    if (setActive) {
      const { error: activeError } = await supabase
        .from('active_spaces')
        .upsert({
          user_id: user.id,
          space_id: spaceId,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'user_id'
        });

      if (activeError) {
        console.error('Error setting active space:', activeError);
        return NextResponse.json({ error: activeError.message }, { status: 400 });
      }

      // Invalidate active space cache
      await deleteCache(CACHE_KEYS.activeSpace(user.id));
      
      // Update spaces cache to reflect new active state
      await deleteCache(CACHE_KEYS.spaces(user.id));

      return NextResponse.json({ ...updatedSpace, isActive: true });
    }

    // Invalidate spaces cache
    await deleteCache(CACHE_KEYS.spaces(user.id));

    return NextResponse.json(updatedSpace);
  } catch (err: any) {
    console.error('Error in space update:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const spaceId = params.id;
    const supabase = await createClient();

    const {
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    const { data, error } = await supabase
      .from('spaces')
      .select('*')
      .eq('id', spaceId)
      .eq('user_id', user.id)
      .single();

    if (error) {
      console.error('Error fetching space:', error);
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    return NextResponse.json(data);
  } catch (err: any) {
    console.error('Error in space fetch:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const spaceId = params.id;
    const supabase = await createClient();
    
    const {
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    const { error } = await supabase
      .from('spaces')
      .update({ is_deleted: true })
      .eq('id', spaceId)
      .eq('user_id', user.id);

    if (error) {
      console.error('Error deleting space:', error);
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    return new Response(null, { status: 204 });
  } catch (err: any) {
    console.error('Error in space deletion:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

================
File: app/api/spaces/route.ts
================
import { NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import { AVAILABLE_MODELS, isValidModelForProvider, type Provider } from '@/config/models';
import { CACHE_KEYS, CACHE_TTL, setCache, getCache, deleteCache } from '@/utils/redis';

/**
 * POST /api/space
 * Creates a new space record in the database.
 * Expects JSON body: { name: string, description?: string, model: string, provider: string, setActive?: boolean }
 */
export async function POST(request: Request) {
  try {
    const body = await request.json();
    console.log('Received request body:', body);

    const { name, description, model, provider, setActive } = body;
    
    if (!name) {
      console.error('Name is required for space creation');
      return NextResponse.json({ error: 'Name is required' }, { status: 400 });
    }

    if (!provider || !Object.keys(AVAILABLE_MODELS).includes(provider)) {
      return NextResponse.json({ 
        error: `Invalid provider. Available providers: ${Object.keys(AVAILABLE_MODELS).join(', ')}` 
      }, { status: 400 });
    }

    if (!model || !isValidModelForProvider(provider as Provider, model)) {
      return NextResponse.json({ 
        error: `Invalid model for provider ${provider}. Available models: ${AVAILABLE_MODELS[provider as Provider].map(m => m.name).join(', ')}` 
      }, { status: 400 });
    }

    const supabase = await createClient();

    const {
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
      console.error('Unauthorized request to create space');
      return new Response('Unauthorized', { status: 401 });
    }

    // If setting as active, first clear any existing active space
    if (setActive) {
      const { error: clearError } = await supabase
        .from('active_spaces')
        .delete()
        .eq('user_id', user.id);

      if (clearError) {
        console.error('Error clearing active space:', clearError);
        return NextResponse.json({ error: clearError.message }, { status: 400 });
      }
    }

    const { data: spaceData, error: spaceError } = await supabase
      .from('spaces')
      .insert({ 
        name, 
        description, 
        user_id: user.id, 
        model, 
        provider
      })
      .select()
      .single();

    if (spaceError) {
      console.error('Error creating space:', spaceError);
      return NextResponse.json({ error: spaceError.message }, { status: 400 });
    }

    // Set as active space if requested
    if (setActive && spaceData) {
      const { error: activeError } = await supabase
        .from('active_spaces')
        .upsert({
          user_id: user.id,
          space_id: spaceData.id,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'user_id'
        });

      if (activeError) {
        console.error('Error setting active space:', activeError);
        return NextResponse.json({ error: activeError.message }, { status: 400 });
      }

      spaceData.isActive = true;
      
      // Update active space cache
      await setCache(
        CACHE_KEYS.activeSpace(user.id),
        { ...spaceData, isActive: true },
        CACHE_TTL.ACTIVE_SPACE
      );
    }

    // Invalidate spaces cache
    await deleteCache(CACHE_KEYS.spaces(user.id));

    if (!spaceError) {
      const { data: convData, error: convError } = await supabase
        .from('conversations')
        .insert({
          space_id: spaceData.id,
          title: 'Default Conversation'
        })
        .select()
        .single();

      if (convError) {
        console.error('Error creating default conversation:', convError);
        return NextResponse.json({ error: convError.message }, { status: 400 });
      }

      // Cache the new conversation
      await setCache(
        CACHE_KEYS.conversations(spaceData.id),
        [convData],
        CACHE_TTL.CONVERSATIONS
      );

      return NextResponse.json({ ...spaceData, default_conversation: convData });
    }

    console.log('Created space:', spaceData);
    return NextResponse.json(spaceData);
  } catch (err: any) {
    console.error('Error in space creation:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

/**
 * GET /api/space
 * Fetches spaces for the current user.
 */
export async function GET(request: Request) {
  try {
    const supabase = await createClient();

    const {
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    // Try to get spaces from cache first
    const cachedSpaces = await getCache(CACHE_KEYS.spaces(user.id));
    if (cachedSpaces) {
      return NextResponse.json(cachedSpaces);
    }

    // If no spaces exist, create a default space
    const { count } = await supabase
      .from('spaces')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .eq('is_deleted', false);

    if (count === 0) {
      const { data: defaultSpace, error: createError } = await supabase
        .from('spaces')
        .insert({ 
          name: 'My First Space',
          description: 'Welcome to your first space!',
          user_id: user.id,
          model: AVAILABLE_MODELS['anthropic'][0].id,
          provider: 'anthropic'
        })
        .select()
        .single();

      if (createError) {
        console.error('Error creating default space:', createError);
        return NextResponse.json({ error: createError.message }, { status: 400 });
      }

      // Set as active space
      const { error: activeError } = await supabase
        .from('active_spaces')
        .upsert({
          user_id: user.id,
          space_id: defaultSpace.id
        }, {
          onConflict: 'user_id'
        });

      if (activeError) {
        console.error('Error setting active space:', activeError);
        return NextResponse.json({ error: activeError.message }, { status: 400 });
      }

      // Create default conversation
      const { data: convData, error: convError } = await supabase
        .from('conversations')
        .insert({
          space_id: defaultSpace.id,
          title: 'Getting Started'
        })
        .select()
        .single();

      if (convError) {
        console.error('Error creating default conversation:', convError);
        return NextResponse.json({ error: convError.message }, { status: 400 });
      }

      // Cache the new conversation
      await setCache(
        CACHE_KEYS.conversations(defaultSpace.id),
        [convData],
        CACHE_TTL.CONVERSATIONS
      );

      // Create welcome message
      const { error: messageError } = await supabase
        .from('messages')
        .insert({
          conversation_id: convData.id,
          user_id: user.id,
          role: 'assistant',
          content: `Welcome to your first space! ðŸ‘‹

I'm Claude, your AI assistant. I'm here to help you with:

â€¢ Writing and analysis
â€¢ Research and learning
â€¢ Creative projects
â€¢ Technical tasks
â€¢ And much more!

What would you like to explore first?`,
          model_used: defaultSpace.model,
          provider: defaultSpace.provider
        });

      if (messageError) {
        console.error('Error creating welcome message:', messageError);
        return NextResponse.json({ error: messageError.message }, { status: 400 });
      }

      const spacesWithActive = [{ ...defaultSpace, isActive: true }];
      
      // Cache the spaces and active space
      await setCache(
        CACHE_KEYS.spaces(user.id),
        spacesWithActive,
        CACHE_TTL.SPACES
      );
      
      await setCache(
        CACHE_KEYS.activeSpace(user.id),
        { ...defaultSpace, isActive: true },
        CACHE_TTL.ACTIVE_SPACE
      );

      return NextResponse.json(spacesWithActive);
    }

    const { data: activeSpaceData } = await supabase
      .from('active_spaces')
      .select('space_id')
      .eq('user_id', user.id)
      .single();

    const { data: spaces, error } = await supabase
      .from('spaces')
      .select('*')
      .eq('user_id', user.id)
      .eq('is_deleted', false)
      .order('updated_at', { ascending: false });

    if (error) {
      console.error('Error fetching spaces:', error);
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    // Add isActive flag and ensure active space is first
    const activeSpace = spaces.find(space => space.id === activeSpaceData?.space_id);
    const otherSpaces = spaces.filter(space => space.id !== activeSpaceData?.space_id);
    
    const spacesWithActive = [
      ...(activeSpace ? [{ ...activeSpace, isActive: true }] : []),
      ...otherSpaces.map(space => ({ ...space, isActive: false }))
    ];

    // Cache the spaces
    await setCache(
      CACHE_KEYS.spaces(user.id),
      spacesWithActive,
      CACHE_TTL.SPACES
    );

    // Cache the active space if it exists
    if (activeSpace) {
      await setCache(
        CACHE_KEYS.activeSpace(user.id),
        { ...activeSpace, isActive: true },
        CACHE_TTL.ACTIVE_SPACE
      );
    }

    return NextResponse.json(spacesWithActive);
  } catch (err: any) {
    console.error('Error in space fetch:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

export async function DELETE(request: Request) {
  try {
    const url = new URL(request.url);
    const id = url.pathname.split('/').pop();

    const supabase = await createClient();
    
    const {
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    const { error } = await supabase
      .from('spaces')
      .update({ is_deleted: true })
      .eq('id', id)
      .eq('user_id', user.id);

    if (error) {
      console.error('Error deleting space:', error);
      return NextResponse.json({ error: error.message }, { status: 400 });
    }

    return new Response(null, { status: 204 });
  } catch (err: any) {
    console.error('Error in space deletion:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

================
File: app/auth/callback/route.ts
================
import { createClient } from "@/utils/supabase/server";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  // The `/auth/callback` route is required for the server-side auth flow implemented
  // by the SSR package. It exchanges an auth code for the user's session.
  // https://supabase.com/docs/guides/auth/server-side/nextjs
  const requestUrl = new URL(request.url);
  const code = requestUrl.searchParams.get("code");
  const origin = requestUrl.origin;
  const redirectTo = requestUrl.searchParams.get("redirect_to")?.toString();

  if (code) {
    const supabase = await createClient();
    await supabase.auth.exchangeCodeForSession(code);
  }

  if (redirectTo) {
    return NextResponse.redirect(`${origin}${redirectTo}`);
  }

  // URL to redirect to after sign up process completes
  return NextResponse.redirect(`${origin}/protected`);
}

================
File: app/hooks/chat-provider.tsx
================
import { User } from "@supabase/supabase-js";

export type ActionType = 
  | { type: 'SET_USER'; payload: User | null }
  | { type: 'SET_INITIALIZING'; payload: boolean }
  | { type: 'SET_LOADING'; payload: boolean }; 

interface ChatState {
  user: User | null;
  isInitializing: boolean;
  isLoading: boolean;
}

const initialState: ChatState = {
  user: null,
  isInitializing: true,
  isLoading: false
};

function reducer(state: ChatState, action: ActionType): ChatState {
  switch (action.type) {
    case 'SET_USER':
      return { ...state, user: action.payload };
    case 'SET_INITIALIZING':
      return { ...state, isInitializing: action.payload };
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    default:
      return state;
  }
}

================
File: app/protected/reset-password/page.tsx
================
import { resetPasswordAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/form-message";
import { SubmitButton } from "@/components/submit-button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

export default async function ResetPassword(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  return (
    <form className="flex flex-col w-full max-w-md p-4 gap-2 [&>input]:mb-4">
      <h1 className="text-2xl font-medium">Reset password</h1>
      <p className="text-sm text-foreground/60">
        Please enter your new password below.
      </p>
      <Label htmlFor="password">New password</Label>
      <Input
        type="password"
        name="password"
        placeholder="New password"
        required
      />
      <Label htmlFor="confirmPassword">Confirm password</Label>
      <Input
        type="password"
        name="confirmPassword"
        placeholder="Confirm password"
        required
      />
      <SubmitButton formAction={resetPasswordAction}>
        Reset password
      </SubmitButton>
      <FormMessage message={searchParams} />
    </form>
  );
}

================
File: app/protected/page.tsx
================
"use client"

import { redirect } from "next/navigation";
import { useChat } from "ai/react";
import { UnifiedInput } from "@/components/ui/unified-input";
import { ChatMessages } from "@/components/ui/chat-messages";
import { CommandStateProvider } from "@/components/ui/command-state-provider";
import { QuickActionsCommandProvider } from "@/components/ui/quick-actions-command-provider";
import { SpacesProvider, useSpaces } from "@/hooks/spaces-provider";
import { ConversationsProvider, useConversations } from "@/hooks/conversations-provider";
import { MessagesProvider, useMessages } from "@/hooks/messages-provider";
import { ChatStateProvider, useChatState } from "@/hooks/chat-state-provider";
import { Message, convertToAIMessage } from "@/types";
import { useCallback, useState, useEffect, useMemo } from "react";
import { createClient } from "@/utils/supabase/client";

const supabase = createClient();

function ChatContent() {
  const { activeSpace, state: spacesState } = useSpaces();
  const { activeConversation, state: conversationsState } = useConversations();
  const { messages: chatMessages, state: messagesState, addMessage } = useMessages();
  const { batchUpdate } = useChatState();
  const [userId, setUserId] = useState<string | null>(null);
  const [streamingMessage, setStreamingMessage] = useState<Message | null>(null);

  // Fetch user ID only once on component mount
  useEffect(() => {
    const fetchUser = async () => {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.user) {
        redirect('/sign-in');
      }
      setUserId(session.user.id);
    };

    fetchUser();
  }, []);

  const {
    messages: aiMessages,
    input,
    handleInputChange,
    handleSubmit: originalHandleSubmit,
    isLoading: isStreaming,
  } = useChat({
    api: "/api/chat",
    body: {
      spaceId: activeSpace?.id,
      model: activeSpace?.model,
      provider: activeSpace?.provider,
    },
    id: activeConversation?.id,
    initialMessages: chatMessages.map(convertToAIMessage),
    onResponse: (response: Response) => {
      if (!response.ok) {
        console.error('Failed to get response from server', response.status, response.statusText);
        batchUpdate({ error: 'Failed to get response from server' });
      } else {
        batchUpdate({ isLoading: true, error: null });
      }
    },
    onFinish: async (message: { content: string }) => {
      if (!activeSpace?.id || !activeConversation?.id || !userId) return;

      try {
        const response = await fetch('/api/messages', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            conversation_id: activeConversation.id,
            user_id: userId,
            role: 'assistant',
            content: message.content,
            model_used: activeSpace.model,
            provider: activeSpace.provider
          }),
        });

        if (!response.ok) {
          throw new Error(`Failed to save assistant message: ${response.status} ${response.statusText}`);
        }

        const assistantMessageData = await response.json();
        if(!assistantMessageData.id) throw new Error('Failed to save assistant message: Invalid API response');
        
        // Add the full message from the database
        addMessage(assistantMessageData);
        // Clear the streaming message since we now have the final version
        setStreamingMessage(null);

      } catch (error) {
        console.error('Error saving assistant message:', error);
        batchUpdate({ error: 'Failed to save assistant message' });
      } finally {
        batchUpdate({ isLoading: false });
      }
    },
  });

  // Update streaming message whenever AI messages change
  useEffect(() => {
    if (!isStreaming || aiMessages.length === 0) return;
    
    const lastMessage = aiMessages[aiMessages.length - 1];
    if (lastMessage.role === 'assistant') {
      setStreamingMessage(prev => {
        if (!prev || prev.content !== lastMessage.content) {
          return {
            id: lastMessage.id,
            conversation_id: activeConversation?.id || '',
            user_id: userId || '',
            role: 'assistant',
            content: lastMessage.content,
            model_used: activeSpace?.model,
            provider: activeSpace?.provider,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          };
        }
        return prev;
      });
    }
  }, [aiMessages, isStreaming, activeSpace?.model, activeSpace?.provider, activeConversation?.id, userId]);

  const handleSubmit = useCallback(async (e?: React.FormEvent) => {
    e?.preventDefault();
    if (!input.trim() || isStreaming || !userId || !activeConversation?.id) return;

    batchUpdate({ isLoading: true, error: null });

    try {
      const response = await fetch('/api/messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          conversation_id: activeConversation.id,
          user_id: userId,
          role: 'user',
          content: input,
          model_used: activeSpace?.model,
          provider: activeSpace?.provider
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to save user message: ${response.status} ${response.statusText}`);
      }
      const userMessageData = await response.json();
      if(!userMessageData.id) throw new Error('Failed to save user message: Invalid API response');

      // Add the full message from the database
      addMessage(userMessageData);
      
      // Create skeleton assistant message immediately
      setStreamingMessage({
        id: crypto.randomUUID(),
        conversation_id: activeConversation.id,
        user_id: userId,
        role: 'assistant',
        content: '',
        model_used: activeSpace?.model,
        provider: activeSpace?.provider,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      });
      
      await originalHandleSubmit(e);

    } catch (error) {
      console.error('Error in handleSubmit:', error);
      batchUpdate({ isLoading: false, error: 'Failed to send message' });
      // Clear streaming message if there's an error
      setStreamingMessage(null);
    }
  }, [input, isStreaming, userId, activeConversation?.id, activeSpace?.model, activeSpace?.provider, originalHandleSubmit, batchUpdate, addMessage]);

  // Loading state - only show if we don't have a user ID yet
  if (!userId) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-black">
        <div className="flex items-center gap-2">
          <div className="h-4 w-4 rounded-full bg-blue-500 animate-pulse" />
          <span className="text-sm text-white/70">Loading...</span>
        </div>
      </div>
    );
  }

  // Render chat interface immediately once we have userId
  return (
    <div className="flex flex-col h-screen bg-black text-white">
      <div className="flex-1 w-full h-full flex flex-col">
        <ChatMessages messages={streamingMessage ? [...chatMessages, streamingMessage] : chatMessages} />
        <UnifiedInput
          value={input}
          onChange={handleInputChange}
          onSubmit={handleSubmit}
          disabled={isStreaming}
        />
      </div>
    </div>
  );
}

export default function Chat() {
  return (
    <SpacesProvider>
      <ConversationsProvider>
        <MessagesProvider>
          <ChatStateProvider>
            <CommandStateProvider>
              <QuickActionsCommandProvider>
                <ChatContent />
              </QuickActionsCommandProvider>
            </CommandStateProvider>
          </ChatStateProvider>
        </MessagesProvider>
      </ConversationsProvider>
    </SpacesProvider>
  );
}

================
File: app/actions.ts
================
"use server";

import { encodedRedirect } from "@/utils/utils";
import { createClient } from "@/utils/supabase/server";
import { headers } from "next/headers";
import { redirect } from "next/navigation";

export const signUpAction = async (formData: FormData) => {
  const email = formData.get("email")?.toString();
  const password = formData.get("password")?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get("origin");

  if (!email || !password) {
    return encodedRedirect(
      "error",
      "/sign-up",
      "Email and password are required",
    );
  }

  const { error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: `${origin}/auth/callback`,
    },
  });

  if (error) {
    console.error(error.code + " " + error.message);
    return encodedRedirect("error", "/sign-up", error.message);
  } else {
    return encodedRedirect(
      "success",
      "/sign-up",
      "Thanks for signing up! Please check your email for a verification link.",
    );
  }
};

export const signInAction = async (formData: FormData) => {
  const email = formData.get("email") as string;
  const password = formData.get("password") as string;
  const supabase = await createClient();

  const { error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    return encodedRedirect("error", "/sign-in", error.message);
  }

  return redirect("/protected");
};

export const forgotPasswordAction = async (formData: FormData) => {
  const email = formData.get("email")?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get("origin");
  const callbackUrl = formData.get("callbackUrl")?.toString();

  if (!email) {
    return encodedRedirect("error", "/forgot-password", "Email is required");
  }

  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${origin}/auth/callback?redirect_to=/protected/reset-password`,
  });

  if (error) {
    console.error(error.message);
    return encodedRedirect(
      "error",
      "/forgot-password",
      "Could not reset password",
    );
  }

  if (callbackUrl) {
    return redirect(callbackUrl);
  }

  return encodedRedirect(
    "success",
    "/forgot-password",
    "Check your email for a link to reset your password.",
  );
};

export const resetPasswordAction = async (formData: FormData) => {
  const supabase = await createClient();

  const password = formData.get("password") as string;
  const confirmPassword = formData.get("confirmPassword") as string;

  if (!password || !confirmPassword) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Password and confirm password are required",
    );
  }

  if (password !== confirmPassword) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Passwords do not match",
    );
  }

  const { error } = await supabase.auth.updateUser({
    password: password,
  });

  if (error) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Password update failed",
    );
  }

  encodedRedirect("success", "/protected/reset-password", "Password updated");
};

export const signOutAction = async () => {
  const supabase = await createClient();
  await supabase.auth.signOut();
  return redirect("/sign-in");
};

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  color-scheme: dark;
  --background: #000000;
  --surface: #151515;
  --surface-elevated: #1f1f1f;
  --primary: #5E6AD2;
  --primary-light: #8A94F0;
  --text: #FFFFFF;
  --text-secondary: rgba(255, 255, 255, 0.6);
  --border: rgba(255, 255, 255, 0.1);
  --radius: 0.5rem;
}

body {
  margin: 0;
  overflow: hidden;
  background: var(--background);
  font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
}

.glass {
  background: rgba(255, 255, 255, 0.03);
  backdrop-filter: blur(8px);
  border: 1px solid var(--border);
  border-radius: 8px;
}

.glass-hover {
  transition: all 0.2s ease;
}

.glass-hover:hover {
  background: rgba(255, 255, 255, 0.06);
  border-color: rgba(255, 255, 255, 0.15);
}

input, textarea {
  background: transparent;
  color: var(--text);
  font-size: 14px;
  line-height: 1.5;
  transition: all 0.2s ease;
}

input:focus, textarea:focus {
  outline: none;
  background: rgba(255, 255, 255, 0.03);
}

.btn {
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.btn-primary {
  background: var(--primary);
  color: white;
}

.btn-primary:hover {
  background: var(--primary-light);
}

::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.15);
}

.command-content {
  transition: opacity 0.2s ease, transform 0.2s ease;
}

.command-content-enter {
  opacity: 0;
  transform: translateY(10px);
}

.command-content-exit {
  opacity: 0;
  transform: translateY(-10px);
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Spatial",
  description: "Spatial App",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
          {children}
      </body>
    </html>
  );
}

================
File: app/page.tsx
================
import Hero from "@/components/hero";

export default async function Home() {
  return (
    <>
      <Hero />
      <main className="flex-1 flex flex-col gap-6 px-4">
        <h2 className="font-medium text-xl mb-4">Next steps</h2>
      </main>
    </>
  );
}

================
File: components/ui/badge.tsx
================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

================
File: components/ui/button.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        ghost: "hover:bg-zinc-700/50 text-zinc-400",
        toggle: "hover:bg-zinc-700/50 text-zinc-300 border-t border-zinc-700/50 rounded-t-md rounded-b-none",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-8 px-3 rounded-md",
        icon: "h-8 w-8",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  active?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, active, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }), active && "bg-zinc-700/50")}
        ref={ref}
        {...props}
      />
    )
  },
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/chat-content-client.tsx
================
"use client";

import { useChat } from "ai/react";
import { UnifiedInput } from "@/components/ui/unified-input";
import { ChatMessages } from "@/components/ui/chat-messages";
import { CommandStateProvider } from "@/components/ui/command-state-provider";
import { QuickActionsCommandProvider } from "@/components/ui/quick-actions-command-provider";
import { SpacesProvider, useSpaces } from "@/hooks/spaces-provider";
import { ConversationsProvider, useConversations } from "@/hooks/conversations-provider";
import { MessagesProvider, useMessages } from "@/hooks/messages-provider";
import { ChatStateProvider, useChatState } from "@/hooks/chat-state-provider";
import { Message, convertToAIMessage, Space, Conversation } from "@/types";
import { useCallback, useState, useEffect, useMemo } from "react";
import { User } from "@supabase/supabase-js";

interface ChatContentClientProps {
  initialData: {
    user: User | null;
    spaces: Space[] | null;
    activeSpace: Space | null;
    conversations: Conversation[] | null;
    messages: { [conversationId: string]: Message[] };
  };
}

function ChatContentClient({ initialData }: ChatContentClientProps) {
  const { activeSpace, setSpaces, setActiveSpace } = useSpaces();
  const { activeConversation, setConversations, setActiveConversation } = useConversations();
  const { messages: chatMessages, addMessage, setMessages } = useMessages();
  const { batchUpdate } = useChatState();

  useEffect(() => {
    if (initialData.spaces) {
      setSpaces(initialData.spaces);
    }
    if (initialData.activeSpace) {
        setActiveSpace(initialData.activeSpace);
    }

    if (initialData.conversations) {
        setConversations(initialData.conversations);
    }

    if(initialData.conversations && initialData.conversations.length > 0){
        setActiveConversation(initialData.conversations[0])
    }

    if (initialData.messages && initialData.conversations && initialData.conversations.length > 0) {

      setMessages(initialData.messages[initialData.conversations[0].id] || []);
    }

  }, [initialData, setSpaces, setConversations, setMessages]);



  const [streamingMessage, setStreamingMessage] = useState<Message | null>(null);
  const userId = initialData.user?.id;


    const {
        messages: aiMessages,
        input,
        handleInputChange,
        handleSubmit: originalHandleSubmit,
        isLoading: isStreaming,
    } = useChat({
        api: "/api/chat",
        body: {
            spaceId: activeSpace?.id,
            model: activeSpace?.model,
            provider: activeSpace?.provider,
        },
        id: activeConversation?.id,
        initialMessages: useMemo(() => {
            return chatMessages.map(convertToAIMessage)
        }, [chatMessages]),
        onResponse: (response: Response) => {
            if (!response.ok) {
                console.error('Failed to get response from server', response.status, response.statusText);
                batchUpdate({ error: 'Failed to get response from server' });
            } else {
                batchUpdate({ isLoading: true, error: null });
            }
        },
        onFinish: async (message: { content: string }) => {
            if (!activeSpace?.id || !activeConversation?.id || !userId) return;

            try {
                const response = await fetch('/api/messages', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation_id: activeConversation.id,
                        user_id: userId,
                        role: 'assistant',
                        content: message.content,
                        model_used: activeSpace.model,
                        provider: activeSpace.provider
                    }),
                });

                if (!response.ok) {
                    throw new Error(`Failed to save assistant message: ${response.status} ${response.statusText}`);
                }

                const assistantMessageData = await response.json();
                if (!assistantMessageData.id) throw new Error('Failed to save assistant message: Invalid API response');

                // Add the full message from the database
                addMessage(assistantMessageData);
                // Clear the streaming message since we now have the final version
                setStreamingMessage(null);

            } catch (error) {
                console.error('Error saving assistant message:', error);
                batchUpdate({ error: 'Failed to save assistant message' });
            } finally {
                batchUpdate({ isLoading: false });
            }
        },
    });

    // Update streaming message whenever AI messages change
    useEffect(() => {
        if (!isStreaming || aiMessages.length === 0) return;

        const lastMessage = aiMessages[aiMessages.length - 1];
        if (lastMessage.role === 'assistant') {
            setStreamingMessage(prev => {
                if (!prev || prev.content !== lastMessage.content) {
                    return {
                        id: lastMessage.id,
                        conversation_id: activeConversation?.id || '',
                        user_id: userId || '',
                        role: 'assistant',
                        content: lastMessage.content,
                        model_used: activeSpace?.model,
                        provider: activeSpace?.provider,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    };
                }
                return prev;
            });
        }
    }, [aiMessages, isStreaming, activeSpace?.model, activeSpace?.provider, activeConversation?.id, userId]);

  const handleSubmit = useCallback(
    async (e?: React.FormEvent) => {
      e?.preventDefault();
      if (!input.trim() || isStreaming || !userId || !activeConversation?.id) return;

      batchUpdate({ isLoading: true, error: null });

      try {
        const response = await fetch("/api/messages", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            conversation_id: activeConversation.id,
            user_id: userId,
            role: "user",
            content: input,
            model_used: activeSpace?.model,
            provider: activeSpace?.provider,
          }),
        });

        if (!response.ok) {
          throw new Error(
            `Failed to save user message: ${response.status} ${response.statusText}`,
          );
        }
        const userMessageData = await response.json();
        if (!userMessageData.id)
          throw new Error("Failed to save user message: Invalid API response");

        // Add the full message from the database
        addMessage(userMessageData);

        // Create skeleton assistant message immediately
        setStreamingMessage({
          id: crypto.randomUUID(),
          conversation_id: activeConversation.id,
          user_id: userId,
          role: "assistant",
          content: "",
          model_used: activeSpace?.model,
          provider: activeSpace?.provider,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        });

        await originalHandleSubmit(e);
      } catch (error) {
        console.error("Error in handleSubmit:", error);
        batchUpdate({ isLoading: false, error: "Failed to send message" });
        // Clear streaming message if there's an error
        setStreamingMessage(null);
      }
    },
    [
      input,
      isStreaming,
      userId,
      activeConversation?.id,
      activeSpace?.model,
      activeSpace?.provider,
      originalHandleSubmit,
      batchUpdate,
      addMessage,
    ],
  );


  return (
    <div className="flex flex-col h-screen bg-black text-white">
      <div className="flex-1 w-full h-full flex flex-col">
        <ChatMessages
          messages={
            streamingMessage
              ? [...chatMessages, streamingMessage]
              : chatMessages
          }
        />
        <UnifiedInput
          value={input}
          onChange={handleInputChange}
          onSubmit={handleSubmit}
          disabled={isStreaming}
        />
      </div>
    </div>
  );
}


//Wrapping providers.
export default function Chat() {

    return (
        <SpacesProvider>
            <ConversationsProvider>
                <MessagesProvider>
                    <ChatStateProvider>
                        <CommandStateProvider>
                            <QuickActionsCommandProvider>
                                <ChatContentClient initialData={{
                                    user: null,
                                    spaces: [],
                                    activeSpace: null,
                                    conversations: [],
                                    messages: {}
                                }} />
                            </QuickActionsCommandProvider>
                        </CommandStateProvider>
                    </ChatStateProvider>
                </MessagesProvider>
            </ConversationsProvider>
        </SpacesProvider>
    );
}

================
File: components/ui/chat-message.tsx
================
'use client';

import { User } from 'lucide-react';
import { FC } from 'react';
import { Message } from '@/types';
import { getModelName, type Provider } from '@/config/models';
import { ProviderIcon } from './provider-icon';

interface ChatMessageProps {
  message: Message;
}

export const ChatMessage: FC<ChatMessageProps> = ({ message }) => {
  const isUser = message.role === 'user';
  const content = isUser 
    ? message.content 
    : message.content;

  // Get model name and provider display
  const modelName = message.model_used && message.provider
    ? getModelName(message.provider as Provider, message.model_used)
    : message.model_used || 'AI';
  const providerName = message.provider 
    ? message.provider.charAt(0).toUpperCase() + message.provider.slice(1)
    : '';

  return (
    <div className={`flex items-start gap-4 ${isUser ? 'justify-end' : ''} w-full max-w-7xl mx-auto group transition-opacity`}>
      {!isUser && (
        <div className="flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-md border bg-gradient-to-b from-white/[0.07] to-white/[0.03] border-white/[0.05] relative">
          <div className="absolute inset-0 rounded-md bg-blue-500/20 blur-sm" />
          <div className="w-5 h-5 rounded-full bg-gradient-to-br from-blue-400 to-indigo-500 relative">
            <div className="absolute inset-0 rounded-full bg-gradient-to-t from-transparent to-white/30" />
            <div className="absolute -inset-1 rounded-full bg-blue-500/20 blur-sm animate-pulse" />
          </div>
        </div>
      )}
      <div className={`flex-1 space-y-2 overflow-hidden ${isUser ? 'text-right' : ''} max-w-[85%]`}>
        <div className={`prose prose-invert max-w-none ${isUser ? 'ml-auto' : 'mr-auto'}`}>
          {message.role === 'assistant' && (
            <div className="flex items-center gap-1.5 mb-2.5">
              {message.provider && (
                <div className="px-2 py-0.5 rounded backdrop-blur-2xl bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit
                  before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
                  <ProviderIcon provider={message.provider as Provider} size={14} />
                </div>
              )}
              <div className="px-2.5 py-0.5 rounded backdrop-blur-2xl bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit
                before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
                <span className="text-white">{modelName}</span>
              </div>
            </div>
          )}
          <p className={`text-sm leading-relaxed whitespace-pre-wrap break-words ${
            isUser 
              ? 'text-white shadow-[0_0_15px_-5px_rgba(255,255,255,0.3)]' 
              : 'text-white/90'
          }`}>
            {content || (
              <span className="flex gap-1">
                <span className="inline-block w-12 h-4 bg-white/[0.07] rounded animate-pulse" />
                <span className="inline-block w-16 h-4 bg-white/[0.07] rounded animate-pulse" />
                <span className="inline-block w-8 h-4 bg-white/[0.07] rounded animate-pulse" />
              </span>
            )}
          </p>
        </div>
      </div>
      {isUser && (
        <div className="flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1] relative overflow-hidden backdrop-blur-sm">
          <div className="absolute inset-0 bg-gradient-to-b from-white/[0.08] to-transparent" />
          <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_120%,rgba(255,255,255,0.1),transparent)]" />
          <div className="relative z-10 w-5 h-5 rounded-full bg-white/[0.1] flex items-center justify-center backdrop-blur-md">
            <div className="absolute inset-0 rounded-full bg-gradient-to-t from-transparent to-white/20" />
            <User className="h-3 w-3 text-white relative z-10" />
            <div className="absolute -inset-1 rounded-full bg-white/10 blur-md" />
          </div>
          <div className="absolute inset-0 bg-white/5 shadow-[inset_0_0_15px_rgba(255,255,255,0.2)]" />
        </div>
      )}
    </div>
  );
};

================
File: components/ui/chat-messages.tsx
================
'use client';

import { useStickToBottom } from '@/hooks/use-stick-to-bottom';
import { FC, useEffect, useState } from 'react';
import { ChatMessage } from './chat-message';
import { Message } from '@/types';
import { useChatState } from '@/hooks/chat-state-provider';

interface ChatMessagesProps {
  messages: Message[];
}

export const ChatMessages: FC<ChatMessagesProps> = ({ messages }) => {
  const { containerRef,isStickToBottom } = useStickToBottom();
  const { state: chatState } = useChatState();
  const [isMessagesReady, setIsMessagesReady] = useState(false);

  // Wait for messages to be loaded before showing them
  useEffect(() => {
    if (messages.length > 0) {
      setIsMessagesReady(true);
    }
  }, [messages]);

  // Reset ready state when messages are cleared
  useEffect(() => {
    if (messages.length === 0) {
      setIsMessagesReady(false);
    }
  }, [messages.length]);

  return (
    <div className="relative flex-1 flex flex-col">
      <div 
        ref={isMessagesReady ? containerRef : null}
        className={`absolute inset-0 ${
          isMessagesReady ? 'overflow-y-auto' : 'overflow-hidden'
        } py-12 px-4 pb-52 transition-opacity duration-200 ${
          isMessagesReady ? 'opacity-100' : 'opacity-0'
        }`}
      >
        <div className="max-w-7xl mx-auto">
          <div className="space-y-12 min-h-full">
            {isMessagesReady && messages.map((message, index) => (
              <div key={message.id}>
                <ChatMessage message={message} />
                {index < messages.length - 1 && messages[index].role !== messages[index + 1].role && (
                  <div className="w-full flex justify-center my-8">
                    <div className="w-1/3 h-px bg-white/[0.05]" />
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
      </div>

      {isStickToBottom && isMessagesReady && messages.length > 0 && (
        <button
          onClick={() => containerRef.current?.scrollTo({ top: containerRef.current.scrollHeight, behavior: 'smooth' })}
          className="fixed top-4 left-1/2 -translate-x-1/2 px-3 py-1.5 rounded-lg backdrop-blur-2xl bg-white/[0.03] border border-white/[0.05] text-white text-xs font-medium flex items-center gap-1.5 overflow-hidden
            before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10
            hover:bg-white/[0.05] transition-colors duration-200"
        >
          <span>Scroll to Bottom â†“</span>
        </button>
      )}
    </div>
  );
};

================
File: components/ui/checkbox.tsx
================
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

================
File: components/ui/command-modal.tsx
================
import { Command } from 'cmdk';
import { motion, AnimatePresence } from 'framer-motion';
import { useState, useEffect, useRef } from 'react';

interface CommandModalProps {
  isOpen: boolean;
  onClose: () => void;
  placeholder?: string;
  children?: React.ReactNode;
  leftElement?: React.ReactNode;
  footerElement?: React.ReactNode;
  searchValue?: string;
  onSearchChange?: (value: string) => void;
  hideSearch?: boolean;
  // Navigation state
  showSpaceForm?: boolean;
  setShowSpaceForm?: (show: boolean) => void;
  showSpaces?: boolean;
  setShowSpaces?: (show: boolean) => void;
  showModels?: boolean;
  setShowModels?: (show: boolean) => void;
  selectedProvider?: any;
  setSelectedProvider?: (provider: any) => void;
}

export function CommandModal({ 
  isOpen, 
  onClose, 
  placeholder = 'Type a command or search...', 
  children, 
  leftElement,
  footerElement,
  searchValue,
  onSearchChange,
  hideSearch = false,
  showSpaceForm,
  setShowSpaceForm,
  showSpaces,
  setShowSpaces,
  showModels,
  setShowModels,
  selectedProvider,
  setSelectedProvider
}: CommandModalProps) {
  const [isFocused, setIsFocused] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);

  // Auto-focus the input when the modal opens
  useEffect(() => {
    if (isOpen && !hideSearch) {
      // Small delay to ensure the modal is rendered
      const timeoutId = setTimeout(() => {
        inputRef.current?.focus();
      }, 50);
      return () => clearTimeout(timeoutId);
    }
  }, [isOpen, hideSearch]);

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-50 flex items-start justify-center pt-[15vh]">
          {/* Backdrop with enhanced blur */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="absolute inset-0 bg-black/80 backdrop-blur-md"
            onClick={onClose}
          />

          {/* Command Menu */}
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.2 }}
            className="relative w-full max-w-2xl"
          >
            <div
              className={`
                relative overflow-hidden rounded-xl
                bg-black border border-white/[0.2]
                before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.05] before:to-white/[0.02] before:-z-10
                transition-all duration-300
                shadow-[0_0_15px_-5px_rgba(94,106,210,0.4)]
                after:absolute after:inset-0 after:rounded-xl after:-z-20 after:transition-opacity after:duration-300
                after:bg-gradient-to-t after:from-[#5E6AD2]/20 after:to-transparent after:blur-xl
                ${isFocused 
                  ? 'ring-2 ring-[#5E6AD2]/30 ring-offset-0 shadow-[0_0_30px_-5px_rgba(94,106,210,0.6)] after:opacity-100'
                  : 'after:opacity-70'
                }
              `}
            >
              <Command
                className="relative overflow-hidden w-full"
                onKeyDown={(e) => {
                  if (e.key === 'Escape') {
                    onClose();
                  } else if (e.key === 'Backspace' && !searchValue) {
                    // Handle back navigation when search is empty
                    if (showSpaceForm && setShowSpaceForm) {
                      setShowSpaceForm(false);
                      e.preventDefault();
                    } else if (showSpaces && setShowSpaces) {
                      setShowSpaces(false);
                      e.preventDefault();
                    } else if (showModels && setShowModels) {
                      if (selectedProvider && setSelectedProvider) {
                        setSelectedProvider(null);
                      } else {
                        setShowModels(false);
                      }
                      e.preventDefault();
                    }
                  }
                }}
                shouldFilter={true}
                loop
              >
                <div 
                  className={`flex items-center px-4 ${!hideSearch ? 'border-b border-white/10' : 'py-3'}`}
                >
                  {leftElement}
                  {!hideSearch && (
                    <Command.Input
                      ref={inputRef}
                      value={searchValue}
                      onValueChange={onSearchChange}
                      placeholder={placeholder}
                      onFocus={() => setIsFocused(true)}
                      onBlur={() => setIsFocused(false)}
                      className="flex-1 h-14 focus:bg-transparent border-none text-white/90 placeholder:text-white/40 outline-none"
                    />
                  )}
                </div>

                <div className="flex flex-col h-[min(60vh,400px)]">
                  <Command.List className="flex-1 overflow-y-auto overscroll-contain scrollbar-thin scrollbar-track-transparent scrollbar-thumb-white/10 p-2">
                    {!hideSearch && searchValue && (
                      <Command.Empty className="py-6 text-center text-sm text-white/40">
                        No results found.
                      </Command.Empty>
                    )}

                    {children}
                  </Command.List>

                  {footerElement && (
                    <div className="flex items-center justify-center p-2 border-t border-white/10">
                      {footerElement}
                    </div>
                  )}
                </div>
              </Command>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}

================
File: components/ui/command-state-provider.tsx
================
'use client';

import React, { createContext, useContext, useState } from 'react';

type CommandType = 'quick-actions' | 'space' | 'model' | null;

interface CommandStateContextType {
  activeCommand: CommandType;
  setActiveCommand: (command: CommandType) => void;
}

const CommandStateContext = createContext<CommandStateContextType>({
  activeCommand: null,
  setActiveCommand: () => {},
});

export const useCommandState = () => {
  const context = useContext(CommandStateContext);
  if (!context) {
    throw new Error('useCommandState must be used within a CommandStateProvider');
  }
  return context;
};

export const CommandStateProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [activeCommand, setActiveCommand] = useState<CommandType>(null);

  return (
    <CommandStateContext.Provider value={{ activeCommand, setActiveCommand }}>
      {children}
    </CommandStateContext.Provider>
  );
};

================
File: components/ui/dropdown-menu.tsx
================
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

================
File: components/ui/input.tsx
================
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };

================
File: components/ui/label.tsx
================
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

================
File: components/ui/model-tab.tsx
================
import { useSpaces } from '@/hooks/spaces-provider';
import { useQuickActionsCommand } from '@/components/ui/quick-actions-command-provider';
import { getModelName, type Provider } from '@/config/models';
import { ProviderIcon } from './provider-icon';
import React from 'react';

export const ModelTab: React.FC = () => {
  const { activeSpace } = useSpaces();
  const { toggleQuickActionsCommand } = useQuickActionsCommand();

  const modelName = activeSpace?.model && activeSpace?.provider 
    ? getModelName(activeSpace.provider as Provider, activeSpace.model)
    : 'Select Model';

  return (
    <div
      onClick={() => toggleQuickActionsCommand(false, true)}
      className="px-3 py-1 rounded-t-lg backdrop-blur-2xl bg-white/[0.03] border border-white/[0.05] text-white text-xs font-medium flex items-center gap-1.5 relative overflow-hidden cursor-pointer
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10
        hover:bg-white/[0.05] transition-colors"
    >
      {activeSpace?.provider && (
        <ProviderIcon provider={activeSpace.provider as Provider} size={14} className="opacity-75" />
      )}
      <span>{modelName}</span>
      <span className="text-white/60 text-[10px] ml-1">âŒ˜M</span>
    </div>
  );
};

================
File: components/ui/provider-icon.tsx
================
import { 
  Anthropic, 
  OpenAI, 
  Cohere, 
  Mistral, 
  Google, 
  XAI, 
  Together, 
  DeepSeek, 
  Perplexity, 
  Groq 
} from '@lobehub/icons';
import { Provider } from '@/config/models';

interface ProviderIconProps {
  provider: Provider;
  size?: number;
  className?: string;
}

const PROVIDER_COMPONENTS = {
  groq: Groq,
  anthropic: Anthropic,
  openai: OpenAI,
  cohere: Cohere.Color,
  mistral: Mistral.Color,
  google: Google.Color,
  xai: XAI,
  togetherai: Together.Color,
  deepseek: DeepSeek.Color,
  cerebras: OpenAI,
  perplexity: Perplexity.Color
} as const;

export function ProviderIcon({ provider, size = 24, className = '' }: ProviderIconProps) {
  const IconComponent = PROVIDER_COMPONENTS[provider];
  if (!IconComponent) return null;
  
  return (
    <div className={`relative inline-block ${className}`} style={{ width: size, height: size }}>
      <IconComponent size={size} />
    </div>
  );
}

================
File: components/ui/quick-actions-command-provider.tsx
================
'use client';

import React, { createContext, useContext, useEffect, useState } from 'react';
import { QuickActionsCommand } from '@/components/ui/quick-actions-command';
import { useCommandState } from '@/components/ui/command-state-provider';

interface QuickActionsCommandContextType {
  isOpen: boolean;
  openQuickActionsCommand: (withSpaces?: boolean) => void;
  closeQuickActionsCommand: () => void;
  toggleQuickActionsCommand: (withSpaces?: boolean, withModels?: boolean) => void;
  isExecuting: boolean;
  handleGlobalCommand: (handler: () => void) => void;
  showSpaces: boolean;
  setShowSpaces: (show: boolean) => void;
  showModels: boolean;
  setShowModels: (show: boolean) => void;
}

const QuickActionsCommandContext = createContext<QuickActionsCommandContextType>({
  isOpen: false,
  openQuickActionsCommand: () => {},
  closeQuickActionsCommand: () => {},
  toggleQuickActionsCommand: () => {},
  isExecuting: false,
  handleGlobalCommand: () => {},
  showSpaces: false,
  setShowSpaces: () => {},
  showModels: false,
  setShowModels: () => {},
});

export const useQuickActionsCommand = () => {
  const context = useContext(QuickActionsCommandContext);
  if (!context) {
    throw new Error('useQuickActionsCommand must be used within a QuickActionsCommandProvider');
  }
  return context;
};

export const QuickActionsCommandProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isExecuting, setIsExecuting] = useState(false);
  const [showSpaces, setShowSpaces] = useState(false);
  const [showModels, setShowModels] = useState(false);
  const { activeCommand, setActiveCommand } = useCommandState();
  const isOpen = activeCommand === 'quick-actions';

  const openQuickActionsCommand = (withSpaces = false) => {
    setActiveCommand('quick-actions');
    setShowSpaces(withSpaces);
    setShowModels(false);
  };

  const closeQuickActionsCommand = () => {
    setActiveCommand(null);
    setShowSpaces(false);
    setShowModels(false);
  };
  
  const toggleQuickActionsCommand = (withSpaces = false, withModels = false) => {
    if (isOpen) {
      closeQuickActionsCommand();
    } else {
      setActiveCommand('quick-actions');
      setShowSpaces(withSpaces);
      setShowModels(withModels);
    }
  };

  const handleGlobalCommand = (handler: () => void) => {
    if (isExecuting) return;
    setIsExecuting(true);
    try {
      handler();
    } finally {
      setIsExecuting(false);
    }
  };

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.metaKey || e.ctrlKey) {
        // Handle Command/Ctrl + K
        if (e.key.toLowerCase() === 'k') {
          e.preventDefault();
          if (!isExecuting) {
            toggleQuickActionsCommand(false, false);
          }
        }
        // Handle Command/Ctrl + S
        else if (e.key.toLowerCase() === 's') {
          e.preventDefault();
          if (!isExecuting) {
            toggleQuickActionsCommand(true, false);
          }
        }
        // Handle Command/Ctrl + M
        else if (e.key.toLowerCase() === 'm') {
          e.preventDefault();
          if (!isExecuting) {
            toggleQuickActionsCommand(false, true);
          }
        }
      }
    };
  
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isExecuting, isOpen]);

  return (
    <QuickActionsCommandContext.Provider
      value={{
        isOpen,
        openQuickActionsCommand,
        closeQuickActionsCommand,
        toggleQuickActionsCommand,
        isExecuting,
        handleGlobalCommand,
        showSpaces,
        setShowSpaces,
        showModels,
        setShowModels,
      }}
    >
      {children}
      <QuickActionsCommand isOpen={isOpen} onClose={closeQuickActionsCommand} />
    </QuickActionsCommandContext.Provider>
  );
};

================
File: components/ui/quick-actions-command.tsx
================
'use client';

import { CommandModal } from '@/components/ui/command-modal';
import { Sparkles, Image, Link, FileText, Share2, Bookmark, Globe, Plus, Cpu, ArrowLeft } from 'lucide-react';
import { useQuickActionsCommand } from '@/components/ui/quick-actions-command-provider';
import { useSpaces } from '@/hooks/spaces-provider';
import { useChatState } from '@/hooks/chat-state-provider';
import { Command } from 'cmdk';
import { useState, useEffect } from 'react';
import { AVAILABLE_MODELS, PROVIDER_NAMES, type Provider } from '@/config/models';
import { ProviderIcon } from './provider-icon';

interface QuickActionsCommandProps {
  isOpen: boolean;
  onClose: () => void;
}

export const QuickActionsCommand = ({ isOpen, onClose }: QuickActionsCommandProps) => {
  const { isExecuting, handleGlobalCommand, showSpaces, setShowSpaces, showModels, setShowModels } = useQuickActionsCommand();
  const { spaces, setActiveSpace, activeSpace, setSpaces } = useSpaces();
  const { batchUpdate } = useChatState();
  const [searchValue, setSearchValue] = useState('');
  const [selectedProvider, setSelectedProvider] = useState<Provider | null>(null);
  const [showSpaceForm, setShowSpaceForm] = useState(false);
  const [spaceForm, setSpaceForm] = useState<{
    name: string;
    description: string;
    provider: Provider;
    model: string;
  }>({
    name: '',
    description: '',
    provider: 'groq',
    model: AVAILABLE_MODELS['groq'][0]?.id || ''
  });

  // Clear search and selected provider when switching views
  useEffect(() => {
    setSearchValue('');
    setSelectedProvider(null);
  }, [showSpaces, showModels]);

  // Reset form when closing modal
  useEffect(() => {
    if (!isOpen) {
      setShowSpaceForm(false);
      setSpaceForm({
        name: '',
        description: '',
        provider: 'groq',
        model: AVAILABLE_MODELS['groq'][0]?.id || ''
      });
    }
  }, [isOpen]);

  // Add this effect to handle focus when switching views
  useEffect(() => {
    if (showSpaces || showModels || (showModels && selectedProvider)) {
      // Small delay to ensure the list is rendered
      const timeoutId = setTimeout(() => {
        const firstItem = document.querySelector('[cmdk-item]') as HTMLElement;
        if (firstItem) {
          firstItem.dataset.selected = 'true';
          firstItem.focus();
        }
      }, 50);
      return () => clearTimeout(timeoutId);
    }
  }, [showSpaces, showModels, selectedProvider]);

  const handleSpaceSelect = async (spaceId: string) => {
    console.log('Selecting space:', spaceId);
    setSearchValue('');
    onClose();
    
    try {
      console.log('Making request to:', `/api/spaces/${spaceId}`);
      const response = await fetch(`/api/spaces/${spaceId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ setActive: true })
      });
      
      if (!response.ok) {
        throw new Error('Failed to set active space');
      }
      
      const space = await response.json();
      console.log('Received space data:', space);
      
      // Update the spaces list with the new active space
      const updatedSpaces = spaces.map(s => ({
        ...s,
        isActive: s.id === spaceId
      }));
      
      // Ensure active space is first in the list
      const activeSpace = updatedSpaces.find(s => s.id === spaceId);
      const otherSpaces = updatedSpaces.filter(s => s.id !== spaceId);
      const reorderedSpaces = activeSpace ? [activeSpace, ...otherSpaces] : updatedSpaces;
      
      setSpaces(reorderedSpaces);
      setActiveSpace(space);
    } catch (error) {
      console.error('Error switching space:', error);
    }
  };

  const handleCreateSpace = async () => {
    if (!spaceForm.name) return;
    
    // Close modal immediately for better UX
    onClose();
    
    try {
      // Create space and set as active
      const response = await fetch('/api/spaces', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: spaceForm.name,
          description: spaceForm.description,
          model: spaceForm.model || AVAILABLE_MODELS[spaceForm.provider][0]?.id,
          provider: spaceForm.provider,
          setActive: true
        })
      });

      if (!response.ok) {
        throw new Error('Failed to create space');
      }

      const newSpace = await response.json();
      
      // Create initial conversation synchronously
      const convResponse = await fetch('/api/conversations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          space_id: newSpace.id,
          title: 'Getting Started'
        })
      });

      if (!convResponse.ok) {
        throw new Error('Failed to create conversation');
      }

      const newConversation = await convResponse.json();

      // Create welcome message synchronously
      const messageResponse = await fetch('/api/messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          conversation_id: newConversation.id,
          role: 'assistant',
          content: 'Welcome to your new space! I\'m here to help you explore and create. What would you like to do?',
          model_used: newSpace.model,
          provider: newSpace.provider
        })
      });

      if (!messageResponse.ok) {
        throw new Error('Failed to create welcome message');
      }

      const welcomeMessage = await messageResponse.json();
      
      // Update local state with all the new data
      const updatedSpaces = spaces.map(space => ({
        ...space,
        isActive: false
      }));
      
      const newSpaces = [
        { ...newSpace, isActive: true },
        ...updatedSpaces
      ];
      
      setSpaces(newSpaces);
      setActiveSpace({ 
        ...newSpace, 
        isActive: true,
        default_conversation: newConversation,
        welcome_message: welcomeMessage
      });

    } catch (error) {
      console.error('Error creating space:', error);
    }
  };

  const handleModelSelect = async (modelId: string, provider: Provider) => {
    if (!activeSpace) return;
    setSearchValue('');
    onClose();
    
    try {
      const response = await fetch(`/api/spaces/${activeSpace.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: modelId,
          provider: provider
        })
      });

      const updatedSpace = await response.json();
      if (!updatedSpace.error) {
        setActiveSpace(updatedSpace);
      }
    } catch (error) {
      console.error('Error updating model:', error);
    }
  };

  const quickActions = [
    { 
      id: 'spaces',
      name: 'Spaces',
      icon: <Globe className="w-4 h-4" />,
      shortcut: ['âŒ˜', 'S'],
      callback: () => {
        setShowSpaces(true)
        setSearchValue('')
      }
    },
    {
      id: 'models',
      name: 'Models',
      icon: <Cpu className="w-4 h-4" />,
      shortcut: ['âŒ˜', 'M'],
      callback: () => {
        setShowModels(true)
        setSearchValue('')
      }
    },
    { 
      id: 'generate',
      name: 'Generate Content',
      icon: <Sparkles className="w-4 h-4" />,
      callback: () => handleGlobalCommand(() => console.log('Generate'))
    },
    { 
      id: 'image',
      name: 'Create Image',
      icon: <Image className="w-4 h-4" />,
      callback: () => handleGlobalCommand(() => console.log('Image'))
    },
    { 
      id: 'link',
      name: 'Add Link',
      icon: <Link className="w-4 h-4" />,
      callback: () => handleGlobalCommand(() => console.log('Link'))
    },
    { 
      id: 'document',
      name: 'New Document',
      icon: <FileText className="w-4 h-4" />,
      callback: () => handleGlobalCommand(() => console.log('Doc'))
    },
    { 
      id: 'share',
      name: 'Share',
      icon: <Share2 className="w-4 h-4" />,
      callback: () => handleGlobalCommand(() => console.log('Share'))
    },
    { 
      id: 'bookmark',
      name: 'Bookmark',
      icon: <Bookmark className="w-4 h-4" />,
      callback: () => handleGlobalCommand(() => console.log('Bookmark'))
    },
  ];

  const commandItemBaseClass = `group relative flex items-center gap-3 mx-2 my-1 px-4 py-3 text-sm text-white/90 outline-none
    transition-all duration-200 rounded-lg backdrop-blur-sm border border-transparent
    data-[selected=true]:bg-white/[0.08] data-[selected=true]:border-white/20 data-[selected=true]:text-white
    hover:bg-white/[0.08] hover:border-white/20`;

  const createSpaceButton = (
    <Command.Item
      value="new-space create-space"
      onSelect={() => {
        setShowSpaceForm(true)
        setSearchValue('')
      }}
      className="flex items-center gap-2 px-4 py-2 text-sm text-white/90 bg-[#5E6AD2] hover:bg-[#4F5ABF] rounded-md transition-colors
        border border-white/10 backdrop-blur-xl w-full max-w-[200px] justify-center font-medium"
    >
      <Plus className="w-4 h-4" />
      <span>Create New Space</span>
    </Command.Item>
  );

  return (
    <CommandModal
      isOpen={isOpen}
      onClose={() => {
        onClose();
        setShowSpaces(false);
        setShowModels(false);
        setSearchValue('');
        setSelectedProvider(null);
        setShowSpaceForm(false);
      }}
      placeholder={
        showSpaceForm
          ? "Configure your new space..."
          : showSpaces 
            ? "Search spaces..." 
            : showModels 
              ? selectedProvider 
                ? `Search ${PROVIDER_NAMES[selectedProvider]} models...`
                : "Select a provider..."
              : "Search quick actions..."
      }
      searchValue={showSpaceForm ? '' : searchValue}
      onSearchChange={showSpaceForm ? undefined : setSearchValue}
      hideSearch={showSpaceForm}
      leftElement={
        (showSpaces || showModels || showSpaceForm) ? (
          <button
            onClick={() => {
              if (showSpaceForm) {
                setShowSpaceForm(false);
              } else if (showSpaces) {
                setShowSpaces(false);
              } else if (showModels) {
                if (selectedProvider) {
                  setSelectedProvider(null);
                } else {
                  setShowModels(false);
                }
              }
              setSearchValue('');
            }}
            className="flex items-center gap-2 text-white/70 hover:text-white transition-colors px-2 py-1 rounded-md
              border border-white/10 bg-white/5 hover:bg-white/10 mr-2"
          >
            <ArrowLeft className="w-4 h-4" />
            <span className="text-sm font-medium">Back</span>
          </button>
        ) : null
      }
      footerElement={showSpaces && !showSpaceForm ? createSpaceButton : null}
      showSpaceForm={showSpaceForm}
      setShowSpaceForm={setShowSpaceForm}
      showSpaces={showSpaces}
      setShowSpaces={setShowSpaces}
      showModels={showModels}
      setShowModels={setShowModels}
      selectedProvider={selectedProvider}
      setSelectedProvider={setSelectedProvider}
    >
      <Command.List>
        {showSpaceForm ? (
          <Command.Group>
            <div className="flex flex-col">
              <div className="p-4 space-y-4">
                <div>
                  <label className="block text-sm font-medium text-white/70 mb-1">Name</label>
                  <input
                    type="text"
                    value={spaceForm.name}
                    onChange={(e) => setSpaceForm(prev => ({ ...prev, name: e.target.value }))}
                    className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-md text-white/90 text-sm
                      focus:outline-none focus:ring-2 focus:ring-[#5E6AD2]/50"
                    placeholder="Enter space name"
                    autoFocus
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white/70 mb-1">Description (Optional)</label>
                  <input
                    type="text"
                    value={spaceForm.description}
                    onChange={(e) => setSpaceForm(prev => ({ ...prev, description: e.target.value }))}
                    className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-md text-white/90 text-sm
                      focus:outline-none focus:ring-2 focus:ring-[#5E6AD2]/50"
                    placeholder="Enter space description"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-white/70 mb-1">Provider</label>
                  <select
                    value={spaceForm.provider}
                    onChange={(e) => {
                      const provider = e.target.value as Provider;
                      setSpaceForm(prev => ({ 
                        ...prev, 
                        provider,
                        model: AVAILABLE_MODELS[provider][0]?.id || ''
                      }));
                    }}
                    className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-md text-white/90 text-sm
                      focus:outline-none focus:ring-2 focus:ring-[#5E6AD2]/50"
                  >
                    {Object.entries(PROVIDER_NAMES).map(([provider, name]) => (
                      <option key={provider} value={provider}>{name}</option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-white/70 mb-1">Model</label>
                  <select
                    value={spaceForm.model}
                    onChange={(e) => setSpaceForm(prev => ({ ...prev, model: e.target.value }))}
                    className="w-full px-3 py-2 bg-white/5 border border-white/10 rounded-md text-white/90 text-sm
                      focus:outline-none focus:ring-2 focus:ring-[#5E6AD2]/50"
                  >
                    {AVAILABLE_MODELS[spaceForm.provider].map((model) => (
                      <option key={model.id} value={model.id}>{model.name}</option>
                    ))}
                  </select>
                </div>
                <div className="flex justify-center">
                  <button
                    onClick={handleCreateSpace}
                    disabled={!spaceForm.name}
                    className="px-8 py-1.5 bg-[#5E6AD2] text-white/90 rounded-md text-xs font-medium
                      hover:bg-[#4F5ABF] disabled:opacity-50 disabled:cursor-not-allowed transition-colors
                      border border-white/10 backdrop-blur-xl"
                  >
                    Create Space
                  </button>
                </div>
              </div>
            </div>
          </Command.Group>
        ) : !showSpaces && !showModels ? (
          <Command.Group>
            {quickActions.map((item, index) => (
              <Command.Item
                key={item.id}
                value={`${item.id} ${item.name}`}
                onSelect={() => {
                  item.callback?.();
                }}
                data-selected={index === 0 ? 'true' : undefined}
                className={commandItemBaseClass}
              >
                <span className="flex-shrink-0 opacity-70 group-hover:opacity-100 group-data-[selected=true]:opacity-100 transition-opacity">
                  {item.icon}
                </span>
                <span className="flex-1 transition-colors duration-200 group-hover:text-white">
                  {item.name}
                </span>
                {item.shortcut?.length && (
                  <span className="flex items-center gap-1">
                    {item.shortcut.map((key, index) => (
                      <kbd
                        key={`${item.id}-shortcut-${index}`}
                        className="flex items-center justify-center w-6 h-6 rounded bg-white/5 text-[10px] font-medium text-white/40 border border-white/10 transition-colors group-hover:bg-white/10 group-data-[selected=true]:bg-white/10"
                      >
                        {key}
                      </kbd>
                    ))}
                  </span>
                )}
              </Command.Item>
            ))}
          </Command.Group>
        ) : showSpaces ? (
          <Command.Group>
            {spaces.length === 0 ? (
              <div className="flex flex-col items-center justify-center py-8 text-white/40">
                <p className="text-sm mb-4">No spaces found</p>
              </div>
            ) : (
              <>
                {spaces.map((space, index) => (
                  <Command.Item
                    key={space.id}
                    value={`space ${space.id} ${space.name}`}
                    onSelect={() => handleSpaceSelect(space.id)}
                    data-selected={index === 0 ? 'true' : undefined}
                    className={`group relative flex items-center gap-3 mx-2 my-1 px-4 py-3 text-sm outline-none
                      transition-all duration-200 rounded-lg backdrop-blur-sm
                      data-[selected=true]:bg-white/[0.08] data-[selected=true]:border-white/20 data-[selected=true]:text-white
                      hover:bg-white/[0.08] hover:border-white/20
                      ${space.isActive 
                        ? 'bg-white/[0.05] border border-white/10 shadow-[0_0_1px_rgba(255,255,255,0.1)]' 
                        : 'text-white/90 border border-transparent'}`}
                  >
                    <div className={`w-2 h-2 rounded-full transition-all duration-200 
                      ${space.isActive 
                        ? 'bg-blue-500 ring-2 ring-blue-500/20' 
                        : 'bg-white/20 group-hover:bg-white/40 group-data-[selected=true]:bg-white/40'}`} />
                    <span className={`transition-all duration-200 
                      ${space.isActive 
                        ? 'text-white font-medium' 
                        : 'text-white/90 group-hover:text-white group-data-[selected=true]:text-white'}`}>
                      {space.name}
                    </span>
                    {space.isActive && (
                      <span className="ml-auto text-[10px] text-white/40 border border-white/10 px-1.5 py-0.5 rounded-md">
                        Active
                      </span>
                    )}
                  </Command.Item>
                ))}
              </>
            )}
          </Command.Group>
        ) : (
          <>
            {!selectedProvider ? (
              <Command.Group>
                {Object.entries(PROVIDER_NAMES).map(([provider, name], index) => (
                  <Command.Item
                    key={provider}
                    value={`provider ${provider} ${name}`}
                    onSelect={() => {
                      setSelectedProvider(provider as Provider)
                      setSearchValue('')
                    }}
                    data-selected={index === 0 ? 'true' : undefined}
                    className={`group relative flex items-center gap-3 mx-2 my-1 px-4 py-3 text-sm outline-none
                      transition-all duration-200 rounded-lg backdrop-blur-sm
                      data-[selected=true]:bg-white/[0.08] data-[selected=true]:border-white/20 data-[selected=true]:text-white
                      hover:bg-white/[0.08] hover:border-white/20
                      ${activeSpace?.provider === provider 
                        ? 'bg-white/[0.05] border border-white/10 shadow-[0_0_1px_rgba(255,255,255,0.1)]' 
                        : 'text-white/90 border border-transparent'}`}
                  >
                    <ProviderIcon 
                      provider={provider as Provider} 
                      size={16} 
                      className={`transition-opacity duration-200 
                        ${activeSpace?.provider === provider 
                          ? 'opacity-100' 
                          : 'opacity-75 group-hover:opacity-100 group-data-[selected=true]:opacity-100'}`} 
                    />
                    <span className={`transition-all duration-200 
                      ${activeSpace?.provider === provider 
                        ? 'text-white font-medium' 
                        : 'text-white/90 group-hover:text-white group-data-[selected=true]:text-white'}`}>
                      {name}
                    </span>
                    {activeSpace?.provider === provider && (
                      <span className="ml-auto text-[10px] text-white/40 border border-white/10 px-1.5 py-0.5 rounded-md">
                        Active
                      </span>
                    )}
                  </Command.Item>
                ))}
              </Command.Group>
            ) : (
              <Command.Group>
                {AVAILABLE_MODELS[selectedProvider].map((model, index) => (
                  <Command.Item
                    key={model.id}
                    value={`model ${model.id} ${model.name}`}
                    onSelect={() => handleModelSelect(model.id, selectedProvider)}
                    data-selected={index === 0 ? 'true' : undefined}
                    className={`group relative flex items-center gap-3 mx-2 my-1 px-4 py-3 text-sm outline-none
                      transition-all duration-200 rounded-lg backdrop-blur-sm
                      data-[selected=true]:bg-white/[0.08] data-[selected=true]:border-white/20 data-[selected=true]:text-white
                      hover:bg-white/[0.08] hover:border-white/20
                      ${activeSpace?.model === model.id 
                        ? 'bg-white/[0.05] border border-white/10 shadow-[0_0_1px_rgba(255,255,255,0.1)]' 
                        : 'text-white/90 border border-transparent'}`}
                  >
                    <ProviderIcon 
                      provider={selectedProvider} 
                      size={16} 
                      className={`transition-opacity duration-200 
                        ${activeSpace?.model === model.id 
                          ? 'opacity-100' 
                          : 'opacity-75 group-hover:opacity-100 group-data-[selected=true]:opacity-100'}`} 
                    />
                    <span className={`transition-all duration-200 
                      ${activeSpace?.model === model.id 
                        ? 'text-white font-medium' 
                        : 'text-white/90 group-hover:text-white group-data-[selected=true]:text-white'}`}>
                      {model.name}
                    </span>
                    {activeSpace?.model === model.id && (
                      <span className="ml-auto text-[10px] text-white/40 border border-white/10 px-1.5 py-0.5 rounded-md">
                        Active
                      </span>
                    )}
                  </Command.Item>
                ))}
              </Command.Group>
            )}
          </>
        )}
      </Command.List>
    </CommandModal>
  );
};

================
File: components/ui/quick-actions-tab.tsx
================
import { Sparkles } from "lucide-react";
import { useQuickActionsCommand } from '@/components/ui/quick-actions-command-provider';

export default function QuickActionsTab() {
    const { openQuickActionsCommand } = useQuickActionsCommand();

    return (
        <button
            onClick={() => openQuickActionsCommand(false)}
            className="px-3 py-1 rounded-t-lg backdrop-blur-2xl bg-white/[0.03] border border-white/[0.05] text-white text-xs font-medium flex items-center gap-1.5 relative overflow-hidden
              before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10
              hover:bg-white/[0.05] transition-colors cursor-pointer"
        >
            <Sparkles className="w-3 h-3" />
            Quick Actions
            <span className="text-white/60 text-[10px]">âŒ˜K</span>
        </button>
    );
}

================
File: components/ui/space-tab.tsx
================
import { useSpaces } from '@/hooks/spaces-provider';
import { useQuickActionsCommand } from '@/components/ui/quick-actions-command-provider';
import React from 'react';

export const SpaceTab: React.FC = () => {
  const { activeSpace } = useSpaces();
  const { openQuickActionsCommand } = useQuickActionsCommand();

  const handleClick = () => {
    openQuickActionsCommand(true);
  };

  return (
    <div
      onClick={handleClick}
      className="px-3 py-1 rounded-t-lg backdrop-blur-2xl bg-white/[0.03] border border-white/[0.05] text-white text-xs font-medium flex items-center gap-1.5 relative overflow-hidden cursor-pointer
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10
        hover:bg-white/[0.05] transition-colors"
    >
      <div className="w-2 h-2 rounded-full bg-blue-500" />
      <span>{activeSpace?.name || 'Select Space'}</span>
      <span className="text-white/60 text-[10px] ml-1">âŒ˜S</span>
    </div>
  );
};

================
File: components/ui/status-tab.tsx
================
import React, { useMemo } from 'react';
import { useChatState } from '@/hooks/chat-state-provider';

export const StatusTab: React.FC = React.memo(() => {
  const { state } = useChatState();

  const { statusText, statusColor } = useMemo(() => {
    const text = state.error 
      ? state.error 
      : state.isLoading 
        ? 'Generating...' 
        : 'Ready';

    const color = state.error 
      ? 'bg-red-500' 
      : state.isLoading 
        ? 'bg-yellow-500' 
        : 'bg-green-500';

    return { statusText: text, statusColor: color };
  }, [state.error, state.isLoading]);

  return (
    <div
      className="px-3 py-1 rounded-t-lg backdrop-blur-2xl bg-white/[0.03] border border-white/[0.05] text-white text-xs font-medium flex items-center gap-1.5 relative overflow-hidden
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10"
    >
      <div className={`w-1.5 h-1.5 rounded-full ${statusColor}`} />
      <span>{statusText}</span>
    </div>
  );
});

================
File: components/ui/unified-input.tsx
================
"use client";

import React, { useState, useRef, useEffect } from 'react';
import { 
  Send, Paperclip, AtSign, Mic, Search, Filter, 
  Calendar, MessageSquare, Command, Sparkles, Image, Link,
  FileText, Share2, Bookmark, Settings, Mail,
  FolderPlus, Users, Clock, Upload, GitBranch, Layers, Globe, Archive, GitMerge
} from 'lucide-react';
import { SpaceTab } from '@/components/ui/space-tab';
import QuickActionsTab from './quick-actions-tab';
import { StatusTab } from '@/components/ui/status-tab';
import { useChatState } from '@/store/chatStateStore';
import { ModelTab } from './model-tab';

interface ActionItem {
  icon: React.ReactNode;
  label: string;
  onClick: () => void;
}

interface UnifiedInputProps {
  value: string;
  onChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => void;
  onSubmit: (e?: React.FormEvent) => Promise<void> | void;
  disabled?: boolean;
}

export const UnifiedInput: React.FC<UnifiedInputProps> = ({ 
  value, 
  onChange, 
  onSubmit,
  disabled
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const { status } = useChatState();
  const isLoading = status === 'generating';

  useEffect(() => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = 'auto';
      const newHeight = Math.min(Math.max(textarea.scrollHeight, 48), 200);
      textarea.style.height = `${newHeight}px`;
    }
  }, [value]);

  const actions: ActionItem[] = [
    {
      label: 'History',
      icon: <Clock className="w-5 h-5" />,
      onClick: () => {/* TODO: Implement history view */}
    },
    {
      label: 'Upload',
      icon: <Upload className="w-5 h-5" />,
      onClick: () => {/* TODO: Implement file upload */}
    },
    {
      label: 'Branch',
      icon: <GitBranch className="w-5 h-5" />,
      onClick: () => {/* TODO: Create new conversation branch */}
    },
    {
      label: 'Context',
      icon: <Layers className="w-5 h-5" />,
      onClick: () => {/* TODO: Open context manager */}
    },
    {
      label: 'Space',
      icon: <Globe className="w-5 h-5" />,
      onClick: () => {/* TODO: Switch workspace */}
    },
    {
      label: 'Archive',
      icon: <Archive className="w-5 h-5" />,
      onClick: () => {/* TODO: Archive conversation */}
    },
    {
      label: 'Merge',
      icon: <GitMerge className="w-5 h-5" />,
      onClick: () => {/* TODO: Merge conversations */}
    },
    {
      label: 'Actions',
      icon: <Command className="w-5 h-5" />,
      onClick: () => {/* TODO: Open actions view */}
    }
  ];

  return (
    <>      
      <div className="fixed left-1/2 bottom-8 -translate-x-1/2 w-[800px] z-50">
        <div className="relative w-full">
          <div className="absolute -top-8 left-0 right-0 flex justify-center z-[100]">
            <div className="flex items-center gap-2">
              <SpaceTab />
              <StatusTab />
              <QuickActionsTab />
              <ModelTab />
            </div>
          </div>
          
          <div 
            className={`
              bg-black border border-white/[0.2]
              before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.05] before:to-white/[0.02] before:-z-10
              p-3 transition-all duration-300 rounded-xl relative overflow-visible
              shadow-[0_0_15px_-5px_rgba(94,106,210,0.4)]
              after:absolute after:inset-0 after:rounded-xl after:-z-20 after:transition-opacity after:duration-300
              after:bg-gradient-to-t after:from-[#5E6AD2]/20 after:to-transparent after:blur-xl
              ${isFocused 
                ? 'ring-2 ring-[#5E6AD2]/30 ring-offset-0 shadow-[0_0_30px_-5px_rgba(94,106,210,0.6)] after:opacity-100'
                : 'after:opacity-70'
              }
            `}
          >
            <div className="flex items-end gap-3">
              <div className="flex-1">
                <textarea
                  ref={textareaRef}
                  value={value}
                  onChange={onChange}
                  onFocus={() => setIsFocused(true)}
                  onBlur={() => setIsFocused(false)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                      e.preventDefault();
                      if (value.trim()) {
                        onSubmit();
                      }
                    }
                  }}
                  placeholder="Type your message..."
                  className="w-full text-sm resize-none min-h-[48px] max-h-[200px] px-1 py-0.5 focus:bg-transparent bg-transparent focus:outline-none transition-colors duration-200 overflow-y-scroll [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none] text-white/90 placeholder:text-white/40"
                  rows={1}
                  disabled={disabled}
                />
              </div>
              <button 
                className={`
                  flex items-center gap-2 px-4 py-2 rounded-md relative
                  bg-white/[0.03] border border-white/[0.1]
                  transition-all duration-300
                  overflow-hidden backdrop-blur-sm
                  group
                  ${isLoading || disabled ? 'opacity-50 cursor-not-allowed' : 'hover:bg-white/[0.06] hover:border-white/[0.15]'}
                `}
                onClick={(e) => {
                  e.preventDefault();
                  if (value.trim()) {
                    onSubmit();
                  }
                }}
                disabled={isLoading || disabled}
              >
                {/* Glow effects */}
                <div className="absolute inset-0 bg-gradient-to-b from-white/[0.08] to-transparent opacity-80" />
                <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_120%,rgba(255,255,255,0.1),transparent)]" />
                <div className="absolute inset-0 bg-white/5 shadow-[inset_0_0_15px_rgba(255,255,255,0.2)]" />
                
                {/* Content */}
                <div className="relative z-10 flex items-center gap-2">
                  <Send className="w-3.5 h-3.5 text-white/90" />
                  <span className="text-sm font-medium text-white/90">Send</span>
                </div>
                
                {/* Hover glow */}
                <div className={`
                  absolute inset-0 bg-white/5 opacity-0 blur-md
                  transition-opacity duration-300
                  group-hover:opacity-100
                `} />
              </button>
            </div>
          </div>
        </div>
      </div>
    </>
  );
};

================
File: components/deploy-button.tsx
================
import Link from "next/link";
import { Button } from "./ui/button";

export default function DeployButton() {
  return (
    <>
      <Link
        href="https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&project-name=nextjs-with-supabase&repository-name=nextjs-with-supabase&demo-title=nextjs-with-supabase&demo-description=This+starter+configures+Supabase+Auth+to+use+cookies%2C+making+the+user%27s+session+available+throughout+the+entire+Next.js+app+-+Client+Components%2C+Server+Components%2C+Route+Handlers%2C+Server+Actions+and+Middleware.&demo-url=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2F&external-id=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&demo-image=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2Fopengraph-image.png"
        target="_blank"
      >
        <Button className="flex items-center gap-2" size={"sm"}>
          <svg
            className="h-3 w-3"
            viewBox="0 0 76 65"
            fill="hsl(var(--background)/1)"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M37.5274 0L75.0548 65H0L37.5274 0Z" fill="inherit" />
          </svg>
          <span>Deploy to Vercel</span>
        </Button>
      </Link>
    </>
  );
}

================
File: components/env-var-warning.tsx
================
import Link from "next/link";
import { Badge } from "./ui/badge";
import { Button } from "./ui/button";

export function EnvVarWarning() {
  return (
    <div className="flex gap-4 items-center">
      <Badge variant={"outline"} className="font-normal">
        Supabase environment variables required
      </Badge>
      <div className="flex gap-2">
        <Button
          asChild
          size="sm"
          variant={"outline"}
          disabled
          className="opacity-75 cursor-none pointer-events-none"
        >
          <Link href="/sign-in">Sign in</Link>
        </Button>
        <Button
          asChild
          size="sm"
          variant={"default"}
          disabled
          className="opacity-75 cursor-none pointer-events-none"
        >
          <Link href="/sign-up">Sign up</Link>
        </Button>
      </div>
    </div>
  );
}

================
File: components/form-message.tsx
================
export type Message =
  | { success: string }
  | { error: string }
  | { message: string };

export function FormMessage({ message }: { message: Message }) {
  return (
    <div className="flex flex-col gap-2 w-full max-w-md text-sm">
      {"success" in message && (
        <div className="text-foreground border-l-2 border-foreground px-4">
          {message.success}
        </div>
      )}
      {"error" in message && (
        <div className="text-destructive-foreground border-l-2 border-destructive-foreground px-4">
          {message.error}
        </div>
      )}
      {"message" in message && (
        <div className="text-foreground border-l-2 px-4">{message.message}</div>
      )}
    </div>
  );
}

================
File: components/header-auth.tsx
================
import { signOutAction } from "@/app/actions";
import { hasEnvVars } from "@/utils/supabase/check-env-vars";
import Link from "next/link";
import { Badge } from "./ui/badge";
import { Button } from "./ui/button";
import { createClient } from "@/utils/supabase/server";

export default async function AuthButton() {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!hasEnvVars) {
    return (
      <>
        <div className="flex gap-4 items-center">
          <div>
            <Badge
              variant={"default"}
              className="font-normal pointer-events-none"
            >
              Please update .env.local file with anon key and url
            </Badge>
          </div>
          <div className="flex gap-2">
            <Button
              asChild
              size="sm"
              variant={"outline"}
              disabled
              className="opacity-75 cursor-none pointer-events-none"
            >
              <Link href="/sign-in">Sign in</Link>
            </Button>
            <Button
              asChild
              size="sm"
              variant={"default"}
              disabled
              className="opacity-75 cursor-none pointer-events-none"
            >
              <Link href="/sign-up">Sign up</Link>
            </Button>
          </div>
        </div>
      </>
    );
  }
  return user ? (
    <div className="flex items-center gap-4">
      Hey, {user.email}!
      <form action={signOutAction}>
        <Button type="submit" variant={"outline"}>
          Sign out
        </Button>
      </form>
    </div>
  ) : (
    <div className="flex gap-2">
      <Button asChild size="sm" variant={"outline"}>
        <Link href="/sign-in">Sign in</Link>
      </Button>
      <Button asChild size="sm" variant={"default"}>
        <Link href="/sign-up">Sign up</Link>
      </Button>
    </div>
  );
}

================
File: components/hero.tsx
================
import NextLogo from "./next-logo";
import SupabaseLogo from "./supabase-logo";

export default function Header() {
  return (
    <div className="flex flex-col gap-16 items-center">
      <div className="flex gap-8 justify-center items-center">
        <a
          href="https://supabase.com/?utm_source=create-next-app&utm_medium=template&utm_term=nextjs"
          target="_blank"
          rel="noreferrer"
        >
          <SupabaseLogo />
        </a>
        <span className="border-l rotate-45 h-6" />
        <a href="https://nextjs.org/" target="_blank" rel="noreferrer">
          <NextLogo />
        </a>
      </div>
      <h1 className="sr-only">Supabase and Next.js Starter Template</h1>
      <p className="text-3xl lg:text-4xl !leading-tight mx-auto max-w-xl text-center">
        The fastest way to build apps with{" "}
        <a
          href="https://supabase.com/?utm_source=create-next-app&utm_medium=template&utm_term=nextjs"
          target="_blank"
          className="font-bold hover:underline"
          rel="noreferrer"
        >
          Supabase
        </a>{" "}
        and{" "}
        <a
          href="https://nextjs.org/"
          target="_blank"
          className="font-bold hover:underline"
          rel="noreferrer"
        >
          Next.js
        </a>
      </p>
      <div className="w-full p-[1px] bg-gradient-to-r from-transparent via-foreground/10 to-transparent my-8" />
    </div>
  );
}

================
File: components/next-logo.tsx
================
export default function NextLogo() {
  return (
    <svg
      aria-label="Next.js logotype"
      height="68"
      role="img"
      viewBox="0 0 394 79"
      width="100"
    >
      <path
        d="M261.919 0.0330722H330.547V12.7H303.323V79.339H289.71V12.7H261.919V0.0330722Z"
        fill="currentColor"
      />
      <path
        d="M149.052 0.0330722V12.7H94.0421V33.0772H138.281V45.7441H94.0421V66.6721H149.052V79.339H80.43V12.7H80.4243V0.0330722H149.052Z"
        fill="currentColor"
      />
      <path
        d="M183.32 0.0661486H165.506L229.312 79.3721H247.178L215.271 39.7464L247.127 0.126654L229.312 0.154184L206.352 28.6697L183.32 0.0661486Z"
        fill="currentColor"
      />
      <path
        d="M201.6 56.7148L192.679 45.6229L165.455 79.4326H183.32L201.6 56.7148Z"
        fill="currentColor"
      />
      <path
        clipRule="evenodd"
        d="M80.907 79.339L17.0151 0H0V79.3059H13.6121V16.9516L63.8067 79.339H80.907Z"
        fill="currentColor"
        fillRule="evenodd"
      />
      <path
        d="M333.607 78.8546C332.61 78.8546 331.762 78.5093 331.052 77.8186C330.342 77.1279 329.991 76.2917 330 75.3011C329.991 74.3377 330.342 73.5106 331.052 72.8199C331.762 72.1292 332.61 71.7838 333.607 71.7838C334.566 71.7838 335.405 72.1292 336.115 72.8199C336.835 73.5106 337.194 74.3377 337.204 75.3011C337.194 75.9554 337.028 76.5552 336.696 77.0914C336.355 77.6368 335.922 78.064 335.377 78.373C334.842 78.6911 334.252 78.8546 333.607 78.8546Z"
        fill="currentColor"
      />
      <path
        d="M356.84 45.4453H362.872V68.6846C362.863 70.8204 362.401 72.6472 361.498 74.1832C360.585 75.7191 359.321 76.8914 357.698 77.7185C356.084 78.5364 354.193 78.9546 352.044 78.9546C350.079 78.9546 348.318 78.6001 346.75 77.9094C345.182 77.2187 343.937 76.1826 343.024 74.8193C342.101 73.456 341.649 71.7565 341.649 69.7207H347.691C347.7 70.6114 347.903 71.3838 348.29 72.0291C348.677 72.6744 349.212 73.1651 349.895 73.5105C350.586 73.8559 351.38 74.0286 352.274 74.0286C353.243 74.0286 354.073 73.8286 354.746 73.4196C355.419 73.0197 355.936 72.4199 356.296 71.6201C356.646 70.8295 356.831 69.8479 356.84 68.6846V45.4453Z"
        fill="currentColor"
      />
      <path
        d="M387.691 54.5338C387.544 53.1251 386.898 52.0254 385.773 51.2438C384.638 50.4531 383.172 50.0623 381.373 50.0623C380.11 50.0623 379.022 50.2532 378.118 50.6258C377.214 51.0075 376.513 51.5164 376.033 52.1617C375.554 52.807 375.314 53.5432 375.295 54.3703C375.295 55.061 375.461 55.6608 375.784 56.1607C376.107 56.6696 376.54 57.0968 377.103 57.4422C377.656 57.7966 378.274 58.0874 378.948 58.3237C379.63 58.56 380.313 58.76 380.995 58.9236L384.14 59.6961C385.404 59.9869 386.631 60.3778 387.802 60.8776C388.973 61.3684 390.034 61.9955 390.965 62.7498C391.897 63.5042 392.635 64.413 393.179 65.4764C393.723 66.5397 394 67.7848 394 69.2208C394 71.1566 393.502 72.8562 392.496 74.3285C391.491 75.7917 390.043 76.9369 388.143 77.764C386.252 78.582 383.965 79 381.272 79C378.671 79 376.402 78.6002 374.493 77.8004C372.575 77.0097 371.08 75.8463 370.001 74.3194C368.922 72.7926 368.341 70.9294 368.258 68.7391H374.235C374.318 69.8842 374.687 70.8386 375.314 71.6111C375.95 72.3745 376.78 72.938 377.795 73.3197C378.819 73.6923 379.962 73.8832 381.226 73.8832C382.545 73.8832 383.707 73.6832 384.712 73.2924C385.708 72.9016 386.492 72.3564 387.055 71.6475C387.627 70.9476 387.913 70.1206 387.922 69.1754C387.913 68.312 387.654 67.5939 387.156 67.0304C386.649 66.467 385.948 65.9944 385.053 65.6127C384.15 65.231 383.098 64.8856 381.899 64.5857L378.081 63.6223C375.323 62.9225 373.137 61.8592 371.541 60.4323C369.937 59.0054 369.143 57.115 369.143 54.7429C369.143 52.798 369.678 51.0894 370.758 49.6261C371.827 48.1629 373.294 47.0268 375.148 46.2179C377.011 45.4 379.114 45 381.456 45C383.836 45 385.92 45.4 387.719 46.2179C389.517 47.0268 390.929 48.1538 391.952 49.5897C392.976 51.0257 393.511 52.6707 393.539 54.5338H387.691Z"
        fill="currentColor"
      />
    </svg>
  );
}

================
File: components/submit-button.tsx
================
"use client";

import { Button } from "@/components/ui/button";
import { type ComponentProps } from "react";
import { useFormStatus } from "react-dom";

type Props = ComponentProps<typeof Button> & {
  pendingText?: string;
};

export function SubmitButton({
  children,
  pendingText = "Submitting...",
  ...props
}: Props) {
  const { pending } = useFormStatus();

  return (
    <Button type="submit" aria-disabled={pending} {...props}>
      {pending ? pendingText : children}
    </Button>
  );
}

================
File: components/supabase-logo.tsx
================
export default function SupabaseLogo() {
  return (
    <svg
      aria-label="Supabase logo"
      width="140"
      height="30"
      viewBox="0 0 115 23"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <g clipPath="url(#clip0_4671_51136)">
        <g clipPath="url(#clip1_4671_51136)">
          <path
            d="M13.4028 21.8652C12.8424 22.5629 11.7063 22.1806 11.6928 21.2898L11.4954 8.25948H20.3564C21.9614 8.25948 22.8565 10.0924 21.8585 11.3353L13.4028 21.8652Z"
            fill="url(#paint0_linear_4671_51136)"
          />
          <path
            d="M13.4028 21.8652C12.8424 22.5629 11.7063 22.1806 11.6928 21.2898L11.4954 8.25948H20.3564C21.9614 8.25948 22.8565 10.0924 21.8585 11.3353L13.4028 21.8652Z"
            fill="url(#paint1_linear_4671_51136)"
            fillOpacity="0.2"
          />
          <path
            d="M9.79895 0.89838C10.3593 0.200591 11.4954 0.582929 11.5089 1.47383L11.5955 14.5041H2.84528C1.24026 14.5041 0.345103 12.6711 1.34316 11.4283L9.79895 0.89838Z"
            fill="#3ECF8E"
          />
        </g>
        <path
          d="M30.5894 13.3913C30.7068 14.4766 31.7052 16.3371 34.6026 16.3371C37.1279 16.3371 38.3418 14.7479 38.3418 13.1976C38.3418 11.8022 37.3824 10.6588 35.4836 10.2712L34.1131 9.98049C33.5846 9.88359 33.2323 9.5929 33.2323 9.12777C33.2323 8.58512 33.7804 8.17818 34.4656 8.17818C35.5618 8.17818 35.9729 8.89521 36.0513 9.45725L38.2243 8.97275C38.1069 7.94561 37.1867 6.22083 34.446 6.22083C32.3709 6.22083 30.844 7.63555 30.844 9.34094C30.844 10.6781 31.6856 11.7828 33.5454 12.1898L34.8179 12.4805C35.5618 12.6355 35.8555 12.9844 35.8555 13.4107C35.8555 13.9146 35.4444 14.3603 34.583 14.3603C33.4476 14.3603 32.8797 13.6626 32.8212 12.9068L30.5894 13.3913Z"
          fill="currentColor"
        />
        <path
          d="M46.6623 16.0464H49.1486C49.1094 15.717 49.0506 15.0581 49.0506 14.3216V6.51154H46.4468V12.0542C46.4468 13.1588 45.7813 13.934 44.6263 13.934C43.4126 13.934 42.8643 13.0813 42.8643 12.0154V6.51154H40.2606V12.5387C40.2606 14.6123 41.5918 16.2984 43.9215 16.2984C44.9393 16.2984 46.0556 15.9108 46.5841 15.0193C46.5841 15.4069 46.6231 15.8526 46.6623 16.0464Z"
          fill="currentColor"
        />
        <path
          d="M54.433 19.7286V15.1162C54.9027 15.7558 55.8817 16.279 57.213 16.279C59.9341 16.279 61.7545 14.1472 61.7545 11.2596C61.7545 8.43021 60.1298 6.29842 57.3108 6.29842C55.8623 6.29842 54.7855 6.93792 54.3548 7.67439V6.51159H51.8295V19.7286H54.433ZM59.19 11.279C59.19 12.9845 58.133 13.9728 56.8017 13.9728C55.4708 13.9728 54.394 12.9651 54.394 11.279C54.394 9.59299 55.4708 8.6046 56.8017 8.6046C58.133 8.6046 59.19 9.59299 59.19 11.279Z"
          fill="currentColor"
        />
        <path
          d="M63.229 13.4495C63.229 14.9417 64.4818 16.3177 66.5375 16.3177C67.9662 16.3177 68.8865 15.6588 69.3758 14.9029C69.3758 15.2712 69.4149 15.7944 69.4737 16.0464H71.862C71.8033 15.7169 71.7449 15.0386 71.7449 14.5348V9.84482C71.7449 7.92622 70.6093 6.22083 67.5555 6.22083C64.9713 6.22083 63.5811 7.86807 63.4248 9.36033L65.7347 9.84482C65.8131 9.0115 66.4395 8.29445 67.5747 8.29445C68.6713 8.29445 69.1998 8.85646 69.1998 9.53475C69.1998 9.86421 69.0238 10.1355 68.4755 10.2131L66.1068 10.5619C64.5015 10.7945 63.229 11.744 63.229 13.4495ZM67.0854 14.3991C66.2438 14.3991 65.8325 13.8565 65.8325 13.2945C65.8325 12.558 66.361 12.1898 67.0268 12.0929L69.1998 11.7634V12.1898C69.1998 13.8759 68.1818 14.3991 67.0854 14.3991Z"
          fill="currentColor"
        />
        <path
          d="M76.895 16.0465V14.8837C77.4038 15.6976 78.4217 16.279 79.7531 16.279C82.4941 16.279 84.2951 14.1278 84.2951 11.2403C84.2951 8.4108 82.6701 6.25965 79.851 6.25965C78.4217 6.25965 77.3648 6.8798 76.934 7.55806V2.01546H74.3696V16.0465H76.895ZM81.6911 11.2596C81.6911 13.0038 80.6341 13.9728 79.3028 13.9728C77.9912 13.9728 76.895 12.9845 76.895 11.2596C76.895 9.51543 77.9912 8.56584 79.3028 8.56584C80.6341 8.56584 81.6911 9.51543 81.6911 11.2596Z"
          fill="currentColor"
        />
        <path
          d="M85.7692 13.4495C85.7692 14.9417 87.022 16.3177 89.0776 16.3177C90.5065 16.3177 91.4269 15.6588 91.916 14.9029C91.916 15.2712 91.9554 15.7944 92.014 16.0464H94.4023C94.3439 15.7169 94.2851 15.0386 94.2851 14.5348V9.84482C94.2851 7.92622 93.1495 6.22083 90.0955 6.22083C87.5115 6.22083 86.1216 7.86807 85.965 9.36033L88.2747 9.84482C88.3533 9.0115 88.9798 8.29445 90.1149 8.29445C91.2115 8.29445 91.74 8.85646 91.74 9.53475C91.74 9.86421 91.5638 10.1355 91.0156 10.2131L88.647 10.5619C87.0418 10.7945 85.7692 11.744 85.7692 13.4495ZM89.6258 14.3991C88.784 14.3991 88.3727 13.8565 88.3727 13.2945C88.3727 12.558 88.9012 12.1898 89.5671 12.0929L91.74 11.7634V12.1898C91.74 13.8759 90.722 14.3991 89.6258 14.3991Z"
          fill="currentColor"
        />
        <path
          d="M96.087 13.3913C96.2042 14.4766 97.2028 16.3371 100.1 16.3371C102.626 16.3371 103.839 14.7479 103.839 13.1976C103.839 11.8022 102.88 10.6588 100.981 10.2712L99.6105 9.98049C99.082 9.88359 98.7299 9.5929 98.7299 9.12777C98.7299 8.58512 99.2778 8.17818 99.963 8.17818C101.06 8.17818 101.471 8.89521 101.549 9.45725L103.722 8.97275C103.604 7.94561 102.684 6.22083 99.9436 6.22083C97.8683 6.22083 96.3416 7.63555 96.3416 9.34094C96.3416 10.6781 97.183 11.7828 99.043 12.1898L100.316 12.4805C101.06 12.6355 101.353 12.9844 101.353 13.4107C101.353 13.9146 100.942 14.3603 100.081 14.3603C98.9451 14.3603 98.3776 13.6626 98.3188 12.9068L96.087 13.3913Z"
          fill="currentColor"
        />
        <path
          d="M107.794 10.1937C107.852 9.32158 108.596 8.31381 109.947 8.31381C111.435 8.31381 112.062 9.24406 112.101 10.1937H107.794ZM112.355 12.6743C112.042 13.527 111.376 14.1278 110.163 14.1278C108.87 14.1278 107.794 13.2169 107.735 11.9573H114.626C114.626 11.9184 114.665 11.5309 114.665 11.1626C114.665 8.10064 112.884 6.22083 109.908 6.22083C107.441 6.22083 105.17 8.19753 105.17 11.2402C105.17 14.4572 107.5 16.3371 110.143 16.3371C112.512 16.3371 114.039 14.9611 114.528 13.3138L112.355 12.6743Z"
          fill="currentColor"
        />
      </g>
      <defs>
        <linearGradient
          id="paint0_linear_4671_51136"
          x1="11.4954"
          y1="11.1486"
          x2="19.3439"
          y2="14.4777"
          gradientUnits="userSpaceOnUse"
        >
          <stop stopColor="#249361" />
          <stop offset="1" stopColor="#3ECF8E" />
        </linearGradient>
        <linearGradient
          id="paint1_linear_4671_51136"
          x1="8.00382"
          y1="6.42177"
          x2="11.5325"
          y2="13.1398"
          gradientUnits="userSpaceOnUse"
        >
          <stop />
          <stop offset="1" stopOpacity="0" />
        </linearGradient>
        <clipPath id="clip0_4671_51136">
          <rect
            width="113.85"
            height="21.8943"
            fill="currentColor"
            transform="translate(0.922119 0.456161)"
          />
        </clipPath>
        <clipPath id="clip1_4671_51136">
          <rect
            width="21.3592"
            height="21.8943"
            fill="currentColor"
            transform="translate(0.919006 0.497101)"
          />
        </clipPath>
      </defs>
    </svg>
  );
}

================
File: components/theme-switcher.tsx
================
"use client";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Laptop, Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";

const ThemeSwitcher = () => {
  const [mounted, setMounted] = useState(false);
  const { theme, setTheme } = useTheme();

  // useEffect only runs on the client, so now we can safely show the UI
  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  const ICON_SIZE = 16;

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size={"sm"}>
          {theme === "light" ? (
            <Sun
              key="light"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : theme === "dark" ? (
            <Moon
              key="dark"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : (
            <Laptop
              key="system"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-content" align="start">
        <DropdownMenuRadioGroup
          value={theme}
          onValueChange={(e) => setTheme(e)}
        >
          <DropdownMenuRadioItem className="flex gap-2" value="light">
            <Sun size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Light</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="dark">
            <Moon size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Dark</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="system">
            <Laptop size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>System</span>
          </DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

export { ThemeSwitcher };

================
File: config/models.ts
================
export const AVAILABLE_MODELS = {
  groq: [
    { id: 'deepseek-r1-distill-llama-70b', name: 'Deepseek R1 70B' },
    { id: 'mixtral-8x7b-instruct', name: 'Mixtral 8x7B' },
    { id: 'deepseek-r1-distill-llama-70b-specdec', name: 'Deepseek R1 70B SpecDec' },
    { id: 'gemma2-9b-it', name: 'Gemma 2 9B' },
    { id: 'llama-3.3-70b-versatile', name: 'LLaMA 3.3 70B Versatile' },
  ],
  anthropic: [
    { id: 'claude-3-opus-latest', name: 'Claude 3 Opus' },
    { id: 'claude-3-5-sonnet-latest', name: 'Claude 3.5 Sonnet' },
    { id: 'claude-3-5-haiku-latest', name: 'Claude 3.5 Haiku' },
  ],
  openai: [
    { id: 'gpt-4o', name: 'GPT-4o' },
    { id: 'gpt-4o-mini', name: 'GPT-4o Mini' },
    { id: 'o1', name: 'O1' },
    { id: 'o3-mini', name: 'O3 Mini' },
  ],
  cohere: [
    { id: 'command', name: 'Command' },
    { id: 'command-light', name: 'Command Light' },
    { id: 'command-nightly', name: 'Command Nightly' },
    { id: 'command-light-nightly', name: 'Command Light Nightly' }
  ],
  mistral: [
    { id: 'mistral-large-latest', name: 'Mistral Large' },
    { id: 'codestral-latest', name: 'Codestral' },
    { id: 'pixtral-large-latest', name: 'Pixtral Large' },
    { id: 'ministral-3b-latest', name: 'Ministral 3B' },
    { id: 'ministral-8b-latest', name: 'Ministral 8B' },
    { id: 'mistral-small-latest', name: 'Mistral Small' },
  ],
  google: [
    { id: 'gemini-2.0-flash-001', name: 'Gemini 2.0 Flash' },
    { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro' },
  ],
  xai: [
    { id: 'grok-2-1212', name: 'Grok 2' },
    { id: 'grok-2-vision-1212', name: 'Grok 2 Vision' },
  ],
  togetherai: [
    { id: 'deepseek-ai/DeepSeek-R1', name: 'DeepSeek R1' },
    { id: 'deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free', name: 'DeepSeek R1 Distill Llama 70B' },
    { id: 'deepseek-ai/DeepSeek-V3', name: 'DeepSeek V3' },
    { id: 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free', name: 'Llama 3.3 70B Instruct Turbo' },
    { id: 'meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo', name: 'Llama 3.1 405B Instruct Turbo' },
  ],
  deepseek: [
    { id: 'deepseek-chat', name: 'DeepSeek V3' },
    { id: 'deepseek-reasoner', name: 'DeepSeek R1' }
  ],
  cerebras: [
    { id: 'llama3.1-8b', name: 'Llama 3.1 8B' },
    { id: 'llama-3.3-70b', name: 'Llama 3.3 70B' },
  ],
  perplexity: [
    { id: 'sonar-reasoning-pro', name: 'Sonar Reasoning Pro' },
    { id: 'sonar-reasoning', name: 'Sonar Reasoning' },
    { id: 'sonar-pro', name: 'Sonar Pro' },
    { id: 'sonar', name: 'Sonar' },
  ]
} as const;

export type Provider = keyof typeof AVAILABLE_MODELS;
export type ModelsByProvider = {
  [P in Provider]: typeof AVAILABLE_MODELS[P][number]['id'];
};

export const PROVIDER_NAMES: Record<Provider, string> = {
  groq: 'Groq',
  anthropic: 'Anthropic',
  openai: 'OpenAI',
  cohere: 'Cohere',
  mistral: 'Mistral',
  google: 'Google',
  xai: 'xAI',
  togetherai: 'Together AI',
  deepseek: 'DeepSeek',
  cerebras: 'Cerebras',
  perplexity: 'Perplexity'
};

export function isValidModelForProvider(provider: Provider, model: string): boolean {
  return AVAILABLE_MODELS[provider].some(m => m.id === model);
}

export function getModelName(provider: Provider, modelId: string): string {
  const model = AVAILABLE_MODELS[provider].find(m => m.id === modelId);
  return model?.name || modelId;
}

================
File: electron/main.ts
================
import { app, BrowserWindow } from "electron";
import { join } from "path";

const createWindow = () => {
  const mainWindow = new BrowserWindow({
    width: 900,
    height: 670,
    webPreferences: {
      preload: join(__dirname, "preload.js"),
      nodeIntegration: true,
    },
  });
  
  mainWindow.loadURL("http://localhost:3000");
};

app.whenReady().then(createWindow);

================
File: hooks/chat-provider.tsx
================
import React, {
    createContext,
    useContext,
    useReducer,
    useMemo,
    ReactNode,
    useState,
    useEffect,
    useCallback
  } from 'react';
import { Space, Conversation, Message } from '@/types';
import { User } from '@supabase/supabase-js';
import { createClient } from '@/utils/supabase/client';
  
  /*----------------------------------------------------------------------------
    Define Your State Shape and Initial Values
  ----------------------------------------------------------------------------*/
  const supabase = createClient();
  
  interface ChatState {
    spaces: Space[];
    activeSpace: Space | null;
    conversations: { [spaceId: string]: Conversation[] };
    activeConversation: Conversation | null;
    messages: { [conversationId: string]: Message[] };
    user: User | null;
    isInitializing: boolean;
    isLoading: boolean;
    error: string | null;
  }
  
  const initialState: ChatState = {
    spaces: [],
    activeSpace: null,
    conversations: {},
    activeConversation: null,
    messages: {},
    user: null,
    isInitializing: true,
    isLoading: false,
    error: null
  };
  
  /*----------------------------------------------------------------------------
    Define Actions and Reducer
  ----------------------------------------------------------------------------*/
  export enum ActionType {
    SET_SPACES = 'SET_SPACES',
    SET_ACTIVE_SPACE = 'SET_ACTIVE_SPACE',
    SET_CONVERSATIONS = 'SET_CONVERSATIONS',
    SET_ACTIVE_CONVERSATION = 'SET_ACTIVE_CONVERSATION',
    SET_MESSAGES = 'SET_MESSAGES',
    ADD_MESSAGE = 'ADD_MESSAGE',
    SET_USER = 'SET_USER',
    SET_INITIALIZING = 'SET_INITIALIZING',
    SET_LOADING = 'SET_LOADING',
    SET_ERROR = 'SET_ERROR'
  }
  
  type Action =
    | { type: ActionType.SET_SPACES; payload: Space[] }
    | { type: ActionType.SET_ACTIVE_SPACE; payload: Space }
    | {
        type: ActionType.SET_CONVERSATIONS;
        payload: { spaceId: string; conversations: Conversation[] };
      }
    | { type: ActionType.SET_ACTIVE_CONVERSATION; payload: Conversation }
    | {
        type: ActionType.SET_MESSAGES;
        payload: { conversationId: string; messages: Message[] };
      }
    | {
        type: ActionType.ADD_MESSAGE;
        payload: { conversationId: string; message: Message };
      }
    | { type: ActionType.SET_USER; payload: User | null }
    | { type: ActionType.SET_INITIALIZING; payload: boolean }
    | { type: ActionType.SET_LOADING; payload: boolean }
    | { type: ActionType.SET_ERROR; payload: string | null };
  
  function chatReducer(state: ChatState, action: Action): ChatState {
    switch (action.type) {
      case ActionType.SET_SPACES:
        return { ...state, spaces: action.payload };
      case ActionType.SET_ACTIVE_SPACE:
        return { ...state, activeSpace: action.payload, activeConversation: null };
      case ActionType.SET_CONVERSATIONS:
        return {
          ...state,
          conversations: {
            ...state.conversations,
            [action.payload.spaceId]: action.payload.conversations,
          },
        };
      case ActionType.SET_ACTIVE_CONVERSATION:
        return { ...state, activeConversation: action.payload };
      case ActionType.SET_MESSAGES:
        return {
          ...state,
          messages: {
            ...state.messages,
            [action.payload.conversationId]: action.payload.messages,
          },
        };
      case ActionType.ADD_MESSAGE:
        return {
          ...state,
          messages: {
            ...state.messages,
            [action.payload.conversationId]: [
              ...(state.messages[action.payload.conversationId] || []),
              action.payload.message,
            ],
          },
        };
      case ActionType.SET_USER:
        return { ...state, user: action.payload };
      case ActionType.SET_INITIALIZING:
        return { ...state, isInitializing: action.payload };
      case ActionType.SET_LOADING:
        return { ...state, isLoading: action.payload };
      case ActionType.SET_ERROR:
        return { ...state, error: action.payload };
      default:
        return state;
    }
  }
  
  /*----------------------------------------------------------------------------
    Create Chat Context & Provider
  ----------------------------------------------------------------------------*/
  interface ChatContextProps {
    state: ChatState;
    dispatch: React.Dispatch<Action>;
  }
  
  const ChatContext = createContext<ChatContextProps | undefined>(undefined);
  
  export const ChatProvider = ({ children }: { children: ReactNode }) => {
    const [state, dispatch] = useReducer(chatReducer, initialState);
  
    // Initialize auth
    useEffect(() => {
      supabase.auth.getSession().then(({ data: { session } }) => {
        dispatch({ type: ActionType.SET_USER, payload: session?.user ?? null });
        dispatch({ type: ActionType.SET_INITIALIZING, payload: false });
      });
  
      const {
        data: { subscription },
      } = supabase.auth.onAuthStateChange((_event, session) => {
        dispatch({ type: ActionType.SET_USER, payload: session?.user ?? null });
      });
  
      return () => subscription.unsubscribe();
    }, []);
  
    // Initialize user data when auth changes
    useEffect(() => {
      const initializeUserData = async () => {
        if (!state.user) return;
  
        dispatch({ type: ActionType.SET_INITIALIZING, payload: true });
        try {
          // Load spaces
          const response = await fetch('/api/spaces');
          const spaces = await response.json();
          
          if (!spaces.error) {
            dispatch({ type: ActionType.SET_SPACES, payload: spaces });
            
            // If no spaces exist, create initial space
            if (spaces.length === 0) {
              const spaceResponse = await fetch('/api/spaces', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  name: 'My Space',
                  description: 'My default space',
                  model: 'deepseek-r1-distill-llama-70b',
                  provider: 'groq'
                })
              });
  
              const spaceData = await spaceResponse.json();
              if (!spaceData.error) {
                dispatch({ type: ActionType.SET_SPACES, payload: [spaceData] });
                dispatch({ type: ActionType.SET_ACTIVE_SPACE, payload: spaceData });
  
                // Create initial conversation
                const convResponse = await fetch('/api/conversations', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    space_id: spaceData.id,
                    title: 'Getting Started'
                  })
                });
  
                const convData = await convResponse.json();
                if (!convData.error) {
                  dispatch({
                    type: ActionType.SET_CONVERSATIONS,
                    payload: { spaceId: spaceData.id, conversations: [convData] }
                  });
                  dispatch({ type: ActionType.SET_ACTIVE_CONVERSATION, payload: convData });
  
                  // Create and load welcome message
                  const welcomeResponse = await fetch('/api/messages', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      conversation_id: convData.id,
                      user_id: state.user.id,
                      role: 'assistant',
                      content: 'Welcome to Spatial! I\'m here to help you explore and create. What would you like to do?',
                      model_used: spaceData.model
                    })
                  });
  
                  const welcomeMessage = await welcomeResponse.json();
                  if (!welcomeMessage.error) {
                    dispatch({
                      type: ActionType.SET_MESSAGES,
                      payload: { 
                        conversationId: convData.id, 
                        messages: [welcomeMessage] 
                      }
                    });
                  }
                }
              }
            } else {
              // Set first space as active and load its conversations
              const firstSpace = spaces[0];
              dispatch({ type: ActionType.SET_ACTIVE_SPACE, payload: firstSpace });
              
              const conversationsResponse = await fetch(`/api/conversations/${firstSpace.id}`);
              const conversations = await conversationsResponse.json();
              
              if (!conversations.error) {
                dispatch({
                  type: ActionType.SET_CONVERSATIONS,
                  payload: { spaceId: firstSpace.id, conversations }
                });
                
                if (conversations.length > 0) {
                  const firstConversation = conversations[0];
                  dispatch({ type: ActionType.SET_ACTIVE_CONVERSATION, payload: firstConversation });
                  
                  // Load messages for the first conversation
                  const messagesResponse = await fetch(`/api/messages/${firstConversation.id}`);
                  const messages = await messagesResponse.json();
                  if (!messages.error) {
                    dispatch({
                      type: ActionType.SET_MESSAGES,
                      payload: { 
                        conversationId: firstConversation.id, 
                        messages 
                      }
                    });
                  }
                }
              }
            }
          }
        } catch (error) {
          console.error('Error initializing user data:', error);
        } finally {
          dispatch({ type: ActionType.SET_INITIALIZING, payload: false });
        }
      };
  
      initializeUserData();
    }, [state.user]);
  
    // Memoize the context value to avoid unnecessary re-renders
    const value = useMemo(() => ({ state, dispatch }), [state]);
  
    return (
      <ChatContext.Provider value={value}>
        {children}
      </ChatContext.Provider>
    );
  };
  
  export function useChatContext() {
    const context = useContext(ChatContext);
    if (!context) {
      throw new Error('useChatContext must be used within a ChatProvider');
    }
    return context;
  }
  
  /*----------------------------------------------------------------------------
    Custom Hook: useActiveSpace
  ----------------------------------------------------------------------------*/
  export const useActiveSpace = () => {
    const { state, dispatch } = useChatContext();
  
    const loadSpaces = async () => {
      try {
        const response = await fetch('/api/spaces');
        const data = await response.json();
        if (!data.error) {
          dispatch({ type: ActionType.SET_SPACES, payload: data });
          // If there are spaces and no active space, set the first one as active
          if (data.length > 0 && !state.activeSpace) {
            dispatch({ type: ActionType.SET_ACTIVE_SPACE, payload: data[0] });
          }
        }
      } catch (error) {
        console.error('Error loading spaces:', error);
      }
    };
  
    const setActiveSpace = (space: Space) => {
      dispatch({ type: ActionType.SET_ACTIVE_SPACE, payload: space });
    };
  
    const setSpaces = (spaces: Space[]) => {
      dispatch({ type: ActionType.SET_SPACES, payload: spaces });
    };
  
    return {
      activeSpace: state.activeSpace,
      spaces: state.spaces,
      setActiveSpace,
      setSpaces,
      loadSpaces,
    };
  };
  
  /*----------------------------------------------------------------------------
    Custom Hook: useConversations
  ----------------------------------------------------------------------------*/
  export const useConversations = () => {
    const { state, dispatch } = useChatContext();
    const activeSpaceId = state.activeSpace?.id;
  
    const loadConversations = async (spaceId: string) => {
      try {
        const response = await fetch(`/api/conversations/${spaceId}`);
        const data = await response.json();
        
        if (!data.error) {
          dispatch({
            type: ActionType.SET_CONVERSATIONS,
            payload: { spaceId, conversations: data },
          });
          
          // If there are conversations and no active conversation, set the first one
          if (data.length > 0 && !state.activeConversation) {
            const firstConversation = data[0];
            dispatch({ type: ActionType.SET_ACTIVE_CONVERSATION, payload: firstConversation });
            
            // Load messages for the first conversation
            const messagesResponse = await fetch(`/api/messages/${firstConversation.id}`);
            const messages = await messagesResponse.json();
            if (!messages.error) {
              dispatch({
                type: ActionType.SET_MESSAGES,
                payload: { conversationId: firstConversation.id, messages },
              });
            }
          }
        }
      } catch (error) {
        console.error('Error loading conversations:', error);
      }
    };
  
    const setConversations = (conversations: Conversation[]) => {
      if (activeSpaceId) {
        dispatch({
          type: ActionType.SET_CONVERSATIONS,
          payload: { spaceId: activeSpaceId, conversations },
        });
      }
    };
  
    const setActiveConversation = async (conversation: Conversation) => {
      dispatch({ type: ActionType.SET_ACTIVE_CONVERSATION, payload: conversation });
      try {
        const messagesResponse = await fetch(`/api/messages/${conversation.id}`);
        const messages = await messagesResponse.json();
        if (!messages.error) {
          dispatch({
            type: ActionType.SET_MESSAGES,
            payload: { conversationId: conversation.id, messages },
          });
        }
      } catch (error) {
        console.error('Error loading messages:', error);
      }
    };
  
    const conversationsForActiveSpace = activeSpaceId
      ? state.conversations[activeSpaceId] || []
      : [];
  
    return {
      conversations: conversationsForActiveSpace,
      activeConversation: state.activeConversation,
      setConversations,
      setActiveConversation,
      loadConversations,
    };
  };
  
  /*----------------------------------------------------------------------------
    Custom Hook: useMessages
  ----------------------------------------------------------------------------*/
  export const useMessages = () => {
    const { state, dispatch } = useChatContext();
    const conversationId = state.activeConversation?.id;
  
    const loadMessages = async (conversationId: string) => {
      if (!conversationId) return;
      
      try {
        const response = await fetch(`/api/messages/${conversationId}`);
        const data = await response.json();
        
        if (!data.error) {
          dispatch({
            type: ActionType.SET_MESSAGES,
            payload: { conversationId, messages: data },
          });
        }
      } catch (error) {
        console.error('Error loading messages:', error);
      }
    };
  
    const setMessages = (messages: Message[]) => {
      if (conversationId) {
        dispatch({
          type: ActionType.SET_MESSAGES,
          payload: { conversationId, messages },
        });
      }
    };
  
    const addMessage = (message: Message) => {
      if (conversationId) {
        dispatch({
          type: ActionType.ADD_MESSAGE,
          payload: { conversationId, message },
        });
      }
    };
  
    const messagesForActiveConversation = conversationId
      ? state.messages[conversationId] || []
      : [];
  
    return {
      messages: messagesForActiveConversation,
      setMessages,
      addMessage,
      loadMessages,
    };
  };

================
File: hooks/chat-state-provider.tsx
================
import React, { createContext, useContext, useReducer, useMemo, ReactNode, useEffect, useCallback } from 'react';

interface ChatState {
  isInitializing: boolean;
  isLoading: boolean;
  error: string | null;
}

const initialState: ChatState = {
  isInitializing: true,
  isLoading: false,
  error: null
};

export enum ChatStateActionType {
  SET_INITIALIZING = 'SET_INITIALIZING',
  SET_LOADING = 'SET_LOADING',
  SET_ERROR = 'SET_ERROR',
  BATCH_UPDATE = 'BATCH_UPDATE'
}

type ChatStateAction =
  | { type: ChatStateActionType.SET_INITIALIZING; payload: boolean }
  | { type: ChatStateActionType.SET_LOADING; payload: boolean }
  | { type: ChatStateActionType.SET_ERROR; payload: string | null }
  | { type: ChatStateActionType.BATCH_UPDATE; payload: Partial<ChatState> };

function chatStateReducer(state: ChatState, action: ChatStateAction): ChatState {
  switch (action.type) {
    case ChatStateActionType.SET_INITIALIZING:
      return { ...state, isInitializing: action.payload };
    case ChatStateActionType.SET_LOADING:
      return { ...state, isLoading: action.payload };
    case ChatStateActionType.SET_ERROR:
      return { ...state, error: action.payload };
    case ChatStateActionType.BATCH_UPDATE:
      return { ...state, ...action.payload };
    default:
      return state;
  }
}

interface ChatStateContextProps {
  state: ChatState;
  dispatch: React.Dispatch<ChatStateAction>;
  batchUpdate: (updates: Partial<ChatState>) => void;
}

const ChatStateContext = createContext<ChatStateContextProps | undefined>(undefined);

export function ChatStateProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(chatStateReducer, initialState);

  const batchUpdate = useCallback((updates: Partial<ChatState>) => {
    dispatch({ type: ChatStateActionType.BATCH_UPDATE, payload: updates });
  }, []);

  // Initialize chat state when provider mounts
  useEffect(() => {
    dispatch({ type: ChatStateActionType.SET_INITIALIZING, payload: false });
  }, []);

  const value = useMemo(() => ({ 
    state, 
    dispatch,
    batchUpdate 
  }), [state, batchUpdate]);

  return (
    <ChatStateContext.Provider value={value}>
      {children}
    </ChatStateContext.Provider>
  );
}

export function useChatState() {
  const context = useContext(ChatStateContext);
  if (!context) {
    throw new Error('useChatState must be used within a ChatStateProvider');
  }
  return context;
}

================
File: hooks/conversations-provider.tsx
================
import React, { createContext, useContext, useReducer, useMemo, ReactNode, useEffect } from 'react';
import { Conversation } from '@/types';
import { useSpaces } from './spaces-provider';

interface ConversationsState {
  conversations: { [spaceId: string]: Conversation[] };
  activeConversation: Conversation | null;
  isInitialized: boolean;
}

const initialState: ConversationsState = {
  conversations: {},
  activeConversation: null,
  isInitialized: false
};

enum ConversationsActionType {
  SET_CONVERSATIONS = 'SET_CONVERSATIONS',
  SET_ACTIVE_CONVERSATION = 'SET_ACTIVE_CONVERSATION',
  SET_INITIALIZED = 'SET_INITIALIZED'
}

type ConversationsAction =
  | { type: ConversationsActionType.SET_CONVERSATIONS; payload: { spaceId: string; conversations: Conversation[] } }
  | { type: ConversationsActionType.SET_ACTIVE_CONVERSATION; payload: Conversation }
  | { type: ConversationsActionType.SET_INITIALIZED; payload: boolean };

function conversationsReducer(state: ConversationsState, action: ConversationsAction): ConversationsState {
  switch (action.type) {
    case ConversationsActionType.SET_CONVERSATIONS:
      return {
        ...state,
        conversations: {
          ...state.conversations,
          [action.payload.spaceId]: action.payload.conversations,
        },
      };
    case ConversationsActionType.SET_ACTIVE_CONVERSATION:
      return { ...state, activeConversation: action.payload };
    case ConversationsActionType.SET_INITIALIZED:
      return { ...state, isInitialized: action.payload };
    default:
      return state;
  }
}

interface ConversationsContextProps {
  state: ConversationsState;
  dispatch: React.Dispatch<ConversationsAction>;
}

const ConversationsContext = createContext<ConversationsContextProps | undefined>(undefined);

export function ConversationsProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(conversationsReducer, initialState);
  const { activeSpace, state: spacesState } = useSpaces();

  // Load conversations when active space changes
  useEffect(() => {
    const loadConversations = async () => {
      if (!activeSpace?.id || !spacesState.isInitialized) return;

      try {
        const response = await fetch(`/api/conversations/${activeSpace.id}`);
        const data = await response.json();
        
        if (!data.error) {
          dispatch({
            type: ConversationsActionType.SET_CONVERSATIONS,
            payload: { spaceId: activeSpace.id, conversations: data },
          });
          
          if (data.length > 0) {
            dispatch({ type: ConversationsActionType.SET_ACTIVE_CONVERSATION, payload: data[0] });
          } else {
            // Create initial conversation if none exists
            const convResponse = await fetch('/api/conversations', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                space_id: activeSpace.id,
                title: 'New Chat'
              })
            });

            const convData = await convResponse.json();
            if (!convData.error) {
              dispatch({
                type: ConversationsActionType.SET_CONVERSATIONS,
                payload: { spaceId: activeSpace.id, conversations: [convData] }
              });
              dispatch({ type: ConversationsActionType.SET_ACTIVE_CONVERSATION, payload: convData });
            }
          }
        }
      } catch (error) {
        console.error('Error loading conversations:', error);
      } finally {
        dispatch({ type: ConversationsActionType.SET_INITIALIZED, payload: true });
      }
    };

    // Only load if not initialized or if space changes
    if (!state.isInitialized || activeSpace?.id) {
      loadConversations();
    }
  }, [activeSpace?.id, spacesState.isInitialized]);

  const value = useMemo(() => ({ state, dispatch }), [state]);

  return (
    <ConversationsContext.Provider value={value}>
      {children}
    </ConversationsContext.Provider>
  );
}

function useConversationsContext() {
  const context = useContext(ConversationsContext);
  if (!context) {
    throw new Error('useConversationsContext must be used within a ConversationsProvider');
  }
  return context;
}

export function useConversations() {
  const { state, dispatch } = useConversationsContext();
  const { activeSpace } = useSpaces();
  const activeSpaceId = activeSpace?.id;

  const loadConversations = async (spaceId: string) => {
    try {
      dispatch({ type: ConversationsActionType.SET_INITIALIZED, payload: false });
      const response = await fetch(`/api/conversations/${spaceId}`);
      const data = await response.json();
      
      if (!data.error) {
        dispatch({
          type: ConversationsActionType.SET_CONVERSATIONS,
          payload: { spaceId, conversations: data },
        });
        
        if (data.length > 0 && !state.activeConversation) {
          dispatch({ type: ConversationsActionType.SET_ACTIVE_CONVERSATION, payload: data[0] });
        }
      }
    } catch (error) {
      console.error('Error loading conversations:', error);
    } finally {
      dispatch({ type: ConversationsActionType.SET_INITIALIZED, payload: true });
    }
  };

  return {
    state,
    conversations: activeSpaceId ? state.conversations[activeSpaceId] || [] : [],
    activeConversation: state.activeConversation,
    setConversations: (conversations: Conversation[]) => {
      if (activeSpaceId) {
        dispatch({
          type: ConversationsActionType.SET_CONVERSATIONS,
          payload: { spaceId: activeSpaceId, conversations },
        });
      }
    },
    setActiveConversation: (conversation: Conversation) => {
      dispatch({ type: ConversationsActionType.SET_ACTIVE_CONVERSATION, payload: conversation });
    },
    loadConversations,
  };
}

================
File: hooks/messages-provider.tsx
================
import React, { createContext, useContext, useReducer, useMemo, ReactNode, useEffect } from 'react';
import { Message } from '@/types';
import { useConversations } from './conversations-provider';

interface MessagesState {
  messages: { [conversationId: string]: Message[] };
  isInitialized: boolean;
}

const initialState: MessagesState = {
  messages: {},
  isInitialized: false
};

enum MessagesActionType {
  SET_MESSAGES = 'SET_MESSAGES',
  ADD_MESSAGE = 'ADD_MESSAGE',
  SET_INITIALIZED = 'SET_INITIALIZED'
}

type MessagesAction =
  | { type: MessagesActionType.SET_MESSAGES; payload: { conversationId: string; messages: Message[] } }
  | { type: MessagesActionType.ADD_MESSAGE; payload: { conversationId: string; message: Message } }
  | { type: MessagesActionType.SET_INITIALIZED; payload: boolean };

function messagesReducer(state: MessagesState, action: MessagesAction): MessagesState {
  switch (action.type) {
    case MessagesActionType.SET_MESSAGES:
      return {
        ...state,
        messages: {
          ...state.messages,
          [action.payload.conversationId]: action.payload.messages,
        },
      };
    case MessagesActionType.ADD_MESSAGE:
      return {
        ...state,
        messages: {
          ...state.messages,
          [action.payload.conversationId]: [
            ...(state.messages[action.payload.conversationId] || []),
            action.payload.message,
          ],
        },
      };
    case MessagesActionType.SET_INITIALIZED:
      return { ...state, isInitialized: action.payload };
    default:
      return state;
  }
}

interface MessagesContextProps {
  state: MessagesState;
  dispatch: React.Dispatch<MessagesAction>;
}

const MessagesContext = createContext<MessagesContextProps | undefined>(undefined);

export function MessagesProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(messagesReducer, initialState);
  const { activeConversation, state: conversationsState } = useConversations();

  // Load messages when active conversation changes
  useEffect(() => {
    if (!conversationsState.isInitialized) return;
    
    // If there's no active conversation but conversations are initialized,
    // we should still mark messages as initialized with an empty state
    if (!activeConversation?.id) {
      dispatch({ type: MessagesActionType.SET_INITIALIZED, payload: true });
      return;
    }

    // Don't reload if we already have messages for this conversation
    if (state.messages[activeConversation.id]?.length > 0) {
      dispatch({ type: MessagesActionType.SET_INITIALIZED, payload: true });
      return;
    }

    const loadMessages = async () => {
      try {
        dispatch({ type: MessagesActionType.SET_INITIALIZED, payload: false });
        const response = await fetch(`/api/messages/${activeConversation.id}`);
        const data = await response.json();
        
        if (!data.error) {
          dispatch({
            type: MessagesActionType.SET_MESSAGES,
            payload: { conversationId: activeConversation.id, messages: data }
          });
        }
      } catch (error) {
        console.error('Error loading messages:', error);
      } finally {
        dispatch({ type: MessagesActionType.SET_INITIALIZED, payload: true });
      }
    };

    loadMessages();
  }, [activeConversation?.id, conversationsState.isInitialized]);

  const value = useMemo(() => ({ state, dispatch }), [state]);

  return (
    <MessagesContext.Provider value={value}>
      {children}
    </MessagesContext.Provider>
  );
}

function useMessagesContext() {
  const context = useContext(MessagesContext);
  if (!context) {
    throw new Error('useMessagesContext must be used within a MessagesProvider');
  }
  return context;
}

export function useMessages() {
  const { state, dispatch } = useMessagesContext();
  const { activeConversation } = useConversations();
  const conversationId = activeConversation?.id;

  const loadMessages = async (conversationId: string) => {
    if (!conversationId) return;
    
    try {
      dispatch({ type: MessagesActionType.SET_INITIALIZED, payload: false });
      const response = await fetch(`/api/messages/${conversationId}`);
      const data = await response.json();
      
      if (!data.error) {
        dispatch({
          type: MessagesActionType.SET_MESSAGES,
          payload: { conversationId, messages: data },
        });
      }
    } catch (error) {
      console.error('Error loading messages:', error);
    } finally {
      dispatch({ type: MessagesActionType.SET_INITIALIZED, payload: true });
    }
  };

  return {
    state,
    messages: conversationId ? state.messages[conversationId] || [] : [],
    setMessages: (messages: Message[]) => {
      if (conversationId) {
        dispatch({
          type: MessagesActionType.SET_MESSAGES,
          payload: { conversationId, messages },
        });
      }
    },
    addMessage: (message: Message) => {
      if (conversationId) {
        dispatch({
          type: MessagesActionType.ADD_MESSAGE,
          payload: { conversationId, message },
        });
      }
    },
    loadMessages,
  };
}

================
File: hooks/spaces-provider.tsx
================
import React, { createContext, useContext, useReducer, useMemo, ReactNode, useEffect } from 'react';
import { Space } from '@/types';
import { createClient } from '@/utils/supabase/client';

const supabase = createClient();

interface SpacesState {
  spaces: Space[];
  activeSpace: Space | null;
  isInitialized: boolean;
  error: string | null;
}

const initialState: SpacesState = {
  spaces: [],
  activeSpace: null,
  isInitialized: false,
  error: null
};

enum ActionType {
  SET_SPACES = 'SET_SPACES',
  SET_ACTIVE_SPACE = 'SET_ACTIVE_SPACE',
  SET_INITIALIZED = 'SET_INITIALIZED',
  SET_ERROR = 'SET_ERROR'
}

type Action =
  | { type: ActionType.SET_SPACES; payload: Space[] }
  | { type: ActionType.SET_ACTIVE_SPACE; payload: Space }
  | { type: ActionType.SET_INITIALIZED; payload: boolean }
  | { type: ActionType.SET_ERROR; payload: string | null }

function spacesReducer(state: SpacesState, action: Action): SpacesState {
  switch (action.type) {
    case ActionType.SET_SPACES:
      return { ...state, spaces: action.payload };
    case ActionType.SET_ACTIVE_SPACE:
      return { ...state, activeSpace: action.payload };
    case ActionType.SET_INITIALIZED:
      return { ...state, isInitialized: action.payload };
    case ActionType.SET_ERROR:
      return { ...state, error: action.payload };
    default:
      return state;
  }
}

const SpacesContext = createContext<{
  state: SpacesState;
  dispatch: React.Dispatch<Action>;
} | undefined>(undefined);

export function SpacesProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(spacesReducer, {
    ...initialState,
    isInitialized: true // Start with initialized true to prevent loading screen
  });

  useEffect(() => {
    const initializeSpaces = async () => {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        if (!session?.user) return;

        const response = await fetch('/api/spaces');
        const data = await response.json();
        
        if (!data.error) {
          dispatch({ type: ActionType.SET_SPACES, payload: data });
          
          if (data.length > 0) {
            const activeSpace = data.find((s: Space) => s.isActive);
            if (activeSpace) {
              dispatch({ type: ActionType.SET_ACTIVE_SPACE, payload: activeSpace });
            } else {
              // If no active space, set the first one as active
              const spaceResponse = await fetch(`/api/spaces/${data[0].id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ setActive: true })
              });
              
              if (spaceResponse.ok) {
                const updatedSpace = await spaceResponse.json();
                dispatch({ type: ActionType.SET_ACTIVE_SPACE, payload: updatedSpace });
              }
            }
          } else {
            // Create initial space synchronously if none exists
            const spaceResponse = await fetch('/api/spaces', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                name: 'My Space',
                description: 'My first space',
                model: 'deepseek-r1-distill-llama-70b',
                provider: 'groq',
                setActive: true
              })
            });

            if (spaceResponse.ok) {
              const spaceData = await spaceResponse.json();
              dispatch({ type: ActionType.SET_SPACES, payload: [spaceData] });
              dispatch({ type: ActionType.SET_ACTIVE_SPACE, payload: spaceData });
            }
          }
        }
      } catch (error) {
        console.error('Error initializing spaces:', error);
      }
    };

    initializeSpaces();

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      if (session?.user) {
        initializeSpaces();
      } else {
        // Reset state when user logs out
        dispatch({ type: ActionType.SET_SPACES, payload: [] });
        dispatch({ type: ActionType.SET_ACTIVE_SPACE, payload: null });
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  const value = useMemo(() => ({ state, dispatch }), [state]);

  return (
    <SpacesContext.Provider value={value}>
      {children}
    </SpacesContext.Provider>
  );
}

export function useSpaces() {
  const context = useContext(SpacesContext);
  if (!context) {
    throw new Error('useSpaces must be used within a SpacesProvider');
  }

  const { state, dispatch } = context;

  const setSpaces = (spaces: Space[]) => {
    dispatch({ type: ActionType.SET_SPACES, payload: spaces });
  };

  const setActiveSpace = (space: Space) => {
    dispatch({ type: ActionType.SET_ACTIVE_SPACE, payload: space });
  };

  return {
    spaces: state.spaces,
    activeSpace: state.activeSpace,
    state,
    setSpaces,
    setActiveSpace
  };
}

================
File: hooks/use-stick-to-bottom.ts
================
import { useCallback, useEffect, useRef, useState } from 'react';

export function useStickToBottom(threshold = 150) {
  const [isStickToBottom, setIsStickToBottom] = useState(true);
  const containerRef = useRef<HTMLDivElement>(null);
  const prevScrollHeightRef = useRef<number>(0);

  const checkIsStickToBottom = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    const { scrollHeight, scrollTop, clientHeight } = container;
    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
    
    setIsStickToBottom(distanceFromBottom <= threshold);
  }, [threshold]);

  const scrollToBottom = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    container.scrollTop = container.scrollHeight;
  }, []);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = () => {
      checkIsStickToBottom();
    };

    container.addEventListener('scroll', handleScroll);
    return () => container.removeEventListener('scroll', handleScroll);
  }, [checkIsStickToBottom]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleResize = () => {
      if (isStickToBottom) {
        scrollToBottom();
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [isStickToBottom, scrollToBottom]);

  // Auto-scroll when content changes if we're sticking to bottom
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const { scrollHeight } = container;
    
    if (scrollHeight !== prevScrollHeightRef.current) {
      if (isStickToBottom) {
        scrollToBottom();
      }
      prevScrollHeightRef.current = scrollHeight;
    }
  });

  return {
    containerRef,
    isStickToBottom,
    scrollToBottom
  };
}

================
File: lib/constants.ts
================
export interface AIModel {
  id: string;
  name: string;
  contextLength: number;
  provider: string;
}

export interface AIProvider {
  id: string;
  name: string;
  models: AIModel[];
}

export const AI_PROVIDERS: AIProvider[] = [
  {
    id: 'anthropic',
    name: 'Anthropic',
    models: [
      {
        id: 'claude-3-opus',
        name: 'Claude 3 Opus',
        contextLength: 200000,
        provider: 'anthropic'
      },
      {
        id: 'claude-3-sonnet',
        name: 'Claude 3 Sonnet',
        contextLength: 200000,
        provider: 'anthropic'
      }
    ]
  },
  {
    id: 'groq',
    name: 'Groq',
    models: [
      {
        id: 'llama3-70b-8192',
        name: 'LLaMA 3 70B',
        contextLength: 8192,
        provider: 'groq'
      },
      {
        id: 'mixtral-8x7b-32768',
        name: 'Mixtral 8x7B',
        contextLength: 32768,
        provider: 'groq'
      }
    ]
  },
  {
    id: 'deepseek',
    name: 'DeepSeek',
    models: [
      {
        id: 'deepseek-r1-distill-llama-70b',
        name: 'DeepSeek LLaMA 70B',
        contextLength: 4096,
        provider: 'deepseek'
      }
    ]
  }
];

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

================
File: public/icons/providers/default.svg
================
<?xml version="1.0" encoding="UTF-8"?>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M12 2L2 7L12 12L22 7L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M2 17L12 22L22 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M2 12L12 17L22 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: public/icons/providers/groq.svg
================
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="152px" height="55.5px" viewBox="0 32.25 152 55.5" enable-background="new 0 32.25 152 55.5" xml:space="preserve">
 <title>
  groq_logo
 </title>
 <g id="Layer_2">
  <g id="Layer_1-2">
   <path d="M84.848,34.137c-9.798,0-17.769,7.971-17.769,17.77s7.971,17.769,17.769,17.769s17.77-7.971,17.77-17.769
			S94.645,34.137,84.848,34.137z M84.848,63.013c-6.124,0-11.106-4.983-11.106-11.106s4.982-11.106,11.106-11.106
			c6.124,0,11.106,4.982,11.106,11.106S90.973,63.013,84.848,63.013z">
   </path>
   <path d="M60.315,34.206c-0.607-0.068-1.217-0.104-1.827-0.108c-0.304,0-0.595,0.009-0.893,0.014s-0.594,0.033-0.891,0.051
			c-1.197,0.094-2.382,0.299-3.541,0.611c-2.329,0.629-4.574,1.723-6.515,3.277c-1.97,1.57-3.548,3.575-4.611,5.859
			c-0.53,1.138-0.921,2.336-1.165,3.567c-0.121,0.608-0.21,1.222-0.266,1.84c-0.02,0.307-0.055,0.615-0.059,0.921l-0.011,0.459
			l-0.005,0.23v0.19l0.015,5.951l0.015,5.951l0.041,5.95h6.664l0.042-5.95l0.015-5.952l0.015-5.951v-0.182l0.005-0.142l0.008-0.285
			c0-0.191,0.028-0.375,0.039-0.564c0.036-0.37,0.091-0.738,0.165-1.102c0.146-0.716,0.374-1.413,0.678-2.077
			c0.613-1.332,1.528-2.502,2.673-3.419c1.156-0.932,2.541-1.628,4.038-2.042c0.757-0.207,1.532-0.344,2.314-0.408
			c0.198-0.011,0.395-0.03,0.594-0.037c0.199-0.007,0.402-0.013,0.595-0.012c0.383,0,0.76,0.025,1.142,0.06
			c1.518,0.153,2.989,0.619,4.318,1.368l3.326-5.776C65.108,35.263,62.753,34.484,60.315,34.206z">
   </path>
   <path d="M17.77,34.048C7.971,34.048,0,42.019,0,51.817s7.971,17.77,17.77,17.77h5.844v-6.664H17.77
			c-6.124,0-11.106-4.982-11.106-11.106s4.982-11.106,11.106-11.106s11.132,4.982,11.132,11.106l0,0v16.365l0,0
			c0,6.084-4.954,11.039-11.023,11.103c-2.904-0.024-5.681-1.191-7.729-3.25l-4.712,4.712c3.266,3.283,7.691,5.151,12.321,5.201
			v0.003c0.04,0,0.08,0,0.119,0h0.125v-0.003c9.659-0.131,17.48-8.005,17.525-17.686l0.006-16.881
			C35.302,41.785,27.422,34.048,17.77,34.048z">
   </path>
   <path d="M124.083,34.137c-9.798,0-17.769,7.971-17.769,17.77s7.971,17.769,17.769,17.769h6.08v-6.663h-6.08
			c-6.124,0-11.106-4.983-11.106-11.106s4.982-11.106,11.106-11.106c5.799,0,10.572,4.468,11.062,10.143h-0.01v34.12h6.664V51.907
			l0,0C141.797,42.108,133.881,34.137,124.083,34.137z">
   </path>
   <polygon points="151.983,35.04 151.033,35.04 149.737,37.053 148.399,35.04 147.44,35.04 147.44,38.624 148.511,38.624 
			148.511,36.88 149.461,38.288 149.979,38.288 150.912,36.836 150.929,38.624 152,38.624 		">
   </polygon>
   <polygon points="143.519,35.896 144.685,35.896 144.685,38.624 145.86,38.624 145.86,35.896 147.034,35.896 147.034,35.04 
			143.519,35.04 		">
   </polygon>
  </g>
 </g>
</svg>

================
File: store/chatStateStore.ts
================
import { DatabaseMessage } from '@/app/protected/page';
import { Message } from 'ai';
import { create } from 'zustand';

type ChatStatus = 'idle' | 'generating' | 'error';

interface ChatState {
  status: ChatStatus;
  error?: string;
  setStatus: (status: ChatStatus, error?: string) => void;
  conversationId?: string;
  messages: DatabaseMessage[];
  setConversationId: (id: string | undefined) => void;
  setMessages: (messages: DatabaseMessage[]) => void;
}

export const useChatState = create<ChatState>((set) => ({
  status: 'idle',
  error: undefined,
  conversationId: undefined,
  messages: [],
  setStatus: (status, error) => set({ status, error }),
  setConversationId: (id) => set({ conversationId: id }),
  setMessages: (messages) => set({ messages })
}));

================
File: store/chatStore.ts
================
import { create } from 'zustand';

interface ChatMessage {
  id: string;
  content: string;
  timestamp: Date;
  importance: number;
  parentId?: string;
}

interface ChatState {
  messages: ChatMessage[];
  addMessage: (message: Omit<ChatMessage, 'id' | 'timestamp'>) => void;
  archiveMessage: (id: string) => void;
}

export const useChatStore = create<ChatState>((set) => ({
  messages: [],
  addMessage: (message) =>
    set((state) => ({
      messages: [
        ...state.messages,
        {
          ...message,
          id: Math.random().toString(36).substring(7),
          timestamp: new Date(),
        },
      ],
    })),
  archiveMessage: (id) =>
    set((state) => ({
      messages: state.messages.filter((msg) => msg.id !== id),
    })),
}));

================
File: store/spaceStore.ts
================
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export interface Space {
  id: string;
  name: string;
  user_id: string;
  description?: string;
  icon?: string;
  color?: string;
  model: string;
  provider: string;
  created_at: string;
  updated_at: string;
}

interface SpaceStore {
  spaces: Space[];
  activeSpaceId: string | null;
  addSpace: (space: Omit<Space, 'id' | 'created_at' | 'updated_at'>) => void;
  removeSpace: (id: string) => void;
  updateSpace: (id: string, updates: Partial<Space>) => void;
  setActiveSpace: (id: string) => void;
}

export const useSpaceStore = create<SpaceStore>()(
  persist(
    (set) => ({
      spaces: [],
      activeSpaceId: null,
      addSpace: (spaceData) => set((state) => {
        const newSpace: Space = {
          id: crypto.randomUUID(),
          ...spaceData,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };
        return {
          spaces: [...state.spaces, newSpace],
          activeSpaceId: state.activeSpaceId || newSpace.id,
        };
      }),
      removeSpace: (id) => set((state) => ({
        spaces: state.spaces.filter((space) => space.id !== id),
        activeSpaceId: state.activeSpaceId === id
          ? state.spaces[0]?.id || null
          : state.activeSpaceId,
      })),
      updateSpace: (id, updates) => set((state) => ({
        spaces: state.spaces.map((space) =>
          space.id === id
            ? { ...space, ...updates, updated_at: new Date().toISOString() }
            : space
        ),
      })),
      setActiveSpace: (id) => set({ activeSpaceId: id }),
    }),
    {
      name: 'spatial-spaces',
    }
  )
);

================
File: supabase/migrations/20250204124800_create_complete_schema.sql
================
-- Create complete schema for Spatial app
-- Timestamp: 2025-02-04T12:48:00-07:00

-- USERS TABLE: Supabase Auth will manage user accounts.
-- No changes needed; we'll use `auth.users`.

-- SPACES TABLE: Metadata for spaces.
CREATE TABLE spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    is_archived BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on spaces
ALTER TABLE spaces ENABLE ROW LEVEL SECURITY;

-- RLS policies for spaces
CREATE POLICY "Users can view their own spaces"
    ON spaces FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own spaces"
    ON spaces FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own spaces"
    ON spaces FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own spaces"
    ON spaces FOR DELETE
    USING (user_id = auth.uid());

-- CONVERSATIONS TABLE: Each conversation is part of a space.
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    title TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on conversations
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for conversations
CREATE POLICY "Users can view conversations in their spaces"
    ON conversations FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create conversations in their spaces"
    ON conversations FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = space_id
            AND spaces.user_id = auth.uid()
        )
    );

-- MESSAGES TABLE: Each message entry contains both user and assistant messages
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    model_used TEXT,
    provider TEXT,
    parent_message_id UUID REFERENCES messages(id) ON DELETE SET NULL,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on messages
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- RLS policies for messages
CREATE POLICY "Users can view messages in their spaces"
    ON messages FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can insert messages in their spaces"
    ON messages FOR INSERT
    WITH CHECK (
        user_id = auth.uid() AND
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = conversation_id
            AND s.user_id = auth.uid()
        )
    );

-- SPACE_USER_RELATIONS (Optional for shared spaces).
CREATE TABLE space_user_relations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces (id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    role TEXT CHECK (role IN ('owner', 'editor', 'viewer')) DEFAULT 'viewer',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space_user_relations
ALTER TABLE space_user_relations ENABLE ROW LEVEL SECURITY;

-- Add indexes for better query performance
CREATE INDEX idx_spaces_user_id ON spaces(user_id);
CREATE INDEX idx_conversations_space_id ON conversations(space_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_parent_id ON messages(parent_message_id);
CREATE INDEX idx_space_user_relations_space_id ON space_user_relations(space_id);
CREATE INDEX idx_space_user_relations_user_id ON space_user_relations(user_id);

-- Create a function to get the latest messages in a conversation
CREATE OR REPLACE FUNCTION get_conversation_messages(conversation_uuid UUID)
RETURNS TABLE (
    id UUID,
    conversation_id UUID,
    user_id UUID,
    role TEXT,
    content TEXT,
    model_used TEXT,
    parent_message_id UUID,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        m.id,
        m.conversation_id,
        m.user_id,
        m.role,
        m.content,
        m.model_used,
        m.parent_message_id,
        m.created_at,
        m.updated_at
    FROM messages m
    WHERE m.conversation_id = conversation_uuid
    AND m.is_deleted = FALSE
    ORDER BY m.created_at ASC;
END;
$$;

================
File: supabase/migrations/20250204124900_alter_space_table.sql
================
ALTER TABLE "spaces" ADD COLUMN model TEXT NOT NULL DEFAULT 'deepseek-r1-distill-llama-70b';
ALTER TABLE "spaces" ADD COLUMN provider text NOT NULL DEFAULT 'groq';

================
File: supabase/migrations/20250204125000_create_active_space_table.sql
================
-- Create active_spaces table to track which space is active for each user
CREATE TABLE active_spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id)  -- Ensures only one active space per user
);

-- Enable RLS on active_spaces
ALTER TABLE active_spaces ENABLE ROW LEVEL SECURITY;

-- RLS policies for active_spaces
CREATE POLICY "Users can view their own active space"
    ON active_spaces FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can insert their own active space"
    ON active_spaces FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can modify their own active space"
    ON active_spaces FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- Create function to update active space
CREATE OR REPLACE FUNCTION set_active_space(space_uuid UUID)
RETURNS TABLE (
    id UUID,
    user_id UUID,
    space_id UUID,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id UUID;
BEGIN
    -- Get the current user's ID
    v_user_id := auth.uid();
    
    RETURN QUERY
    INSERT INTO active_spaces (user_id, space_id)
    VALUES (v_user_id, space_uuid)
    ON CONFLICT (user_id)
    DO UPDATE SET
        space_id = EXCLUDED.space_id,
        updated_at = now()
    WHERE active_spaces.user_id = v_user_id
    RETURNING active_spaces.*;
END;
$$;

================
File: supabase/.gitignore
================
# Supabase
.branches
.temp
.env

================
File: supabase/config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "ui"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: types/index.ts
================
export interface Space {
  id: string;
  name: string;
  description?: string;
  model: string;
  provider: string;
  is_archived?: boolean;
  is_deleted?: boolean;
  created_at?: string;
  updated_at?: string;
  user_id: string;
  isActive?: boolean;
}

export interface Conversation {
  id: string;
  space_id: string;
  title?: string;
  created_at?: string;
  updated_at?: string;
}

export interface Message {
  id: string;
  conversation_id: string;
  user_id: string;
  role: 'user' | 'assistant';
  content: string;
  model_used?: string;
  provider?: string;
  parent_message_id?: string;
  is_deleted?: boolean;
  created_at?: string;
  updated_at?: string;
}

export function convertToAIMessage(message: Message) {
  // Only include the fields that the AI SDK needs
  return {
    id: message.id,
    role: message.role,
    content: message.content
  };
}

// Helper function to create a new message
export function createMessage(params: {
  conversation_id: string;
  user_id: string;
  role: 'user' | 'assistant';
  content: string;
  model_used?: string;
  parent_message_id?: string;
}): Message {
  return {
    id: crypto.randomUUID(),
    ...params,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    is_deleted: false
  };
}

================
File: utils/supabase/check-env-vars.ts
================
// This check can be removed
// it is just for tutorial purposes

export const hasEnvVars =
  process.env.NEXT_PUBLIC_SUPABASE_URL &&
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

================
File: utils/supabase/client.ts
================
import { createBrowserClient } from "@supabase/ssr";

export const createClient = () =>
  createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );

================
File: utils/supabase/middleware.ts
================
import { createServerClient } from "@supabase/ssr";
import { type NextRequest, NextResponse } from "next/server";

export const updateSession = async (request: NextRequest) => {
  // This `try/catch` block is only here for the interactive tutorial.
  // Feel free to remove once you have Supabase connected.
  try {
    // Create an unmodified response
    let response = NextResponse.next({
      request: {
        headers: request.headers,
      },
    });

    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return request.cookies.getAll();
          },
          setAll(cookiesToSet) {
            cookiesToSet.forEach(({ name, value }) =>
              request.cookies.set(name, value),
            );
            response = NextResponse.next({
              request,
            });
            cookiesToSet.forEach(({ name, value, options }) =>
              response.cookies.set(name, value, options),
            );
          },
        },
      },
    );

    // This will refresh session if expired - required for Server Components
    // https://supabase.com/docs/guides/auth/server-side/nextjs
    const user = await supabase.auth.getUser();

    // protected routes
    if (request.nextUrl.pathname.startsWith("/protected") && user.error) {
      return NextResponse.redirect(new URL("/sign-in", request.url));
    }

    if (request.nextUrl.pathname === "/" && !user.error) {
      return NextResponse.redirect(new URL("/protected", request.url));
    }

    return response;
  } catch (e) {
    // If you are here, a Supabase client could not be created!
    // This is likely because you have not set up environment variables.
    // Check out http://localhost:3000 for Next Steps.
    return NextResponse.next({
      request: {
        headers: request.headers,
      },
    });
  }
};

================
File: utils/supabase/server.ts
================
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export const createClient = async () => {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => {
              cookieStore.set(name, value, options);
            });
          } catch (error) {
            // The `set` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    },
  );
};

================
File: utils/redis.ts
================


================
File: utils/utils.ts
================
import { redirect } from "next/navigation";

/**
 * Redirects to a specified path with an encoded message as a query parameter.
 * @param {('error' | 'success')} type - The type of message, either 'error' or 'success'.
 * @param {string} path - The path to redirect to.
 * @param {string} message - The message to be encoded and added as a query parameter.
 * @returns {never} This function doesn't return as it triggers a redirect.
 */
export function encodedRedirect(
  type: "error" | "success",
  path: string,
  message: string,
) {
  return redirect(`${path}?${type}=${encodeURIComponent(message)}`);
}

================
File: .cursorrules
================
After each composer completion, you must add what we have done to a file called changelog.md at the rootlevel.


  You are an expert in JavaScript, React, Node.js, Next.js App Router, Zustand, Shadcn UI, Radix UI, Tailwind, and Stylus.

  Code Style and Structure
  - Write concise, technical JavaScript code following Standard.js rules.
  - Use functional and declarative programming patterns; avoid classes.
  - Prefer iteration and modularization over code duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
  - Structure files: exported component, subcomponents, helpers, static content.

  Standard.js Rules
  - Use 2 space indentation.
  - Use single quotes for strings except to avoid escaping.
  - No semicolons (unless required to disambiguate statements).
  - No unused variables.
  - Add a space after keywords.
  - Add a space before a function declaration's parentheses.
  - Always use === instead of ==.
  - Infix operators must be spaced.
  - Commas should have a space after them.
  - Keep else statements on the same line as their curly braces.
  - For multi-line if statements, use curly braces.
  - Always handle the err function parameter.
  - Use camelcase for variables and functions.
  - Use PascalCase for constructors and React components.

  Naming Conventions
  - Use lowercase with dashes for directories (e.g., components/auth-wizard).
  - Favor named exports for components.

  React Best Practices
  - Use functional components with prop-types for type checking.
  - Use the "function" keyword for component definitions.
  - Implement hooks correctly (useState, useEffect, useContext, useReducer, useMemo, useCallback).
  - Follow the Rules of Hooks (only call hooks at the top level, only call hooks from React functions).
  - Create custom hooks to extract reusable component logic.
  - Use React.memo() for component memoization when appropriate.
  - Implement useCallback for memoizing functions passed as props.
  - Use useMemo for expensive computations.
  - Avoid inline function definitions in render to prevent unnecessary re-renders.
  - Prefer composition over inheritance.
  - Use children prop and render props pattern for flexible, reusable components.
  - Implement React.lazy() and Suspense for code splitting.
  - Use refs sparingly and mainly for DOM access.
  - Prefer controlled components over uncontrolled components.
  - Implement error boundaries to catch and handle errors gracefully.
  - Use cleanup functions in useEffect to prevent memory leaks.
  - Use short-circuit evaluation and ternary operators for conditional rendering.

  State Management
  - Use Zustand for global state management.
  - Lift state up when needed to share state between components.
  - Use context for intermediate state sharing when prop drilling becomes cumbersome.

  UI and Styling
  - Use Shadcn UI and Radix UI for component foundations.
  - Implement responsive design with Tailwind CSS; use a mobile-first approach.
  - Use Stylus as CSS Modules for component-specific styles:
    - Create a .module.styl file for each component that needs custom styling.
    - Use camelCase for class names in Stylus files.
    - Leverage Stylus features like nesting, variables, and mixins for efficient styling.
  - Implement a consistent naming convention for CSS classes (e.g., BEM) within Stylus modules.
  - Use Tailwind for utility classes and rapid prototyping.
  - Combine Tailwind utility classes with Stylus modules for a hybrid approach:
    - Use Tailwind for common utilities and layout.
    - Use Stylus modules for complex, component-specific styles.
    - Never use the @apply directive

  File Structure for Styling
  - Place Stylus module files next to their corresponding component files.
  - Example structure:
    components/
      Button/
        Button.js
        Button.module.styl
      Card/
        Card.js
        Card.module.styl

  Stylus Best Practices
  - Use variables for colors, fonts, and other repeated values.
  - Create mixins for commonly used style patterns.
  - Utilize Stylus' parent selector (&) for nesting and pseudo-classes.
  - Keep specificity low by avoiding deep nesting.

  Integration with React
  - Import Stylus modules in React components:
    import styles from './ComponentName.module.styl'
  - Apply classes using the styles object:
    <div className={styles.containerClass}>

  Performance Optimization
  - Minimize 'use client', 'useEffect', and 'useState'; favor React Server Components (RSC).
  - Wrap client components in Suspense with fallback.
  - Use dynamic loading for non-critical components.
  - Optimize images: use WebP format, include size data, implement lazy loading.
  - Implement route-based code splitting in Next.js.
  - Minimize the use of global styles; prefer modular, scoped styles.
  - Use PurgeCSS with Tailwind to remove unused styles in production.

  Forms and Validation
  - Use controlled components for form inputs.
  - Implement form validation (client-side and server-side).
  - Consider using libraries like react-hook-form for complex forms.
  - Use Zod or Joi for schema validation.

  Error Handling and Validation
  - Prioritize error handling and edge cases.
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging and user-friendly error messages.
  - Model expected errors as return values in Server Actions.

  Accessibility (a11y)
  - Use semantic HTML elements.
  - Implement proper ARIA attributes.
  - Ensure keyboard navigation support.

  Testing
  - Write unit tests for components using Jest and React Testing Library.
  - Implement integration tests for critical user flows.
  - Use snapshot testing judiciously.

  Security
  - Sanitize user inputs to prevent XSS attacks.
  - Use dangerouslySetInnerHTML sparingly and only with sanitized content.

  Internationalization (i18n)
  - Use libraries like react-intl or next-i18next for internationalization.

  Key Conventions
  - Use 'nuqs' for URL search parameter state management.
  - Optimize Web Vitals (LCP, CLS, FID).
  - Limit 'use client':
    - Favor server components and Next.js SSR.
    - Use only for Web API access in small components.
    - Avoid for data fetching or state management.
  - Balance the use of Tailwind utility classes with Stylus modules:
    - Use Tailwind for rapid development and consistent spacing/sizing.
    - Use Stylus modules for complex, unique component styles.

  Follow Next.js docs for Data Fetching, Rendering, and Routing.

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: changelog.md
================
# Changelog

## [Unreleased]

### Added
- Search box clearing functionality when navigating between different command modal views
  - Clears search when selecting a provider in models view
  - Clears search when selecting a specific model
  - Clears search when selecting a space
  - Clears search when using quick actions to switch views 
- New space creation form in command modal
  - Added form interface with name, description, provider, and model fields
  - Auto-populates available models based on selected provider
  - Form validation and error handling
  - Smooth navigation with back button support
  - Removed search functionality in form view
  - Fixed "No results found" message to only show during active search
  - Improved space creation workflow from space tab
  - Fixed back button visibility in form view
- Added server-side active space management
  - New setActive flag in space creation API
  - Automatic active space persistence in database
  - Proper active space state handling across sessions
  - Upsert functionality to maintain single active space per user
- Improved spaces list organization
  - Spaces now sorted by last updated date
  - Active space always appears at the top
  - Enhanced visual indication of active space
  - Added "Active" label to current space
  - Improved contrast and visibility of active state
  - Added spacing between space items
  - Enhanced hover effects with subtle transitions
  - Added backdrop blur and border effects
  - Improved visual hierarchy with better shadows
- Added automatic spaces list refresh
  - Command window now fetches latest spaces data when opened
  - Ensures active space is correctly reflected in UI
  - Maintains consistency between backend and frontend state
- Enhanced keyboard navigation in command modal
  - Arrow keys now navigate between search input and list items
  - Up arrow from first list item returns focus to search
  - Down arrow from search moves focus to first list item
  - Maintains natural focus flow for better user experience
  - Preserves existing keyboard shortcuts and navigation
- Improved empty state handling in spaces list
  - Added "No spaces found" message when no spaces exist
  - Moved create space button to center of empty state
  - Enhanced visibility of space creation option
  - Added proper type definitions for space active state
  - Improved user experience for first-time users
- Added keyboard back navigation in command modal
  - Backspace key now acts as back button when search is empty
  - Matches back button behavior for all navigation states
  - Handles space form, spaces list, and models views
  - Preserves search functionality when typing
- Added active provider indication
  - Matches active model styling for consistency
  - Shows active state with visual indicators
  - Added "Active" label to current provider
  - Enhanced visual feedback for active state
- Enhanced default space creation with improved welcome message
  - Added detailed welcome message with AI assistant capabilities
  - Improved onboarding experience for new users
  - Added bullet points for key features and use cases
- Implemented Redis caching with Upstash
  - Added Redis client configuration with TTL settings
  - Implemented caching for spaces, active spaces, conversations, and messages
  - Added cache invalidation on data updates
  - Added cache key generators for consistent key naming
  - Optimized API routes to check cache before database
  - Added background cache updates for better performance
  - Implemented 5-minute TTL for all cached data
  - Added proper cache invalidation on write operations
  - Enhanced response times with Redis caching

### Fixed
- Back button now properly visible at the top of the space creation form
- Added proper padding to modal header when search is hidden
- Adjusted create space button to be more compact and consistent with UI
  - Reduced padding and font size
  - Added border and backdrop blur
  - Adjusted text opacity for better visual harmony
  - Made button width more compact and centered
- Fixed spaces list not updating immediately after creating a new space 
  - Now fetches the complete updated list of spaces from the server after creation
  - Ensures the UI reflects the latest state without requiring a page refresh
- Fixed inconsistent modal behavior when opening from space tab
  - Now uses openQuickActionsCommand instead of toggle to ensure consistent state
  - Prevents state synchronization issues between different open methods
- Fixed space creation initialization issues
  - Now creates initial conversation and welcome message for new spaces
  - Properly initializes all states (spaces, conversations, messages)
  - Ensures smooth transition after space creation
  - Prevents "stuck generating" state in new spaces
  - Added consistent model tags for all messages
  - Removed unnecessary loading states during creation
  - Sets new space as active immediately after creation
  - Persists active space state across page refreshes
- Fixed infinite update loop in state management
  - Removed unnecessary page reload after space creation
  - Improved state update sequence to prevent circular dependencies
  - Fixed maximum update depth exceeded error
- Fixed chat message loading and state management
  - Removed duplicate message loading effects
  - Added message caching to prevent unnecessary reloads
  - Fixed circular dependencies in effects and callbacks
  - Improved streaming message state management
  - Removed unnecessary state updates and re-renders
- Fixed space switching behavior
  - Removed all loading states during space switching
  - Eliminated error state updates for non-critical operations
  - Enhanced user experience with instant space transitions
  - Prevented loading screen from appearing during space changes
  - Maintained smooth UI transitions without interruptions
- Improved keyboard navigation in command modal
  - Fixed arrow key navigation between search and list items
  - Added proper focus management for list items
  - Improved integration with CMDK's built-in navigation
  - Enhanced accessibility for keyboard users
  - Fixed edge cases with focus handling
- Fixed command modal keyboard navigation
  - Properly integrated with CMDK's native keyboard navigation
  - Fixed arrow key navigation between search and items
  - Added support for cycling through items with loop
  - Corrected component hierarchy for better accessibility
  - Removed custom navigation logic that interfered with built-in behavior
- Optimized command modal structure
  - Simplified DOM hierarchy to match CMDK's expectations
  - Fixed keyboard navigation between search and items
  - Enabled simultaneous focus of search and first item
  - Improved filtering and sorting behavior
  - Enhanced list scrolling and item cycling
- Improved command modal structure and navigation
  - Added proper Command.Group components for better keyboard navigation
  - Fixed list item grouping and hierarchy
  - Enhanced focus management between groups
  - Improved accessibility with proper ARIA roles
  - Maintained consistent styling within groups
- Updated Next.js API route params handling for version 15
  - Properly awaiting params object in dynamic route handlers
  - Updated type definitions to reflect Promise-based params
  - Fixed params access pattern to match Next.js 15 requirements
  - Improved type safety with proper Promise typing
  - Added proper async handling in spaces API routes
  - Standardized params handling across all dynamic routes
  - Added model validation in spaces update endpoint
  - Improved space update data handling
- Fixed automatic space creation on first load
  - Added proper error handling in spaces provider
  - Improved initialization logic for new users
  - Added automatic creation of first space when none exist
  - Set proper default values for initial space
- Fixed create space button visibility
  - Button now shows consistently in spaces view
  - Appears both when spaces list is empty and when spaces exist
  - Improved button placement and styling
  - Enhanced user experience for space creation workflow
- Improved keyboard navigation visual feedback
  - Added proper hover effects for keyboard-selected items
  - Unified hover and keyboard selection styles
  - Added data-selected state handling for all command items
  - Enhanced visual feedback for keyboard navigation
  - Improved accessibility with consistent focus styles
  - Fixed opacity transitions for icons during keyboard navigation
  - Added proper group data attributes for nested elements
- Fixed spaces list and creation functionality
  - Added automatic default space creation for new users
  - Improved create space button visibility and styling
  - Fixed empty state handling in spaces list
  - Added proper autofocus to space creation form
  - Enhanced visual feedback for space creation
  - Improved error handling in spaces API
  - Added proper type checking for space active state
  - Fixed space switching behavior
  - Improved user experience for first-time users
- Improved modal structure for fixed footer
  - Added proper flex layout for scrollable content
  - Fixed footer positioning at bottom of modal
  - Added border separator for visual clarity
  - Maintained consistent padding and spacing
- Fixed multiple active spaces issue
  - Added proper clearing of previous active space when creating new space
  - Updated client-side state management to correctly handle active states
  - Removed upsert in favor of delete + insert for active space management
  - Ensured only one space can be active at a time
  - Fixed active state visual indicators
- Fixed active space management
  - Resolved unique constraint violation in active_spaces table
  - Updated POST handler to use upsert instead of insert
  - Added proper timestamp handling for active space updates
  - Improved client-side active state management
  - Ensured consistent active state between client and server
  - Fixed race conditions in space activation
- Improved model switching behavior
  - Removed unnecessary loading state updates in status tab
  - Simplified model selection logic
  - Removed error state updates for non-critical operations
  - Enhanced user experience with smoother model switching
- Improved command modal focus management
  - Added automatic focus on first item in nested lists
  - Ensured consistent focus behavior across all navigation states
  - Fixed focus when switching between providers and models
  - Added proper data-selected attributes for visual feedback
  - Improved keyboard navigation experience
- Fixed model name display in default space creation
  - Updated default space creation to use correct model ID from AVAILABLE_MODELS configuration
  - Ensures consistent model naming between UI and backend
  - Fixed customer-facing model names in initial space setup
  - Removed hardcoded model IDs in favor of configuration-based values
- Optimized space creation performance
  - Removed unnecessary loading states during space creation
  - Made modal close immediately after initiating space creation
  - Moved conversation and message creation to background operations
  - Improved initial space creation responsiveness
  - Reduced perceived latency in space switching
  - Eliminated loading screen during space operations
  - Enhanced user experience with instant feedback
  - Optimized state updates for smoother transitions
  - Improved error handling with silent background operations
- Further optimized space creation performance
  - Made conversation and welcome message creation synchronous
  - Ensured initial message appears immediately without refresh
  - Improved state updates to include all related data
  - Enhanced space provider initialization
  - Made initial space creation synchronous
  - Added proper active space handling during initialization
  - Reduced overall latency in space operations
  - Improved state consistency across components
  - Fixed missing welcome message on first load
- Further optimized loading states during space operations
  - Removed loading screen during space creation and initialization
  - Initialized spaces provider with isInitialized true by default
  - Simplified loading state logic to only show during initial auth check
  - Improved state management to prevent unnecessary loading screens
  - Enhanced user experience with immediate UI feedback
  - Optimized space provider initialization flow
  - Removed redundant loading states in protected route
  - Streamlined space creation and switching process
- Fixed JSON parsing errors in Redis caching implementation
  - Updated conversations route to use new cache helper functions
  - Updated messages route to use new cache helper functions
  - Removed manual JSON.parse/stringify operations
  - Improved error handling in cache operations
  - Fixed type safety in cache data handling
- Improved error handling in API routes
- Enhanced type safety in API responses
- Enhanced message creation with proper schema validation:
  - Added validation for role field (must be 'user' or 'assistant')
  - Added proper handling of is_deleted field
  - Added validation for parent_message_id existence
  - Added all required fields from database schema
  - Improved error messages for invalid fields
  - Added warning for invalid parent message references
  - Added required model_used and provider validation for assistant messages
  - Fixed missing fields error during message creation
  - Enhanced error handling and response formatting
  - Improved type safety with Message interface
  - Added proper cache invalidation after message creation

### Changed
- Updated quick actions menu names to be more concise
  - Changed "Switch Space" to "Spaces"
  - Changed "Switch Model" to "Models"
- Improved keyboard shortcut styling
  - Made shortcut keys perfect squares with consistent dimensions
  - Added flex layout for better centering
  - Standardized size to 24x24 pixels
- Improved command modal response time
  - Modal now closes immediately upon selection (space or model)
  - Actions continue in background after modal closes
  - Better user experience with instant feedback
- Improved space creation process
  - Form now only requires space name to be valid
  - Default model is automatically selected
  - Modal closes immediately when creating space
  - Creation process continues in background
  - Faster and more responsive user experience 
  - No loading indicators during space creation
  - Immediate activation of newly created spaces
  - Active space persists across page refreshes
- Enhanced model selection interface
  - Added visual indication of active model
  - Consistent styling with spaces list
  - Added "Active" label to current model
  - Improved hover effects and transitions
  - Better spacing and visual hierarchy
  - Added backdrop blur and border effects
- Unified command modal item styling
  - Consistent hover effects across all items
  - Added subtle borders and transitions
  - Improved spacing and padding
  - Enhanced visual feedback on interaction
  - Standardized rounded corners
  - Added backdrop blur effect to all items
  - Smoother opacity transitions for icons 
- Updated create space button styling
  - Changed to primary action button style
  - Added hover and focus states
  - Improved visual feedback
  - Centered in footer with max width 
- Refactored API routes for better type safety and error handling
- Improved cache key management
- Enhanced response formatting for better client compatibility
- Standardized API response structure

### Performance
- Optimized Redis caching implementation
- Reduced unnecessary JSON parsing operations
- Improved cache hit ratio with better invalidation strategy
- Enhanced response times for frequently accessed data
- Implemented Redis helper functions for consistent cache operations:
  - `setCache`: Handles JSON serialization and TTL setting
  - `getCache`: Handles JSON parsing and type safety
  - `deleteCache`: Handles cache invalidation
- Updated all API routes to use new cache helper functions:
  - Spaces route now uses consistent caching pattern
  - Conversations route implements proper cache invalidation
  - Messages route includes improved error handling
- Added proper error logging across all routes
- Implemented consistent error response format

### Fixed
- Improved cache invalidation when switching models:
  - Added cache clearing for all conversations in a space
  - Added cache clearing for all messages in affected conversations
  - Added cache clearing for active space and spaces list
  - Fixed issue where old model settings were persisting in cache
  - Added proper cache invalidation triggers in space update endpoint
  - Improved cache key management for model-specific data
  - Enhanced cache consistency during model switches
- Improved message creation error handling:
  - Added proper validation for required fields (content and role)
  - Added clear error messages for missing fields
  - Improved type safety with Message interface
  - Added proper handling of optional fields
  - Enhanced error logging and status codes
  - Fixed "Missing required fields" error during chat
- Fixed JSON parsing errors in Redis caching implementation:
  - Updated conversations route to use new cache helper functions
  - Updated messages route to use new cache helper functions
  - Removed manual JSON.parse/stringify operations
  - Improved error handling in cache operations
  - Fixed type safety in cache data handling
- Improved error handling in API routes
- Enhanced type safety in API responses

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}

================
File: middleware.ts
================
import { type NextRequest } from "next/server";
import { updateSession } from "@/utils/supabase/middleware";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - images - .svg, .png, .jpg, .jpeg, .gif, .webp
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};

================
File: next.config.ts
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: "standalone",
  reactStrictMode: true,
  env: {
    NEXT_PUBLIC_SUPPORTED_MODELS: process.env.SUPPORTED_MODELS,
    NEXT_PUBLIC_MODEL_PROVIDERS: process.env.MODEL_PROVIDERS,
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'unpkg.com',
        pathname: '/@lobehub/**',
      },
      {
        protocol: 'https',
        hostname: 'registry.npmmirror.com',
        pathname: '/@lobehub/**',
      }
    ],
  },
  transpilePackages: ['@lobehub/icons'],
};

export default nextConfig;

================
File: nodemon.json
================
{
    "$schema": "https://json.schemastore.org/nodemon.json",
    "exec": "electron .",
    "watch": ["build"],
    "ignore": ["build", "public/build"]
  }

================
File: package.json
================
{
  "private": true,
  "main": "build/main.js",
  "scripts": {
    "next:dev": "next dev",
    "next:build": "next build",
    "electron:build": "tsup",
    "electron:build_watch": "tsup --watch",
    "electron:watch": "cross-env NODE_ENV='development' nodemon",
    "electron:dev": "npm-run-all --parallel electron:build_watch electron:watch",
    "dev": "npm-run-all --parallel electron:dev next:dev"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.1.6",
    "@ai-sdk/cerebras": "^0.1.8",
    "@ai-sdk/cohere": "^1.1.7",
    "@ai-sdk/deepseek": "^0.1.8",
    "@ai-sdk/fireworks": "^0.1.8",
    "@ai-sdk/google": "^1.1.10",
    "@ai-sdk/groq": "^1.1.7",
    "@ai-sdk/mistral": "^1.1.6",
    "@ai-sdk/openai": "^1.1.9",
    "@ai-sdk/perplexity": "^0.0.7",
    "@ai-sdk/togetherai": "^0.1.9",
    "@ai-sdk/xai": "^1.1.8",
    "@electron-toolkit/utils": "^3.0.0",
    "@lobehub/icons": "^1.68.0",
    "@openrouter/ai-sdk-provider": "^0.2.0",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@supabase/ssr": "latest",
    "@supabase/supabase-js": "latest",
    "ai": "^4.1.16",
    "autoprefixer": "10.4.20",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.4",
    "framer-motion": "^12.0.6",
    "get-port-please": "^3.1.2",
    "lucide-react": "^0.468.0",
    "next": "latest",
    "next-themes": "^0.4.3",
    "prettier": "^3.3.3",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-intersection-observer": "^9.15.1",
    "react-textarea-autosize": "^8.5.7",
    "shiki": "^2.2.0",
    "zod": "^3.24.1",
    "zod-to-json-schema": "^3.24.1",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@swc/core": "^1.10.12",
    "@swc/helpers": "^0.5.15",
    "@types/node": "22.10.2",
    "@types/react": "^19.0.2",
    "@types/react-dom": "19.0.2",
    "cross-env": "^7.0.3",
    "electron": "^34.0.2",
    "electron-builder": "^25.1.8",
    "nodemon": "^3.1.9",
    "npm-run-all": "^4.1.5",
    "postcss": "8.4.49",
    "tailwind-merge": "^2.5.2",
    "tailwindcss": "3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "tsup": "^8.3.6",
    "typescript": "5.7.2"
  }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: README.md
================
<a href="https://demo-nextjs-with-supabase.vercel.app/">
  <img alt="Next.js and Supabase Starter Kit - the fastest way to build apps with Next.js and Supabase" src="https://demo-nextjs-with-supabase.vercel.app/opengraph-image.png">
  <h1 align="center">Next.js and Supabase Starter Kit</h1>
</a>

<p align="center">
 The fastest way to build apps with Next.js and Supabase
</p>

<p align="center">
  <a href="#features"><strong>Features</strong></a> Â·
  <a href="#demo"><strong>Demo</strong></a> Â·
  <a href="#deploy-to-vercel"><strong>Deploy to Vercel</strong></a> Â·
  <a href="#clone-and-run-locally"><strong>Clone and run locally</strong></a> Â·
  <a href="#feedback-and-issues"><strong>Feedback and issues</strong></a>
  <a href="#more-supabase-examples"><strong>More Examples</strong></a>
</p>
<br/>

## Features

- Works across the entire [Next.js](https://nextjs.org) stack
  - App Router
  - Pages Router
  - Middleware
  - Client
  - Server
  - It just works!
- supabase-ssr. A package to configure Supabase Auth to use cookies
- Styling with [Tailwind CSS](https://tailwindcss.com)
- Components with [shadcn/ui](https://ui.shadcn.com/)
- Optional deployment with [Supabase Vercel Integration and Vercel deploy](#deploy-your-own)
  - Environment variables automatically assigned to Vercel project

## Demo

You can view a fully working demo at [demo-nextjs-with-supabase.vercel.app](https://demo-nextjs-with-supabase.vercel.app/).

## Deploy to Vercel

Vercel deployment will guide you through creating a Supabase account and project.

After installation of the Supabase integration, all relevant environment variables will be assigned to the project so the deployment is fully functioning.

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&project-name=nextjs-with-supabase&repository-name=nextjs-with-supabase&demo-title=nextjs-with-supabase&demo-description=This+starter+configures+Supabase+Auth+to+use+cookies%2C+making+the+user%27s+session+available+throughout+the+entire+Next.js+app+-+Client+Components%2C+Server+Components%2C+Route+Handlers%2C+Server+Actions+and+Middleware.&demo-url=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2F&external-id=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&demo-image=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2Fopengraph-image.png)

The above will also clone the Starter kit to your GitHub, you can clone that locally and develop locally.

If you wish to just develop locally and not deploy to Vercel, [follow the steps below](#clone-and-run-locally).

## Clone and run locally

1. You'll first need a Supabase project which can be made [via the Supabase dashboard](https://database.new)

2. Create a Next.js app using the Supabase Starter template npx command

   ```bash
   npx create-next-app --example with-supabase with-supabase-app
   ```

   ```bash
   yarn create next-app --example with-supabase with-supabase-app
   ```

   ```bash
   pnpm create next-app --example with-supabase with-supabase-app
   ```

3. Use `cd` to change into the app's directory

   ```bash
   cd with-supabase-app
   ```

4. Rename `.env.example` to `.env.local` and update the following:

   ```
   NEXT_PUBLIC_SUPABASE_URL=[INSERT SUPABASE PROJECT URL]
   NEXT_PUBLIC_SUPABASE_ANON_KEY=[INSERT SUPABASE PROJECT API ANON KEY]
   ```

   Both `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` can be found in [your Supabase project's API settings](https://app.supabase.com/project/_/settings/api)

5. You can now run the Next.js local development server:

   ```bash
   npm run dev
   ```

   The starter kit should now be running on [localhost:3000](http://localhost:3000/).

6. This template comes with the default shadcn/ui style initialized. If you instead want other ui.shadcn styles, delete `components.json` and [re-install shadcn/ui](https://ui.shadcn.com/docs/installation/next)

> Check out [the docs for Local Development](https://supabase.com/docs/guides/getting-started/local-development) to also run Supabase locally.

## Feedback and issues

Please file feedback and issues over on the [Supabase GitHub org](https://github.com/supabase/supabase/issues/new/choose).

## More Supabase examples

- [Next.js Subscription Payments Starter](https://github.com/vercel/nextjs-subscription-payments)
- [Cookie-based Auth and the Next.js 13 App Router (free course)](https://youtube.com/playlist?list=PL5S4mPUpp4OtMhpnp93EFSo42iQ40XjbF)
- [Supabase Auth and the Next.js App Router](https://github.com/supabase/supabase/tree/master/examples/auth/nextjs)
# spatial-application

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: tsup.config.ts
================
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["./electron/main.ts", "./electron/preload.ts"],
  splitting: false,
  sourcemap: false,
  clean: true,
  outDir: "build",
  external: ["electron"],
  format: ["cjs"]
});
