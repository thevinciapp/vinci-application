This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-27T20:42:32.807Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    project.mdc
app/
  (auth-pages)/
    forgot-password/
      page.tsx
    sign-in/
      page.tsx
    sign-up/
      page.tsx
    layout.tsx
    smtp-message.tsx
  api/
    auth/
      callback/
        route.ts
    chat/
      route.ts
  protected/
    profile/
      page.tsx
    reset-password/
      page.tsx
    settings/
      page.tsx
    page.tsx
  actions.ts
  globals.css
  layout.tsx
  page.tsx
components/
  providers/
    DataProvider.tsx
    Providers.tsx
  ui/
    auth/
      form-message.tsx
      header-auth.tsx
      submit-button.tsx
      user-profile-dropdown.tsx
    chat/
      chat-content-client.tsx
      chat-message.tsx
      chat-messages-skeleton.tsx
      chat-messages.tsx
      chat-mode-tab.tsx
      language-icon.tsx
      loading-message.tsx
      markdown-renderer.tsx
      markdown.tsx
      model-tab.tsx
      provider-icon.tsx
      stream-status.tsx
      unified-input.tsx
    common/
      avatar.tsx
      badge.tsx
      base-tab.tsx
      button.tsx
      card.tsx
      checkbox.tsx
      code-block.tsx
      command-badge.tsx
      dialog.tsx
      dropdown-menu.tsx
      input.tsx
      label.tsx
      select.tsx
      switch.tsx
      theme-switcher.tsx
      toast.tsx
      toaster.tsx
      tooltip.tsx
    conversation/
      conversation-tab.tsx
    space/
      planet-icon.tsx
      space-tab.tsx
    command.tsx
    quick-actions-tab.tsx
    tab-skeleton.tsx
    tabs.tsx
  CommandButton.tsx
  CommandCenter.tsx
  CommandProviders.tsx
  CommandRoot.tsx
  CommandShortcuts.tsx
config/
  models.ts
docs/
  COMMAND_SYSTEM.md
electron/
  main.ts
hooks/
  use-stick-to-bottom.ts
  use-toast.ts
  useCommandCenter.tsx
public/
  icons/
    providers/
      default.svg
      groq.svg
store/
  useSpacesStore.ts
stores/
  conversation-store.ts
  messages-search-store.ts
  modal-navigation-store.ts
  notification-store.ts
  space-store.ts
supabase/
  migrations/
    20250204124800_create_complete_schema.sql
    20250204124900_alter_space_table.sql
    20250204125000_create_active_space_table.sql
    20250204125100_update_rls_policies.sql
    20250221221400_add_active_conversations.sql
    20250223171800_add_notifications.sql
    20250223171900_add_realtime_notifications.sql
    20250223175200_add_space_history.sql
    20250223175201_migration_add_is_deleted_to_conversations.sql
    20250225012800_add_conversations_update_policy.sql
  .gitignore
  config.toml
  repomix-output.txt
types/
  index.ts
utils/
  supabase/
    check-env-vars.ts
    client.ts
    middleware.ts
    server.ts
  pinecone.ts
.gitignore
components.json
constants.ts
middleware.ts
next.config.ts
nodemon.json
package.json
postcss.config.js
README.md
tailwind.config.ts
tsconfig.json
tsup.config.ts
utils.ts

================================================================
Files
================================================================

================
File: .cursor/rules/project.mdc
================
---
description: 
globs: 
alwaysApply: true
---
You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS, and modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You provide thoughtful, nuanced, and accurate answers, excelling at logical reasoning and best practices.

Strictly adhere to the user’s requirements, implementing all requested functionality completely.
Plan your solution step-by-step in detailed pseudocode before coding, ensuring clarity and structure.
Confirm the plan with the user, then proceed to write code.
Write clean, bug-free, fully functional code following the DRY (Don’t Repeat Yourself) principle, SOLID principles (e.g., Single Responsibility, Open/Closed), and the Code Implementation Guidelines below.
Prioritize readability, simplicity, and scalability—design solutions to be reusable and maintainable, avoiding hardcoding or repetition, as if supporting a million users or a million conditional cases.
Include all necessary imports and use descriptive, meaningful names for variables, constants, and components.
Leave no incomplete sections, placeholders, or TODOs—deliver fully verified, production-ready code.
If a solution isn’t feasible or you lack sufficient knowledge, clearly state so instead of guessing.
Coding Environment
You specialize in:

ReactJS
NextJS
JavaScript
TypeScript
TailwindCSS
HTML
CSS
Code Implementation Guidelines
Adhere to these best practices:

Use early returns to flatten logic and enhance readability.
Style with TailwindCSS classes exclusively; avoid raw CSS or <style> tags.
Prefer class: syntax over ternary operators in class attributes where applicable.
Use clear, descriptive names (e.g., handleClick for onClick, handleKeyDown for onKeyDown).
Ensure accessibility (a11y) with attributes like tabindex="0", aria-label, and event handlers (onClick, onKeyDown).
Favor const arrow functions (e.g., const toggle = () =>) over traditional function declarations, and define TypeScript types where applicable.
For scalability, favor data-driven approaches (e.g., arrays, maps, or configs) over repetitive conditionals or static code, ensuring easy extension and reuse.

================
File: app/(auth-pages)/forgot-password/page.tsx
================
import { forgotPasswordAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import Link from "next/link";
import { SmtpMessage } from "../smtp-message";

export default async function ForgotPassword(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  return (
    <>
      <form className="flex flex-col w-full">
        <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-6">
          <div className="flex flex-col gap-2 mb-8">
            <h1 className="text-2xl font-medium text-white/90">Reset Password</h1>
            <p className="text-sm text-white/60">
              Already have an account?{" "}
              <Link className="text-[#3ecfff]/80 hover:text-[#3ecfff] transition-colors" href="/sign-in">
                Sign in
              </Link>
            </p>
          </div>
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-2">
              <Label htmlFor="email" className="text-white/60">Email</Label>
              <Input 
                name="email" 
                placeholder="you@example.com" 
                required 
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <SubmitButton 
              formAction={forgotPasswordAction} 
              pendingText="Sending reset link..."
              variant="cyan"
            >
              Reset Password
            </SubmitButton>
            <FormMessage message={searchParams} />
          </div>
        </div>
      </form>
      <div className="mt-6">
        <SmtpMessage />
      </div>
    </>
  );
}

================
File: app/(auth-pages)/sign-in/page.tsx
================
import { signInAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import Link from "next/link";

export default async function Login(props: { searchParams: Promise<Message> }) {
  const searchParams = await props.searchParams;
  return (
    <form className="flex flex-col w-full">
      <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-6">
        <div className="flex flex-col gap-2 mb-8">
          <h1 className="text-2xl font-medium text-white/90">Sign in</h1>
          <p className="text-sm text-white/60">
            Don't have an account?{" "}
            <Link className="text-[#3ecfff]/80 hover:text-[#3ecfff] transition-colors" href="/sign-up">
              Sign up
            </Link>
          </p>
        </div>
        <div className="flex flex-col gap-4">
          <div className="flex flex-col gap-2">
            <Label htmlFor="email" className="text-white/60">Email</Label>
            <Input 
              name="email" 
              placeholder="you@example.com" 
              required 
              className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
            />
          </div>
          <div className="flex flex-col gap-2">
            <div className="flex justify-between items-center">
              <Label htmlFor="password" className="text-white/60">Password</Label>
              <Link
                className="text-xs text-[#3ecfff]/60 hover:text-[#3ecfff]/80 transition-colors"
                href="/forgot-password"
              >
                Forgot Password?
              </Link>
            </div>
            <Input
              type="password"
              name="password"
              placeholder="Your password"
              required
              className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
            />
          </div>
          <SubmitButton 
            pendingText="Signing In..." 
            formAction={signInAction}
            variant="cyan"
          >
            Sign in
          </SubmitButton>
          <FormMessage message={searchParams} />
        </div>
      </div>
    </form>
  );
}

================
File: app/(auth-pages)/sign-up/page.tsx
================
import { signUpAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";
import Link from "next/link";
import { SmtpMessage } from "../smtp-message";

export default async function Signup(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  if ("message" in searchParams) {
    return (
      <div className="w-full flex-1 flex items-center justify-center">
        <FormMessage message={searchParams} />
      </div>
    );
  }

  return (
    <>
      <form className="flex flex-col w-full">
        <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-xl p-6">
          <div className="flex flex-col gap-2 mb-8">
            <h1 className="text-2xl font-medium text-white/90">Sign up</h1>
            <p className="text-sm text-white/60">
              Already have an account?{" "}
              <Link className="text-[#3ecfff]/80 hover:text-[#3ecfff] transition-colors" href="/sign-in">
                Sign in
              </Link>
            </p>
          </div>
          <div className="flex flex-col gap-4">
            <div className="flex flex-col gap-2">
              <Label htmlFor="email" className="text-white/60">Email</Label>
              <Input 
                name="email" 
                placeholder="you@example.com" 
                required 
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <div className="flex flex-col gap-2">
              <Label htmlFor="password" className="text-white/60">Password</Label>
              <Input
                type="password"
                name="password"
                placeholder="Your password"
                minLength={6}
                required
                className="bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl text-white/90 h-11 px-4 py-2 rounded-lg focus:border-[#3ecfff]/50 focus:ring-0 transition-colors placeholder:text-white/20"
              />
            </div>
            <SubmitButton 
              formAction={signUpAction} 
              pendingText="Signing up..."
              variant="cyan"
            >
              Sign up
            </SubmitButton>
            <FormMessage message={searchParams} />
          </div>
        </div>
      </form>
      <div className="mt-6">
        <SmtpMessage />
      </div>
    </>
  );
}

================
File: app/(auth-pages)/layout.tsx
================
export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-black text-white relative overflow-hidden">
      <div className="absolute top-0 left-0 w-full h-screen pointer-events-none">
        <div className="absolute top-0 left-[20%] w-[500px] h-[500px] bg-[#3ecfff]/[0.015] blur-[120px] rounded-full" />
        <div className="absolute top-[20%] right-[20%] w-[400px] h-[400px] bg-[#D4966A]/[0.015] blur-[100px] rounded-full" />
        <div className="absolute bottom-[10%] left-[30%] w-[600px] h-[600px] bg-[#3ecfff]/[0.01] blur-[130px] rounded-full" />
      </div>
      <div className="relative z-10 w-full max-w-md p-6">
        {children}
      </div>
    </div>
  );
}

================
File: app/(auth-pages)/smtp-message.tsx
================
import { ArrowUpRight, InfoIcon } from "lucide-react";
import Link from "next/link";

export function SmtpMessage() {
  return (
    <div className="bg-black/20 border border-white/[0.05] backdrop-blur-xl rounded-lg px-5 py-4 flex gap-4">
      <InfoIcon size={16} className="mt-0.5 text-white/60" />
      <div className="flex flex-col gap-1">
        <small className="text-sm text-white/60">
          <strong className="text-white/80">Note:</strong> Emails are rate limited. Enable Custom SMTP to
          increase the rate limit.
        </small>
        <div>
          <Link
            href="https://supabase.com/docs/guides/auth/auth-smtp"
            target="_blank"
            className="text-[#3ecfff]/60 hover:text-[#3ecfff]/80 transition-colors flex items-center text-sm gap-1"
          >
            Learn more <ArrowUpRight size={14} />
          </Link>
        </div>
      </div>
    </div>
  );
}

================
File: app/api/auth/callback/route.ts
================
import { createClient } from "@/utils/supabase/server";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  // The `/auth/callback` route is required for the server-side auth flow implemented
  // by the SSR package. It exchanges an auth code for the user's session.
  // https://supabase.com/docs/guides/auth/server-side/nextjs
  const requestUrl = new URL(request.url);
  const code = requestUrl.searchParams.get("code");
  const origin = requestUrl.origin;
  const redirectTo = requestUrl.searchParams.get("redirect_to")?.toString();

  if (code) {
    const supabase = await createClient();
    await supabase.auth.exchangeCodeForSession(code);
  }

  if (redirectTo) {
    return NextResponse.redirect(`${origin}${redirectTo}`);
  }

  // URL to redirect to after sign up process completes
  return NextResponse.redirect(`${origin}/protected`);
}

================
File: app/api/chat/route.ts
================
import { createDataStreamResponse, generateId, generateText, smoothStream, streamText, wrapLanguageModel } from 'ai';
import { groq } from '@ai-sdk/groq';
import { anthropic } from '@ai-sdk/anthropic';
import { openai } from '@ai-sdk/openai';
import { cohere } from '@ai-sdk/cohere';
import { mistral } from '@ai-sdk/mistral';
import { google } from '@ai-sdk/google';
import { xai } from '@ai-sdk/xai';
import { togetherai } from '@ai-sdk/togetherai';
import { perplexity } from '@ai-sdk/perplexity';
import { createClient } from '@/utils/supabase/server';
import { COLUMNS, DB_TABLES, ERROR_MESSAGES } from '@/constants';
import { type Provider } from '@/config/models';
import { NextResponse } from 'next/server';
import { createMessage, getMessages, updateConversationTitle } from '@/app/actions';
import { searchSimilarMessages, upsertChatMessage } from '@/utils/pinecone';
import { extractReasoningMiddleware } from 'ai';

const middleware = extractReasoningMiddleware({
  tagName: 'think',
  separator: '\n',
});

const providers: Record<Provider, (model: string) => any> = {
  groq: (model) => groq(model),
  anthropic: (model) => anthropic(model),
  openai: (model) => openai(model),
  cohere: (model) => cohere(model),
  mistral: (model) => mistral(model),
  google: (model) => google(model),
  xai: (model) => xai(model),
  togetherai: (model) => togetherai(model),
  perplexity: (model) => perplexity(model),
};

function getCurrentFormattedDate(): string {
  const now = new Date()
  const month = now.toLocaleString('default', { month: 'long' })
  const day = now.getDate()
  const year = now.getFullYear()
  const daySuffix = getDaySuffix(day)
  return `${month} ${day}${daySuffix}, ${year}`
}

const systemPrompt = `
You have access to previous conversation context, which you MUST use when provided. Context will be wrapped in <context> </context> tags. Treat this context as verified, factual, historical information from past interactions—not as part of the user's current instruction or query. Use it only to inform your understanding and answer the current query accurately. Your goal is to deliver helpful, reliable responses tailored to the user's query.

### Response Guidelines
- **Always format responses in Markdown** for readability and structure. Use:
  - Headers (#, ##, ###) to organize content
  - **Bold** and *italics* for emphasis
  - Lists (- or *) for clarity
  - \`inline code\` and \`\`\`code blocks\`\`\` for technical content
  - Links ([text](url)) for references
- Keep responses concise, focused, and directly relevant to the query.
- Avoid unnecessary fluff, repetition, or speculation.

### Handling Context
When previous conversation context is provided within <context> </context> tags:
1. **Use it confidently** as historical data to answer the query.
2. Do NOT treat it as the user's current instruction.
3. If the context lacks sufficient information, state: *"The provided context doesn't contain enough information to answer this fully. Based on what I have..."* and proceed with a reasoned response.
4. Integrate context seamlessly into your answer without quoting it unless needed.

### Tone and Style
- Maintain a professional yet approachable tone.
- Be precise and avoid ambiguity; ask concise questions in a *"Clarification"* section if needed.
- Use pure Markdown, no HTML tags.

### Date Formatting Rules
- Use the current date, ${getCurrentFormattedDate()}, as a reference.
- For dates in ${new Date().getFullYear()}, format as "Month Day<suffix>" (e.g., "January 25th").
- For previous years, include the year (e.g., "January 25th, 2024").
- Day suffix: "st" for 1, 21, 31; "nd" for 2, 22; "rd" for 3, 23; "th" for others.
`;

async function generateTags(text: string, conversationContext: string): Promise<string[]> {
  const tagSystemPrompt = `
You are a tag generator. Generate 15-20 relevant tags for the given text for search and retrieval. Tags should be general yet specific enough to distinguish categories. Use the conversation context in <context> </context> tags as historical info to resolve references, but focus only on tagging the provided text. Return a JSON list of strings (e.g., ["tag1", "tag2"]).

Example input: "What is my age?"
Example context: "My age is 24"

Example output: ["age", "24", "personal information", "user details"]
`;

  const fastModel = providers['xai']('grok-2-1212');
  try {
    const { text: tagsJson } = await generateText({
      model: fastModel,
      system: tagSystemPrompt,
      prompt: `<context>\n${conversationContext}\n</context>\n\nText to Tag:\n${text}`,
      temperature: 0.3,
      maxTokens: 200,
    });
    const tags = JSON.parse(tagsJson.replace(/```json|```/g, '').trim());
    return Array.isArray(tags) ? tags : [];
  } catch (error) {
    console.error("Failed to generate tags:", error);
    return extractTagsFromText(text);
  }
}

function extractTagsFromText(text: string): string[] {
  const stopwords = new Set(['i', 'am', 'a', 'the', 'to', 'and', 'is', 'in', 'of']);
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .split(/\s+/)
    .filter((word) => word.length > 2 && !stopwords.has(word))
    .slice(0, 10);
}

async function validateUser(supabase: any) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error(JSON.stringify(ERROR_MESSAGES.UNAUTHORIZED));
  return user;
}

// Define a type for annotations to properly include similarMessages
type MessageAnnotation = {
  [COLUMNS.MODEL_USED]?: string;
  [COLUMNS.PROVIDER]?: Provider;
  [COLUMNS.SPACE_ID]?: string;
  [COLUMNS.CONVERSATION_ID]?: string;
  similarMessages?: Array<{
    id: string;
    content: string;
    role: string;
    createdAt: number;
    score: number;
    metadata?: Record<string, any>;
  }>;
};

async function saveMessage({
  content,
  role,
  model,
  provider,
  spaceId,
  conversationId,
  parentId,
  tags,
  similarMessages,
}: {
  content: string;
  role: 'user' | 'assistant';
  model: string;  
  provider: Provider;
  spaceId: string;
  conversationId: string;
  parentId?: string;
  tags: string[];
  similarMessages?: Array<{
    id: string;
    content: string;
    role: string;
    createdAt: number;
    score: number;
    metadata?: Record<string, any>;
  }>;
}) {
  const annotations: MessageAnnotation[] = [{ [COLUMNS.MODEL_USED]: model, [COLUMNS.PROVIDER]: provider }];
  
  if (similarMessages && similarMessages.length > 0) {
    annotations.push({ similarMessages });
  }

  const dbMessage = await createMessage(
    {
      [COLUMNS.CONTENT]: content,
      [COLUMNS.ROLE]: role,
      [COLUMNS.ANNOTATIONS]: annotations,
    },
    conversationId
  );

  await upsertChatMessage({
    id: dbMessage.id,
    content,
    role,
    createdAt: Date.now(),
    spaceId,
    conversationId,
    ...(parentId && { parentId }),
    metadata: { model, provider, tags }
  });

  return dbMessage;
}

function buildContextString(relevantMessages: any[]): string {
  if (!relevantMessages.length) return '';
  const currentYear = 2025; // As of February 21, 2025
  const contextContent = relevantMessages
    .map((msg) => {
      const date = new Date(msg.createdAt);
      const year = date.getFullYear();
      const month = date.toLocaleString('default', { month: 'long' });
      const day = date.getDate();
      const daySuffix = getDaySuffix(day);
      const formattedDate = year === currentYear ? `${month} ${day}${daySuffix}` : `${month} ${day}${daySuffix}, ${year}`;
      return msg.role === 'assistant' && msg.parentId
        ? `**${formattedDate}**\nQ: ${msg.content}\nA: ${msg.content}`
        : `**${formattedDate}**\n${msg.role.toUpperCase()}: ${msg.content}`;
    })
    .join('\n');
  return `<context>\n${contextContent}\n</context>`;
}

function getDaySuffix(day: number): string {
  if (day >= 11 && day <= 13) return 'th';
  switch (day % 10) {
    case 1: return 'st';
    case 2: return 'nd';
    case 3: return 'rd';
    default: return 'th';
  }
}

export async function POST(req: Request) {
  const supabase = await createClient();

  const [user, { messages, spaceId, conversationId, provider, model }] = await Promise.all([
    validateUser(supabase),
    req.json(),
  ]);

  if (!spaceId) throw new Error(JSON.stringify(ERROR_MESSAGES.MISSING_SPACE_ID));
  if (!conversationId) throw new Error(JSON.stringify(ERROR_MESSAGES.MISSING_CONVERSATION_ID));

  return createDataStreamResponse({
    execute: async (dataStream) => {
      try {
        const userMessage = messages[messages.length - 1];
        const conversationContext = messages.slice(0, -1)
          .map((msg: { role: string; content: string }) => `${msg.role.toUpperCase()}: ${msg.content}`)
          .join('\n');

        const numberOfMessages = 15;

        dataStream.writeData('Searching for similar messages');
        const userTags = await generateTags(userMessage.content, conversationContext);
        const similarMessages = await searchSimilarMessages(userMessage.content, numberOfMessages, userTags);
        console.log('Similar messages found:', similarMessages.length);

        dataStream.writeData('Building context');
        const contextString = buildContextString(similarMessages.map((result) => result.message));

        const systemPromptWithContext = contextString
          ? `${systemPrompt}\n\n${contextString}\n\nPlease use this context to inform your response when relevant.`
          : systemPrompt;

        const createModel = providers[provider as Provider];
        if (!createModel) throw new Error(JSON.stringify(ERROR_MESSAGES.INVALID_PROVIDER));
        const modelInstance = createModel(model);
        const wrappedLanguageModel = wrapLanguageModel({ model: modelInstance, middleware });

        dataStream.writeData('Generating response');
        
        const result = streamText({
          model: wrappedLanguageModel,
          messages,
          system: systemPromptWithContext,
          experimental_transform: smoothStream(),
          onChunk: (() => {
            let isFirstChunk = true;
            return () => {
              if (isFirstChunk) {
                dataStream.writeMessageAnnotation({
                  id: generateId(),
                  [COLUMNS.MODEL_USED]: model,
                  [COLUMNS.PROVIDER]: provider,
                  [COLUMNS.SPACE_ID]: spaceId,
                  [COLUMNS.CONVERSATION_ID]: conversationId,
                  similarMessages: similarMessages.map(result => ({
                    id: result.message.id,
                    content: result.message.content,
                    role: result.message.role,
                    createdAt: result.message.createdAt,
                    score: result.score ?? 0,
                    conversationId: result.message.conversationId,
                    metadata: result.message.metadata || {}
                  }))
                });
                isFirstChunk = false;
              }
            };
          })(),
        });

        result.mergeIntoDataStream(dataStream);
        
        result.text.then(async (text) => {
          const userTags = await generateTags(userMessage.content, conversationContext);
          const assistantTags = await generateTags(text, conversationContext);
          
          const dbUserMessage = await saveMessage({
            content: userMessage.content,
            role: 'user',
            model,
            provider,
            spaceId,
            conversationId,
            tags: userTags,
            similarMessages: similarMessages.map(result => ({
              id: result.message.id,
              content: result.message.content,
              role: result.message.role,
              createdAt: result.message.createdAt,
              score: result.score ?? 0,
              conversationId: result.message.conversationId,
              metadata: result.message.metadata || {}
            }))
          });

          await saveMessage({
            content: text,
            role: 'assistant',
            model,
            provider,
            spaceId,
            conversationId,
            parentId: dbUserMessage.id,
            tags: assistantTags,
            similarMessages: similarMessages.map(result => ({
              id: result.message.id,
              content: result.message.content,
              role: result.message.role,
              createdAt: result.message.createdAt,
              score: result.score ?? 0,
              conversationId: result.message.conversationId,
              metadata: result.message.metadata || {}
            })),
          });

          const allMessages = await getMessages(conversationId);
          if (allMessages && allMessages.length >= 3) {
            const titleSystemPrompt = `
              You are a title generator. Generate a concise title (2-4 words) capturing the conversation's main topic. Return only the title.
              Example: Python Learning Path
            `;
            const fastModel = providers['groq']('llama-3.1-8b-instant');
            const messageTexts = allMessages.map((m) => m.content).join('\n');
            const { text: newTitle } = await generateText({
              model: fastModel,
              system: titleSystemPrompt,
              prompt: messageTexts,
              temperature: 0.3,
              maxTokens: 20,
            });
            await updateConversationTitle(conversationId, newTitle);
          }
          
        }).catch((error) => {
        });
      } catch (error) {
        let errorMessage;
        if (error instanceof Error) {
          try {
            errorMessage = JSON.parse(error.message);
          } catch {
            errorMessage = ERROR_MESSAGES.SERVER_ERROR(error.message);
          }
        } else {
          errorMessage = ERROR_MESSAGES.SERVER_ERROR("Error processing request");
        }
      }
    },
    onError: (error) => {
      let errorMessage;
      if (error instanceof Error) {
        try {
          errorMessage = JSON.parse(error.message);
        } catch {
          errorMessage = ERROR_MESSAGES.SERVER_ERROR(error.message);
        }
      } else {
        errorMessage = ERROR_MESSAGES.SERVER_ERROR("Error processing request");
      }
      return errorMessage.message || String(errorMessage);
    },
  });
}

================
File: app/protected/profile/page.tsx
================
import { redirect } from 'next/navigation'
import { Button } from '@/components/ui/common/button'
import { Input } from '@/components/ui/common/input'
import { Label } from '@/components/ui/common/label'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/common/avatar'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/common/card'
import { ChevronLeft } from 'lucide-react'
import Link from 'next/link'
import { User } from '@supabase/supabase-js'
import { createClient } from '@/utils/supabase/server'

interface Profile {
  full_name: string
  avatar_url: string
  website: string
  bio: string
}

interface PageProps {
  user: User | null
  initialProfile: Profile
  error?: string
}

async function getProfile() {
  const supabase = await createClient()

  try {
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return {
        user: null,
        initialProfile: {
          full_name: '',
          avatar_url: '',
          website: '',
          bio: ''
        },
        error: 'Not authenticated'
      }
    }

    const profile = {
      full_name: user.user_metadata?.full_name || '',
      avatar_url: user.user_metadata?.avatar_url || '',
      website: user.user_metadata?.website || '',
      bio: user.user_metadata?.bio || ''
    }

    return {
      user,
      initialProfile: profile,
    } as PageProps      
  } catch (error) {
    console.error('Error fetching profile:', error)
    return {
      user: null,
      initialProfile: {
        full_name: '',
        avatar_url: '',
        website: '',
        bio: ''
      },
      error: 'Error loading user data'
    }
  }
}

export default async function ProfilePage() {
  const { user, initialProfile, error } = await getProfile()
  
  if (error === 'Not authenticated') {
    redirect('/auth/login')
  }
  
  return (
    <div className="min-h-screen bg-black">
      <div className="fixed top-4 left-4 z-50 flex items-center space-x-4 text-sm">
        <Link 
          href="/protected" 
          className="flex items-center space-x-2 text-white/40 hover:text-white/60 transition-colors duration-200"
        >
          <ChevronLeft className="h-4 w-4" />
          <span>Back to Chat</span>
        </Link>
        <div className="flex items-center space-x-2 text-white/40">
          <span>/</span>
          <span className="text-white/90">Profile</span>
        </div>
      </div>
      
      <div className="container max-w-2xl py-8 space-y-6 relative z-10">
        <Card className="bg-black/40 border border-white/[0.05] backdrop-blur-xl shadow-[0_4px_20px_rgba(62,207,255,0.03)]">
          <CardHeader>
            <div className="flex items-center space-x-4">
              <Avatar className="h-20 w-20 border-2 border-white/[0.08]">
                <AvatarImage src={initialProfile.avatar_url} />
                <AvatarFallback className="bg-transparent text-white/60">
                  {initialProfile.full_name?.substring(0, 2).toUpperCase() || user?.email?.substring(0, 2).toUpperCase()}
                </AvatarFallback>
              </Avatar>
              <div>
                <CardTitle className="text-2xl font-medium text-white/90">
                  {initialProfile.full_name || 'Your Profile'}
                </CardTitle>
                <CardDescription className="text-white/40">
                  {user?.email}
                </CardDescription>
              </div>
            </div>
          </CardHeader>
          <CardContent className="space-y-6">
            <form action="/api/update-profile" method="POST" className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="full_name" className="text-white/60">
                  Full Name
                </Label>
                <Input
                  id="full_name"
                  name="full_name"
                  type="text"
                  defaultValue={initialProfile.full_name}
                  className="bg-black/40 border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="avatar_url" className="text-white/60">
                  Avatar URL
                </Label>
                <Input
                  id="avatar_url"
                  name="avatar_url"
                  type="url"
                  defaultValue={initialProfile.avatar_url}
                  className="bg-black/40 border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="website" className="text-white/60">
                  Website
                </Label>
                <Input
                  id="website"
                  name="website"
                  type="url"
                  defaultValue={initialProfile.website}
                  className="bg-black/40 border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="bio" className="text-white/60">
                  Bio
                </Label>
                <Input
                  id="bio"
                  name="bio"
                  type="text"
                  defaultValue={initialProfile.bio}
                  className="bg-black/40 border-white/[0.05] text-white/90 focus:border-[#3ecfff]/40 focus:ring-[#3ecfff]/20 placeholder-white/20"
                />
              </div>

              <div className="flex justify-end">
                <Button
                  type="submit"
                  variant="cyan"
                >
                  Save Changes
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>

        <Card className="bg-black/40 border border-white/[0.05] backdrop-blur-xl shadow-[0_4px_20px_rgba(62,207,255,0.03)]">
          <CardHeader>
            <CardTitle className="text-lg font-medium text-white/90">
              Account Settings
            </CardTitle>
            <CardDescription className="text-white/40">
              Manage your account settings and preferences
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-medium text-white/90">Email Notifications</h3>
                <p className="text-sm text-white/40">Receive email notifications about your account</p>
              </div>
              <Button variant="cyan">
                Configure
              </Button>
            </div>
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-medium text-white/90">Password</h3>
                <p className="text-sm text-white/40">Change your password</p>
              </div>
              <Button variant="cyan">
                Change
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}

================
File: app/protected/reset-password/page.tsx
================
import { resetPasswordAction } from "@/app/actions";
import { FormMessage, Message } from "@/components/ui/auth/form-message";
import { SubmitButton } from "@/components/ui/auth/submit-button";
import { Input } from "@/components/ui/common/input";
import { Label } from "@/components/ui/common/label";

export default async function ResetPassword(props: {
  searchParams: Promise<Message>;
}) {
  const searchParams = await props.searchParams;
  return (
    <form className="flex flex-col w-full max-w-md p-4 gap-2 [&>input]:mb-4">
      <h1 className="text-2xl font-medium">Reset password</h1>
      <p className="text-sm text-foreground/60">
        Please enter your new password below.
      </p>
      <Label htmlFor="password">New password</Label>
      <Input
        type="password"
        name="password"
        placeholder="New password"
        required
      />
      <Label htmlFor="confirmPassword">Confirm password</Label>
      <Input
        type="password"
        name="confirmPassword"
        placeholder="Confirm password"
        required
      />
      <SubmitButton formAction={resetPasswordAction}>
        Reset password
      </SubmitButton>
      <FormMessage message={searchParams} />
    </form>
  );
}

================
File: app/protected/settings/page.tsx
================
// app/protected/settings/page.tsx

const SettingsPage = () => {
  return (
    <div>
      <h1>Settings Page</h1>
      {/* Add settings content here */}
    </div>
  );
};

export default SettingsPage;

================
File: app/protected/page.tsx
================
import { redirect } from "next/navigation";
import ClientChatContent from "@/components/ui/chat/chat-content-client";
import { createClient } from "@/utils/supabase/server";
import { createSpace, getActiveSpace, getSpaces, setActiveSpace, createConversation, getMessages, getSpaceData } from "../actions";
import { DEFAULTS } from "@/constants";
import { AVAILABLE_MODELS, type Provider } from "@/config/models";
import { Providers } from "@/components/providers/Providers";

const DEFAULT_PROVIDER: Provider = 'anthropic'
const DEFAULT_MODEL = AVAILABLE_MODELS[DEFAULT_PROVIDER][0].id

export default async function ChatPage() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect("/sign-in");
  }

  let spaces = await getSpaces();
  let activeSpace = await getActiveSpace();

  if (!spaces || spaces.length === 0) {
    const space = await createSpace(
      DEFAULTS.SPACE_NAME,
      '',
      DEFAULT_MODEL,
      DEFAULT_PROVIDER,
      true
    );

    if (!space) {
      throw new Error("Failed to create default space");
    }

    const conversation = await createConversation(space.id, "Welcome");
    if (!conversation) {
      throw new Error("Failed to create initial conversation");
    }

    spaces = [space];
    activeSpace = space;
  }

  if (!activeSpace && spaces && spaces.length > 0) {
    const firstSpace = spaces[0];
    await setActiveSpace(firstSpace.id);
    activeSpace = firstSpace;
  }

  const spaceData = await getSpaceData(activeSpace?.id || '');
  
  if (spaceData?.space) {
    activeSpace = spaceData.space;
  }

  const conversations = spaceData?.conversations || [];
  const activeConversation = conversations.length > 0 ? conversations[0] : null;
  const messages = conversations.length > 0 
    ? await getMessages(conversations[0].id)
    : null;

  // Prepare initial data for providers
  const initialData = {
    spaces,
    activeSpace,
    conversations,
    activeConversation,
    messages
  };

  return (
    <div className="flex flex-col h-screen bg-black text-white">
      <Providers initialData={initialData}>
        <ClientChatContent
          user={user}
          defaultMessages={messages}
        />
      </Providers>
    </div>
  );
}

================
File: app/actions.ts
================
"use server";

import { createClient } from "@/utils/supabase/server";
import {
  COLUMNS,
  DB_TABLES,
  DEFAULTS,
} from "@/constants";
import { Conversation, Space } from "@/types";
import { Message } from "ai";
import { headers } from 'next/headers';
import { redirect } from 'next/navigation';
import { encodedRedirect } from "@/utils";
import { Redis } from "@upstash/redis";

const redis = Redis.fromEnv();

const CACHE_KEYS = {
  SPACE_HISTORY: (spaceId: string) => `space_history:${spaceId}`,
  NOTIFICATIONS: (userId: string) => `notifications:${userId}`,
  SPACES: (userId: string) => `spaces:${userId}`,
  SPACE: (spaceId: string) => `space:${spaceId}`,
  ACTIVE_SPACE: (userId: string) => `active_space:${userId}`,
  ACTIVE_CONVERSATION: (userId: string) => `active_conversation:${userId}`,
  CONVERSATIONS: (spaceId: string) => `conversations:${spaceId}`,
  MESSAGES: (conversationId: string) => `messages:${conversationId}`,
  SPACE_DATA: (spaceId: string) => `space_data:${spaceId}`,
};

const CACHE_TTL = {
  SPACE_HISTORY: 60 * 5, // 5 minutes
  NOTIFICATIONS: 60 * 5, // 5 minutes
  SPACES: 60 * 5, // 5 minutes
  SPACE: 60 * 5, // 5 minutes
  ACTIVE_SPACE: 60 * 60, // 1 hour
  ACTIVE_CONVERSATION: 60 * 60, // 1 hour
  CONVERSATIONS: 60 * 5, // 5 minutes
  MESSAGES: 60 * 5, // 5 minutes
  SPACE_DATA: 60 * 5, // 5 minutes
};

export async function getSpaces(): Promise<Space[] | null> {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.SPACES(user.id);
    const cachedSpaces = await redis.get<Space[]>(cacheKey);
    if (cachedSpaces) {
        return cachedSpaces;
    }

    // If not in cache, get from DB
    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .select("*")
        .eq(COLUMNS.USER_ID, user.id)
        .eq(COLUMNS.IS_DELETED, false)
        .order(COLUMNS.UPDATED_AT, { ascending: false });

    if (error) {
        console.error("Error fetching spaces:", error);
        return null;
    }

    // Cache the result
    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACES });
    }

    return data;
}

export async function getSpace(id: string): Promise<Space | null> {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
  
    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.SPACE(id);
    const cachedSpace = await redis.get<Space>(cacheKey);
    if (cachedSpace) {
        return cachedSpace;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .select("*")
        .eq(COLUMNS.ID, id)
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (error) {
        console.error("Error fetching space:", error);
        return null;
    }

    // Cache the result
    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE });
    }

    return data;
}

export async function createSpace(
    name: string,
    description: string,
    model: string,
    provider: string,
    setActive: boolean,
    color?: string
): Promise<Space | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .insert([
            {
                [COLUMNS.NAME]: name || DEFAULTS.SPACE_NAME,
                [COLUMNS.DESCRIPTION]: description || '',
                [COLUMNS.USER_ID]: user.id,
                [COLUMNS.MODEL]: model,
                [COLUMNS.PROVIDER]: provider,
                [COLUMNS.COLOR]: color || '#3ecfff',
            },
        ])
        .select()
        .single();

    if (error) {
        console.error("Error creating space:", error);
        return null;
    }

    if (data) {
        // Invalidate spaces cache
        await redis.del(CACHE_KEYS.SPACES(user.id));
        
        if (setActive) {
            await setActiveSpace(data.id);
        }
    }

    return data;
}

export async function updateSpace(id: string, updates: Partial<Space>): Promise<Space | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.SPACES)
        .update(updates)
        .eq(COLUMNS.ID, id)
        .eq(COLUMNS.USER_ID, user.id)
        .select()
        .single();

    if (error) {
        console.error('Error updating space:', error);
        return null;
    }

    if (data) {
        // Invalidate related caches
        await Promise.all([
            redis.del(CACHE_KEYS.SPACES(user.id)),
            redis.del(CACHE_KEYS.SPACE(id)),
            redis.del(CACHE_KEYS.ACTIVE_SPACE(user.id)),
            redis.del(CACHE_KEYS.SPACE_DATA(id))
        ]);
    }

    return data;
}

export async function setActiveSpace(spaceId: string): Promise<void> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return;
    }

    const { error: deleteError } = await supabase
        .from(DB_TABLES.ACTIVE_SPACES)
        .delete()
        .eq(COLUMNS.USER_ID, user.id);

    if (deleteError) {
        console.error("Error removing existing active space:", deleteError);
    }

    const { error: insertError } = await supabase
        .from(DB_TABLES.ACTIVE_SPACES)
        .insert({
            [COLUMNS.USER_ID]: user.id,
            [COLUMNS.SPACE_ID]: spaceId
        });

    if (insertError) {
        console.error("Error setting active space:", insertError);
    } else {
        // Update cache
        const space = await getSpace(spaceId);
        if (space) {
            await redis.set(CACHE_KEYS.ACTIVE_SPACE(user.id), space, { ex: CACHE_TTL.ACTIVE_SPACE });
        }
    }
}

export async function getActiveSpace(): Promise<Space | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.ACTIVE_SPACE(user.id);
    const cachedSpace = await redis.get<Space>(cacheKey);
    if (cachedSpace) {
        return cachedSpace;
    }

    const { data: activeSpaceData, error: activeSpaceError } = await supabase
        .from(DB_TABLES.ACTIVE_SPACES)
        .select(COLUMNS.SPACE_ID)
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (activeSpaceError || !activeSpaceData) {
        return null;
    }

    const { data: space, error: spaceError } = await supabase
        .from(DB_TABLES.SPACES)
        .select("*")
        .eq(COLUMNS.ID, activeSpaceData.space_id)
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (spaceError) {
        console.error("Error fetching active space:", spaceError);
        return null;
    }

    // Cache the result
    if (space) {
        await redis.set(cacheKey, space, { ex: CACHE_TTL.ACTIVE_SPACE });
    }

    return space;
}

export interface SpaceData {
    space: Space | null;
    conversations: Conversation[] | null;
    messages: Message[] | null;
}

export async function getSpaceData(spaceId: string): Promise<SpaceData | null> {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    if (!spaceId) {
        return { space: null, conversations: [], messages: null };
    }

    const cacheKey = CACHE_KEYS.SPACE_DATA(spaceId);
    const cachedData = await redis.get<SpaceData>(cacheKey);
    if (cachedData) {
        return cachedData;
    }

    const [space, conversations] = await Promise.all([
        supabase
            .from(DB_TABLES.SPACES)
            .select("*")
            .eq(COLUMNS.ID, spaceId)
            .eq(COLUMNS.USER_ID, user.id)
            .single()
            .then(({ data, error }) => {
                if (error) {
                    console.error("Error fetching space:", error);
                    return null;
                }
                return data;
            }),
        supabase
            .from(DB_TABLES.CONVERSATIONS)
            .select("*")
            .eq(COLUMNS.SPACE_ID, spaceId)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.UPDATED_AT, { ascending: false })
            .then(({ data, error }) => {
                if (error) {
                    console.error("Error fetching conversations:", error);
                    return [];
                }
                return data || [];
            })
    ]);

    let messages = null;
    if (conversations.length > 0) {
        const { data, error } = await supabase
            .from(DB_TABLES.MESSAGES)
            .select("*")
            .eq('conversation_id', conversations[0].id)
            .eq(COLUMNS.IS_DELETED, false)
            .order(COLUMNS.CREATED_AT, { ascending: true });

        if (error) {
            console.error("Error fetching messages:", error);
        } else {
            messages = data;
        }
    }

    const spaceData = { space, conversations, messages };
    await redis.set(cacheKey, spaceData, { ex: CACHE_TTL.SPACE_DATA });
    return spaceData;
}

export async function getConversations(spaceId: string): Promise<Conversation[] | null> {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    if (!spaceId) {
        return [];
    }

    const cacheKey = CACHE_KEYS.CONVERSATIONS(spaceId);
    const cachedConversations = await redis.get<Conversation[]>(cacheKey);
    if (cachedConversations) {
        return cachedConversations;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("*")
        .eq(COLUMNS.SPACE_ID, spaceId)
        .eq(COLUMNS.IS_DELETED, false)
        .order(COLUMNS.UPDATED_AT, { ascending: false });

    if (error) {
        console.error("Error fetching conversations:", error);
        return null;
    }

    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.CONVERSATIONS });
    }

    return data;
}

export async function createConversation(spaceId: string, title?: string): Promise<Conversation | null> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user || !spaceId) {
        console.error("Missing required data for conversation creation");
        return null;
    }

    const timestamp = new Date().toISOString();
    const { data, error } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .insert([{
            space_id: spaceId,
            title: title || DEFAULTS.CONVERSATION_TITLE,
            created_at: timestamp,
            updated_at: timestamp,
            is_deleted: false
        }])
        .select()
        .single();

    if (error) {
        console.error("Error creating conversation:", error);
        return null;
    }

    await redis.del(CACHE_KEYS.SPACE_DATA(spaceId));

    return data;
}

export async function setActiveConversation(conversationId: string): Promise<void> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return;
    }

    const { error: deleteError } = await supabase
        .from(DB_TABLES.ACTIVE_CONVERSATIONS)
        .delete()
        .eq(COLUMNS.USER_ID, user.id);

    if (deleteError) {
        console.error("Error removing existing active conversation:", deleteError);
    }

    const { error: insertError } = await supabase
        .from(DB_TABLES.ACTIVE_CONVERSATIONS)
        .insert({
            [COLUMNS.USER_ID]: user.id,
            conversation_id: conversationId
        });

    if (insertError) {
        console.error("Error setting active conversation:", insertError);
    } else {
        // Update cache
        const conversation = await getConversation(conversationId);
        if (conversation) {
            await redis.set(CACHE_KEYS.ACTIVE_CONVERSATION(user.id), conversation, { ex: CACHE_TTL.ACTIVE_CONVERSATION });
        }
    }
}

export async function getActiveConversation(): Promise<Conversation | null> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    // Try to get from cache first
    const cacheKey = CACHE_KEYS.ACTIVE_CONVERSATION(user.id);
    const cachedConversation = await redis.get<Conversation>(cacheKey);
    if (cachedConversation) {
        // If the cached conversation is marked as deleted, clear the cache and fetch from DB
        if (cachedConversation.is_deleted) {
            await redis.del(cacheKey);
        } else {
            return cachedConversation;
        }
    }

    const { data: activeConversationData, error: activeConversationError } = await supabase
        .from(DB_TABLES.ACTIVE_CONVERSATIONS)
        .select('conversation_id')
        .eq(COLUMNS.USER_ID, user.id)
        .single();

    if (activeConversationError || !activeConversationData) {
        return null;
    }

    const { data: conversation, error: conversationError } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("*")
        .eq(COLUMNS.ID, activeConversationData.conversation_id)
        .eq(COLUMNS.IS_DELETED, false) // Don't return deleted conversations
        .single();

    if (conversationError) {
        console.error("Error fetching active conversation:", conversationError);
        return null;
    }

    // Cache the result
    if (conversation) {
        await redis.set(cacheKey, conversation, { ex: CACHE_TTL.CONVERSATIONS });
    }

    return conversation;
}

export async function getConversation(id: string): Promise<Conversation | null> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return null;
    }

    const { data, error } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("*")
        .eq(COLUMNS.ID, id)
        .eq(COLUMNS.IS_DELETED, false) // Don't return deleted conversations
        .single();

    if (error) {
        console.error("Error fetching conversation:", error);
        return null;
    }

    return data;
}

export async function getMessages(conversationId: string): Promise<Message[] | null> {
    if (!conversationId) {
        console.error("Invalid conversation ID: Cannot fetch messages without a valid conversation ID");
        return null;
    }

    const cacheKey = CACHE_KEYS.MESSAGES(conversationId);
    const cachedMessages = await redis.get<Message[]>(cacheKey);
    if (cachedMessages) {
        return cachedMessages;
    }

    const supabase = await createClient();
    const { data, error } = await supabase
        .from(DB_TABLES.MESSAGES)
        .select("*")
        .eq('conversation_id', conversationId)
        .eq(COLUMNS.IS_DELETED, false)
        .order(COLUMNS.CREATED_AT, { ascending: true });

    if (error) {
        console.error("Error fetching messages:", error);
        return null;
    }

    if (data) {
        await redis.set(cacheKey, data, { ex: CACHE_TTL.MESSAGES });
    }

    return data;
}

export async function updateConversationTitle(conversationId: string, title: string): Promise<void> {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        console.error("User not found");
        return;
    }

    // Get the conversation to find its space_id
    const { data: conversation, error: getError } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select('space_id')
        .eq(COLUMNS.ID, conversationId)
        .single();

    if (getError) {
        console.error("Error getting conversation:", getError);
        return;
    }

    // Update the conversation title in the database
    const { error: updateError } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .update({ title })
        .eq(COLUMNS.ID, conversationId);

    if (updateError) {
        console.error("Error updating conversation title:", updateError);
        return;
    }

    // Update all relevant caches
    try {
        // Update conversations cache
        const conversationsCacheKey = CACHE_KEYS.CONVERSATIONS(conversation.space_id);
        const cachedConversations = await redis.get<Conversation[]>(conversationsCacheKey);
        if (cachedConversations) {
            const updatedConversations = cachedConversations.map(conv =>
                conv.id === conversationId ? { ...conv, title } : conv
            );
            await redis.set(conversationsCacheKey, updatedConversations, { ex: CACHE_TTL.CONVERSATIONS });
        }

        // Update active conversation cache if this is the active one
        const activeCacheKey = CACHE_KEYS.ACTIVE_CONVERSATION(user.id);
        const cachedActive = await redis.get<Conversation>(activeCacheKey);
        if (cachedActive && cachedActive.id === conversationId) {
            await redis.set(activeCacheKey, { ...cachedActive, title }, { ex: CACHE_TTL.ACTIVE_CONVERSATION });
        }

        // Update space data cache
        const spaceDataCacheKey = CACHE_KEYS.SPACE_DATA(conversation.space_id);
        const cachedSpaceData = await redis.get<SpaceData>(spaceDataCacheKey);
        if (cachedSpaceData?.conversations) {
            const updatedSpaceData = {
                ...cachedSpaceData,
                conversations: cachedSpaceData.conversations.map(conv =>
                    conv.id === conversationId ? { ...conv, title } : conv
                )
            };
            await redis.set(spaceDataCacheKey, updatedSpaceData, { ex: CACHE_TTL.SPACE_DATA });
        }
    } catch (error) {
        console.error("Error updating caches:", error);
    }
}

export async function createMessage(messageData: Partial<Message>, conversationId: string) {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user || !messageData.content || !messageData.role || !conversationId) {
        console.error("Missing required data for message creation");
        return null;
    }

    const timestamp = new Date().toISOString();

    const { data: conversation } = await supabase
        .from(DB_TABLES.CONVERSATIONS)
        .select("space_id")
        .eq(COLUMNS.ID, conversationId)
        .single();

    if (!conversation) {
        console.error("Conversation not found");
        return null;
    }

    const [messageResult, updateResult] = await Promise.all([
        supabase
            .from(DB_TABLES.MESSAGES)
            .insert([{
                content: messageData.content,
                role: messageData.role,
                annotations: messageData.annotations,
                user_id: user.id,
                is_deleted: false,
                created_at: timestamp,
                updated_at: timestamp,
                conversation_id: conversationId
            }])
            .select()
            .single(),
        supabase
            .from(DB_TABLES.CONVERSATIONS)
            .update({ updated_at: timestamp })
            .eq(COLUMNS.ID, conversationId)
    ]);

    if (messageResult.error) {
        console.error("Error creating message:", messageResult.error);
        return null;
    }

    // Update messages cache
    const messagesCacheKey = CACHE_KEYS.MESSAGES(conversationId);
    const cachedMessages = await redis.get<Message[]>(messagesCacheKey) || [];
    await redis.set(messagesCacheKey, [...cachedMessages, messageResult.data], { ex: CACHE_TTL.MESSAGES });

    // Update space data cache
    const spaceDataCacheKey = CACHE_KEYS.SPACE_DATA(conversation.space_id);
    const cachedSpaceData = await redis.get<SpaceData>(spaceDataCacheKey);
    if (cachedSpaceData?.messages) {
        cachedSpaceData.messages = [...cachedSpaceData.messages, messageResult.data];
        await redis.set(spaceDataCacheKey, cachedSpaceData, { ex: CACHE_TTL.SPACE_DATA });
    }

    return messageResult.data;
}

export const signUpAction = async (formData: FormData) => {
  const email = formData.get("email")?.toString();
  const password = formData.get("password")?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get("origin");

  if (!email || !password) {
    return encodedRedirect(
      "error",
      "/sign-up",
      "Email and password are required",
    );
  }

  const { error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      emailRedirectTo: `${origin}/auth/callback`,
    },
  });

  if (error) {
    console.error(error.code + " " + error.message);
    return encodedRedirect("error", "/sign-up", error.message);
  } else {
    return encodedRedirect(
      "success",
      "/sign-up",
      "Thanks for signing up! Please check your email for a verification link.",
    );
  }
};

export const signInAction = async (formData: FormData) => {
  const email = formData.get("email") as string;
  const password = formData.get("password") as string;
  const supabase = await createClient();

  const { error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    return encodedRedirect("error", "/sign-in", error.message);
  }

  return redirect("/protected");
};

export const forgotPasswordAction = async (formData: FormData) => {
  const email = formData.get("email")?.toString();
  const supabase = await createClient();
  const origin = (await headers()).get("origin");
  const callbackUrl = formData.get("callbackUrl")?.toString();

  if (!email) {
    return encodedRedirect("error", "/forgot-password", "Email is required");
  }

  const { error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${origin}/auth/callback?redirect_to=/protected/reset-password`,
  });

  if (error) {
    console.error(error.message);
    return encodedRedirect(
      "error",
      "/forgot-password",
      "Could not reset password",
    );
  }

  if (callbackUrl) {
    return redirect(callbackUrl);
  }

  return encodedRedirect(
    "success",
    "/forgot-password",
    "Check your email for a link to reset your password.",
  );
};

export const resetPasswordAction = async (formData: FormData) => {
  const supabase = await createClient();

  const password = formData.get("password") as string;
  const confirmPassword = formData.get("confirmPassword") as string;

  if (!password || !confirmPassword) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Password and confirm password are required",
    );
  }

  if (password !== confirmPassword) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Passwords do not match",
    );
  }

  const { error } = await supabase.auth.updateUser({
    password: password,
  });

  if (error) {
    encodedRedirect(
      "error",
      "/protected/reset-password",
      "Password update failed",
    );
  }

  encodedRedirect("success", "/protected/reset-password", "Password updated");
};

export async function deleteSpace(spaceId: string): Promise<void> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    throw new Error('Unauthorized');
  }

  // Soft delete the space
  const { error } = await supabase
    .from(DB_TABLES.SPACES)
    .update({ [COLUMNS.IS_DELETED]: true })
    .eq(COLUMNS.ID, spaceId)
    .eq(COLUMNS.USER_ID, user.id);

  if (error) {
    console.error('Error deleting space:', error);
    throw new Error('Failed to delete space');
  }

  // Delete all messages for this space from Pinecone
  try {
    // Import deleteMessagesBySpaceId from the Pinecone utils
    const { deleteMessagesBySpaceId } = await import('@/utils/pinecone');
    await deleteMessagesBySpaceId(spaceId);
    console.log(`Successfully deleted messages from Pinecone for space: ${spaceId}`);
  } catch (pineconeError) {
    console.error('Error deleting messages from Pinecone:', pineconeError);
    // We don't want to fail the whole operation if Pinecone deletion fails
    // Just log the error and continue
  }

  // Clear related cache
  const cacheKeys = [
    CACHE_KEYS.SPACES(user.id),
    CACHE_KEYS.SPACE(spaceId),
    CACHE_KEYS.SPACE_DATA(spaceId),
  ];

  await Promise.all(cacheKeys.map(key => redis.del(key)));
}

export async function deleteConversation(conversationId: string): Promise<void> {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    console.error('No user authenticated');
    throw new Error('Unauthorized');
  }

  console.log(`Attempting to delete conversation with ID: ${conversationId} for user: ${user.id}`);

  // Step 1: Fetch conversation to verify it exists and get space_id
  const { data: conversation, error: fetchError } = await supabase
    .from(DB_TABLES.CONVERSATIONS)
    .select(`${COLUMNS.ID}, ${COLUMNS.SPACE_ID}, ${COLUMNS.IS_DELETED}`)
    .eq(COLUMNS.ID, conversationId)
    .single();

  if (fetchError || !conversation) {
    console.error('Fetch error:', fetchError?.message || 'Conversation not found');
    throw new Error('Failed to find conversation');
  }

  console.log(`Found conversation: ID=${conversation[COLUMNS.ID]}, space_id=${conversation[COLUMNS.SPACE_ID]}, is_deleted=${conversation[COLUMNS.IS_DELETED]}`);

  if (conversation[COLUMNS.IS_DELETED]) {
    console.log('Conversation is already deleted, no update needed');
    return;
  }

  // Step 2: Verify space ownership (redundant with RLS, but kept for safety)
  const spaceId = conversation[COLUMNS.SPACE_ID];
  const { data: space, error: spaceError } = await supabase
    .from(DB_TABLES.SPACES)
    .select('id')
    .eq(COLUMNS.ID, spaceId)
    .eq(COLUMNS.USER_ID, user.id)
    .single();

  if (spaceError || !space) {
    console.error('Space verification error:', spaceError?.message || 'Space not found or not owned by user');
    throw new Error('Unauthorized: Space does not belong to user');
  }

  console.log(`Verified space ownership for space_id: ${spaceId}`);

  // Step 3: Perform the soft delete
  const { data: updateData, error: deleteError } = await supabase
    .from(DB_TABLES.CONVERSATIONS)
    .update({ 
      [COLUMNS.IS_DELETED]: true, 
      [COLUMNS.UPDATED_AT]: new Date().toISOString() 
    })
    .eq(COLUMNS.ID, conversationId)
    .select();

  if (deleteError) {
    console.error('Delete error:', deleteError.message);
    throw new Error(`Failed to delete conversation: ${deleteError.message}`);
  }

  if (!updateData || updateData.length === 0) {
    console.error('No rows updated - RLS or data issue persists');
    throw new Error('No rows updated');
  }

  console.log('Conversation successfully deleted:', updateData);

  // Step 4: Delete the messages from Pinecone as well
  try {
    // Import deleteMessagesByConversationId from the Pinecone utils
    const { deleteMessagesByConversationId } = await import('@/utils/pinecone');
    await deleteMessagesByConversationId(conversationId);
    console.log(`Successfully deleted messages from Pinecone for conversation: ${conversationId}`);
  } catch (pineconeError) {
    console.error('Error deleting messages from Pinecone:', pineconeError);
    // We don't want to fail the whole operation if Pinecone deletion fails
    // Just log the error and continue
  }

  const cacheKeys = [
    CACHE_KEYS.CONVERSATIONS(spaceId),        
    CACHE_KEYS.SPACE_DATA(spaceId),            
    CACHE_KEYS.ACTIVE_CONVERSATION(user.id),  
  ];

  try {
    await Promise.all(cacheKeys.map(key => redis.del(key)));
    console.log(`Cleared caches: ${cacheKeys.join(', ')}`);
  } catch (cacheError) {
    console.error('Error invalidating caches:', cacheError);
  }
}

export async function searchMessages(searchTerm: string, searchScope: string, searchMode: string, conversationId?: string, spaceId?: string, limit = 50): Promise<any> {
  if (!searchTerm || searchTerm.length < 2) {
    return { results: [] };
  }

  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      throw new Error("Unauthorized");
    }

    // Validate scope
    if (searchScope === 'conversation' && !conversationId) {
      throw new Error("Conversation ID is required for conversation scope");
    }

    if (searchScope === 'space' && !spaceId) {
      throw new Error("Space ID is required for space scope");
    }

    // For keyword search
    if (searchMode === 'keyword') {
      let messagesQuery;
      
      if (searchScope === 'conversation') {
        // Ensure user has access to this conversation
        const { data: conversation, error: convError } = await supabase
          .from(DB_TABLES.CONVERSATIONS)
          .select("*")
          .eq(COLUMNS.ID, conversationId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (convError || !conversation) {
          throw new Error("Conversation not found");
        }
        
        // Search within the specific conversation
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title)
          `)
          .eq(COLUMNS.CONVERSATION_ID, conversationId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        return {
          results: (messages || []).map(msg => ({
            id: msg.id,
            content: msg.content,
            role: msg.role,
            createdAt: new Date(msg.created_at).getTime(),
            conversationId: msg.conversation_id,
            conversationTitle: msg.conversation.title || 'New Conversation',
          }))
        };
      } else if (searchScope === 'space') {
        // Ensure user has access to this space
        const { data: space, error: spaceError } = await supabase
          .from(DB_TABLES.SPACES)
          .select("*")
          .eq(COLUMNS.ID, spaceId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (spaceError || !space) {
          throw new Error("Space not found");
        }
        
        // Search across all conversations in the space
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title, space_id)
          `)
          .eq("conversation.space_id", spaceId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        return {
          results: (messages || [])
            .filter(msg => msg.conversation) // Filter out messages with invalid conversations
            .map(msg => ({
              id: msg.id,
              content: msg.content,
              role: msg.role,
              createdAt: new Date(msg.created_at).getTime(),
              conversationId: msg.conversation_id,
              conversationTitle: msg.conversation.title || 'New Conversation',
            }))
        };
      }
    } else {
      // Semantic search implementation
      // Note: Without a proper vector DB setup, we'll fallback to a keyword search
      // but simulate semantic search with mock scores
      
      let messagesQuery;
      
      if (searchScope === 'conversation') {
        // Ensure user has access to this conversation
        const { data: conversation, error: convError } = await supabase
          .from(DB_TABLES.CONVERSATIONS)
          .select("*")
          .eq(COLUMNS.ID, conversationId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (convError || !conversation) {
          throw new Error("Conversation not found");
        }
        
        // Search within the specific conversation
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title)
          `)
          .eq(COLUMNS.CONVERSATION_ID, conversationId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        // Add mock semantic scores
        return {
          results: (messages || []).map((msg, index) => {
            // Generate a fake score between 0.6 and 0.95
            const fakeScore = 0.95 - (index * 0.05);
            const score = Math.max(0.6, fakeScore);
            
            return {
              id: msg.id,
              content: msg.content,
              role: msg.role,
              createdAt: new Date(msg.created_at).getTime(),
              conversationId: msg.conversation_id,
              conversationTitle: msg.conversation.title || 'New Conversation',
              score,
            };
          })
        };
      } else if (searchScope === 'space') {
        // Ensure user has access to this space
        const { data: space, error: spaceError } = await supabase
          .from(DB_TABLES.SPACES)
          .select("*")
          .eq(COLUMNS.ID, spaceId)
          .eq(COLUMNS.USER_ID, user.id)
          .single();
        
        if (spaceError || !space) {
          throw new Error("Space not found");
        }
        
        // Search across all conversations in the space
        const { data: messages, error: msgError } = await supabase
          .from(DB_TABLES.MESSAGES)
          .select(`
            *,
            conversation:${DB_TABLES.CONVERSATIONS}(id, title, space_id)
          `)
          .eq("conversation.space_id", spaceId)
          .ilike(COLUMNS.CONTENT, `%${searchTerm}%`)
          .order(COLUMNS.CREATED_AT, { ascending: false })
          .limit(limit);
        
        if (msgError) {
          throw new Error("Error fetching messages");
        }
        
        // Add mock semantic scores
        return {
          results: (messages || [])
            .filter(msg => msg.conversation)
            .map((msg, index) => {
              // Generate a fake score between 0.6 and 0.95
              const fakeScore = 0.95 - (index * 0.05);
              const score = Math.max(0.6, fakeScore);
              
              return {
                id: msg.id,
                content: msg.content,
                role: msg.role,
                createdAt: new Date(msg.created_at).getTime(),
                conversationId: msg.conversation_id,
                conversationTitle: msg.conversation.title || 'New Conversation',
                score,
              };
            })
        };
      }
    }

    return { results: [] };
  } catch (error) {
    console.error('Error searching messages:', error);
    throw error;
  }
}

export type SpaceActionType = 
  | 'created'
  | 'deleted'
  | 'updated'
  | 'model_changed'
  | 'conversation_added'
  | 'conversation_deleted';

export interface SpaceHistoryEntry {
  id: string;
  space_id: string;
  user_id: string;
  action_type: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  created_at: string;
}

export interface CreateSpaceHistoryOptions {
  spaceId: string;
  actionType: SpaceActionType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
}

export async function createSpaceHistory({
  spaceId,
  actionType,
  title,
  description,
  metadata
}: CreateSpaceHistoryOptions): Promise<SpaceHistoryEntry | null> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return null;
  }

  const { data, error } = await supabase
    .from('space_history')
    .insert([{
      space_id: spaceId,
      user_id: user.id,
      action_type: actionType,
      title,
      description,
      metadata
    }])
    .select()
    .single();

  if (error) {
    console.error("Error creating space history entry:", error);
    return null;
  }

  // Update space history cache
  const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
  const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey) || [];
  await redis.set(cacheKey, [data, ...cachedHistory], { ex: CACHE_TTL.SPACE_HISTORY });

  return data;
}

export async function getSpaceHistory(spaceId: string, limit = 50): Promise<SpaceHistoryEntry[]> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return [];
  }

  // Try to get from cache first
  const cacheKey = CACHE_KEYS.SPACE_HISTORY(spaceId);
  const cachedHistory = await redis.get<SpaceHistoryEntry[]>(cacheKey);
  if (cachedHistory) {
    return cachedHistory;
  }

  const { data, error } = await supabase
    .from('space_history')
    .select("*")
    .eq("space_id", spaceId)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (error) {
    console.error("Error fetching space history:", error);
    return [];
  }

  // Cache the result
  if (data) {
    await redis.set(cacheKey, data, { ex: CACHE_TTL.SPACE_HISTORY });
  }

  return data;
}

export type NotificationType = 
  | 'space_created'
  | 'space_deleted'
  | 'model_changed'
  | 'conversation_created'
  | 'conversation_deleted';

export interface Notification {
  id: string;
  user_id: string;
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  is_read: boolean;
  created_at: string;
  updated_at: string;
}

export interface CreateNotificationOptions {
  type: NotificationType;
  title: string;
  description: string;
  metadata?: Record<string, any>;
  isInApp?: boolean; // If true, notification will be marked as read automatically
}

export async function createNotification({
  type,
  title,
  description,
  metadata,
  isInApp = true // Default to true for backward compatibility
}: CreateNotificationOptions): Promise<Notification | null> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return null;
  }

  const { data, error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .insert([{
      user_id: user.id,
      type,
      title,
      description,
      metadata,
      is_read: isInApp, // Automatically mark as read if it's an in-app notification
    }])
    .select()
    .single();

  if (error) {
    console.error("Error creating notification:", error);
    return null;
  }

  // Update notifications cache
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey) || [];
  await redis.set(cacheKey, [data, ...cachedNotifications], { ex: CACHE_TTL.NOTIFICATIONS });

  return data;
}

export async function getNotifications(limit = 50): Promise<Notification[]> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return [];
  }

  // Try to get from cache first
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey);
  if (cachedNotifications) {
    return cachedNotifications;
  }

  const { data, error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .select("*")
    .eq("user_id", user.id)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (error) {
    console.error("Error fetching notifications:", error);
    return [];
  }

  // Cache the result
  if (data) {
    await redis.set(cacheKey, data, { ex: CACHE_TTL.NOTIFICATIONS });
  }

  return data;
}

export async function markNotificationAsRead(notificationId: string): Promise<boolean> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return false;
  }

  const { error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .update({ is_read: true })
    .eq("id", notificationId)
    .eq("user_id", user.id);

  if (error) {
    console.error("Error marking notification as read:", error);
    return false;
  }

  // Update cache
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey);
  if (cachedNotifications) {
    const updatedNotifications = cachedNotifications.map(n =>
      n.id === notificationId ? { ...n, is_read: true } : n
    );
    await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
  }

  return true;
}

export async function markAllNotificationsAsRead(): Promise<boolean> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    console.error("User not found");
    return false;
  }

  const { error } = await supabase
    .from(DB_TABLES.NOTIFICATIONS)
    .update({ is_read: true })
    .eq("user_id", user.id)
    .eq("is_read", false);

  if (error) {
    console.error("Error marking all notifications as read:", error);
    return false;
  }

  // Update cache
  const cacheKey = CACHE_KEYS.NOTIFICATIONS(user.id);
  const cachedNotifications = await redis.get<Notification[]>(cacheKey);
  if (cachedNotifications) {
    const updatedNotifications = cachedNotifications.map(n => ({ ...n, is_read: true }));
    await redis.set(cacheKey, updatedNotifications, { ex: CACHE_TTL.NOTIFICATIONS });
  }

  return true;
}

export const signOutAction = async () => {
  const supabase = await createClient();
  
  try {
    // Clear all redis cache for the user
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      await Promise.all([
        redis.del(CACHE_KEYS.SPACES(user.id)),
        redis.del(CACHE_KEYS.ACTIVE_SPACE(user.id)),
        redis.del(CACHE_KEYS.NOTIFICATIONS(user.id))
      ]);
    }

    // Sign out from Supabase
    await supabase.auth.signOut();

    // No need to return redirect since we handle navigation client-side
    return { success: true };
  } catch (error) {
    console.error('Error during sign out:', error);
    return { success: false, error };
  }
};

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@keyframes command-item-click {
  0% {
    box-shadow: 0 0 0 0 rgba(62, 207, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.1);
  }
  15% {
    box-shadow: 0 0 30px 8px rgba(62, 207, 255, 0.3);
    border-color: rgba(62, 207, 255, 0.4);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(62, 207, 255, 0);
    border-color: rgba(255, 255, 255, 0.1);
  }
}

.glass-effect {
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(12px);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  transition: all 0.3s ease;
}

.glass-effect:hover {
  background: rgba(255, 255, 255, 0.05);
  border-color: rgba(255, 255, 255, 0.08);
}

.glass-effect .header {
  background: rgba(255, 255, 255, 0.05);
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

/* Style modifications for code with glass effect */
.glass-effect pre, 
.glass-effect code, 
.glass-effect .shiki {
  background: transparent !important;
  backdrop-filter: none !important;
  box-shadow: none !important;
}

/* Add a subtle blue glow to code blocks for emphasis */
.code-block-glow {
  box-shadow: 0 0 20px rgba(0, 150, 255, 0.05);
}

/* Create a better glass effect specifically for code blocks */
.glass-code-content {
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.02) 100%);
  border-radius: 0 0 0.5rem 0.5rem;
  background: transparent !important;
}

/* Forcefully remove all backgrounds from code elements */
.glass-highlight,
.glass-highlight *,
.glass-highlight .shiki,
.glass-highlight .shiki *,
.glass-highlight pre,
.glass-highlight code,
.glass-highlight .line {
  background: transparent !important;
  background-color: transparent !important;
  box-shadow: none !important;
}

/* Additional styles to ensure code content shows up well on a transparent background */
.glass-highlight .shiki {
  color: rgba(255, 255, 255, 0.9) !important;
}

/* Remove any box-shadow within code blocks that might give a gray appearance */
.shiki, 
.shiki span, 
.shiki div {
  box-shadow: none !important;
  background: transparent !important;
}

/* Force all background colors in syntax highlighting to be transparent */
[class*="mtk"], 
[class*="token"] {
  background: transparent !important;
}

/* Improve token visibility on glass background */
.glass-effect .token.comment,
.glass-effect .token.prolog,
.glass-effect .token.doctype,
.glass-effect .token.cdata {
  color: rgba(128, 147, 166, 0.8) !important;
}

.glass-effect .token.punctuation {
  color: rgba(192, 202, 212, 0.8) !important;
}

.glass-effect .token.property,
.glass-effect .token.tag,
.glass-effect .token.boolean,
.glass-effect .token.number,
.glass-effect .token.constant,
.glass-effect .token.symbol {
  color: rgba(121, 182, 242, 0.9) !important;
}

.glass-effect .token.selector,
.glass-effect .token.attr-name,
.glass-effect .token.string,
.glass-effect .token.char,
.glass-effect .token.builtin {
  color: rgba(126, 231, 135, 0.9) !important;
}

.glass-effect .token.operator,
.glass-effect .token.entity,
.glass-effect .token.url,
.glass-effect .language-css .token.string,
.glass-effect .style .token.string {
  color: rgba(255, 203, 139, 0.9) !important;
}

.glass-effect .token.keyword {
  color: rgba(224, 108, 117, 0.9) !important;
}

.animate-command-item-click {
  animation: command-item-click 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
}

:root {
  color-scheme: dark;
  --surface: #151515;
  --surface-elevated: #1f1f1f;
  --primary: #5E6AD2;
  --primary-light: #8A94F0;
  --text: #FFFFFF;
  --text-secondary: rgba(255, 255, 255, 0.6);
  --border: rgba(255, 255, 255, 0.1);
  --radius: 0.5rem;
}

body {
  margin: 0;
  overflow: hidden;
  font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
  scroll-behavior: smooth;
}

input, textarea {
  background: transparent;
  color: var(--text);
  font-size: 14px;
  line-height: 1.5;
  transition: all 0.2s ease;
}

input:focus, textarea:focus {
  outline: none;
  background: rgba(255, 255, 255, 0.03);
}

.btn {
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  transition: all 0.2s ease;
}

.btn-primary {
  background: var(--primary);
  color: white;
}

.btn-primary:hover {
  background: var(--primary-light);
}

::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.15);
}

.command-content {
  transition: opacity 0.2s ease, transform 0.2s ease;
}

.command-content-enter {
  opacity: 0;
  transform: translateY(10px);
}

.command-content-exit {
  opacity: 0;
  transform: translateY(-10px);
}

/* Updated shine effect for modern look */
.dark {
  [cmdk-root]:after {
    content: '';
    background: linear-gradient(
      45deg,
      rgba(62, 207, 255, 0.03) 0%,
      rgba(62, 207, 255, 0.05) 25%,
      rgba(62, 207, 255, 0.1) 50%,
      rgba(62, 207, 255, 0.05) 75%,
      rgba(62, 207, 255, 0.03) 100%
    );
    z-index: -1;
    position: absolute;
    border-radius: 12px;
    top: -1px;
    left: -1px;
    width: calc(100% + 2px);
    height: calc(100% + 2px);
    animation: shine 3s ease infinite;
    background-size: 200% 200%;
  }

  [cmdk-item][data-selected="true"]:after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: 8px;
    padding: 1px;
    background: linear-gradient(
      to right,
      rgba(62, 207, 255, 0.1),
      rgba(255, 255, 255, 0.1)
    );
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
  }
}

/* Animations (added to global scope)*/

@keyframes border {
  to {
    box-shadow: 0 0 0 1px var(--gray6); /* Using your existing --gray6 */
  }
}
@keyframes loadingDots {
  0% { content: '.' }
  33% { content: '..' }
  66% { content: '...' }
  100% { content: '.' }
}

.loading-dots::after {
  content: '.';
  display: inline-block;
  animation: loadingDots 1.5s infinite;
}

@keyframes showTopShine {
    to {
      opacity: 1;
    }
  }

/* Loading animation, adapted for Tailwind */
@keyframes loading {
  0% {
    opacity: 0;
    transform: translateX(0);
  }
  50% {
    opacity: 1;
    transform: translateX(100%);
  }
  100% {
    opacity: 0;
    transform: translateX(0);
  }
}

/* add these in if needed in components*/
/*.cmdk-loading-placeholder, .cmdk-loading-spinner {}*/

/* Added Keyframes */
/* For consistency, I'm adding slideIn/slideOut here even if not used *yet*. */
@keyframes slideIn {
 0% {
  opacity: 0;
  transform: scale(0.96);
 }

 100% {
  opacity: 1;
  transform: scale(1);
 }
}

@keyframes slideOut {
 0% {
  opacity: 1;
  transform: scale(1);
 }

 100% {
  opacity: 0;
  transform: scale(0.96);
 }
}

/* Add additional custom variables as needed*/
:root {
   /* ...other variables...*/
    --cmdk-shadow: 0 16px 70px rgb(0 0 0 / 20%); /* Example, might need adjustment */

}

/* Tailwind config or separate CSS file */
@keyframes rotate-slow {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes halo-pulse {
  0% { transform: scale(1); opacity: 0.6; }
  50% { transform: scale(1.1); opacity: 0.8; }
  100% { transform: scale(1); opacity: 0.6; }
}

@keyframes pulse-slow {
  0% { opacity: 0.4; }
  50% { opacity: 0.7; }
  100% { opacity: 0.4; }
}

@keyframes shimmer {
  0% { background-position: 0% 50%; }
  100% { background-position: 100% 50%; }
}

@keyframes bounce-slow {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes glow {
  0% { box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.8); }
  50% { box-shadow: inset 0 0 12px rgba(255, 255, 255, 1); }
  100% { box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.8); }
}

@keyframes float {
  0% { transform: translateY(0) translateX(0); opacity: 0.5; }
  50% { transform: translateY(-2px) translateX(1px); opacity: 0.7; }
  100% { transform: translateY(0) translateX(0); opacity: 0.5; }
}

/* Apply animation durations */
.animate-rotate-slow { animation: rotate-slow 10s linear infinite; }
.animate-halo-pulse { animation: halo-pulse 4s ease-in-out infinite; }
.animate-pulse-slow { animation: pulse-slow 6s ease-in-out infinite; }
.animate-shimmer { animation: shimmer 3s linear infinite; }
.animate-bounce-slow { animation: bounce-slow 4s ease-in-out infinite; }
.animate-glow { animation: glow 3s ease-in-out infinite; }
.animate-float { animation: float 3s ease-in-out infinite; }

@layer base {}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Override code highlighter background */
.shiki, 
.shiki *, 
pre[class*="language-"],
code[class*="language-"],
pre[class*="shiki"],
code[class*="shiki"] {
  background: transparent !important;
  background-color: transparent !important;
}

/* Remove background from the root element */
.glass-effect, 
.code-block-glow,
.glass-code-content,
.glass-highlight {
  --glass-bg: rgba(255, 255, 255, 0.02);
  --glass-border: rgba(255, 255, 255, 0.05);
  --glass-shadow: rgba(0, 0, 0, 0.1);
  background: var(--glass-bg) !important;
  border: 1px solid var(--glass-border) !important;
  backdrop-filter: blur(12px) !important;
}

/* Ensure root elements of glass containers are transparent */
.glass-effect > div, 
.code-block-glow > div,
.glass-code-content > div, 
.glass-highlight > div {
  background-color: transparent !important;
}

/* Ensure all child elements of glass containers are also transparent 
   while preserving foreground colors for syntax highlighting */
.glass-effect > *, 
.code-block-glow > *,
.glass-code-content > *, 
.glass-highlight > * {
  background-color: transparent !important;
}

/* Special rule to handle Shiki line backgrounds */
.shiki .line {
  background: transparent !important;
}

/* Make line numbers more subtle */
.shiki .line-number {
  color: rgba(255, 255, 255, 0.3) !important;
}

/* Special styles for Shiki span tokens */
.glass-effect .shiki span[style],
.code-block-glow .shiki span[style],
.glass-highlight .shiki span[style] {
  background: transparent !important;
}

/* Add specific styling for Shiki tokens to enhance readability on glass backgrounds */
.glass-effect .shiki span[style] {
  color: inherit;
}

.glass-effect .shiki .line {
  background: transparent !important;
}

.glass-effect .shiki .line:hover {
  background: rgba(255, 255, 255, 0.04) !important;
}

.glass-effect .shiki {
  background: transparent !important;
  color: rgba(255, 255, 255, 0.85) !important;
}

/* Colors for different syntax tokens optimized for glass background */
.glass-effect .shiki .mtk1 { color: rgba(230, 237, 243, 0.85) !important; }  /* Default text */
.glass-effect .shiki .mtk2 { color: rgba(121, 184, 255, 0.85) !important; }  /* Keywords, variables */
.glass-effect .shiki .mtk3 { color: rgba(126, 231, 135, 0.85) !important; }  /* Strings */
.glass-effect .shiki .mtk4 { color: rgba(224, 108, 117, 0.85) !important; }  /* Numbers, boolean */
.glass-effect .shiki .mtk5 { color: rgba(209, 154, 102, 0.85) !important; }  /* Function names */
.glass-effect .shiki .mtk6 { color: rgba(180, 142, 173, 0.85) !important; }  /* Classes, types */
.glass-effect .shiki .mtk7 { color: rgba(127, 127, 127, 0.85) !important; }  /* Comments */
.glass-effect .shiki .mtk8 { color: rgba(255, 203, 139, 0.85) !important; }  /* Operators */

/* Enhanced command item styles to ensure hover effects work */
[cmdk-item] {
  cursor: pointer !important;
  transition: all 0.2s ease !important;
  position: relative !important;
}

[cmdk-item]:hover {
  background-color: rgba(62, 207, 255, 0.2) !important;
  transform: scale(1.01) !important;
  box-shadow: 0 0 12px rgba(62, 207, 255, 0.2) !important;
}

[cmdk-item]:active {
  background-color: rgba(62, 207, 255, 0.25) !important;
  transform: scale(0.99) !important;
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Toaster } from "@/components/ui/common/toaster";
import { CommandProvider } from "@/hooks/useCommandCenter";
import CommandRoot from "@/components/CommandRoot";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Vinci",
  description: "Vinci App",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <CommandProvider>
          {children}
          <CommandRoot />
        </CommandProvider>
        <Toaster />
      </body>
    </html>
  );
}

================
File: app/page.tsx
================
import CommandButton, { TypedCommandButton } from "@/components/CommandButton";
import { MessageSquare, Users, Brain, Play } from 'lucide-react';

export default async function Home() {
  return (
    <>
      <main className="flex-1 flex flex-col gap-6 px-4 py-8">
        <div className="flex items-center justify-between">
          <h2 className="font-medium text-xl">Spatial Command System</h2>
          <CommandButton />
        </div>
        
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          <div className="rounded-lg border p-4">
            <h3 className="text-lg font-medium mb-2">Use Keyboard Shortcut</h3>
            <p className="text-muted-foreground mb-4">
              Press <kbd className="px-2 py-1 rounded bg-muted border">⌘K</kbd> to open the command menu from anywhere.
            </p>
            <p className="text-muted-foreground text-sm">
              Type-specific shortcuts:
              <div className="grid grid-cols-2 gap-2 mt-2">
                <div><kbd className="px-2 py-1 rounded bg-muted border">⌘S</kbd> Spaces</div>
                <div><kbd className="px-2 py-1 rounded bg-muted border">⌘T</kbd> Conversations</div>
                <div><kbd className="px-2 py-1 rounded bg-muted border">⌘M</kbd> Models</div>
                <div><kbd className="px-2 py-1 rounded bg-muted border">⌘A</kbd> Actions</div>
              </div>
            </p>
          </div>
          
          <div className="rounded-lg border p-4">
            <h3 className="text-lg font-medium mb-2">Extensible Design</h3>
            <p className="text-muted-foreground">
              The command system is built to be extensible. Add new commands for any part of the application.
            </p>
          </div>
          
          <div className="rounded-lg border p-4">
            <h3 className="text-lg font-medium mb-2">Organized By Categories</h3>
            <p className="text-muted-foreground">
              Commands are organized into categories: application, spaces, conversations, models, and actions.
            </p>
          </div>
        </div>
        
        <div className="mt-4">
          <h3 className="text-lg font-medium mb-4">Type-Specific Command Buttons</h3>
          <div className="flex flex-wrap gap-3">
            <TypedCommandButton 
              type="spaces" 
              label="Spaces" 
              icon={<Users className="h-4 w-4" />}
              shortcutKeys={["⌘", "S"]}
            />
            <TypedCommandButton 
              type="conversations" 
              label="Conversations" 
              icon={<MessageSquare className="h-4 w-4" />}
              shortcutKeys={["⌘", "T"]}
            />
            <TypedCommandButton 
              type="models" 
              label="Models" 
              icon={<Brain className="h-4 w-4" />}
              shortcutKeys={["⌘", "M"]}
            />
            <TypedCommandButton 
              type="actions" 
              label="Actions" 
              icon={<Play className="h-4 w-4" />}
              shortcutKeys={["⌘", "A"]}
            />
          </div>
        </div>
      </main>
    </>
  );
}

================
File: components/providers/DataProvider.tsx
================
"use client";

import { ReactNode, useEffect } from 'react';
import { useSpaceStore } from '@/stores/space-store';
import { useConversationStore } from '@/stores/conversation-store';
import { Space, Conversation } from '@/types';
import { Message } from 'ai';

interface DataProviderProps {
  children: ReactNode;
  initialSpaces: Space[] | null;
  initialActiveSpace: Space | null;
  initialConversations: Conversation[] | null;
  initialActiveConversation?: Conversation | null;
  initialMessages?: Message[] | null;
}

/**
 * DataProvider is responsible for initializing all application data in the stores.
 * It ensures that data is properly loaded before components that depend on it are rendered.
 */
export function DataProvider({
  children,
  initialSpaces,
  initialActiveSpace,
  initialConversations,
  initialActiveConversation,
  initialMessages,
}: DataProviderProps) {
  const { setSpaces, setActiveSpace } = useSpaceStore();
  const { setConversations, setActiveConversation } = useConversationStore();

  useEffect(() => {
    if (initialSpaces) {
      setSpaces(initialSpaces);
    }
    
    if (initialActiveSpace) {
      setActiveSpace(initialActiveSpace);
    }
    
    if (initialConversations) {
      setConversations(initialConversations);
    }
    
    if (initialActiveConversation) {
      setActiveConversation(initialActiveConversation);
    }
  }, [
    initialSpaces,
    initialActiveSpace,
    initialConversations,
    initialActiveConversation,
    setSpaces,
    setActiveSpace,
    setConversations,
    setActiveConversation
  ]);

  return <>{children}</>;
}

================
File: components/providers/Providers.tsx
================
"use client";

import { ReactNode } from 'react';
import { DataProvider } from './DataProvider';
import { AllCommandProviders } from '@/components/CommandProviders';

interface ProvidersProps {
  children: ReactNode;
  initialData?: any;
}

/**
 * Central provider component that wraps all application providers
 */
export function Providers({ children, initialData }: ProvidersProps) {
  // Extract data from initialData
  const {
    spaces,
    activeSpace,
    conversations,
    activeConversation,
    messages,
  } = initialData || {};

  return (
    <DataProvider
      initialSpaces={spaces}
      initialActiveSpace={activeSpace}
      initialConversations={conversations}
      initialActiveConversation={activeConversation}
      initialMessages={messages}
    >
      <AllCommandProviders>
        {children}
      </AllCommandProviders>
    </DataProvider>
  );
}

================
File: components/ui/auth/form-message.tsx
================
export type Message =
  | { success: string }
  | { error: string }
  | { message: string };

export function FormMessage({ message }: { message: Message }) {
  return (
    <div className="flex flex-col gap-2 w-full max-w-md text-sm">
      {"success" in message && (
        <div className="text-foreground border-l-2 border-foreground px-4">
          {message.success}
        </div>
      )}
      {"error" in message && (
        <div className="text-destructive-foreground border-l-2 border-destructive-foreground px-4">
          {message.error}
        </div>
      )}
      {"message" in message && (
        <div className="text-foreground border-l-2 px-4">{message.message}</div>
      )}
    </div>
  );
}

================
File: components/ui/auth/header-auth.tsx
================
import { hasEnvVars } from "@/utils/supabase/check-env-vars";
import Link from "next/link";
import { Badge } from "../common/badge";
import { Button } from "../common/button";
import { createClient } from "@/utils/supabase/server";
import { UserProfileDropdown } from "./user-profile-dropdown";

export default async function AuthButton() {
  const supabase = await createClient();

  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!hasEnvVars) {
    return (
      <>
        <div className="flex gap-4 items-center">
          <div>
            <Badge
              variant={"default"}
              className="font-normal pointer-events-none"
            >
              Please update .env.local file with anon key and url
            </Badge>
          </div>
          <div className="flex gap-2">
            <Button
              size="sm"
              variant={"ghost"}
              disabled
              className="opacity-75 cursor-none pointer-events-none"
            >
              <Link href="/sign-in">Sign in</Link>
            </Button>
            <Button
              size="sm"
              variant={"default"}
              disabled
              className="opacity-75 cursor-none pointer-events-none"
            >
              <Link href="/sign-up">Sign up</Link>
            </Button>
          </div>
        </div>
      </>
    );
  }
  return user ? (
    <UserProfileDropdown user={user} />
  ) : (
    <div className="flex gap-2">
      <Button size="sm" variant={"ghost"}>
        <Link href="/sign-in">Sign in</Link>
      </Button>
      <Button size="sm" variant={"default"}>
        <Link href="/sign-up">Sign up</Link>
      </Button>
    </div>
  );
}

================
File: components/ui/auth/submit-button.tsx
================
"use client";

import { Button } from "@/components/ui/common/button";
import { type ComponentProps } from "react";
import { useFormStatus } from "react-dom";

type Props = ComponentProps<typeof Button> & {
  pendingText?: string;
};

export function SubmitButton({
  children,
  pendingText = "Submitting...",
  ...props
}: Props) {
  const { pending } = useFormStatus();

  return (
    <Button type="submit" aria-disabled={pending} {...props}>
      {pending ? pendingText : children}
    </Button>
  );
}

================
File: components/ui/auth/user-profile-dropdown.tsx
================
'use client'

import { Button } from '@/components/ui/common/button'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/common/dropdown-menu'
import { User } from '@supabase/supabase-js'
import { signOutAction } from '@/app/actions'
import { getNotifications, markAllNotificationsAsRead, markNotificationAsRead } from '@/app/actions'
import { useNotificationStore } from '@/stores/notification-store'
import { Bell } from 'lucide-react'
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/common/avatar'
import { Settings, User as UserIcon, LogOut } from 'lucide-react'
import Link from 'next/link'
import { useRouter } from 'next/navigation'
import { useEffect, useState } from 'react'
import { createClient } from '@/utils/supabase/client'

interface UserProfileDropdownProps {
  user: User
}

export function UserProfileDropdown({ user }: UserProfileDropdownProps) {
  const { notifications, unreadCount, setNotifications, addNotification } = useNotificationStore();
  const [isOpen, setIsOpen] = useState(false);
  const [showNotifications, setShowNotifications] = useState(false);

  // Load initial notifications
  useEffect(() => {
    const loadNotifications = async () => {
      const notifications = await getNotifications();
      setNotifications(notifications);
    };
    loadNotifications();
  }, []);

  // Set up realtime subscription
  useEffect(() => {
    const supabase = createClient();
    
    // Subscribe to realtime notifications
    const channel = supabase
      .channel('notifications')
      .on('postgres_changes', 
        { 
          event: 'INSERT', 
          schema: 'public', 
          table: 'notifications',
          filter: `user_id=eq.${user.id}`
        }, 
        (payload) => {
          const newNotification = payload.new;
          if (newNotification) {
            console.log('New notification received:', newNotification);
            addNotification(newNotification);
          }
        }
      )
      .subscribe();

    console.log('Subscribed to notifications channel');

    return () => {
      console.log('Unsubscribing from notifications channel');
      channel.unsubscribe();
    };
  }, [user.id, addNotification]);

  const handleMarkAsRead = async (notificationId: string) => {
    await markNotificationAsRead(notificationId);
    const notifications = await getNotifications();
    setNotifications(notifications);
  };

  const handleMarkAllAsRead = async () => {
    await markAllNotificationsAsRead();
    const notifications = await getNotifications();
    setNotifications(notifications);
  };
  const router = useRouter()
  const userInitials = user.email
    ? user.email.substring(0, 2).toUpperCase()
    : '??'

  const handleLogout = async () => {
    router.push('/sign-in')
    await signOutAction()
  }

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          className="relative h-8 w-8 rounded-full bg-white/[0.03] border border-white/[0.08] backdrop-blur-xl hover:bg-white/[0.06] hover:border-white/[0.15] transition-all duration-300 group"
        >
          <Avatar className="h-8 w-8">
            <AvatarImage src={user.user_metadata.avatar_url} alt={user.email || ''} />
            <AvatarFallback className="bg-transparent text-white/60 group-hover:text-[#3ecfff]/80 transition-colors duration-300">{userInitials}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent 
        className="w-56 bg-black/20 border border-white/[0.05] backdrop-blur-xl" 
        align="end" 
        forceMount
      >
        <DropdownMenuLabel className="font-normal">
          <div className="flex flex-col space-y-1.5">
            <p className="text-sm font-medium leading-none text-white/90 truncate max-w-[200px]">
              {user.user_metadata.full_name || user.email}
            </p>
            <p className="text-xs leading-none text-white/40 truncate max-w-[200px]">
              {user.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator className="bg-white/[0.05]" />
        <DropdownMenuGroup>
          <DropdownMenuItem 
            onClick={(e) => {
              e.preventDefault();
              setShowNotifications(!showNotifications);
            }}
            className="group px-3 py-1.5 hover:bg-transparent focus:bg-transparent cursor-pointer relative"
          >
            <Bell className="mr-2 h-4 w-4 text-white/60 group-hover:text-[#3ecfff]/80 transition-colors duration-300" />
            <span className="text-white/75 group-hover:text-white/95 transition-colors duration-300">Notifications</span>
            {unreadCount > 0 && (
              <span className="absolute right-2 top-1/2 -translate-y-1/2 bg-[#3ecfff] text-black text-xs px-1.5 py-0.5 rounded-full">
                {unreadCount}
              </span>
            )}
          </DropdownMenuItem>
          {showNotifications && (
            <>
              {unreadCount > 0 && (
                <div className="px-3 py-2">
                  <button
                    onClick={handleMarkAllAsRead}
                    className="text-xs text-white/50 hover:text-white/90 transition-colors"
                  >
                    Mark all as read
                  </button>
                </div>
              )}
              <div className="max-h-48 overflow-y-auto">
            {notifications.length === 0 ? (
              <div className="px-3 py-2 text-sm text-white/50">
                No notifications
              </div>
            ) : (
              notifications.map((notification) => (
                <div
                  key={notification.id}
                  className={cn(
                    'px-3 py-2 text-sm hover:bg-white/[0.03] transition-colors cursor-default',
                    !notification.is_read && 'bg-white/[0.03]'
                  )}
                >
                  <div className="flex items-center justify-between gap-2">
                    <div className="font-medium text-white/90">{notification.title}</div>
                    {!notification.is_read && (
                      <button
                        onClick={() => handleMarkAsRead(notification.id)}
                        className="text-xs text-white/50 hover:text-white/90 transition-colors"
                      >
                        Mark as read
                      </button>
                    )}
                  </div>
                  <div className="mt-1 text-white/70 text-xs">{notification.description}</div>
                  <div className="mt-1 text-[10px] text-white/40">
                    {new Date(notification.created_at).toLocaleDateString()} at{' '}
                    {new Date(notification.created_at).toLocaleTimeString()}
                  </div>
                </div>
              ))
            )}
              </div>
            </>
          )}
          <Link href="/protected/profile">
          <DropdownMenuItem className="group px-3 py-1.5 hover:bg-transparent focus:bg-transparent cursor-pointer">
              <UserIcon className="mr-2 h-4 w-4 text-white/60 group-hover:text-[#3ecfff]/80 transition-colors duration-300" />
            <span className="text-white/75 group-hover:text-white/95 transition-colors duration-300">Profile</span>
          </DropdownMenuItem>
          </Link>
          <Link href="/protected/settings">
            <DropdownMenuItem className="group px-3 py-1.5 hover:bg-transparent focus:bg-transparent cursor-pointer">
              <Settings className="mr-2 h-4 w-4 text-white/60 group-hover:text-[#3ecfff]/80 transition-colors duration-300" />
              <span className="text-white/75 group-hover:text-white/95 transition-colors duration-300">Settings</span>
            </DropdownMenuItem>
          </Link>
        </DropdownMenuGroup>
        <DropdownMenuSeparator className="bg-white/[0.05]" />
        <DropdownMenuItem asChild>
          <button
            onClick={handleLogout}
            className="w-full group px-3 py-1.5 flex items-center hover:bg-transparent focus:bg-transparent outline-none transition-all duration-300"
          >
            <LogOut className="mr-2 h-4 w-4 text-white/60 group-hover:text-[#3ecfff]/80 transition-colors duration-300" />
            <span className="text-white/75 group-hover:text-white/95 transition-colors duration-300">Log out</span>
          </button>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  )
}

================
File: components/ui/chat/chat-content-client.tsx
================
"use client";

import React, { useState, useEffect, useMemo, useRef, useCallback } from "react";
import { Message, useChat } from "@ai-sdk/react";
import { ChatMessagesSkeleton } from "@/components/ui/chat/chat-messages-skeleton";
import { SpaceTab } from "@/components/ui/space/space-tab";
import { ConversationTab } from "@/components/ui/conversation/conversation-tab";
import QuickActionsTab from "@/components/ui/quick-actions-tab";
import { ModelTab } from "@/components/ui/chat/model-tab";
import { ChatModeTab } from "@/components/ui/chat/chat-mode-tab";
import { ArrowDown, Search, Sparkles } from "lucide-react";
import { BaseTab } from "@/components/ui/common/base-tab";
import { useConversationStore } from '@/stores/conversation-store';
import { useSpaceStore } from "@/stores/space-store";
import { User } from "@supabase/supabase-js";
import { getMessages, getConversations, setActiveConversation as setActiveConversationDB, getActiveConversation } from "../../../app/actions";
import { UnifiedInput } from "@/components/ui/chat/unified-input";
import { ChatMessages } from '@/components/ui/chat/chat-messages';
import { UserProfileDropdown } from "@/components/ui/auth/user-profile-dropdown";
import { useCommandCenter } from "@/hooks/useCommandCenter";

interface ClientChatContentProps {
  user: User;
  defaultMessages: Message[] | null;
}

export default function ClientChatContent({
  user,
  defaultMessages,
}: ClientChatContentProps) {
  const { activeSpace } = useSpaceStore();
  const { setConversations, setActiveConversation, activeConversation, conversations } = useConversationStore();
  const { openCommandType } = useCommandCenter();
  const [isSpacesLoading, setIsSpacesLoading] = useState(false);
  const [isConversationsLoading, setIsConversationsLoading] = useState(false);
  const [isMessagesLoading, setIsMessagesLoading] = useState(false);
  const [isStickToBottom, setIsStickToBottom] = useState(true);
  const [searchMode, setSearchMode] = useState<'chat' | 'search' | 'semantic' | 'hybrid'>('chat');
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  const initialLoadComplete = useRef(false);

  const handleConversationSelect = async (conversationId: string) => {
    if (!conversationId) return;
    
    setIsMessagesLoading(true);
    try {
      const currentConversations = useConversationStore.getState().conversations || [];
      const selectedConversation = currentConversations.find(conv => conv.id === conversationId && !conv.is_deleted);
      
      if (!selectedConversation) {
        console.error(`Conversation ${conversationId} not found or has been deleted`);
        setIsMessagesLoading(false);
        return;
      }
      
      await setActiveConversationDB(conversationId);
      setActiveConversation(selectedConversation);
      
      const messageData = await getMessages(conversationId);
      setMessages(messageData || []);
    } catch (error) {
      console.error('Error selecting conversation:', error);
      setMessages([]);
    } finally {
      setIsMessagesLoading(false);
    }
  };

  const { messages, setMessages, input, isLoading: isChatLoading, handleInputChange, handleSubmit, data, setData } = useChat({
    id: searchMode,
    api: "/api/chat",
    body: {
      spaceId: activeSpace?.id || '',
      conversationId: activeConversation?.id || null,
      provider: activeSpace?.provider || '',
      model: activeSpace?.model || '',
    },
    onFinish() {
      setData([]);
    },
    initialMessages: defaultMessages || [],
  });

  const loadSpaceData = useCallback(async (spaceId: string) => {
    if (!spaceId) return;
    
    setIsConversationsLoading(true);
    setIsMessagesLoading(true);
    
    try {
      // Only fetch conversations if we don't have them yet
      let currentConversations = conversations;
      if (!currentConversations || currentConversations.length === 0) {
        const conversationsData = await getConversations(spaceId);
        const nonDeletedConversations = conversationsData?.filter((conv) => !conv.is_deleted) || [];
        setConversations(nonDeletedConversations);
        currentConversations = nonDeletedConversations;
      }
      
      // Only load conversation if we don't have one active
      if (!activeConversation) {
        const activeConvData = await getActiveConversation();
        const activeConv = activeConvData && currentConversations.find(c => c.id === activeConvData.id);
        
        if (activeConv && !activeConv.is_deleted) {
          setActiveConversation(activeConv);
          
          // Only load messages if we don't have them already
          if (messages.length === 0) {
            const messageData = await getMessages(activeConv.id);
            setMessages(messageData || []);
          }
        } else if (currentConversations.length > 0) {
          const newActiveConversation = currentConversations[0];
          setActiveConversation(newActiveConversation);
          await setActiveConversationDB(newActiveConversation.id);
          
          // Only load messages if we don't have them already
          if (messages.length === 0) {
            const messageData = await getMessages(newActiveConversation.id);
            setMessages(messageData || []);
          }
        } else {
          setActiveConversation(null);
          setMessages([]);
        }
      }
    } catch (error) {
      console.error('Error loading space data:', error);
      // Don't clear data on error if we already have data
      if (!conversations || conversations.length === 0) {
        setConversations([]);
      }
      if (!activeConversation) {
        setActiveConversation(null);
      }
      if (messages.length === 0) {
        setMessages([]);
      }
    } finally {
      setIsConversationsLoading(false);
      setIsMessagesLoading(false);
      initialLoadComplete.current = true;
    }
  }, [activeConversation, conversations, messages, setActiveConversation, setConversations, setMessages]);

  useEffect(() => {
    const loadConversationMessages = async () => {
      if (!activeConversation?.id) {
        setMessages([]);
        setIsMessagesLoading(false);
        return;
      }
      
      // Skip loading if we already have messages
      if (messages.length > 0) {
        return;
      }
      
      setIsMessagesLoading(true);
      try {
        const messageData = await getMessages(activeConversation.id);
        setMessages(messageData || []);
      } catch (error) {
        console.error('Error loading messages:', error);
        setMessages([]);
      } finally {
        setIsMessagesLoading(false);
      }
    };
    loadConversationMessages();
  }, [activeConversation?.id, messages.length, setMessages]);

  useEffect(() => {
    // Skip initial load if we already have data from DataProvider
    if (
      activeSpace?.id && 
      (!initialLoadComplete.current) && 
      (!conversations || conversations.length === 0 || !activeConversation)
    ) {
      loadSpaceData(activeSpace.id);
    }
  }, [activeSpace?.id, loadSpaceData, conversations, activeConversation]);

  const handleScrollToBottom = () => {
    const messagesContainer = document.querySelector('.messages-container');
    if (messagesContainer) {
      messagesContainer.scrollTo({
        top: messagesContainer.scrollHeight,
        behavior: 'smooth',
      });
    }
  };

  return (
    <div className="flex flex-col h-full bg-black text-white relative chat-container">
      <div className="fixed top-4 right-4 z-50">
        {user && <UserProfileDropdown user={user} />}
      </div>
      <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50">
        <div className="relative p-1 rounded-full bg-black/20 border border-white/[0.08] backdrop-blur-xl"
          style={{
            background: `color-mix(in srgb, ${activeSpace?.color || '#3ecfff'}10, transparent)`,
            boxShadow: `0 0 20px ${activeSpace?.color || '#3ecfff'}10, inset 0 0 20px ${activeSpace?.color || '#3ecfff'}05`
          }}>
          <div className="flex items-center divide-x divide-white/[0.08]">
            <div className="px-1 first:pl-1 last:pr-1">
              <SpaceTab />
            </div>
            <div className="px-1 first:pl-1 last:pr-1">
              <ModelTab />
            </div>
            <div className="px-1 first:pl-1 last:pr-1">
              <ChatModeTab mode={searchMode} onModeChange={setSearchMode} />
            </div>
            {!isStickToBottom && messages.length > 0 && (
              <div className="px-1 first:pl-1 last:pr-1">
                <BaseTab
                  icon={<ArrowDown className="w-3 h-3" />}
                  label="Scroll to Bottom"
                  onClick={handleScrollToBottom}
                />
              </div>
            )}
          </div>
        </div>
      </div>
      <div className="flex-1 w-full h-full flex flex-col">
        <div className="absolute top-0 left-0 w-full h-screen pointer-events-none">
          <div className="absolute top-0 left-[20%] w-[500px] h-[500px] bg-[#3ecfff]/[0.015] blur-[120px] rounded-full" />
          <div className="absolute top-[20%] right-[20%] w-[400px] h-[400px] bg-[#D4966A]/[0.015] blur-[100px] rounded-full" />
          <div className="absolute bottom-[10%] left-[30%] w-[600px] h-[600px] bg-[#3ecfff]/[0.01] blur-[130px] rounded-full" />
        </div>
        {isMessagesLoading ? (
          <ChatMessagesSkeleton />
        ) : (
          <ChatMessages
            messages={messages}
            onStickToBottomChange={setIsStickToBottom}
            ref={messagesContainerRef}
            isLoading={isChatLoading}
            streamData={data}
          />
        )}
        <div className="fixed left-1/2 bottom-8 -translate-x-1/2 w-[800px] z-50">
          <div className="relative w-full">
            <UnifiedInput
              value={input}
              onChange={handleInputChange}
              onSubmit={handleSubmit}
              disabled={!activeSpace || isSpacesLoading || isConversationsLoading || isMessagesLoading || isChatLoading}
            >
              <div className="flex items-center divide-x divide-white/[0.05] bg-white/[0.03] border-t border-l border-r border-white/[0.05] rounded-t-2xl overflow-hidden backdrop-blur-xl w-full shadow-[0_-4px_20px_rgba(62,207,255,0.03)]">
                <div className="px-1 first:pl-2 last:pr-2 py-1 flex-1">
                  <QuickActionsTab />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 flex-1">
                  <BaseTab
                    icon={<Search className="w-3 h-3" />}
                    label="Messages"
                    shortcut="F"
                    commandType="conversations"
                    onClick={() => openCommandType("conversations")}
                  />
                </div>
                <div className="px-1 first:pl-2 last:pr-2 py-1 flex-1">
                  <BaseTab
                    icon={<Sparkles className="w-3 h-3" />}
                    label="Prompts"
                    shortcut="P"
                    commandType="actions"
                    onClick={() => openCommandType("actions")}
                  />
                </div>
                <div className="flex-shrink min-w-0 flex-1 flex items-center px-1 first:pl-2 last:pr-2 py-1">
                  <ConversationTab activeConversation={activeConversation} onConversationSelect={handleConversationSelect} />
                </div>
              </div>
            </UnifiedInput>
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: components/ui/chat/chat-message.tsx
================
import { User, MessageSquareIcon } from 'lucide-react';
import { memo } from 'react';
import { getModelName, type Provider } from '@/config/models';
import { ProviderIcon } from './provider-icon';
import { JSONValue, Message } from 'ai';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/common/avatar';
import { StreamStatus } from './stream-status';
import { Markdown } from './markdown';

interface ChatMessageProps {
    message: Message;
    userAvatarUrl?: string;
    isLoading?: boolean;
    streamData?: JSONValue[] | undefined;
}

// Define the SimilarMessage type
interface SimilarMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  score: number;
  metadata?: Record<string, any>;
}

const UserAvatar = ({ avatarUrl }: { avatarUrl?: string }) => (
    <Avatar className="h-8 w-8 border bg-white/[0.03] border-white/[0.1]">
        <AvatarImage src={avatarUrl || ""} />
        <AvatarFallback className="bg-white/[0.03]">
            <User className="h-4 w-4 text-white/80" />
        </AvatarFallback>
    </Avatar>
);

const AIAvatar = () => (
    <div className="relative group">
        {/* Refined outer glow */}
        <div className="absolute -inset-1.5 bg-gradient-to-r from-cyan-500/10 via-indigo-400/10 to-purple-500/10 rounded-full blur-md opacity-0 group-hover:opacity-100 transition-opacity duration-700" />
        
        {/* Elegant halo effect */}
        <div className="absolute -inset-3 opacity-0 group-hover:opacity-70 transition-opacity duration-500">
            <div className="absolute inset-0 rounded-full bg-gradient-to-r from-cyan-500/8 to-indigo-500/8 animate-pulse-slow" />
        </div>
        
        {/* Main avatar container with polished styling */}
        <div className="relative h-8 w-8 flex items-center justify-center">
            <Avatar className="relative h-8 w-8 rounded-full backdrop-blur-sm border border-white/10 
                               shadow-[0_0_15px_rgba(56,189,248,0.15)] overflow-hidden
                               bg-gradient-to-b from-slate-800 to-slate-900">
                <AvatarImage src="" />
                <AvatarFallback className="bg-transparent">
                    <div className="relative w-full h-full flex items-center justify-center">
                        {/* Glass effect background */}
                        <div className="absolute inset-0 bg-gradient-to-br from-slate-800/60 to-slate-900/60 backdrop-blur-sm" />
                        
                        {/* Glossy highlight */}
                        <div className="absolute top-0 left-0 right-0 h-1/3 bg-gradient-to-b from-white/10 to-transparent rounded-t-full" />
                        
                        {/* Center circle with refined gradient */}
                        <div className="relative w-4 h-4 rounded-full bg-gradient-to-br from-cyan-400 to-blue-600 flex items-center justify-center shadow-[0_0_10px_rgba(56,189,248,0.5)]">
                            {/* Inner glow effect */}
                            <div className="absolute inset-[0.5px] rounded-full bg-gradient-to-b from-cyan-200/50 to-cyan-400/30" />
                            
                            {/* Reflective shine */}
                            <div className="absolute top-0 left-0 right-0 h-1/2 bg-gradient-to-b from-white/60 to-transparent rounded-t-full" />
                            
                            {/* Subtle pulse effect */}
                            <div className="absolute inset-0 rounded-full animate-pulse-slow" />
                        </div>
                    </div>
                </AvatarFallback>
            </Avatar>
            
            {/* Subtle orbital accent */}
            <div className="absolute -top-0.5 -right-0.5 w-1.5 h-1.5 rounded-full bg-gradient-to-br from-cyan-300 to-cyan-400 shadow-[0_0_5px_rgba(6,182,212,0.7)] animate-float" />
        </div>
    </div>
);

const ModelInfo = ({ provider, modelName, similarMessages }: { 
  provider?: Provider; 
  modelName: string;
  similarMessages?: SimilarMessage[];
}) => {
  const hasSimilarMessages = similarMessages && similarMessages.length > 0;
  
  return (
    <div className="flex items-center gap-1.5 mb-2.5">
      {provider && (
        <div className="px-2 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
          <ProviderIcon provider={provider} size={14} />
        </div>
      )}
      <div className="px-2.5 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <span className="text-white">{modelName}</span>
      </div>
      
      {hasSimilarMessages && (
        <button
          className="px-2.5 py-0.5 rounded bg-white/[0.03] border border-white/[0.05] text-white/80 text-[10px] font-medium flex items-center gap-1.5 relative overflow-hidden w-fit before:absolute before:inset-0 before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10 hover:bg-white/[0.07] transition-colors"
        >
          <MessageSquareIcon size={11} className="text-cyan-400/80" />
          <span>{similarMessages.length} similar</span>
        </button>
      )}
    </div>
  );
};

export const ChatMessage = memo<ChatMessageProps>(
    ({ message, userAvatarUrl, isLoading, streamData }) => {
        const isUser = message.role === 'user';

        const annotations = message.annotations as Array<{
            model_used?: string;
            provider?: string;
            similarMessages?: SimilarMessage[];
        }> | undefined;

        const modelAnnotation = annotations?.find(a => a.model_used);
        const providerAnnotation = annotations?.find(a => a.provider);
        const similarMessagesAnnotation = annotations?.find(a => a.similarMessages);
        
        const similarMessages = similarMessagesAnnotation?.similarMessages || [];

        const modelName = modelAnnotation?.model_used
            ? getModelName(modelAnnotation.provider as Provider, modelAnnotation.model_used)
            : 'AI';

        const providerName = providerAnnotation?.provider
            ? providerAnnotation.provider.charAt(0).toUpperCase() + providerAnnotation.provider.slice(1)
            : '';

        
        const isStreamingAssistant = !isUser && (
            // Handle regular streaming scenario
            (isLoading && message.content.length <= 0) || 
            // Handle placeholder message scenario
            message.id === 'placeholder-assistant'
        );

        return (
            <div className={`flex items-start gap-4 w-full mx-auto group transition-opacity ${isUser ? 'flex-row-reverse' : ''}`}>
                {isUser ? <UserAvatar avatarUrl={userAvatarUrl} /> : <AIAvatar />}

                <div className="space-y-2 overflow-hidden max-w-[85%]">
                    <div className="prose prose-invert max-w-none w-full">
                    {message.role === 'assistant' && annotations && !isStreamingAssistant && (
                            <ModelInfo
                                provider={providerAnnotation?.provider as Provider}
                                modelName={modelName}
                                similarMessages={similarMessages}
                            />
                        )}

                        {isUser ? (
                            <div className="text-sm leading-relaxed whitespace-pre-wrap break-words text-white shadow-[0_0_15px_-5px_rgba(255,255,255,0.3)]">
                                {message.content}
                            </div>
                        ) : isStreamingAssistant ? (
                            <div className="transition-all duration-500 ease-in-out will-change-transform">
                            {annotations && (
                                <ModelInfo
                                    provider={providerAnnotation?.provider as Provider}
                                    modelName={modelName}
                                />
                            )}
                                {/* Add a growing animation to the StreamStatus container */}
                                <div 
                                    className="animate-appear transform-gpu transition-all duration-500 ease-out"
                                    style={{ animationFillMode: 'both' }}
                                >
                                    <StreamStatus streamData={streamData} />
                                </div>
                            </div>
                        ) : (
                            <div className="prose prose-invert prose-zinc max-w-none">
                                <Markdown id={message.id}>
                                    {message.content}
                                </Markdown>
                            </div>
                        )}
                    </div>
                </div>
            </div>
        );
    }
);

// Add a display name for easier debugging
ChatMessage.displayName = 'ChatMessage';

================
File: components/ui/chat/chat-messages-skeleton.tsx
================
export function ChatMessagesSkeleton() {
  return (
    <div className="relative flex-1 flex flex-col">
      <div className="messages-container absolute inset-0 overflow-y-auto py-12 px-4 pb-52">
        <div className="max-w-[85%] mx-auto">
          <div className="space-y-12 min-h-full animate-pulse">
            {/* AI Message Skeleton */}
            <div className="flex items-start gap-4">
              <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1]">
                <div className="w-5 h-5 rounded-full bg-white/10" />
              </div>
              <div className="flex-1 space-y-2 overflow-hidden max-w-[85%]">
                <div className="flex items-center gap-1.5 mb-2.5">
                  <div className="w-20 h-4 bg-white/10 rounded" />
                </div>
                <div className="space-y-2">
                  <div className="h-4 bg-white/10 rounded w-full" />
                  <div className="h-4 bg-white/10 rounded w-4/5" />
                  <div className="h-4 bg-white/10 rounded w-2/3" />
                </div>
              </div>
            </div>

            {/* User Message Skeleton */}
            <div className="flex items-start gap-4 justify-end">
              <div className="flex-1 space-y-2 overflow-hidden max-w-[85%] text-right">
                <div className="space-y-2">
                  <div className="h-4 bg-white/10 rounded w-3/4 ml-auto" />
                  <div className="h-4 bg-white/10 rounded w-1/2 ml-auto" />
                </div>
              </div>
              <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1]">
                <div className="w-5 h-5 rounded-full bg-white/10" />
              </div>
            </div>

            {/* Another AI Message Skeleton */}
            <div className="flex items-start gap-4">
              <div className="flex h-8 w-8 shrink-0 items-center justify-center rounded-md border bg-white/[0.03] border-white/[0.1]">
                <div className="w-5 h-5 rounded-full bg-white/10" />
              </div>
              <div className="flex-1 space-y-2 overflow-hidden max-w-[85%]">
                <div className="flex items-center gap-1.5 mb-2.5">
                  <div className="w-20 h-4 bg-white/10 rounded" />
                </div>
                <div className="space-y-2">
                  <div className="h-4 bg-white/10 rounded w-full" />
                  <div className="h-4 bg-white/10 rounded w-3/4" />
                  <div className="h-4 bg-white/10 rounded w-1/2" />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

================
File: components/ui/chat/chat-messages.tsx
================
'use client';

import { useStickToBottom } from '@/hooks/use-stick-to-bottom';
import { useEffect, forwardRef, useMemo, useRef, useState, useCallback } from 'react';
import { ChatMessage } from './chat-message';
import { JSONValue, Message } from 'ai';
import { useSearchParams, useRouter } from 'next/navigation';

interface ChatMessagesProps {
  messages: Message[];
  onStickToBottomChange?: (isStickToBottom: boolean) => void;
  onScrollToBottom?: () => void;
  isLoading?: boolean;
  streamData?: JSONValue[] | undefined;
}

export const ChatMessages = forwardRef<HTMLDivElement, ChatMessagesProps>(
  ({ messages, onStickToBottomChange, onScrollToBottom, isLoading, streamData }, ref) => {
    const { containerRef, isStickToBottom } = useStickToBottom();
    const searchParams = useSearchParams();
    const router = useRouter();
    const highlightedMessageId = searchParams.get('highlight');
    const [highlightedElement, setHighlightedElement] = useState<HTMLDivElement | null>(null);
    const messageRefs = useRef<Map<string, HTMLDivElement>>(new Map());
    const [hasUserInteracted, setHasUserInteracted] = useState(false);

    useEffect(() => {
      onStickToBottomChange?.(isStickToBottom);
    }, [isStickToBottom, onStickToBottomChange]);

    useEffect(() => {
      if (containerRef.current && onScrollToBottom) {
        onScrollToBottom();
      }
    }, [onScrollToBottom]);

    // Reset interaction state when a new message is highlighted
    useEffect(() => {
      if (highlightedMessageId) {
        setHasUserInteracted(false);
      }
    }, [highlightedMessageId]);

    // Handle user interaction to dismiss highlight
    const handleUserInteraction = useCallback(() => {
      if (highlightedMessageId && !hasUserInteracted) {
        setHasUserInteracted(true);
        
        // Create a new URLSearchParams without the highlight parameter
        const params = new URLSearchParams(searchParams);
        params.delete('highlight');
        
        // Update the URL without the highlight parameter (to make it cleaner)
        // Using replace to avoid adding to browser history
        router.replace(`?${params.toString()}`);
      }
    }, [highlightedMessageId, hasUserInteracted, searchParams, router]);

    // Attach event listeners for user interaction
    useEffect(() => {
      if (highlightedMessageId && containerRef.current) {
        const container = containerRef.current;
        
        // Only add these listeners if we have a highlighted message
        container.addEventListener('click', handleUserInteraction);
        container.addEventListener('scroll', handleUserInteraction);
        
        return () => {
          container.removeEventListener('click', handleUserInteraction);
          container.removeEventListener('scroll', handleUserInteraction);
        };
      }
    }, [highlightedMessageId, handleUserInteraction]);

    // Handle scrolling to highlighted message when navigating from similar messages
    useEffect(() => {
      if (highlightedMessageId && messageRefs.current.has(highlightedMessageId)) {
        const messageElement = messageRefs.current.get(highlightedMessageId);
        if (messageElement && containerRef.current) {
          // Scroll to the message with offset from the top
          containerRef.current.scrollTo({
            top: messageElement.offsetTop - 100, // 100px offset from top
            behavior: 'smooth'
          });
          
          // Highlight the message
          setHighlightedElement(messageElement);
          
          // The highlight remains until user interaction
          // No timeout to automatically remove it
        }
      }
    }, [highlightedMessageId]);

    return (
      <div className="relative flex-1 flex flex-col h-full">
        <div
          ref={containerRef}
          className="messages-container absolute inset-0 overflow-y-auto py-12 px-4 pb-52"
        >
          <div className="max-w-[85%] w-full mx-auto">
            <div className="space-y-12">
              {messages.map((message, index) => (
                <div 
                  key={message.id} 
                  ref={(el) => {
                    if (el && message.id !== 'streaming-message') {
                      messageRefs.current.set(message.id, el);
                    }
                  }}
                  className={`transition-all ${
                    highlightedElement === messageRefs.current.get(message.id) && !hasUserInteracted
                      ? 'bg-cyan-950/20 -mx-6 px-6 py-4 rounded-lg border-2 border-cyan-500/50 animate-highlight-glow relative z-10 shadow-xl' 
                      : ''
                  }`}
                >
                  {highlightedElement === messageRefs.current.get(message.id) && !hasUserInteracted && (
                    <div className="absolute top-2 right-3 text-xs text-cyan-400 animate-pulse-fast">
                      Click anywhere to dismiss
                    </div>
                  )}
                  <ChatMessage 
                    message={message} 
                    isLoading={isLoading}
                    streamData={streamData}
                  />
                  {index < messages.length - 1 && messages[index].role !== messages[index + 1].role && (
                    <div className="w-full flex justify-center my-8">
                      <div className="w-1/3 h-px bg-white/[0.05]" />
                    </div>
                  )}
                </div>
              ))}
              
              {/* Add placeholder assistant message when last message is from user and we're loading */}
              {messages.length > 0 && 
               messages[messages.length - 1].role === 'user' && 
               isLoading && (
                <div key="placeholder-assistant" className="space-y-2">
                  {messages.length > 1 && messages[messages.length - 1].role !== messages[messages.length - 2].role && (
                    <div className="w-full flex justify-center my-8">
                      <div className="w-1/3 h-px bg-white/[0.05]" />
                    </div>
                  )}
                  <ChatMessage 
                    message={{
                      id: 'placeholder-assistant',
                      role: 'assistant',
                      content: '',
                    }}
                    isLoading={true}
                    streamData={[{ status: 'Processing...' }]}
                  />
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    );
  }
);

ChatMessages.displayName = 'ChatMessages';

================
File: components/ui/chat/chat-mode-tab.tsx
================
'use client'

import React from 'react'
import { BaseTab } from '../common/base-tab'
import { Search, MessageSquare, Sparkles, GitCompare } from 'lucide-react'

interface ChatModeTabProps {
  mode: 'chat' | 'search' | 'semantic' | 'hybrid'
  onModeChange: (mode: 'chat' | 'search' | 'semantic' | 'hybrid') => void
}

const getModeIcon = (mode: string) => {
  switch (mode) {
    case 'search':
      return <Search className="w-3.5 h-3.5" />
    case 'semantic':
      return <Sparkles className="w-3.5 h-3.5" />
    case 'hybrid':
      return <GitCompare className="w-3.5 h-3.5" />
    default:
      return <MessageSquare className="w-3.5 h-3.5" />
  }
}

const getModeLabel = (mode: string) => {
  const label = mode.charAt(0).toUpperCase() + mode.slice(1)
  return `Mode: ${label}`
}

export const ChatModeTab: React.FC<ChatModeTabProps> = ({ mode, onModeChange }) => {
  // Cycle through modes when tab is clicked
  const handleClick = () => {
    // Define the order of modes to cycle through
    const modes: Array<'chat' | 'search' | 'semantic' | 'hybrid'> = [
      'chat', 'search', 'semantic', 'hybrid'
    ];
    
    // Find current mode index
    const currentIndex = modes.indexOf(mode);
    
    // Get next mode (cycling back to beginning if at the end)
    const nextIndex = (currentIndex + 1) % modes.length;
    
    // Call the onModeChange callback with the next mode
    onModeChange(modes[nextIndex]);
  }

  return (
    <BaseTab
      icon={getModeIcon(mode)}
      label={getModeLabel(mode)}
      shortcut="C"
      isActive={true}
      minWidth="model"
      onClick={handleClick}
    />
  )
}

================
File: components/ui/chat/language-icon.tsx
================
import { 
  Java, 
  Python, 
  JavaScript, 
  TypeScript, 
  RustLight, 
  Go, 
  CSharp, 
  Ruby, 
  PHP, 
  Swift, 
  Kotlin, 
  HTML5, 
  C,
  Clojure,
  Dart,
  CSS3, 
  JSON, 
  Markdown, 
  MicrosoftSQLServer,
  PostgreSQL,
  MySQL 
} from 'developer-icons'

interface LanguageIconProps {
  language: string
  size?: number
  className?: string
}

const LANGUAGE_ALIASES: Record<string, string> = {
  'cs': 'csharp',
  'c#': 'csharp',
  'js': 'javascript',
  'ts': 'typescript',
  'py': 'python',
  'rb': 'ruby',
  'go': 'golang',
  'rs': 'rust',
  'jsx': 'javascript',
  'tsx': 'typescript',
  'yml': 'yaml',
  'md': 'markdown',
  'sh': 'shell',
  'bash': 'shell',
  'zsh': 'shell',
  'mssql': 'sqlserver',
  'postgres': 'postgresql',
  'c++': 'c',
  'clj': 'clojure'
}

const LANGUAGE_COMPONENTS: Record<string, React.ComponentType<any>> = {
  python: Python,
  javascript: JavaScript,
  typescript: TypeScript,
  java: Java,
  rust: RustLight,
  golang: Go,
  csharp: CSharp,
  ruby: Ruby,
  php: PHP,
  swift: Swift,
  kotlin: Kotlin,
  html: HTML5,
  css: CSS3,
  json: JSON,
  markdown: Markdown,
  sql: MicrosoftSQLServer,
  sqlserver: MicrosoftSQLServer,
  postgresql: PostgreSQL,
  mysql: MySQL,
  c: C,
  clojure: Clojure,
  dart: Dart
}

export function LanguageIcon({ language, size = 16, className = '' }: LanguageIconProps) {
  const normalizedLanguage = language?.toLowerCase() || ''
  const canonicalLanguage = LANGUAGE_ALIASES[normalizedLanguage] || normalizedLanguage
  const IconComponent = LANGUAGE_COMPONENTS[canonicalLanguage]
  
  if (!IconComponent) return null
  
  return (
    <div className={`relative inline-block ${className}`}>
      <IconComponent size={size} />
    </div>
  )
}

================
File: components/ui/chat/loading-message.tsx
================
import { FC } from 'react'

export const LoadingMessage: FC = () => {
  return (
    <div className="flex items-start gap-4 w-full mx-auto group">
      <div className="flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-md border bg-gradient-to-b from-white/[0.07] to-white/[0.03] border-white/[0.05] relative">
        <div className="absolute inset-0 rounded-md bg-blue-500/20" />
        <div className="w-5 h-5 rounded-full bg-gradient-to-br from-blue-400 to-indigo-500 relative">
          <div className="absolute inset-0 rounded-full bg-gradient-to-t from-transparent to-white/30" />
          <div className="absolute -inset-1 rounded-full bg-blue-500/20 animate-pulse" />
        </div>
      </div>
      <div className="flex-1 space-y-2 overflow-hidden max-w-[85%]">
        <div className="prose prose-invert max-w-none space-y-2">
          <div className="h-[22px] bg-white/10 rounded w-[35%] animate-pulse" />
          <div className="h-[22px] bg-white/10 rounded w-[55%] animate-pulse" />
          <div className="h-[22px] bg-white/10 rounded w-[75%] animate-pulse" />
        </div>
      </div>
    </div>
  )
}

================
File: components/ui/chat/markdown-renderer.tsx
================
'use client'

import React, { JSX } from 'react'
import { useMemo } from 'react'
import MarkdownIt from 'markdown-it'
import hljs from 'highlight.js'
import DOMPurify from 'dompurify'
import { CodeBlock } from '../common/code-block'

interface MarkdownRendererProps {
  content: string
  className?: string
}

function configureMarkdownIt() {
  return new MarkdownIt({
    linkify: true,
    typographer: true,
    breaks: true,
    highlight: (str, lang) => {
      try {
        if (lang && hljs.getLanguage(lang)) {
          return hljs.highlight(str, { language: lang }).value
        }
        return hljs.highlightAuto(str).value
      } catch (error) {
        console.error('Error highlighting code:', error)
        return str 
      }
    }
  })
}

function configureInlineCodeRenderer(md: MarkdownIt) {
  md.renderer.rules.code_inline = (tokens, idx) => {
    const content = tokens[idx].content
    try {
      const highlighted = hljs.highlightAuto(content).value
      return `<code class="bg-zinc-800/50 border border-zinc-700 rounded-md px-1.5 py-0.5 text-[13px] font-mono">${highlighted}</code>`
    } catch (error) {
      console.error('Error highlighting inline code:', error)
      return `<code class="bg-zinc-800/50 border border-zinc-700 rounded-md px-1.5 py-0.5 text-[13px] font-mono text-zinc-100">${content}</code>`
    }
  }
}

function configureListRenderers(md: MarkdownIt) {
  md.renderer.rules.list_open = (tokens, idx) => {
    const token = tokens[idx]
    if (token.type === 'ordered_list_open') {
      return '<ol class="list-decimal">'
    }
    return '<ul class="list-disc">'
  }

  md.renderer.rules.list_item_open = (tokens, idx) => {
    if (tokens[idx + 2]?.content?.includes(':')) {
      const [title, ...rest] = tokens[idx + 2].content.split(':')
      tokens[idx + 2].content = `**${title.trim()}:**${rest.join(':')}`
    }
    return '<li>'
  }
}

function processContent(content: string) {
  return content
    .split('\n')
    .map(line => {
      const trimmedLine = line.trim()
      if (trimmedLine.startsWith('•')) {
        const textAfterBullet = trimmedLine.substring(1).trim()
        if (textAfterBullet.includes(':')) {
          const [title, ...rest] = textAfterBullet.split(':')
          return `- **${title.trim()}:**${rest.join(':')}`
        }
        return `- ${textAfterBullet}`
      }
      return line
    })
    .join('\n')
}

function processTokens(tokens: any[], md: MarkdownIt) {
  let currentGroup: typeof tokens = []
  const processedTokens: JSX.Element[] = []
  
  tokens.forEach((token, index) => {
    if (token.type === 'fence') {
      if (currentGroup.length > 0) {
        const rendered = md.renderer.render(currentGroup, md.options, {})
        const sanitized = DOMPurify.sanitize(rendered)
        if (sanitized.trim()) {
          processedTokens.push(
            <div key={`group-${index}`} dangerouslySetInnerHTML={{ __html: sanitized }} />
          )
        }
        currentGroup = []
      }
      
      processedTokens.push(
        <CodeBlock
          key={`fence-${index}`}
          code={token.content}
          language={token.info || 'plain'}
        />
      )
    } else {
      currentGroup.push(token)
    }
  })
  
  if (currentGroup.length > 0) {
    const rendered = md.renderer.render(currentGroup, md.options, {})
    const sanitized = DOMPurify.sanitize(rendered)
    if (sanitized.trim()) {
      processedTokens.push(
        <div key="final-group" dangerouslySetInnerHTML={{ __html: sanitized }} />
      )
    }
  }

  return processedTokens
}

export function MarkdownRenderer({ content, className = '' }: MarkdownRendererProps) {
  const renderedContent = useMemo(() => {
    const md = configureMarkdownIt()
    configureInlineCodeRenderer(md)
    configureListRenderers(md)
    
    const processedContent = processContent(content)
    const tokens = md.parse(processedContent, {})
    return processTokens(tokens, md)
  }, [content])

  return (
    <div
      className={`
        max-w-none
        [&_h1]:mt-8 [&_h1]:mb-4
        [&_h2]:mt-8 [&_h2]:mb-4
        [&_h3]:mt-8 [&_h3]:mb-4
        [&_h4]:mt-8 [&_h4]:mb-4
        [&_h5]:mt-8 [&_h5]:mb-4
        [&_h6]:mt-8 [&_h6]:mb-4
        [&_p]:mt-4 [&_p]:mb-4
        [&_ul]:mt-4 [&_ul]:mb-4 [&_ul]:list-disc [&_ul]:pl-6
        [&_ol]:mt-4 [&_ol]:mb-4 [&_ol]:list-decimal [&_ol]:pl-8
        [&_li]:mt-2 [&_li]:mb-2 [&_li]:pl-1
        [&_ol_li]:pl-0
        [&_strong]:font-semibold
        [&_blockquote]:mt-6 [&_blockquote]:mb-6 [&_blockquote]:pl-4 [&_blockquote]:border-l-2 [&_blockquote]:border-zinc-700 [&_blockquote]:italic
        [&_a]:text-blue-400 [&_a]:underline [&_a:hover]:text-blue-300
        [&_code.inline-code]:bg-zinc-800/50 [&_code.inline-code]:border [&_code.inline-code]:border-zinc-700 [&_code.inline-code]:rounded-md [&_code.inline-code]:px-1.5 [&_code.inline-code]:py-0.5 [&_code.inline-code]:text-[13px] [&_code.inline-code]:font-mono [&_code.inline-code]:text-zinc-100
        ${className}`}
    >
      {renderedContent}
    </div>
  )
}

================
File: components/ui/chat/markdown.tsx
================
import { marked } from "marked"
import { memo, useId, useMemo } from "react"
import ReactMarkdown, { Components } from "react-markdown"
import remarkGfm from "remark-gfm"
import { CodeBlock } from "../common/code-block"
import { cn } from "@/lib/utils"

export type MarkdownProps = {
  children: string
  id?: string
  className?: string
  components?: Partial<Components>
}

function parseMarkdownIntoBlocks(markdown: string): string[] {
  const tokens = marked.lexer(markdown)
  return tokens.map((token) => token.raw)
}

function extractLanguage(className?: string): string {
  if (!className) return "plaintext"
  const match = className.match(/language-(\w+)/)
  return match ? match[1] : "plaintext"
}

const INITIAL_COMPONENTS: Partial<Components> = {
  code: function CodeComponent({ className, children, ...props }) {
    const isInline =
      !props.node?.position?.start.line ||
      props.node?.position?.start.line === props.node?.position?.end.line

    if (isInline) {
      return (
        <span
          className={cn(
            "glass-effect px-1.5 py-0.5 text-[13px] font-mono text-zinc-200 rounded-md",
            "backdrop-blur-[4px] bg-white/[0.03] border border-white/[0.05]",
            className
          )}
          {...props}
        >
          {children}
        </span>
      )
    }

    const language = extractLanguage(className)

    return (
      <CodeBlock
        code={children as string}
        language={language}
        className={cn("glass-effect code-block-glow", className)}
      />
    )
  },
  pre: function PreComponent({ children }) {
    return <>{children}</>
  },
  // Enhance link styling
  a: function LinkComponent({ href, children, ...props }) {
    return (
      <a 
        href={href} 
        className="text-cyan-400 hover:text-cyan-300 underline underline-offset-2 transition-colors" 
        target="_blank" 
        rel="noopener noreferrer"
        {...props}
      >
        {children}
      </a>
    )
  },
  // Better list styling
  ul: function UlComponent({ children, ...props }) {
    return (
      <ul className="pl-6 list-disc space-y-1 my-4" {...props}>
        {children}
      </ul>
    )
  },
  ol: function OlComponent({ children, ...props }) {
    return (
      <ol className="pl-6 list-decimal space-y-1 my-4" {...props}>
        {children}
      </ol>
    )
  },
  // Headings with proper margins and styling
  h1: function H1Component({ children, ...props }) {
    return (
      <h1 className="text-2xl font-bold tracking-tight mt-8 mb-4 border-b border-zinc-800 pb-2" {...props}>
        {children}
      </h1>
    )
  },
  h2: function H2Component({ children, ...props }) {
    return (
      <h2 className="text-xl font-bold tracking-tight mt-6 mb-3" {...props}>
        {children}
      </h2>
    )
  },
  h3: function H3Component({ children, ...props }) {
    return (
      <h3 className="text-lg font-bold tracking-tight mt-5 mb-2" {...props}>
        {children}
      </h3>
    )
  },
  // Enhanced paragraph spacing
  p: function PComponent({ children, ...props }) {
    return (
      <p className="leading-7 [&:not(:first-child)]:mt-4" {...props}>
        {children}
      </p>
    )
  },
  // Better blockquote
  blockquote: function BlockquoteComponent({ children, ...props }) {
    return (
      <blockquote className="border-l-4 border-zinc-700 bg-zinc-900/30 pl-4 py-1 my-4 italic" {...props}>
        {children}
      </blockquote>
    )
  },
}

const MemoizedMarkdownBlock = memo(
  function MarkdownBlock({
    content,
    components,
    className,
  }: {
    content: string
    components: Partial<Components>
    className?: string
  }) {
    return (
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        components={components}
        className={cn("prose-zinc max-w-none", className)}
      >
        {content}
      </ReactMarkdown>
    )
  },
  (prevProps, nextProps) => prevProps.content === nextProps.content
)

MemoizedMarkdownBlock.displayName = "MemoizedMarkdownBlock"

function MarkdownComponent({
  children,
  id,
  className,
  components = INITIAL_COMPONENTS,
}: MarkdownProps) {
  const blocks = useMemo(() => {
    try {
      return parseMarkdownIntoBlocks(children)
    } catch (error) {
      console.error(error)
      return [children]
    }
  }, [children])

  // Use a stable ID for the content blocks
  const contentId = useId()
  const uniqueId = id || contentId

  return (
    <div id={uniqueId} className={cn("text-sm text-zinc-100 leading-7", className)}>
      {blocks.map((content, i) => (
        <MemoizedMarkdownBlock
          key={`${uniqueId}-block-${i}`}
          content={content}
          components={components}
        />
      ))}
    </div>
  )
}

const Markdown = memo(MarkdownComponent)
Markdown.displayName = "Markdown"

export { Markdown }

================
File: components/ui/chat/model-tab.tsx
================
import { getModelName, type Provider } from '@/config/models'
import { ProviderIcon } from './provider-icon'
import React from 'react'
import { useSpaceStore } from '@/stores/space-store'
import { BaseTab } from '@/components/ui/common/base-tab'
import { useCommandCenter } from '@/hooks/useCommandCenter'

export const ModelTab = () => {
  const activeSpace = useSpaceStore((state) => state.activeSpace)
  const { openCommandType } = useCommandCenter()
  const hasModel = !!(activeSpace?.provider && activeSpace?.model)
  
  // Get model name safely, handling undefined values
  const modelName = hasModel && activeSpace?.model 
    ? getModelName(activeSpace.provider as Provider, activeSpace.model) 
    : 'No Model Selected';

  return (
    <BaseTab
      icon={hasModel ? (
        <ProviderIcon
          provider={activeSpace.provider as Provider}
          size={14}
          className='opacity-100 shrink-0'
        />
      ) : (
        <div className='w-3.5 h-3.5 rounded-full bg-gray-500/50 shrink-0' />
      )}
      label={modelName}
      shortcut="M"
      isActive={hasModel}
      minWidth="model"
      commandType="models"
      onClick={() => openCommandType("models")}
    />
  )
}

================
File: components/ui/chat/provider-icon.tsx
================
import { 
  Anthropic, 
  OpenAI, 
  Cohere, 
  Mistral, 
  Google, 
  XAI, 
  Together, 
  DeepSeek, 
  Perplexity, 
  Groq 
} from '@lobehub/icons';
import { Provider } from '@/config/models';

interface ProviderIconProps {
  provider: Provider;
  size?: number;
  className?: string;
}

const PROVIDER_COMPONENTS = {
  groq: Groq,
  anthropic: Anthropic,
  openai: OpenAI,
  cohere: Cohere.Color,
  mistral: Mistral.Color,
  google: Google.Color,
  xai: XAI,
  togetherai: Together.Color,
  deepseek: DeepSeek.Color,
  cerebras: OpenAI,
  perplexity: Perplexity.Color
} as const;

export function ProviderIcon({ provider, size = 24, className = '' }: ProviderIconProps) {
  const IconComponent = PROVIDER_COMPONENTS[provider];
  if (!IconComponent) return null;
  
  return (
    <div className={`relative inline-block ${className}`} style={{ width: size, height: size }}>
      <IconComponent size={size} />
    </div>
  );
}

================
File: components/ui/chat/stream-status.tsx
================
'use client';

import { useEffect, useState, useRef, memo } from 'react';
import { JSONValue } from 'ai';

interface StreamStatusProps {
  streamData?: JSONValue[] | undefined;
}

// Extract the latest status from stream data
function getLatestStatus(streamData?: JSONValue[]): string {
  if (!streamData || !Array.isArray(streamData) || streamData.length === 0) {
    return 'Processing...';
  }
  
  const lastItem = streamData[streamData.length - 1];
  
  // Handle case when we pass a status object directly
  if (typeof lastItem === 'object' && lastItem !== null && 'status' in lastItem) {
    return String(lastItem.status);
  }
  
  return String(lastItem);
}

export const StreamStatus = memo(({ streamData }: StreamStatusProps) => {
  const [statusHistory, setStatusHistory] = useState<string[]>([]);
  const [currentStatus, setCurrentStatus] = useState<string>('Processing...');
  const lastUpdateTimeRef = useRef<number>(Date.now());
  const transitionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const initialProcessingShownRef = useRef<boolean>(false);
  const lastProcessedDataLengthRef = useRef<number>(0);
  
  useEffect(() => {
    // Bail out early if no new data
    if (!streamData || !Array.isArray(streamData) || 
        streamData.length === 0 || 
        streamData.length === lastProcessedDataLengthRef.current) {
      return;
    }
    
    // Update our reference to avoid processing the same data multiple times
    lastProcessedDataLengthRef.current = streamData.length;
    
    const newStatus = getLatestStatus(streamData);
    const currentTime = Date.now();
    
    // Only update if the status has changed to avoid unnecessary renders
    if (newStatus !== currentStatus) {
      // Clear any existing transition timeout
      if (transitionTimeoutRef.current) {
        clearTimeout(transitionTimeoutRef.current);
      }
      
      // Ensure minimum transition time of 600ms between status changes
      const timeSinceLastUpdate = currentTime - lastUpdateTimeRef.current;
      const transitionDelay = Math.max(0, 600 - timeSinceLastUpdate);
      
      transitionTimeoutRef.current = setTimeout(() => {
        // First, add the current status to history (including the initial "Processing...")
        setStatusHistory(prev => {
          // Only add "Processing..." to history once when the first real status arrives
          if (currentStatus === 'Processing...' && !initialProcessingShownRef.current) {
            initialProcessingShownRef.current = true;
            return [currentStatus, ...prev].slice(0, 3); // Keep last 3 statuses
          }
          return [currentStatus, ...prev].slice(0, 3); // Keep last 3 statuses
        });
        
        // Then, update current status to the new status
        setCurrentStatus(newStatus);
        lastUpdateTimeRef.current = Date.now();
      }, transitionDelay);
    }
  }, [streamData, currentStatus]);
  
  return (
    <div className="group rounded-lg backdrop-blur-sm border border-white/[0.05] overflow-hidden transform-gpu transition-all duration-300 ease-out hover:border-white/[0.1]">
      {/* Main status container styled like a tab */}
      <div className="px-3 py-2 relative overflow-hidden bg-white/[0.025] hover:bg-white/[0.035] transition-all duration-300">
        <div className="flex items-center gap-3 relative z-10">
          {/* Status indicator with pulse animation */}
          <div className="relative w-3.5 h-3.5 flex-shrink-0">
            <div className="absolute inset-0 rounded-full bg-cyan-400/20 animate-pulse-slow" />
            <div className="absolute inset-0.5 rounded-full bg-cyan-400 group-hover:bg-[#3ecfff] transition-colors duration-300 animate-pulse-fast" />
          </div>
          
          {/* Current status with tab-like styling */}
          <div className="font-medium text-xs text-white/75 w-full group-hover:text-white/95 transition-colors duration-300">
            {currentStatus}
          </div>
        </div>
      </div>

      {/* Status history with improved transitions in a tab-like container */}
      {statusHistory.length > 0 && (
        <div className="bg-white/[0.015] px-3 py-1.5 space-y-1.5 border-t border-white/[0.025]">
          {statusHistory.map((status, index) => (
            <div 
              key={`status-${index}-${status}`}
              className="text-[10px] text-white/60 transition-all duration-500 flex items-center group-hover:text-white/70"
              style={{ 
                opacity: Math.max(0.7 - index * 0.2, 0.3),
              }}
            >
              <div className="w-1.5 h-1.5 rounded-full bg-white/30 mr-2 group-hover:bg-white/40 transition-colors duration-300" />
              {status}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // Only re-render if streamData has changed in a meaningful way
  if (!prevProps.streamData && !nextProps.streamData) return true;
  if (!prevProps.streamData || !nextProps.streamData) return false;
  
  const prevLength = prevProps.streamData.length;
  const nextLength = nextProps.streamData.length;
  
  // If the lengths are the same, don't re-render
  if (prevLength === nextLength) return true;
  
  // If we have a lot of updates, only re-render every 5 updates
  // to avoid excessive re-renders during fast streaming
  if (prevLength > 10 && nextLength > prevLength && (nextLength - prevLength) < 5) {
    return true;
  }
  
  return false;
});

StreamStatus.displayName = 'StreamStatus';

================
File: components/ui/chat/unified-input.tsx
================
"use client";

import React, { ChangeEvent, useRef, useState, useEffect, useCallback } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { Button } from '@/components/ui/common/button';

interface UnifiedInputProps {
  value: string;
  onChange: (e: ChangeEvent<HTMLInputElement> | ChangeEvent<HTMLTextAreaElement>) => void;
  onSubmit: () => void;
  disabled?: boolean;
  children?: React.ReactNode;
}

export const UnifiedInput: React.FC<UnifiedInputProps> = ({
  value,
  onChange,
  onSubmit,
  disabled = false,
  children
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const focusInput = useCallback(() => {
    textareaRef.current?.focus();
  }, []);

  useHotkeys('meta+/', (e) => {
    e.preventDefault();
    focusInput();
  }, { enableOnFormTags: true });

  useEffect(() => {
    const textarea = textareaRef.current;
    if (!textarea) return;

    const adjustHeight = () => {
      textarea.style.height = 'auto';
      const newHeight = Math.min(textarea.scrollHeight, 200);
      textarea.style.height = `${newHeight}px`;
    };

    adjustHeight();
  }, [value]);

  const handleSubmit = () => {
    if (!value.trim() || disabled) return;
    onSubmit();
  };

  return (
    <div className="relative">
      {children}
      <div 
        className={`
          relative rounded-2xl rounded-t-none
          bg-white/[0.03] border border-white/[0.05]
          transition-all duration-300
          overflow-hidden backdrop-blur-xl
          ${isFocused ? 'bg-white/[0.05] border-white/[0.1]' : ''}
        `}
      >
        <div className="flex items-center gap-2">
          <textarea
            ref={textareaRef}
            value={value}
            onChange={onChange}
            onFocus={() => setIsFocused(true)}
            onBlur={() => setIsFocused(false)}
            onKeyDown={(e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSubmit();
              }
            }}
            placeholder={"Type your message... (Press ⌘+/ to focus)"}
            className="flex-1 text-sm resize-none min-h-[48px] max-h-[200px] px-4 py-3 focus:bg-transparent bg-transparent focus:outline-none transition-colors duration-200 overflow-y-auto scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent text-white/90 placeholder:text-white/40"
            style={{ overflow: value.split('\n').length > 8 ? 'auto' : 'hidden' }}
            rows={1}
          />

            <Button
              variant="cyan"
              onClick={(e) => {
                e.preventDefault();
                handleSubmit();
              }}
              disabled={disabled}
              className="h-8"
            >
              Send
            </Button>
          </div>
        </div>
        </div>
  );
};

================
File: components/ui/common/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: components/ui/common/badge.tsx
================
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

================
File: components/ui/common/base-tab.tsx
================
import { ReactNode, CSSProperties } from 'react'
import { CommandType } from '@/hooks/useCommandCenter'

interface BaseTabProps {
  icon?: ReactNode
  label: string
  shortcut?: string
  onClick?: () => void
  minWidth?: 'space' | 'model' | 'actions'
  roundedBottom?: boolean
  isActive?: boolean
  style?: CSSProperties
  wrapperStyle?: CSSProperties
  className?: string
  color?: string
  rightElement?: ReactNode
  commandType?: CommandType
}

export function BaseTab({
  icon,
  color,
  label,
  shortcut,
  onClick,
  minWidth,
  style,
  wrapperStyle,
  className = '',
  rightElement,
  commandType
}: BaseTabProps) {
  const minWidthClass = {
    space: 'min-w-[100px]',
    model: 'min-w-[120px]',
    actions: ''
  }[minWidth || 'actions']

  return (
    <div
      className={`relative`}
      style={{ 
        ...wrapperStyle 
      }}
    >
      <div
        onClick={onClick}
        className={`px-3 py-1.5 text-white text-xs font-medium flex items-center gap-1.5 relative overflow-hidden cursor-pointer ${minWidthClass}
           transition-all duration-300 group ${className}`}
        style={{ 
          ...style,
        }}
      >
        {icon && (
          <div className="relative z-10 text-white/60 group-hover:text-[#3ecfff]/80 transition-colors duration-300">
            {icon}
          </div>
        )}
        <span className="text-white/75 truncate relative z-10 group-hover:text-white/95 transition-colors duration-300">
          {label}
        </span>
        {shortcut && (
          <span className="text-white/60 text-[10px] ml-auto shrink-0 relative z-10">⌘{shortcut}</span>
        )}
        {rightElement && (
          <div className="ml-auto relative z-10">
            {rightElement}
          </div>
        )}
      </div>
    </div>
  )
}

================
File: components/ui/common/button.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        ghost: "hover:bg-zinc-700/50 text-zinc-400",
        toggle: "hover:bg-zinc-700/50 text-zinc-300 border-t border-zinc-700/50 rounded-t-md rounded-b-none",
        cyan: "bg-[#3ecfff]/10 text-[#3ecfff] border border-[#3ecfff]/20 shadow-[0_0_12px_rgba(62,207,255,0.1)] hover:bg-[#3ecfff]/20 rounded-xl",
        destructive: "bg-red-500/10 text-red-500 hover:bg-red-500/20 border border-red-500/20",
      },
      size: {
        default: "h-10 py-2 px-4",
        sm: "h-8 px-3 rounded-md",
        icon: "h-8 w-8",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  active?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, active, ...props }, ref) => {
    return (
      <button
        className={cn(buttonVariants({ variant, size, className }), active && "bg-zinc-700/50")}
        ref={ref}
        {...props}
      />
    )
  },
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/common/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: components/ui/common/checkbox.tsx
================
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

================
File: components/ui/common/code-block.tsx
================
"use client"

import { cn } from "@/lib/utils"
import React, { useEffect, useState } from "react"
import { codeToHtml } from "shiki"
import { LanguageIcon } from "../chat/language-icon"
import { Copy, CheckIcon } from "lucide-react"

interface CopyButtonProps {
  code: string
}

function CopyButton({ code }: CopyButtonProps) {
  const [copied, setCopied] = useState(false)

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(code)
      setCopied(true)
      setTimeout(() => setCopied(false), 2000)
    } catch (error) {
      console.error('Failed to copy:', error)
    }
  }

  return (
    <button
      onClick={handleCopy}
      className={cn(
        "flex items-center justify-center rounded-md p-1.5",
        "transition-all duration-200 ease-in-out",
        "bg-white/[0.03] hover:bg-white/[0.08] border border-white/[0.05]",
        copied 
          ? "text-green-400 hover:text-green-300 border-green-500/20 bg-green-500/10" 
          : "text-zinc-400 hover:text-zinc-200"
      )}
      title="Copy code"
    >
      {copied ? <CheckIcon size={14} /> : <Copy size={14} />}
    </button>
  )
}

export type CodeBlockProps = {
  children?: React.ReactNode
  className?: string
  code?: string
  language?: string
} & React.HTMLProps<HTMLDivElement>

function CodeBlock({ children, className, code, language, ...props }: CodeBlockProps) {
  if (code && language) {
    return (
      <div
        className={cn(
          "not-prose flex w-full flex-col overflow-hidden my-4 rounded-lg",
          "glass-effect code-block-glow glass-highlight",
          className
        )}
        style={{
          background: 'rgba(255, 255, 255, 0.02)',
          backdropFilter: 'blur(12px)',
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
          border: '1px solid rgba(255, 255, 255, 0.05)'
        }}
        {...props}
      >
        <div className="flex items-center justify-between w-full px-4 py-2 header" style={{background: 'rgba(255, 255, 255, 0.03)', borderBottom: '1px solid rgba(255, 255, 255, 0.05)'}}>
          <div className="flex items-center space-x-2">
            <div className="flex space-x-1.5">
              <div className="w-3 h-3 rounded-full bg-red-500/90 border border-red-600/30 shadow-inner shadow-red-700/20"></div>
              <div className="w-3 h-3 rounded-full bg-yellow-500/90 border border-yellow-600/30 shadow-inner shadow-yellow-700/20"></div>
              <div className="w-3 h-3 rounded-full bg-green-500/90 border border-green-600/30 shadow-inner shadow-green-700/20"></div>
            </div>
            <div className="text-xs text-zinc-400 ml-2">
              {code.split('\n')[0].startsWith('//') ? code.split('\n')[0].substring(2).trim() : ''}
            </div>
          </div>
          <div className="flex items-center gap-2">
            {language && (
              <div className="flex items-center gap-1.5 text-xs rounded-md p-1.5 bg-white/[0.03] border border-white/[0.05] text-zinc-400">
                <LanguageIcon language={language} size={14} />
                <span>{language}</span>
              </div>
            )}
            <CopyButton code={code} />
          </div>
        </div>
        <CodeBlockCode code={code} language={language} />
      </div>
    )
  }
  
  return (
    <div
      className={cn(
        "not-prose flex w-full flex-col overflow-hidden my-4 rounded-lg",
        "glass-effect code-block-glow glass-highlight",
        className
      )}
      style={{
        background: 'rgba(255, 255, 255, 0.02)',
        backdropFilter: 'blur(12px)',
        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }}
      {...props}
    >
      {children}
    </div>
  )
}

export type CodeBlockCodeProps = {
  code: string
  language?: string
  theme?: string
  className?: string
} & React.HTMLProps<HTMLDivElement>

function CodeBlockCode({
  code,
  language = "tsx",
  theme = "github-dark",
  className,
  ...props
}: CodeBlockCodeProps) {
  const [highlightedHtml, setHighlightedHtml] = useState<string | null>(null)
  const [isLargeCode, setIsLargeCode] = useState(false)
  const codeLength = code?.length || 0

  useEffect(() => {
    // For large code blocks (>10000 chars), set a flag to enable progressive rendering
    if (codeLength > 10000) {
      setIsLargeCode(true)
    } else {
      setIsLargeCode(false)
    }

    let isMounted = true
    
    // For extremely large code blocks, delay highlighting to avoid blocking the UI
    const timer = setTimeout(async () => {
      try {
        // Custom theme setup for transparent glass effect while maintaining syntax highlighting
        const customTheme = {
          name: 'glass-dark',
          type: 'dark',
          fg: '#EEEEEE',
          bg: '#00000000', // Fully transparent
          settings: [
            {
              settings: {
                background: '#00000000',
                foreground: '#EEEEEE',
                caret: '#FFFFFF',
                selection: 'rgba(128, 203, 255, 0.2)',
                selectionBorder: 'rgba(128, 203, 255, 0.4)',
                lineHighlight: 'rgba(255, 255, 255, 0.05)',
                gutterForeground: 'rgba(175, 175, 175, 0.5)',
                gutterBorder: 'rgba(255, 255, 255, 0.05)',
              }
            },
            {
              scope: ['comment', 'punctuation.definition.comment', 'string.comment'],
              settings: {
                foreground: 'rgba(106, 153, 85, 0.9)'
              }
            },
            {
              scope: ['string', 'constant.other.symbol'],
              settings: {
                foreground: 'rgba(206, 145, 120, 0.9)'
              }
            },
            {
              scope: ['keyword', 'storage.type', 'storage.modifier'],
              settings: {
                foreground: 'rgba(86, 156, 214, 0.9)'
              }
            },
            {
              scope: ['entity.name.function', 'support.function'],
              settings: {
                foreground: 'rgba(220, 220, 170, 0.9)'
              }
            },
            {
              scope: ['variable', 'support.variable'],
              settings: {
                foreground: 'rgba(156, 220, 254, 0.9)'
              }
            }
          ]
        };

        // Using the custom theme with glass effect compatibility
        const html = await codeToHtml(code, { 
          lang: language, 
          theme: "github-dark", // Use github-dark as it has better support
          // Apply glass compatibility to Shiki themes
          transformers: [{
            root(node) {
              // Force transparent background at the root level
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            pre(node) {
              // Remove background from pre tag
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            code(node) {
              // Remove background from code tag
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              return node;
            },
            line(node) {
              // Make line transparent but preserve other styles
              const nodeAsAny = node as any;
              if (!nodeAsAny.properties) nodeAsAny.properties = {};
              const style = nodeAsAny.properties.style || '';
              if (style.includes('background')) {
                nodeAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, 'background: transparent !important;');
              }
              return node;
            },
            tokens(node) {
              // Process each token to preserve foreground color but remove background
              return node.map((token: any) => {
                const tokenAsAny = token as any;
                if (!tokenAsAny.properties) tokenAsAny.properties = {};
                const style = tokenAsAny.properties.style || '';
                if (style.includes('background')) {
                  tokenAsAny.properties.style = style.replace(/background[^:]*:[^;]*;/g, '');
                }
                return token;
              });
            }
          }]
        });

        if (isMounted) {
          // Process the HTML to ensure highlighting works while maintaining transparency
          const processedHtml = html
            .replace(/background-color: #24292e;/g, 'background-color: transparent !important;')
            .replace(/background-color: #1f2428;/g, 'background-color: transparent !important;')
            .replace(/background: #24292e;/g, 'background: transparent !important;')
            .replace(/background: #1f2428;/g, 'background: transparent !important;');
          
          setHighlightedHtml(processedHtml);
        }
      } catch (error) {
        console.error('Error highlighting code:', error)
      }
    }, isLargeCode ? 100 : 0) // Small delay for large code blocks

    return () => {
      isMounted = false
      clearTimeout(timer)
    }
  }, [code, language, theme, codeLength, isLargeCode])

  const classNames = cn(
    "w-full overflow-x-auto text-[13px] relative",
    // Ensure there's no background colors in pre and code tags that would block the glass effect
    "bg-transparent [&>pre]:bg-transparent [&>pre]:px-4 [&>pre]:py-4 [&>pre]:rounded-b-lg",
    "[&>pre>code]:bg-transparent [&>pre>code]:font-mono [&>pre>code]:text-zinc-200 [&>.shiki]:bg-transparent [&>.shiki]:px-4 [&>.shiki]:py-4 [&>.shiki]:rounded-b-lg",
    "backdrop-blur-[2px]", // Add subtle blur to enhance text readability over the glass
    "glass-highlight", // New class for true glass effect
    className
  )

  // Use a simplified renderer for very large code blocks before highlighting is complete
  if (isLargeCode && !highlightedHtml) {
    return (
      <div className={cn(classNames, "glass-code-content")} style={{background: 'transparent'}} {...props}>
        <pre className="bg-transparent text-zinc-200 px-4 py-4 rounded-b-lg font-mono" style={{background: 'transparent'}}>
          <code className={`language-${language} bg-transparent font-mono`} style={{background: 'transparent'}}>
            {code.length > 50000 
              ? code.substring(0, 50000) + '...\n\n(Code truncated for performance - full code will appear shortly)'
              : code}
          </code>
        </pre>
      </div>
    )
  }

  // Standard rendering once highlighting is complete or for smaller code blocks
  return highlightedHtml ? (
    <div
      className={cn(classNames, "glass-code-content")}
      style={{background: 'transparent'}}
      dangerouslySetInnerHTML={{ __html: highlightedHtml }}
      {...props}
    />
  ) : (
    <div className={cn(classNames, "glass-code-content")} style={{background: 'transparent'}} {...props}>
      <pre className="bg-transparent text-zinc-200 px-4 py-4 rounded-b-lg font-mono" style={{background: 'transparent'}}>
        <code className="font-mono bg-transparent" style={{background: 'transparent'}}>{code}</code>
      </pre>
    </div>
  )
}

export type CodeBlockGroupProps = React.HTMLAttributes<HTMLDivElement>

function CodeBlockGroup({
  children,
  className,
  ...props
}: CodeBlockGroupProps) {
  return (
    <div
      className={cn("flex items-center justify-between", className)}
      {...props}
    >
      {children}
    </div>
  )
}

export { CodeBlockGroup, CodeBlockCode, CodeBlock }

================
File: components/ui/common/command-badge.tsx
================
import { cn } from '@/utils';

interface CommandBadgeProps {
  children: React.ReactNode;
  variant?: 'active' | 'info' | 'count';
  className?: string;
}

export function CommandBadge({ children, variant = 'info', className }: CommandBadgeProps) {
  return (
    <span
      className={cn(
        'px-1.5 py-0.5 rounded-md text-[10px] font-medium',
        variant === 'active' && 'bg-[#3ecfff]/10 text-[#3ecfff] border border-[#3ecfff]/20',
        variant === 'info' && 'text-white/40 border border-white/10',
        variant === 'count' && 'bg-white/5 text-white/60',
        className
      )}
    >
      {children}
    </span>
  );
}

================
File: components/ui/common/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: components/ui/common/dropdown-menu.tsx
================
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

================
File: components/ui/common/input.tsx
================
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };

================
File: components/ui/common/label.tsx
================
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

================
File: components/ui/common/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: components/ui/common/switch.tsx
================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

================
File: components/ui/common/theme-switcher.tsx
================
"use client";

import { Button } from "@/components/ui/common/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/ui/common/dropdown-menu";
import { Laptop, Moon, Sun } from "lucide-react";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";

const ThemeSwitcher = () => {
  const [mounted, setMounted] = useState(false);
  const { theme, setTheme } = useTheme();

  // useEffect only runs on the client, so now we can safely show the UI
  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return null;
  }

  const ICON_SIZE = 16;

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size={"sm"}>
          {theme === "light" ? (
            <Sun
              key="light"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : theme === "dark" ? (
            <Moon
              key="dark"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          ) : (
            <Laptop
              key="system"
              size={ICON_SIZE}
              className={"text-muted-foreground"}
            />
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-content" align="start">
        <DropdownMenuRadioGroup
          value={theme}
          onValueChange={(e) => setTheme(e)}
        >
          <DropdownMenuRadioItem className="flex gap-2" value="light">
            <Sun size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Light</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="dark">
            <Moon size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>Dark</span>
          </DropdownMenuRadioItem>
          <DropdownMenuRadioItem className="flex gap-2" value="system">
            <Laptop size={ICON_SIZE} className="text-muted-foreground" />{" "}
            <span>System</span>
          </DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

export { ThemeSwitcher };

================
File: components/ui/common/toast.tsx
================
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 right-0 z-[9999] flex max-h-screen w-auto flex-col-reverse items-end gap-2 p-4",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full max-w-[350px] items-center justify-between space-x-2 overflow-hidden rounded-md p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-top-full data-[state=open]:slide-in-from-top-full data-[state=open]:duration-300 data-[state=closed]:duration-200",
  {
    variants: {
      variant: {
        default: 
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
        destructive:
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
        success:
          "bg-black/80 border border-white/10 backdrop-blur-xl text-white/90 font-medium",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: components/ui/common/toaster.tsx
================
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/common/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: components/ui/common/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-lg px-3 py-1.5 text-xs animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 bg-black/90 border border-white/10 backdrop-blur-xl shadow-xl shadow-black/20 text-white/90 font-medium",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: components/ui/conversation/conversation-tab.tsx
================
import { MessageSquare, Plus, Check } from 'lucide-react'
import { useState } from 'react'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/common/tooltip"
import { BaseTab } from '@/components/ui/common/base-tab'
import { Conversation } from '@/types'
import { useSpaceStore } from '@/stores/space-store'
import { useConversationStore } from '@/stores/conversation-store'
import { createConversation, setActiveConversation as setActiveConversationDB } from '@/app/actions'
import { cn } from '@/utils'
import { useToast } from '@/hooks/use-toast'
import { useCommandCenter } from '@/hooks/useCommandCenter'

interface ConversationTabProps {
  activeConversation: Conversation | null
  onConversationSelect?: (conversationId: string) => Promise<void>
}

export function ConversationTab({ activeConversation, onConversationSelect }: ConversationTabProps) {
  const { activeSpace } = useSpaceStore()
  const { setActiveConversation, conversations, setConversations } = useConversationStore()
  const { openCommandType } = useCommandCenter()
  const { toast } = useToast()
  const [isCreating, setIsCreating] = useState(false)
  const [showSuccess, setShowSuccess] = useState(false)

  const handleNewConversation = async () => {
    if (!activeSpace || isCreating) return
    
    try {
      setIsCreating(true)
      const newConversation = await createConversation(activeSpace.id, 'New Conversation')
      
      if (newConversation) {
        await setActiveConversationDB(newConversation.id)
        setActiveConversation(newConversation)
        
        if (conversations) {
          const updatedConversations = [newConversation, ...conversations]
          setConversations(updatedConversations)
          console.log('Updated conversations in ConversationTab:', updatedConversations.length)
        } else {
          setConversations([newConversation])
          console.log('Created first conversation in ConversationTab')
        }
        
        if (onConversationSelect) {
          await onConversationSelect(newConversation.id)
        }

        setShowSuccess(true)
        setTimeout(() => setShowSuccess(false), 1500)
        
        toast({
          title: 'New Conversation Created',
          description: 'You can start chatting right away.',
          variant: "success",
          duration: 2000,
        });
      }
    } finally {
      setIsCreating(false)
    }
  }

  return (
    <div className="flex h-full overflow-hidden">
      {activeSpace ? (
        <div className="flex-1 overflow-hidden">
          <BaseTab
            icon={<MessageSquare className="w-3 h-3" />}
            label={activeConversation?.title || 'Conversations'}
            shortcut="D"
            minWidth="space"
            className="overflow-hidden text-ellipsis"
            commandType="conversations"
            onClick={() => openCommandType("conversations")}
          />
        </div>
      ) : null}
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <button
              onClick={handleNewConversation}
              className={cn(
                'h-full p-2 flex items-center rounded-md border-white/[0.08]',
                'hover:bg-white/[0.08] bg-white/[0.03] active:bg-white/[0.02]',
                'transition-colors duration-200',
                'focus:outline-none',
                'disabled:opacity-50 disabled:cursor-not-allowed'
              )}
              disabled={!activeSpace || isCreating}
            >
              {showSuccess ? (
                <Check className="w-3 h-3 text-emerald-400 animate-in fade-in-0 zoom-in-95" />
              ) : (
                <Plus className={cn(
                  'w-3 h-3',
                  isCreating ? 'text-white/30 animate-pulse' : 'text-white/60'
                )} />
              )}
            </button>
          </TooltipTrigger>
          <TooltipContent>
            <p>Create New Conversation</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
    </div>
  )
}

================
File: components/ui/space/planet-icon.tsx
================
import React, { useMemo } from 'react';

interface PlanetIconProps {
  size?: number;
  seed?: string; // Ensures the same seed produces the same planet
}

const PlanetIcon = ({ size = 32, seed }: PlanetIconProps) => {
  // Compute a stable number from the seed for use in filters
  const filterSeed = useMemo(() => {
    return Math.floor(
      seed
        ? Array.from(seed).reduce((acc, char) => acc + char.charCodeAt(0), 0)
        : Math.random() * 1000
    );
  }, [seed]);

  // Seeded random number generator for reproducibility
  const random = useMemo(() => {
    const seedNum = seed
      ? Array.from(seed).reduce((acc, char) => acc + char.charCodeAt(0), 0)
      : Math.random() * 1000;
    let callCount = 0;
    return () => {
      callCount += 1;
      const x = Math.sin(seedNum + callCount) * 10000;
      return x - Math.floor(x);
    };
  }, [seed]);

  // Generate planet properties
  const {
    hasWater,
    baseHue,
    saturation,
    landHue,
    landColor,
    mountainColor,
    hasRings,
    ringColor,
    hasTrees,
    hasAtmosphere,
  } = useMemo(() => {
    const hasWater = random() < 0.7; // 70% chance of water
    const baseHue = hasWater ? 180 + random() * 60 : random() * 360; // Favor blues when water exists
    const saturation = 60 + random() * 30; // 60%–90%
    const landHue = hasWater ? random() * 120 : (baseHue + random() * 60) % 360; // Green/brown or varied
    const landColor = `hsl(${landHue}, 70%, 50%)`;
    const mountainColor = `hsl(${landHue}, 50%, 30%)`;
    const hasRings = random() < 0.3; // 30% chance
    const ringColor = hasRings ? `hsl(${(baseHue + 180) % 360}, ${saturation}%, 60%)` : null;
    const hasTrees = random() < 0.5; // 50% chance
    const hasAtmosphere = random() < 0.6; // 60% chance of visible atmosphere

    return {
      hasWater,
      baseHue,
      saturation,
      landHue,
      landColor,
      mountainColor,
      hasRings,
      ringColor,
      hasTrees,
      hasAtmosphere,
    };
  }, [random]);

  // Unique gradient IDs
  const baseGradientId = useMemo(() => `base_${Math.random().toString(36).substr(2, 9)}`, []);
  const shadowGradientId = useMemo(() => `shadow_${Math.random().toString(36).substr(2, 9)}`, []);
  const atmosphereGradientId = useMemo(
    () => `atmosphere_${Math.random().toString(36).substr(2, 9)}`,
    []
  );

  // Enhanced land mass generator for more organic coastlines
  const generateLandMassPath = () => {
    const startX = 10 + random() * 20;
    const startY = 10 + random() * 20;
    // Using cubic Bézier curves for a more natural contour
    return `
      M ${startX} ${startY}
      C ${startX + 5} ${startY - 5}, ${startX + 15} ${startY - 5}, ${startX + 20} ${startY}
      C ${startX + 15} ${startY + 10}, ${startX + 5} ${startY + 10}, ${startX} ${startY}
      Z
    `;
  };

  // Enhanced mountain path with natural quadratic curves
  const generateMountainPath = (baseX: number, baseY: number) => {
    const controlX = baseX + 4 + random() * 2;
    const controlY = baseY - 4 - random() * 2;
    const endX = baseX + 8 + random() * 2;
    const endY = baseY;
    return `M ${baseX} ${baseY} Q ${controlX} ${controlY} ${endX} ${endY} Z`;
  };

  return (
    <svg width={size} height={size} viewBox="0 0 50 50" className="flex-shrink-0">
      <defs>
        {/* Realistic base gradient with an extra stop for more depth */}
        <radialGradient id={baseGradientId} cx="0.4" cy="0.4" r="0.6">
          <stop offset="0%" stopColor={`hsl(${baseHue}, ${saturation}%, 85%)`} />
          <stop offset="50%" stopColor={`hsl(${baseHue}, ${saturation}%, 60%)`} />
          <stop offset="100%" stopColor={`hsl(${baseHue}, ${saturation}%, 35%)`} />
        </radialGradient>

        {/* Shadow gradient for 3D effect */}
        <radialGradient id={shadowGradientId} cx="0.75" cy="0.25" r="0.75">
          <stop offset="0%" stopColor="rgba(0,0,0,0)" />
          <stop offset="100%" stopColor="rgba(0,0,0,0.5)" />
        </radialGradient>

        {/* Atmosphere gradient for a subtle halo */}
        {hasAtmosphere && (
          <radialGradient id={atmosphereGradientId} cx="0.5" cy="0.5" r="0.8">
            <stop offset="0%" stopColor={`hsl(${baseHue}, ${saturation}%, 85%)`} stopOpacity="0.15" />
            <stop offset="100%" stopColor="transparent" />
          </radialGradient>
        )}

        {/* Bump filter: adds fractal noise and displacement for a realistic textured surface */}
        <filter id="bumpFilter" filterUnits="objectBoundingBox" x="-0.3" y="-0.3" width="1.6" height="1.6">
          <feTurbulence
            type="fractalNoise"
            baseFrequency="0.02"
            numOctaves="4"
            seed={filterSeed}
            result="noise"
          />
          <feDisplacementMap
            in="SourceGraphic"
            in2="noise"
            scale="3"
            xChannelSelector="R"
            yChannelSelector="G"
          />
        </filter>

        {/* Specular highlights filter: adds a subtle shiny reflection */}
        <filter id="specularHighlights" filterUnits="objectBoundingBox" x="-20%" y="-20%" width="140%" height="140%">
          <feGaussianBlur in="SourceAlpha" stdDeviation="1" result="blur" />
          <feSpecularLighting
            in="blur"
            surfaceScale="1"
            specularConstant="1"
            specularExponent="20"
            lightingColor="#ffffff"
            result="specOut"
          >
            <fePointLight x="-50" y="-50" z="100" />
          </feSpecularLighting>
          <feComposite in="specOut" in2="SourceAlpha" operator="in" result="specOut" />
          <feMerge>
            <feMergeNode in="specOut" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
      </defs>

      {/* Rings */}
      {hasRings && ringColor && (
        <ellipse
          cx="25"
          cy="25"
          rx="24"
          ry="6"
          fill="none"
          stroke={ringColor}
          strokeWidth="2"
          opacity="0.7"
          transform="rotate(-20 25 25)"
        />
      )}

      {/* Planet base with filters */}
      <g filter="url(#bumpFilter)">
        <g filter="url(#specularHighlights)">
          <circle cx="25" cy="25" r="20" fill={`url(#${baseGradientId})`} />
        </g>
      </g>

      {/* Land masses */}
      <path d={generateLandMassPath()} fill={landColor} opacity="0.9" />
      {random() < 0.6 && <path d={generateLandMassPath()} fill={landColor} opacity="0.9" />}

      {/* Mountains */}
      <path d={generateMountainPath(20, 30)} fill={mountainColor} opacity="0.85" />
      {random() < 0.5 && <path d={generateMountainPath(15, 25)} fill={mountainColor} opacity="0.85" />}

      {/* Trees */}
      {hasTrees && (
        <g>
          {Array.from({ length: 3 + Math.floor(random() * 3) }).map((_, i) => (
            <circle
              key={i}
              cx={15 + random() * 20}
              cy={20 + random() * 10}
              r="1"
              fill="hsl(120, 50%, 40%)"
              opacity="0.9"
            />
          ))}
        </g>
      )}

      {/* Atmospheric glow */}
      {hasAtmosphere && (
        <circle cx="25" cy="25" r="22" fill={`url(#${atmosphereGradientId})`} opacity="0.3" />
      )}

      {/* 3D shadow for depth */}
      <circle cx="25" cy="25" r="20" fill={`url(#${shadowGradientId})`} />
    </svg>
  );
};

export default PlanetIcon;

================
File: components/ui/space/space-tab.tsx
================
'use client'

import { useSpaceStore } from '@/stores/space-store';
import { BaseTab } from '../common/base-tab';
import PlanetIcon from './planet-icon';
import { useCommandCenter } from '@/hooks/useCommandCenter';

export const SpaceTab = () => {
  const activeSpace = useSpaceStore((state) => state.activeSpace);
  const { openCommandType } = useCommandCenter();

  const spaceColor = activeSpace?.color || '#3ecfff';

  return (
    <div className="relative flex items-center">
      {activeSpace && (
        <div className="mr-2">
          <PlanetIcon size={20} seed={activeSpace.id} />
        </div>
      )}
      <BaseTab
        color={spaceColor}
        label={activeSpace ? activeSpace.name : 'No Active Space'}
        shortcut="S"
        isActive={!!activeSpace}
        minWidth="space"
        commandType="spaces"
        onClick={() => openCommandType("spaces")}
      />
    </div>
  );
};

================
File: components/ui/command.tsx
================
import * as React from "react";
import { DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";
import { cn } from "@/lib/utils";
import { Dialog, DialogContent, DialogTitle, DialogDescription } from "@/components/ui/common/dialog";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-lg bg-black text-white",
      className
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent 
        className="overflow-hidden p-0 shadow-lg max-w-2xl w-full mx-auto border border-white/20 bg-black/95 rounded-lg backdrop-blur-xl"
        style={{
          boxShadow: '0 0 30px 4px rgba(62, 207, 255, 0.2), 0 0 15px 2px rgba(62, 207, 255, 0.15)',
        }}
      >
        <DialogTitle className="sr-only">Command Menu</DialogTitle>
        <DialogDescription className="sr-only">
          Search commands, actions, and navigate through your workspace.
        </DialogDescription>
        
        <Command className="
          [&_[cmdk-group-heading]]:px-4 
          [&_[cmdk-group-heading]]:font-semibold 
          [&_[cmdk-group-heading]]:text-white/80 
          [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 
          [&_[cmdk-group]]:px-2 
          [&_[cmdk-input-wrapper]_svg]:h-5 
          [&_[cmdk-input-wrapper]_svg]:w-5 
          [&_[cmdk-input]]:h-12 
          [&_[cmdk-item]]:px-3 
          [&_[cmdk-item]]:py-3 
          [&_[cmdk-item]_svg]:h-5 
          [&_[cmdk-item]_svg]:w-5
          transition-all duration-200
        ">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b border-[#3ecfff]/50 px-4" cmdk-input-wrapper="">
    <Search className="mr-2 h-5 w-5 shrink-0 text-white/90" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-12 w-full bg-transparent py-3 text-sm text-white outline-none placeholder:text-white/70 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
));
CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[400px] overflow-y-auto overflow-x-hidden py-2", className)}
    {...props}
  />
));
CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm text-white"
    {...props}
  />
));
CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-white [&_[cmdk-group-heading]]:px-3 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-semibold [&_[cmdk-group-heading]]:text-white/80",
      className
    )}
    {...props}
  />
));
CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-white/20", className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-pointer select-none items-center rounded-md px-3 py-2.5 text-sm text-white outline-none transition-all duration-200",
      "aria-selected:bg-[#3ecfff]/15 aria-selected:text-white",
      "data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      "hover:bg-[#3ecfff]/20 hover:text-white active:bg-[#3ecfff]/25",
      "hover:scale-[1.01] hover:shadow-[0_0_12px_rgba(62,207,255,0.2)]",
      "active:scale-[0.99] active:shadow-inner",
      "before:absolute before:inset-0 before:rounded-md before:opacity-0 before:transition-opacity",
      "hover:before:opacity-100 before:bg-gradient-to-r before:from-[#3ecfff]/10 before:to-transparent before:pointer-events-none",
      "group",
      className
    )}
    {...props}
  />
));
CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto flex items-center gap-1 text-xs tracking-widest text-white/80 group-aria-selected:text-white",
        className
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};

================
File: components/ui/quick-actions-tab.tsx
================
import { Sparkles } from "lucide-react";
import { BaseTab } from "./common/base-tab";
import { useCommandCenter } from "@/hooks/useCommandCenter";

export default function QuickActionsTab() {
    const { openCommandType } = useCommandCenter();
    
    return (
        <BaseTab
            icon={<Sparkles className="w-3 h-3" />}
            label="Quick Actions"
            shortcut="K"
            minWidth="actions"
            commandType="actions"
            onClick={() => openCommandType("actions")}
        />
    );
}

================
File: components/ui/tab-skeleton.tsx
================
export function TabSkeleton() {
  return (
    <div className="flex items-center gap-2 animate-pulse">
      {/* Space Tab Skeleton */}
      <div className="px-3 py-1 rounded-t-lg backdrop-blur-2xl border border-white/[0.05] min-w-[100px]
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <div className="flex items-center gap-1.5">
          <div className="w-2 h-2 rounded-full bg-white/10" />
          <div className="h-3 w-16 bg-white/10 rounded" />
        </div>
      </div>

      {/* Quick Actions Tab Skeleton */}
      <div className="px-3 py-1 rounded-t-lg backdrop-blur-2xl border border-white/[0.05]
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <div className="flex items-center gap-1.5">
          <div className="w-3 h-3 rounded bg-white/10" />
          <div className="h-3 w-20 bg-white/10 rounded" />
        </div>
      </div>

      {/* Model Tab Skeleton */}
      <div className="px-3 py-1 rounded-t-lg backdrop-blur-2xl border border-white/[0.05] min-w-[120px]
        before:absolute before:inset-0 before:backdrop-blur-3xl before:bg-gradient-to-b before:from-white/[0.07] before:to-white/[0.03] before:-z-10">
        <div className="flex items-center gap-1.5">
          <div className="w-3.5 h-3.5 rounded-full bg-white/10" />
          <div className="h-3 w-24 bg-white/10 rounded" />
        </div>
      </div>
    </div>
  )
}

================
File: components/ui/tabs.tsx
================
import { ModelTab } from "@/components/ui/chat/model-tab";
import { SpaceTab } from "@/components/ui/space/space-tab";
import QuickActionsTab from "@/components/ui/quick-actions-tab";

export const Tabs = () => {
    return (
            <div className="flex items-center gap-2">
                <SpaceTab />
                <QuickActionsTab />
                <ModelTab />  
            </div>
    );
};

================
File: components/CommandButton.tsx
================
import React from 'react';
import { Button } from '@/components/ui/common/button';
import { useCommandCenter } from '@/hooks/useCommandCenter';
import { Command } from 'lucide-react';
import { CommandType } from '@/hooks/useCommandCenter';

interface CommandButtonProps {
  className?: string;
  label?: string;
  showIcon?: boolean;
  showShortcut?: boolean;
  type?: CommandType;
}

export function CommandButton({
  className,
  label = 'Command Menu',
  showIcon = true,
  showShortcut = true,
  type,
}: CommandButtonProps) {
  const { openCommandCenter, openCommandType } = useCommandCenter();

  const handleClick = () => {
    if (type) {
      openCommandType(type);
    } else {
      openCommandCenter();
    }
  };

  return (
    <Button
      variant="ghost"
      className={className}
      onClick={handleClick}
    >
      {showIcon && <Command className="mr-2 h-4 w-4" />}
      {label}
      {showShortcut && (
        <kbd className="pointer-events-none ml-auto inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground">
          <span className="text-xs">⌘</span>K
        </kbd>
      )}
    </Button>
  );
}

/**
 * A button that opens the command center with a specific command type pre-selected
 */
export function TypedCommandButton({
  className,
  label,
  type,
  icon,
  shortcutKeys,
}: {
  className?: string;
  label: string;
  type: CommandType;
  icon?: React.ReactNode;
  shortcutKeys?: string[];
}) {
  const { openCommandType } = useCommandCenter();

  return (
    <Button
      variant="ghost"
      className={className}
      onClick={() => openCommandType(type)}
    >
      {icon && <span className="mr-2">{icon}</span>}
      {label}
      {shortcutKeys && (
        <kbd className="pointer-events-none ml-auto inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground">
          {shortcutKeys.map((key, i) => (
            <React.Fragment key={i}>
              {i > 0 && <span className="mx-0.5">+</span>}
              <span className="text-xs">{key}</span>
            </React.Fragment>
          ))}
        </kbd>
      )}
    </Button>
  );
}

export default CommandButton;

================
File: components/CommandCenter.tsx
================
"use client"

import React, { useEffect } from 'react';
import { Command, CommandDialog, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList, CommandSeparator, CommandShortcut } from '@/components/ui/command';
import { CommandOption, CommandType, useCommandCenter } from '@/hooks/useCommandCenter';

/**
 * Main CommandCenter component that integrates with the CMDK library
 * and uses the CommandContext to show available commands
 */
export function CommandCenter() {
  const {
    isOpen,
    closeCommandCenter,
    filteredCommands,
    setSearchQuery,
    activeCommandType,
  } = useCommandCenter();

  // Group commands by type for organized display
  const groupedCommands = React.useMemo(() => {
    const grouped: Record<CommandType, CommandOption[]> = {
      application: [],
      spaces: [],
      conversations: [],
      models: [],
      actions: [],
    };

    filteredCommands.forEach((command) => {
      grouped[command.type].push(command);
    });

    return grouped;
  }, [filteredCommands]);

  // Get all available command types that have commands
  const availableTypes = React.useMemo(() => {
    return Object.entries(groupedCommands)
      .filter(([_, commands]) => commands.length > 0)
      .map(([type]) => type as CommandType);
  }, [groupedCommands]);

  const handleSelect = (command: CommandOption) => {
    closeCommandCenter();
    command.action();
  };

  const renderCommandGroups = () => {
    if (activeCommandType) {
      // Render only the active type
      const commands = groupedCommands[activeCommandType];
      if (commands.length === 0) {
        // Add a message when no commands are found for the active type
        return (
          <CommandEmpty>No {activeCommandType} found.</CommandEmpty>
        );
      }

      return (
        <CommandGroup heading={activeCommandType.charAt(0).toUpperCase() + activeCommandType.slice(1)}>
          {commands.map((command) => (
            <CommandItem
              key={command.id}
              onSelect={() => handleSelect(command)}
              value={command.id}
              className="group cursor-pointer"
              role="button"
              onClick={() => handleSelect(command)}
            >
              {command.icon && (
                <span className="mr-3 text-white group-aria-selected:text-[#3ecfff] group-hover:text-[#3ecfff]">
                  {command.icon}
                </span>
              )}
              <div className="flex flex-col justify-center flex-1 overflow-hidden">
                <span className="truncate text-white font-medium group-hover:text-[#3ecfff]/90">{command.name}</span>
                {command.description && (
                  <span className="text-xs text-white/90 truncate mt-0.5 group-aria-selected:text-white group-hover:text-white">
                    {command.description}
                  </span>
                )}
              </div>
              {command.shortcut && (
                <CommandShortcut>
                  {command.shortcut.map((key, i) => (
                    <React.Fragment key={i}>
                      {i > 0 && <span className="mx-0.5">+</span>}
                      <kbd className="px-1.5 py-0.5 text-[10px] bg-black/50 border border-[#3ecfff]/30 rounded group-aria-selected:border-[#3ecfff]/60 group-aria-selected:bg-[#3ecfff]/10 group-hover:border-[#3ecfff]/60 group-hover:bg-[#3ecfff]/10">
                        {key}
                      </kbd>
                    </React.Fragment>
                  ))}
                </CommandShortcut>
              )}
            </CommandItem>
          ))}
        </CommandGroup>
      );
    }

    // Render all groups
    return availableTypes.map((type, index) => {
      const commands = groupedCommands[type];
      if (commands.length === 0) return null;

      return (
        <React.Fragment key={type}>
          <CommandGroup heading={type.charAt(0).toUpperCase() + type.slice(1)}>
            {commands.map((command) => (
              <CommandItem
                key={command.id}
                onSelect={() => handleSelect(command)}
                value={command.id}
                className="group cursor-pointer"
                role="button"
                onClick={() => handleSelect(command)}
              >
                {command.icon && (
                  <span className="mr-3 text-white group-aria-selected:text-[#3ecfff] group-hover:text-[#3ecfff]">
                    {command.icon}
                  </span>
                )}
                <div className="flex flex-col justify-center flex-1 overflow-hidden">
                  <span className="truncate text-white font-medium group-hover:text-[#3ecfff]/90">{command.name}</span>
                  {command.description && (
                    <span className="text-xs text-white/90 truncate mt-0.5 group-aria-selected:text-white group-hover:text-white">
                      {command.description}
                    </span>
                  )}
                </div>
                {command.shortcut && (
                  <CommandShortcut>
                    {command.shortcut.map((key, i) => (
                      <React.Fragment key={i}>
                        {i > 0 && <span className="mx-0.5">+</span>}
                        <kbd className="px-1.5 py-0.5 text-[10px] bg-black/50 border border-[#3ecfff]/30 rounded group-aria-selected:border-[#3ecfff]/60 group-aria-selected:bg-[#3ecfff]/10 group-hover:border-[#3ecfff]/60 group-hover:bg-[#3ecfff]/10">
                          {key}
                        </kbd>
                      </React.Fragment>
                    ))}
                  </CommandShortcut>
                )}
              </CommandItem>
            ))}
          </CommandGroup>
          {index < availableTypes.length - 1 && <CommandSeparator />}
        </React.Fragment>
      );
    });
  };

  return (
    <CommandDialog open={isOpen} onOpenChange={closeCommandCenter}>
      <CommandInput
        placeholder="Type a command or search..."
        onValueChange={setSearchQuery}
      />
      <CommandList>
        <CommandEmpty>No commands found.</CommandEmpty>
        {renderCommandGroups()}
      </CommandList>
    </CommandDialog>
  );
}

export default CommandCenter;

================
File: components/CommandProviders.tsx
================
"use client"

import React, { ReactNode, useEffect, useMemo, useState } from 'react';
import { CommandOption, useCommandRegistration, CommandType } from '@/hooks/useCommandCenter';
import { Settings, Search, Plus, Users, MessageSquare, Brain, Command } from 'lucide-react';
import { useSpaceStore } from '@/stores/space-store';
import { useRouter } from 'next/navigation';
import { AVAILABLE_MODELS, PROVIDER_NAMES, Provider } from '@/config/models';
import { getSpaces, getActiveSpace, getConversations, createConversation, createSpace } from '@/app/actions';
import { Space, Conversation } from '@/types';
import { useConversationStore } from '@/stores/conversation-store';

/**
 * Provider for application-wide commands
 */
export function ApplicationCommandProvider({ children }: { children: ReactNode }) {
  const applicationCommands: CommandOption[] = useMemo(() => [
    {
      id: 'settings',
      name: 'Open Settings',
      description: 'Open application settings',
      icon: <Settings className="h-4 w-4" />,
      shortcut: ['⌘', ','],
      type: 'application',
      keywords: ['settings', 'preferences', 'config', 'configuration'],
      action: () => {
        // Implement settings opening logic
        console.log('Opening settings');
      },
    },
    {
      id: 'search',
      name: 'Search Everything',
      description: 'Search across all content',
      icon: <Search className="h-4 w-4" />,
      shortcut: ['⌘', 'F'],
      type: 'application',
      keywords: ['search', 'find', 'filter', 'query'],
      action: () => {
        // Implement global search logic
        console.log('Opening global search');
      },
    },
  ], []);

  useCommandRegistration(applicationCommands);

  return <>{children}</>;
}

/**
 * Provider for space-related commands
 */
export function SpacesCommandProvider({ children }: { children: ReactNode }) {
  const { spaces, setActiveSpace } = useSpaceStore();
  const router = useRouter();

  const baseCommands = useMemo<CommandOption[]>(() => [
    {
      id: 'create-space',
      name: 'Create New Space',
      description: 'Create a new workspace',
      icon: <Plus className="h-4 w-4" />,
      shortcut: ['⌘', 'N'],
      type: 'spaces',
      keywords: ['create', 'new', 'space', 'workspace', 'add'],
      action: async () => {
        // Create a new space
        try {
          const newSpace = await createSpace('New Space', '', 'claude-3-opus-20240229', 'anthropic', true);
          if (newSpace) {
            console.log('Created new space:', newSpace);
            // Navigate to the new space
            router.push(`/spaces/${newSpace.id}`);
          }
        } catch (error) {
          console.error('Error creating space:', error);
        }
      },
    }
  ], [router]);

  // Generate dynamic commands for each space
  const spaceCommands = useMemo<CommandOption[]>(() => 
    (spaces?.map(space => ({
      id: `space-${space.id}`,
      name: space.name,
      description: space.description || 'Switch to this workspace',
      icon: <Users className="h-4 w-4" />,
      type: 'spaces' as CommandType,
      keywords: ['space', 'workspace', 'switch', space.name],
      action: async () => {
        // Set active space and navigate to it
        await setActiveSpace(space.id);
        router.push(`/spaces/${space.id}`);
      },
    })) ?? [])
  , [spaces, setActiveSpace, router]);

  const allSpaceCommands = useMemo<CommandOption[]>(() => 
    [...baseCommands, ...spaceCommands]
  , [baseCommands, spaceCommands]);

  useCommandRegistration(allSpaceCommands);

  return <>{children}</>;
}

/**
 * Provider for conversation-related commands
 */
export function ConversationsCommandProvider({ children }: { children: ReactNode }) {
  const { conversations, setConversations } = useConversationStore();
  const { activeSpace } = useSpaceStore();
  const router = useRouter();

  const conversationCommands = useMemo<CommandOption[]>(() => {
    return [
      {
        id: 'new-conversation',
        name: 'Start New Conversation',
        description: 'Begin a new chat conversation',
        icon: <MessageSquare className="h-4 w-4" />,
        shortcut: ['⌘', 'T'],
        type: 'conversations',
        keywords: ['conversation', 'chat', 'new', 'start', 'begin'],
        action: async () => {
          if (activeSpace?.id) {
            try {
              const newConversation = await createConversation(activeSpace.id);
              if (newConversation) {
                // Update the conversation store with the new conversation
                if (conversations) {
                  setConversations([newConversation, ...conversations]);
                } else {
                  setConversations([newConversation]);
                }
                router.push(`/spaces/${activeSpace.id}/conversations/${newConversation.id}`);
              }
            } catch (error) {
              console.error('Error creating conversation:', error);
            }
          } else {
            console.error('No active space found');
          }
        },
      },
      ...(conversations?.filter(conv => !conv.is_deleted).map(conversation => ({
        id: `conversation-${conversation.id}`,
        name: conversation.title || 'Untitled Conversation',
        description: `Open conversation: ${conversation.title || 'Untitled'}`,
        icon: <MessageSquare className="h-4 w-4" />,
        type: 'conversations' as CommandType,
        keywords: ['conversation', 'chat', 'open', conversation.title || ''],
        action: () => {
          if (activeSpace?.id) {
            router.push(`/spaces/${activeSpace.id}/conversations/${conversation.id}`);
          }
        },
      })) ?? [])
    ];
  }, [conversations, activeSpace, router, setConversations]);

  useCommandRegistration(conversationCommands);

  return <>{children}</>;
}

/**
 * Provider for model-related commands
 */
export function ModelsCommandProvider({ children }: { children: ReactNode }) {
  const router = useRouter();
  
  // Create a base command for model selection
  const baseModelCommands: CommandOption[] = useMemo(() => [
    {
      id: 'select-model',
      name: 'Select AI Model',
      description: 'Choose a different AI model',
      icon: <Brain className="h-4 w-4" />,
      type: 'models',
      keywords: ['model', 'ai', 'select', 'change', 'choose'],
      action: () => {
        // Navigate to model selection page or open a modal
        console.log('Opening model selection');
        // Example: router.push('/settings/models');
      },
    },
  ], []);
  
  // Create commands for each provider and their models
  const modelCommands: CommandOption[] = useMemo(() => {
    const commands: CommandOption[] = [];
    
    // Add commands for each provider
    Object.entries(AVAILABLE_MODELS).forEach(([providerKey, models]) => {
      const provider = providerKey as Provider;
      const providerName = PROVIDER_NAMES[provider];
      
      // Add a command for the provider itself
      commands.push({
        id: `provider-${provider}`,
        name: providerName,
        description: `Select a model from ${providerName}`,
        icon: <Brain className="h-4 w-4" />,
        type: 'models',
        keywords: ['provider', providerName.toLowerCase(), 'model'],
        action: () => {
          console.log(`Selecting provider: ${providerName}`);
          // This could open a sub-menu of models for this provider
        },
      });
      
      // Add commands for each model from this provider
      models.forEach((model) => {
        commands.push({
          id: `model-${provider}-${model.id}`,
          name: model.name,
          description: model.description || `${providerName} model`,
          icon: <Brain className="h-4 w-4" />,
          type: 'models',
          keywords: ['model', model.name.toLowerCase(), providerName.toLowerCase()],
          action: () => {
            console.log(`Selecting model: ${model.name} from ${providerName}`);
            // Set this model as active
            // This could update the active model in a store
          },
        });
      });
    });
    
    return commands;
  }, []);
  
  // Combine base commands with dynamic model commands
  const allModelCommands = useMemo(() => [...baseModelCommands, ...modelCommands], 
    [baseModelCommands, modelCommands]);

  console.log(`Registering ${allModelCommands.length} model commands`);
  useCommandRegistration(allModelCommands);

  return <>{children}</>;
}

/**
 * Provider for general actions commands
 */
export function ActionsCommandProvider({ children }: { children: ReactNode }) {
  const actionCommands: CommandOption[] = useMemo(() => [
    {
      id: 'keyboard-shortcuts',
      name: 'View Keyboard Shortcuts',
      description: 'Show all available keyboard shortcuts',
      icon: <Command className="h-4 w-4" />,
      type: 'actions',
      keywords: ['keyboard', 'shortcuts', 'keys', 'bindings', 'help'],
      action: () => {
        // Implement shortcuts display logic
        console.log('Viewing keyboard shortcuts');
      },
    },
  ], []);

  console.log('Registering action commands');
  useCommandRegistration(actionCommands);

  return <>{children}</>;
}

/**
 * Combined provider for all command types
 */
export function AllCommandProviders({ children }: { children: ReactNode }) {
  return (
    <ApplicationCommandProvider>
      <SpacesCommandProvider>
        <ConversationsCommandProvider>
          <ModelsCommandProvider>
            <ActionsCommandProvider>
              {children}
            </ActionsCommandProvider>
          </ModelsCommandProvider>
        </ConversationsCommandProvider>
      </SpacesCommandProvider>
    </ApplicationCommandProvider>
  );
}

================
File: components/CommandRoot.tsx
================
"use client"

import React from 'react';
import { CommandProvider } from "@/hooks/useCommandCenter";
import { AllCommandProviders } from "@/components/CommandProviders";
import CommandCenter from "@/components/CommandCenter";
import CommandShortcuts from "@/components/CommandShortcuts";

export default function CommandRoot() {
  return (
    <CommandProvider>
      <AllCommandProviders>
        <CommandCenter />
        <CommandShortcuts />
      </AllCommandProviders>
    </CommandProvider>
  );
}

================
File: components/CommandShortcuts.tsx
================
import { useModalHotkey, useCommandCenter } from "@/hooks/useCommandCenter";
import { useHotkeys } from "react-hotkeys-hook";

/**
 * Component that registers keyboard shortcuts for specific command types
 * This can be placed anywhere in your component tree, typically near the root
 */
export function CommandShortcuts() {
  const { toggleCommandCenter } = useCommandCenter();

  useHotkeys('meta+k', (event) => {
    event.preventDefault();
    toggleCommandCenter();
  }, {
    enableOnFormTags: true,
    enableOnContentEditable: true
  }); 

  useModalHotkey("spaces", "meta+s");
  useModalHotkey("conversations", "meta+b");
  useModalHotkey("models", "meta+m");
  useModalHotkey("actions", "meta+a");

  return null;
}

export default CommandShortcuts;

================
File: config/models.ts
================
export const PROVIDER_DESCRIPTIONS: Record<Provider, string> = {
  groq: 'Ultra-fast inference optimized for real-time applications',
  anthropic: 'Advanced language models with strong reasoning capabilities',
  openai: 'State-of-the-art models with broad capabilities',
  cohere: 'Specialized models for enterprise and business use cases',
  mistral: 'Open-source foundation models with various specializations',
  google: 'Cutting-edge multimodal models from Google DeepMind',
  xai: 'Advanced models focused on reasoning and transparency',
  togetherai: 'Curated collection of top open-source models',
  perplexity: 'Research-focused models optimized for reasoning tasks'
};

export const AVAILABLE_MODELS = {
  groq: [
    { id: 'deepseek-r1-distill-llama-70b', name: 'Deepseek R1 70B', description: 'Powerful general-purpose model with fast inference', contextWindow: 32768 },
    { id: 'mixtral-8x7b-instruct', name: 'Mixtral 8x7B', description: 'Efficient model balancing speed and capability', contextWindow: 32768 },
    { id: 'deepseek-r1-distill-llama-70b-specdec', name: 'Deepseek R1 70B SpecDec', description: 'Specialized for technical documentation', contextWindow: 32768 },
    { id: 'gemma2-9b-it', name: 'Gemma 2 9B', description: 'Compact model optimized for quick responses', contextWindow: 8192 },
    { id: 'llama-3.3-70b-versatile', name: 'LLaMA 3.3 70B Versatile', description: 'Latest LLaMA optimized for versatility', contextWindow: 128000 },
  ],
  anthropic: [
    { id: 'claude-3-opus-latest', name: 'Claude 3 Opus', description: 'Most capable model for complex tasks', contextWindow: 128000 },
    { id: 'claude-3-5-sonnet-latest', name: 'Claude 3.5 Sonnet', description: 'Balanced performance and speed', contextWindow: 128000 },
    { id: 'claude-3-5-haiku-latest', name: 'Claude 3.5 Haiku', description: 'Fast, efficient for simple tasks', contextWindow: 128000 },
  ],
  openai: [
    { id: 'gpt-4o', name: 'GPT-4o', description: 'Most powerful model for complex reasoning', contextWindow: 128000, multimodal: true },
    { id: 'gpt-4o-mini', name: 'GPT-4o Mini', description: 'Efficient version of GPT-4', contextWindow: 128000, multimodal: true },
    { id: 'o1', name: 'O1', description: 'Fast, general-purpose assistant', contextWindow: 128000 },
    { id: 'o3-mini', name: 'O3 Mini', description: 'Quick responses for simple tasks', contextWindow: 128000 },
  ],
  cohere: [
    { id: 'command', name: 'Command', description: 'Enterprise-grade general model', contextWindow: 128000 },
    { id: 'command-light', name: 'Command Light', description: 'Faster, lighter version of Command', contextWindow: 32768 },
    { id: 'command-nightly', name: 'Command Nightly', description: 'Latest experimental features', contextWindow: 128000 },
    { id: 'command-light-nightly', name: 'Command Light Nightly', description: 'Fast experimental version', contextWindow: 32768 }
  ],
  mistral: [
    { id: 'mistral-large-latest', name: 'Mistral Large', description: 'Most capable open model', contextWindow: 32000 },
    { id: 'codestral-latest', name: 'Codestral', description: 'Specialized for code generation', contextWindow: 32000 },
    { id: 'pixtral-large-latest', name: 'Pixtral Large', description: 'Vision and image understanding', contextWindow: 128000, multimodal: true },
    { id: 'ministral-3b-latest', name: 'Ministral 3B', description: 'Ultra-compact, fast responses', contextWindow: 4096 },
    { id: 'ministral-8b-latest', name: 'Ministral 8B', description: 'Balanced size and capability', contextWindow: 8192 },
    { id: 'mistral-small-latest', name: 'Mistral Small', description: 'Efficient for simple tasks', contextWindow: 4096 },
  ],
  google: [
    { id: 'gemini-2.0-flash-001', name: 'Gemini 2.0 Flash', description: 'Ultra-fast responses, latest version', contextWindow: 1000000, multimodal: true },
    { id: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro', description: 'Balanced performance model', contextWindow: 1000000, multimodal: true },
  ],
  xai: [
    { id: 'grok-2-1212', name: 'Grok 2', description: 'Advanced reasoning capabilities', contextWindow: 128000 },
    { id: 'grok-2-vision-1212', name: 'Grok 2 Vision', description: 'Multimodal understanding', contextWindow: 128000, multimodal: true },
  ],
  togetherai: [
    { id: 'deepseek-ai/DeepSeek-R1', name: 'DeepSeek R1', description: 'General purpose reasoning', contextWindow: 128000 },
    { id: 'deepseek-ai/DeepSeek-R1-Distill-Llama-70B-free', name: 'DeepSeek R1 Distill Llama 70B', description: 'Efficient large model', contextWindow: 32768 },
    { id: 'deepseek-ai/DeepSeek-V3', name: 'DeepSeek V3', description: 'Latest architecture improvements', contextWindow: 128000 },
    { id: 'meta-llama/Llama-3.3-70B-Instruct-Turbo-Free', name: 'Llama 3.3 70B Instruct Turbo', description: 'Fast instruction following', contextWindow: 128000 },
    { id: 'meta-llama/Meta-Llama-3.1-405B-Instruct-Turbo', name: 'Llama 3.1 405B Instruct Turbo', description: 'Massive model, best quality', contextWindow: 128000 },
  ],
  perplexity: [
    { id: 'sonar-reasoning-pro', name: 'Sonar Reasoning Pro', description: 'Advanced reasoning capabilities', contextWindow: 200000 },
    { id: 'sonar-reasoning', name: 'Sonar Reasoning', description: 'Efficient reasoning model', contextWindow: 200000 },
    { id: 'sonar-pro', name: 'Sonar Pro', description: 'Professional general use', contextWindow: 200000 },
    { id: 'sonar', name: 'Sonar', description: 'Fast, reliable model', contextWindow: 200000 }
  ]
} as const;

export type Provider = keyof typeof AVAILABLE_MODELS;
export type ModelsByProvider = {
  [P in Provider]: typeof AVAILABLE_MODELS[P][number]['id'];
};

export const PROVIDER_NAMES: Record<Provider, string> = {
  groq: 'Groq',
  anthropic: 'Anthropic',
  openai: 'OpenAI',
  cohere: 'Cohere',
  mistral: 'Mistral',
  google: 'Google',
  xai: 'xAI',
  togetherai: 'Together AI',
  perplexity: 'Perplexity'
};

export function isValidModelForProvider(provider: Provider, model: string): boolean {
  return AVAILABLE_MODELS[provider].some(m => m.id === model);
}

export function getModelName(provider: Provider | undefined, modelId: string): string {
  if (!provider || !modelId) return 'Select Model';
  
  const models = AVAILABLE_MODELS[provider];
  if (!models) return modelId;

  const model = models.find(m => m.id === modelId);
  return model?.name || modelId;
}

================
File: docs/COMMAND_SYSTEM.md
================
# Command System Architecture

This document outlines the architecture of the Spatial Command System, a unified modal interface for accessing all functionality within the application.

## Overview

The Command System follows the Raycast pattern, providing a single entry point to all application functionalities. It is designed to be:

- **Extensible**: New commands can be easily added to any part of the application
- **Modular**: Commands are organized into logical categories
- **Accessible**: Available via keyboard shortcuts (⌘K) or UI buttons
- **Scalable**: Built to handle an unlimited number of commands
- **Fast**: Quick access to any feature within the application

## Architecture

The Command System architecture follows SOLID principles:

### Single Responsibility Principle
- Each component has a single responsibility
- `CommandCenter` - Displays the command UI
- `CommandProvider` - Manages command state
- Section-specific providers - Register commands for their domains

### Open/Closed Principle
- The system is open for extension but closed for modification
- New command categories can be added without changing existing code
- New commands can be registered without modifying the core framework

### Liskov Substitution Principle
- Command types follow a consistent interface
- All commands have the same structure regardless of their category

### Interface Segregation Principle
- The API is minimal and focused
- Command registration hooks provide just what's needed
- Command rendering is separated from command behavior

### Dependency Inversion Principle
- High-level modules don't depend on low-level modules
- Commands are registered through abstraction (context)
- Components consume the command API through hooks

## Core Components

### 1. Command UI Components (`components/ui/command.tsx`)
- Reusable UI components built on top of CMDK
- Includes dialog, input, list, and item components
- Styled with Tailwind CSS for a consistent look and feel

### 2. Command Context (`hooks/useCommandCenter.tsx`)
- Central state management for the command system
- Handles command registration and filtering
- Manages dialog open/close state and keyboard shortcuts
- Provides functions to open specific command types directly

### 3. Command Providers (`components/CommandProviders.tsx`)
- Section-specific providers that register commands for their domains
- Organized into logical categories (application, spaces, conversations, etc.)
- Each provider registers its commands on mount and unregisters on unmount

### 4. Command Center (`components/CommandCenter.tsx`)
- Main component that displays the command UI
- Handles rendering of command groups and items
- Manages navigation between command categories

### 5. Command Button (`components/CommandButton.tsx`)
- UI component to trigger the command center
- Can be customized and placed anywhere in the application
- Includes TypedCommandButton for direct access to specific command types

### 6. Command Shortcuts (`components/CommandShortcuts.tsx`)
- Registers global keyboard shortcuts for specific command types
- Makes specific categories directly accessible via keyboard

## Command Structure

Each command follows this structure:

```typescript
interface CommandOption {
  id: string;                   // Unique identifier
  name: string;                 // Display name
  description?: string;         // Optional description
  icon?: ReactNode;             // Optional icon
  shortcut?: string[];          // Optional keyboard shortcut
  type: CommandType;            // Category (application, spaces, etc.)
  keywords?: string[];          // Optional keywords for search
  action: () => void;           // Function to execute when selected
}
```

## Extension Points

To add new commands:

1. Create a new command provider or extend an existing one
2. Define your commands following the `CommandOption` interface
3. Register them using the `useCommandRegistration` hook

For a new command category:

1. Add the new type to the `CommandType` union type
2. Create a new provider for that category
3. Add your commands following the structure above
4. Add a modal-specific shortcut if needed

## Keyboard Shortcuts

The system supports two levels of keyboard shortcuts:

1. **Global Command Center Shortcut**: `⌘K` (or `Ctrl+K` on Windows) opens the main command center.
2. **Type-Specific Shortcuts**:
   - `⌘S` - Open Spaces commands
   - `⌘T` - Open Conversations commands
   - `⌘M` - Open Models commands
   - `⌘A` - Open Actions commands

To add a new type-specific shortcut:

```typescript
// In CommandShortcuts.tsx or any component
useModalHotkey("your-command-type", "meta+letter");
```

## Design Decisions

1. **Context-based State Management**
   - Using React Context for global command state
   - Allows any component to register commands from anywhere in the app

2. **Component Composition**
   - Command UI components are composable
   - Allows for customization and future extension

3. **Keyboard Accessibility**
   - All commands are accessible via keyboard shortcuts
   - The command center itself is triggered via ⌘K (or Ctrl+K)
   - Type-specific shortcuts for direct access to specific categories

4. **Search-based Navigation**
   - Commands are searchable by name, description, and keywords
   - Enables quick access to any functionality

5. **Category-based Organization**
   - Commands are organized into logical categories
   - Provides structure to potentially hundreds of commands

6. **Direct Modal Access**
   - Each command category can be accessed directly
   - Supports both keyboard shortcuts and UI buttons

## Future Improvements

1. **Command History**
   - Track recently used commands
   - Allow quick access to frequently used actions

2. **Dynamic Command Loading**
   - Lazy-load commands based on application state
   - Register commands only when needed

3. **Sub-commands and Nested Navigation**
   - Add support for commands that open sub-menus
   - Enable more complex command hierarchies

4. **Command Permissions**
   - Control command visibility based on user permissions
   - Show/hide commands based on application state

5. **Command Palettes**
   - Create context-specific command palettes
   - Show different sets of commands based on the current view

================
File: electron/main.ts
================
import { app, BrowserWindow } from "electron";
import { join } from "path";

const createWindow = () => {
  const mainWindow = new BrowserWindow({
    width: 900,
    height: 670,
    webPreferences: {
      preload: join(__dirname, "preload.js"),
      nodeIntegration: true,
    },
  });
  
  mainWindow.loadURL("http://localhost:3000");
};

app.whenReady().then(createWindow);

================
File: hooks/use-stick-to-bottom.ts
================
import { useCallback, useEffect, useRef, useState } from 'react';

export function useStickToBottom(threshold = 150) {
  const [isStickToBottom, setIsStickToBottom] = useState(true);
  const containerRef = useRef<HTMLDivElement>(null);
  const prevScrollHeightRef = useRef<number>(0);

  const checkIsStickToBottom = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    const { scrollHeight, scrollTop, clientHeight } = container;
    const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
    
    setIsStickToBottom(distanceFromBottom <= threshold);
  }, [threshold]);

  const scrollToBottom = useCallback(() => {
    const container = containerRef.current;
    if (!container) return;

    // Ensure we scroll all the way to the bottom
    container.scrollTop = container.scrollHeight;
  }, []);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = () => {
      checkIsStickToBottom();
    };

    container.addEventListener('scroll', handleScroll);
    return () => container.removeEventListener('scroll', handleScroll);
  }, [checkIsStickToBottom]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleResize = () => {
      if (isStickToBottom) {
        scrollToBottom();
      }
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [isStickToBottom, scrollToBottom]);

  // Auto-scroll when content changes if we're sticking to bottom
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const { scrollHeight } = container;
    
    if (scrollHeight !== prevScrollHeightRef.current) {
      if (isStickToBottom) {
        scrollToBottom();
      }
      prevScrollHeightRef.current = scrollHeight;
    }
  });

  // Always scroll to bottom on initial render
  useEffect(() => {
    scrollToBottom();
  }, []);

  return {
    containerRef,
    isStickToBottom,
    scrollToBottom
  };
}

================
File: hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/common/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: hooks/useCommandCenter.tsx
================
'use client'
import { ReactNode, createContext, useCallback, useContext, useEffect, useMemo, useState, useRef } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';

// Command types
export type CommandType = 'application' | 'spaces' | 'conversations' | 'models' | 'actions';

export interface CommandOption {
  id: string;
  name: string;
  description?: string;
  icon?: ReactNode;
  shortcut?: string[];
  type: CommandType;
  keywords?: string[];
  action: () => void;
}

interface CommandContextType {
  isOpen: boolean;
  openCommandCenter: () => void;
  closeCommandCenter: () => void;
  toggleCommandCenter: () => void;
  openCommandType: (type: CommandType) => void;
  closeCommandType: (type: CommandType) => void;
  registerCommand: (command: CommandOption) => void;
  unregisterCommand: (commandId: string) => void;
  commands: CommandOption[];
  filteredCommands: CommandOption[];
  setSearchQuery: (query: string) => void;
  searchQuery: string;
  activeCommandType: CommandType | null;
  setActiveCommandType: (type: CommandType | null) => void;
}

const CommandContext = createContext<CommandContextType | undefined>(undefined);

export function CommandProvider({ children }: { children: ReactNode }) {
  const [isOpen, setIsOpen] = useState(false);
  const [commands, setCommands] = useState<CommandOption[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [activeCommandType, setActiveCommandType] = useState<CommandType | null>(null);
  
  // Use a ref to track mounted state to avoid state updates after unmount
  const isMounted = useRef(true);
  
  useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);

  // Command center controls
  const openCommandCenter = useCallback(() => setIsOpen(true), []);
  const closeCommandCenter = useCallback(() => {
    setIsOpen(false);
    setSearchQuery('');
    setActiveCommandType(null);
  }, []);
  
  const toggleCommandCenter = useCallback(() => {
    console.log('toggleCommandCenter called');
    console.log('Current state:', { isOpen, activeCommandType });
    
    if (isOpen) {
      if (activeCommandType !== null) {
        console.log('Switching from specific command type to main command center');
        setActiveCommandType(null);
      } else {
        console.log('Closing main command center');
        setIsOpen(false);
        setSearchQuery('');
        setActiveCommandType(null);
      }
    } else {
      console.log('Opening main command center');
      setIsOpen(true);
      setActiveCommandType(null);
    }
  }, [isOpen, activeCommandType]);
  
  // Function to close a specific command type
  const closeCommandType = useCallback((type: CommandType) => {
    console.log('closeCommandType called with:', type);
    if (isOpen && activeCommandType === type) {
      setIsOpen(false);
      setSearchQuery('');
    }
  }, [isOpen, activeCommandType]);
  
  // New function to open command center with a specific type
  const openCommandType = useCallback((type: CommandType) => {
    console.log('openCommandType called with:', type);
    if (isOpen && activeCommandType === type) {
      console.log('Closing the currently open type');
      closeCommandType(type);
    } else {
      console.log('Switching to command type:', type);
      setActiveCommandType(type);
      if (!isOpen) {
        setIsOpen(true);
      }
    }
  }, [isOpen, activeCommandType, closeCommandType]);

  // Register keyboard shortcuts
  // meta+k is now handled in CommandShortcuts component
  useHotkeys('esc', () => {
    if (isOpen) {
      closeCommandCenter();
    }
  });

  // Command registration - properly memoized to prevent infinite loops
  const registerCommand = useCallback((command: CommandOption) => {
    if (!isMounted.current) return;
    
    setCommands(prev => {
      // Check if this exact command already exists to avoid unnecessary updates
      const exists = prev.some(cmd => cmd.id === command.id);
      if (exists) {
        // Only update if there are actual changes
        const isEqual = prev.some(cmd => 
          cmd.id === command.id && 
          cmd.name === command.name && 
          cmd.description === command.description
        );
        if (isEqual) return prev; // No change needed
        
        // Replace the existing command
        return prev.map(cmd => cmd.id === command.id ? command : cmd);
      }
      // Add new command
      return [...prev, command];
    });
  }, []);

  const unregisterCommand = useCallback((commandId: string) => {
    if (!isMounted.current) return;
    
    setCommands(prev => {
      // Only update if the command exists
      const commandExists = prev.some(cmd => cmd.id === commandId);
      if (!commandExists) return prev;
      return prev.filter(cmd => cmd.id !== commandId);
    });
  }, []);

  // Filter commands based on search query and active type - memoize to avoid recalculation
  const filteredCommands = useMemo(() => {
    return commands.filter(command => {
      // Filter by type if active type is set
      if (activeCommandType && command.type !== activeCommandType) {
        return false;
      }

      // If no search query, return all commands of the active type (or all commands if no active type)
      if (!searchQuery) return true;

      const query = searchQuery.toLowerCase();
      
      // Search in name, description, and keywords
      return (
        command.name.toLowerCase().includes(query) ||
        (command.description?.toLowerCase().includes(query)) ||
        command.keywords?.some(keyword => keyword.toLowerCase().includes(query))
      );
    });
  }, [commands, searchQuery, activeCommandType]);

  // Context value - memoize to prevent unnecessary re-renders
  const value = useMemo(() => ({
    isOpen,
    openCommandCenter,
    closeCommandCenter,
    toggleCommandCenter,
    openCommandType,
    closeCommandType,
    registerCommand,
    unregisterCommand,
    commands,
    filteredCommands,
    searchQuery,
    setSearchQuery,
    activeCommandType,
    setActiveCommandType,
  }), [
    isOpen, 
    openCommandCenter, 
    closeCommandCenter, 
    toggleCommandCenter, 
    openCommandType,
    closeCommandType,
    registerCommand, 
    unregisterCommand, 
    commands, 
    filteredCommands, 
    searchQuery, 
    activeCommandType
  ]);

  return (
    <CommandContext.Provider value={value}>
      {children}
    </CommandContext.Provider>
  );
}

export function useCommandCenter() {
  const context = useContext(CommandContext);
  if (context === undefined) {
    throw new Error('useCommandCenter must be used within a CommandProvider');
  }
  return context;
}

export function useCommandRegistration(commands: CommandOption[]) {
  const { registerCommand, unregisterCommand } = useCommandCenter();
  
  const commandsRef = useRef<CommandOption[]>([]);
  
  useEffect(() => {
    console.log(`useCommandRegistration - commands changed, count: ${commands.length}`);
    
    // Make a deep copy of incoming commands to prevent reference issues
    const currentCommands = [...commands];
    
    // Find commands that were previously registered but are no longer in the current list
    const removedCommands = commandsRef.current.filter(
      prevCmd => !currentCommands.some(cmd => cmd.id === prevCmd.id)
    );
    
    // Unregister removed commands
    removedCommands.forEach(command => {
      console.log(`Unregistering command: ${command.id}`);
      unregisterCommand(command.id);
    });
    
    // Find new commands that weren't previously registered
    const newCommands = currentCommands.filter(
      cmd => !commandsRef.current.some(prevCmd => prevCmd.id === cmd.id)
    );
    
    // Register new commands
    newCommands.forEach(command => {
      console.log(`Registering new command: ${command.id}`);
      registerCommand(command);
    });
    
    // Also update any commands that might have changed but kept the same ID
    const updatedCommands = currentCommands.filter(
      cmd => commandsRef.current.some(prevCmd => 
        prevCmd.id === cmd.id && 
        (prevCmd.name !== cmd.name || 
         prevCmd.description !== cmd.description ||
         JSON.stringify(prevCmd.keywords) !== JSON.stringify(cmd.keywords))
      )
    );
    
    // Re-register updated commands
    updatedCommands.forEach(command => {
      console.log(`Updating command: ${command.id}`);
      registerCommand(command);
    });
    
    // Update our ref to the current commands array
    commandsRef.current = currentCommands;
    
  }, [commands, registerCommand, unregisterCommand]);
}

export function useModalHotkey(type: CommandType, hotkey: string) {
  const { openCommandType } = useCommandCenter();
  
  useHotkeys(hotkey, (event) => {
    event.preventDefault();
    console.log('Hotkey pressed:', hotkey);
    openCommandType(type);
  }, { 
    enableOnFormTags: true,
    enableOnContentEditable: true
  });
}

================
File: public/icons/providers/default.svg
================
<?xml version="1.0" encoding="UTF-8"?>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M12 2L2 7L12 12L22 7L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M2 17L12 22L22 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  <path d="M2 12L12 17L22 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: public/icons/providers/groq.svg
================
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="152px" height="55.5px" viewBox="0 32.25 152 55.5" enable-background="new 0 32.25 152 55.5" xml:space="preserve">
 <title>
  groq_logo
 </title>
 <g id="Layer_2">
  <g id="Layer_1-2">
   <path d="M84.848,34.137c-9.798,0-17.769,7.971-17.769,17.77s7.971,17.769,17.769,17.769s17.77-7.971,17.77-17.769
			S94.645,34.137,84.848,34.137z M84.848,63.013c-6.124,0-11.106-4.983-11.106-11.106s4.982-11.106,11.106-11.106
			c6.124,0,11.106,4.982,11.106,11.106S90.973,63.013,84.848,63.013z">
   </path>
   <path d="M60.315,34.206c-0.607-0.068-1.217-0.104-1.827-0.108c-0.304,0-0.595,0.009-0.893,0.014s-0.594,0.033-0.891,0.051
			c-1.197,0.094-2.382,0.299-3.541,0.611c-2.329,0.629-4.574,1.723-6.515,3.277c-1.97,1.57-3.548,3.575-4.611,5.859
			c-0.53,1.138-0.921,2.336-1.165,3.567c-0.121,0.608-0.21,1.222-0.266,1.84c-0.02,0.307-0.055,0.615-0.059,0.921l-0.011,0.459
			l-0.005,0.23v0.19l0.015,5.951l0.015,5.951l0.041,5.95h6.664l0.042-5.95l0.015-5.952l0.015-5.951v-0.182l0.005-0.142l0.008-0.285
			c0-0.191,0.028-0.375,0.039-0.564c0.036-0.37,0.091-0.738,0.165-1.102c0.146-0.716,0.374-1.413,0.678-2.077
			c0.613-1.332,1.528-2.502,2.673-3.419c1.156-0.932,2.541-1.628,4.038-2.042c0.757-0.207,1.532-0.344,2.314-0.408
			c0.198-0.011,0.395-0.03,0.594-0.037c0.199-0.007,0.402-0.013,0.595-0.012c0.383,0,0.76,0.025,1.142,0.06
			c1.518,0.153,2.989,0.619,4.318,1.368l3.326-5.776C65.108,35.263,62.753,34.484,60.315,34.206z">
   </path>
   <path d="M17.77,34.048C7.971,34.048,0,42.019,0,51.817s7.971,17.77,17.77,17.77h5.844v-6.664H17.77
			c-6.124,0-11.106-4.982-11.106-11.106s4.982-11.106,11.106-11.106s11.132,4.982,11.132,11.106l0,0v16.365l0,0
			c0,6.084-4.954,11.039-11.023,11.103c-2.904-0.024-5.681-1.191-7.729-3.25l-4.712,4.712c3.266,3.283,7.691,5.151,12.321,5.201
			v0.003c0.04,0,0.08,0,0.119,0h0.125v-0.003c9.659-0.131,17.48-8.005,17.525-17.686l0.006-16.881
			C35.302,41.785,27.422,34.048,17.77,34.048z">
   </path>
   <path d="M124.083,34.137c-9.798,0-17.769,7.971-17.769,17.77s7.971,17.769,17.769,17.769h6.08v-6.663h-6.08
			c-6.124,0-11.106-4.983-11.106-11.106s4.982-11.106,11.106-11.106c5.799,0,10.572,4.468,11.062,10.143h-0.01v34.12h6.664V51.907
			l0,0C141.797,42.108,133.881,34.137,124.083,34.137z">
   </path>
   <polygon points="151.983,35.04 151.033,35.04 149.737,37.053 148.399,35.04 147.44,35.04 147.44,38.624 148.511,38.624 
			148.511,36.88 149.461,38.288 149.979,38.288 150.912,36.836 150.929,38.624 152,38.624 		">
   </polygon>
   <polygon points="143.519,35.896 144.685,35.896 144.685,38.624 145.86,38.624 145.86,35.896 147.034,35.896 147.034,35.04 
			143.519,35.04 		">
   </polygon>
  </g>
 </g>
</svg>

================
File: store/useSpacesStore.ts
================
import { create } from 'zustand';
import { Space } from '@/types';
import { getSpaces, createSpace, setActiveSpace } from '@/app/actions';

interface SpacesState {
  spaces: Space[];
  isLoading: boolean;
  isInitialized: boolean; // Track if we've attempted to load data
  activeSpaceId: string | null;
  error: string | null;
  
  // Actions
  fetchSpaces: () => Promise<void>;
  createNewSpace: (name: string, description: string, model: string, provider: string) => Promise<Space | null>;
  setActive: (spaceId: string) => Promise<void>;
  clearError: () => void;
}

export const useSpacesStore = create<SpacesState>((set, get) => ({
  spaces: [],
  isLoading: false,
  isInitialized: false,
  activeSpaceId: null,
  error: null,
  
  fetchSpaces: async () => {
    // Don't fetch if already loading
    if (get().isLoading) {
      console.log('Spaces already loading, skipping fetch');
      return;
    }
    
    set({ isLoading: true, error: null });
    try {
      console.log('Fetching spaces from server...');
      const spaces = await getSpaces();
      
      if (!spaces) {
        console.warn('No spaces returned from server - this may be an authentication issue');
        set({ 
          spaces: [], 
          isLoading: false, 
          isInitialized: true,
          error: 'Failed to fetch spaces - please check if you are logged in'
        });
        return;
      }
      
      console.log(`Successfully fetched ${spaces.length} spaces`);
      set({ 
        spaces: spaces, 
        isLoading: false, 
        isInitialized: true,
        error: null
      });
    } catch (error) {
      console.error('Error fetching spaces:', error);
      set({ 
        error: 'Failed to fetch spaces', 
        isLoading: false,
        isInitialized: true 
      });
    }
  },
  
  createNewSpace: async (name, description, model, provider) => {
    set({ isLoading: true, error: null });
    try {
      console.log(`Creating new space "${name}" with model ${model} from ${provider}`);
      const newSpace = await createSpace(name, description, model, provider, true);
      if (newSpace) {
        // Update the spaces list with the new space
        set(state => ({ 
          spaces: [newSpace, ...state.spaces],
          activeSpaceId: newSpace.id,
          isLoading: false,
          error: null
        }));
        console.log(`Successfully created space: ${newSpace.id}`);
      } else {
        set({ 
          error: 'Failed to create space - no space returned', 
          isLoading: false 
        });
      }
      return newSpace;
    } catch (error) {
      console.error('Error creating space:', error);
      set({ error: 'Failed to create space', isLoading: false });
      return null;
    }
  },
  
  setActive: async (spaceId) => {
    try {
      console.log(`Setting active space: ${spaceId}`);
      await setActiveSpace(spaceId);
      set({ activeSpaceId: spaceId });
    } catch (error) {
      console.error('Error setting active space:', error);
      set({ error: 'Failed to set active space' });
    }
  },
  
  clearError: () => set({ error: null })
}));

================
File: stores/conversation-store.ts
================
import { create } from 'zustand'
import { Conversation } from '@/types'

interface ConversationStore {
  conversations: Conversation[] | null
  activeConversation: Conversation | null
  setConversations: (conversations: Conversation[] | null) => void
  setActiveConversation: (conversation: Conversation | null) => void
}

export const useConversationStore = create<ConversationStore>((set) => ({
  conversations: null,
  activeConversation: null,
  setConversations: (conversations) => set({ conversations }),
  setActiveConversation: (conversation) => set({ activeConversation: conversation })
}))

================
File: stores/messages-search-store.ts
================
import { create } from 'zustand';

export type SearchScope = 'conversation' | 'space';
export type SearchMode = 'keyword' | 'semantic';

interface MessagesSearchState {
  // Search configuration
  searchTerm: string;
  searchScope: SearchScope;
  searchMode: SearchMode;
  
  // Search results
  isSearching: boolean;
  
  // Actions
  setSearchTerm: (term: string) => void;
  setSearchScope: (scope: SearchScope) => void;
  setSearchMode: (mode: SearchMode) => void;
  setIsSearching: (isSearching: boolean) => void;
  resetSearch: () => void;
}

export const useMessagesSearchStore = create<MessagesSearchState>((set) => ({
  // Default state
  searchTerm: '',
  searchScope: 'conversation',
  searchMode: 'keyword',
  isSearching: false,
  
  // Actions
  setSearchTerm: (term) => set({ searchTerm: term }),
  setSearchScope: (scope) => set({ searchScope: scope }),
  setSearchMode: (mode) => set({ searchMode: mode }),
  setIsSearching: (isSearching) => set({ isSearching }),
  resetSearch: () => set({
    searchTerm: '',
    isSearching: false,
  }),
}));

================
File: stores/modal-navigation-store.ts
================
import { create } from 'zustand';

type ModalType = 'main' | 'spaces' | 'models' | 'conversations' | 'similarMessages' | 'spaceForm' | 'messagesSearch';

interface ModalNavigationState {
  // Track navigation history for modals
  navigationHistory: ModalType[];
  
  // Check if we're coming from the main modal (for back button logic)
  isNavigatedFromMain: boolean;
  
  // Reset the history when closing the modal
  resetHistory: () => void;
  
  // Add a modal to the navigation history
  addToHistory: (modal: ModalType) => void;
  
  // Remove the last item from history (back button was clicked)
  goBack: () => ModalType | null;
  
  // Record that a direct hotkey open happened (not from main)
  setDirectOpen: (modalType: ModalType) => void;
}

export const useModalNavigationStore = create<ModalNavigationState>((set, get) => ({
  navigationHistory: [],
  isNavigatedFromMain: false,
  
  resetHistory: () => {
    set({ navigationHistory: [], isNavigatedFromMain: false });
  },
  
  addToHistory: (modal) => {
    const { navigationHistory } = get();
    
    // Check if we're navigating from main to another modal
    const isFromMain = navigationHistory.length > 0 && 
                      navigationHistory[navigationHistory.length - 1] === 'main';
    
    set({ 
      navigationHistory: [...navigationHistory, modal],
      isNavigatedFromMain: isFromMain || get().isNavigatedFromMain
    });
  },
  
  goBack: () => {
    const { navigationHistory } = get();
    
    if (navigationHistory.length <= 1) {
      return null;
    }
    
    const newHistory = [...navigationHistory];
    newHistory.pop(); // Remove current modal
    const previousModal = newHistory[newHistory.length - 1];
    
    set({ navigationHistory: newHistory });
    
    return previousModal;
  },
  
  setDirectOpen: (modalType) => {
    set({ 
      navigationHistory: [modalType], 
      isNavigatedFromMain: false 
    });
  }
}));

================
File: stores/notification-store.ts
================
import { create } from 'zustand';
import { Notification } from '@/app/actions/notifications';

interface NotificationStore {
  notifications: Notification[];
  unreadCount: number;
  setNotifications: (notifications: Notification[]) => void;
  addNotification: (notification: Notification) => void;
  markAsRead: (notificationId: string) => void;
  markAllAsRead: () => void;
}

export const useNotificationStore = create<NotificationStore>((set) => ({
  notifications: [],
  unreadCount: 0,
  setNotifications: (notifications) =>
    set({
      notifications,
      unreadCount: notifications.filter((n) => !n.is_read).length,
    }),
  addNotification: (notification) =>
    set((state) => ({
      notifications: [notification, ...state.notifications],
      unreadCount: state.unreadCount + (notification.is_read ? 0 : 1),
    })),
  markAsRead: (notificationId) =>
    set((state) => ({
      notifications: state.notifications.map((n) =>
        n.id === notificationId ? { ...n, is_read: true } : n
      ),
      unreadCount: state.unreadCount - 1,
    })),
  markAllAsRead: () =>
    set((state) => ({
      notifications: state.notifications.map((n) => ({ ...n, is_read: true })),
      unreadCount: 0,
    })),
}));

================
File: stores/space-store.ts
================
import { create } from 'zustand'
import { Space } from '@/types'
import { setActiveSpace as setActiveSpaceAction } from '@/app/actions'

interface SpaceStore {
  activeSpace: Space | null
  setActiveSpace: (spaceOrId: Space | string | null) => Promise<void>
  spaces: Space[] | null
  setSpaces: (spaces: Space[] | null) => void
}

export const useSpaceStore = create<SpaceStore>((set, get) => ({
  activeSpace: null,
  setActiveSpace: async (spaceOrId) => {
    if (typeof spaceOrId === 'string') {
      const space = get().spaces?.find(space => space.id === spaceOrId)
      if (space) {
        set({ activeSpace: space })
      }
      await setActiveSpaceAction(spaceOrId)
    } else {
      set({ activeSpace: spaceOrId })
    }
  },
  spaces: null,
  setSpaces: (spaces) => set({ spaces }),
}))

================
File: supabase/migrations/20250204124800_create_complete_schema.sql
================
-- Create complete schema for Vinci app
-- Timestamp: 2025-02-04T12:48:00-07:00

-- USERS TABLE: Supabase Auth will manage user accounts.
-- No changes needed; we'll use `auth.users`.

-- SPACES TABLE: Metadata for spaces.
CREATE TABLE spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    -- Removed color column
    is_archived BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on spaces
ALTER TABLE spaces ENABLE ROW LEVEL SECURITY;

-- RLS policies for spaces
CREATE POLICY "Users can view their own spaces"
    ON spaces FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own spaces"
    ON spaces FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own spaces"
    ON spaces FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own spaces"
    ON spaces FOR DELETE
    USING (user_id = auth.uid());

-- CONVERSATIONS TABLE: Each conversation is part of a space.
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    title TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on conversations
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for conversations
CREATE POLICY "Users can view conversations in their spaces"
    ON conversations FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create conversations in their spaces"
    ON conversations FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    annotations JSONB DEFAULT '[]'::jsonb,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT valid_annotations CHECK (
        jsonb_typeof(annotations) = 'array'
    )
);

-- Enable RLS on messages
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- RLS policies for messages
CREATE POLICY "Users can view messages in their spaces"
    ON messages FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can insert messages in their spaces"
    ON messages FOR INSERT
    WITH CHECK (
        messages.user_id = auth.uid() AND
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

-- SPACE_USER_RELATIONS (Optional for shared spaces).
CREATE TABLE space_user_relations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces (id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    role TEXT CHECK (role IN ('owner', 'editor', 'viewer')) DEFAULT 'viewer',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space_user_relations
ALTER TABLE space_user_relations ENABLE ROW LEVEL SECURITY;

-- Add indexes for better query performance
CREATE INDEX idx_spaces_user_id ON spaces(user_id);
CREATE INDEX idx_conversations_space_id ON conversations(space_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_space_user_relations_space_id ON space_user_relations(space_id);
CREATE INDEX idx_space_user_relations_user_id ON space_user_relations(user_id);

-- Create a function to get the latest messages in a conversation
CREATE OR REPLACE FUNCTION get_conversation_messages(conversation_uuid UUID)
RETURNS TABLE (
    id UUID,
    user_id UUID,
    role TEXT,
    content TEXT,
    annotations JSONB,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        m.id,
        m.user_id,
        m.role,
        m.content,
        m.annotations,
        m.created_at,
        m.updated_at
    FROM messages m
    WHERE m.conversation_id = conversation_uuid
    AND m.is_deleted = FALSE
    ORDER BY m.created_at ASC;
END;
$$;

================
File: supabase/migrations/20250204124900_alter_space_table.sql
================
ALTER TABLE "spaces" ADD COLUMN model TEXT NOT NULL DEFAULT 'deepseek-r1-distill-llama-70b';
ALTER TABLE "spaces" ADD COLUMN provider text NOT NULL DEFAULT 'groq';

================
File: supabase/migrations/20250204125000_create_active_space_table.sql
================
CREATE TABLE active_spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id) 
);

================
File: supabase/migrations/20250204125100_update_rls_policies.sql
================


================
File: supabase/migrations/20250221221400_add_active_conversations.sql
================
-- Create active_conversations table
CREATE TABLE active_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id)
);

-- Enable RLS on active_conversations
ALTER TABLE active_conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for active_conversations
CREATE POLICY "Users can view their own active conversation"
    ON active_conversations FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can update their own active conversation"
    ON active_conversations FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own active conversation"
    ON active_conversations FOR DELETE
    USING (user_id = auth.uid());

================
File: supabase/migrations/20250223171800_add_notifications.sql
================
-- Create notifications schema
-- Timestamp: 2025-02-23T17:18:00-07:00

-- Create notification types enum
CREATE TYPE notification_type AS ENUM (
    'space_created',
    'space_deleted',
    'model_changed',
    'conversation_created',
    'conversation_deleted'
);

-- Create notifications table
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type notification_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on notifications
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- RLS policies for notifications
CREATE POLICY "Users can view their own notifications"
    ON notifications FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own notifications"
    ON notifications FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own notifications"
    ON notifications FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- Create index for faster notification lookups
CREATE INDEX notifications_user_id_idx ON notifications(user_id);
CREATE INDEX notifications_created_at_idx ON notifications(created_at DESC);

================
File: supabase/migrations/20250223171900_add_realtime_notifications.sql
================
-- Enable realtime for notifications
ALTER PUBLICATION supabase_realtime ADD TABLE notifications;

================
File: supabase/migrations/20250223175200_add_space_history.sql
================
-- Create space history schema
-- Timestamp: 2025-02-23T17:52:00-07:00

-- Create space action types enum
CREATE TYPE space_action_type AS ENUM (
    'created',
    'deleted',
    'updated',
    'model_changed',
    'conversation_added',
    'conversation_deleted'
);

-- Create space history table
CREATE TABLE space_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    action_type space_action_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space history
ALTER TABLE space_history ENABLE ROW LEVEL SECURITY;

-- RLS policies for space history
CREATE POLICY "Users can view history for spaces they have access to"
    ON space_history FOR SELECT
    USING (
        user_id = auth.uid() OR 
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create history entries for their spaces"
    ON space_history FOR INSERT
    WITH CHECK (
        user_id = auth.uid() AND
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

-- Create indexes for faster lookups
CREATE INDEX space_history_space_id_idx ON space_history(space_id);
CREATE INDEX space_history_user_id_idx ON space_history(user_id);
CREATE INDEX space_history_created_at_idx ON space_history(created_at DESC);

================
File: supabase/migrations/20250223175201_migration_add_is_deleted_to_conversations.sql
================
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS is_deleted BOOLEAN DEFAULT FALSE;
UPDATE conversations SET is_deleted = FALSE WHERE is_deleted IS NULL;

================
File: supabase/migrations/20250225012800_add_conversations_update_policy.sql
================
CREATE POLICY "Users can update conversations in their spaces"
    ON conversations FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

================
File: supabase/.gitignore
================
# Supabase
.branches
.temp
.env

================
File: supabase/config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "ui"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: supabase/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-25T01:28:27.566Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
migrations/
  20250204124800_create_complete_schema.sql
  20250204124900_alter_space_table.sql
  20250204125000_create_active_space_table.sql
  20250204125100_update_rls_policies.sql
  20250221221400_add_active_conversations.sql
  20250223171800_add_notifications.sql
  20250223171900_add_realtime_notifications.sql
  20250223175200_add_space_history.sql
  20250223175201_migration_add_is_deleted_to_conversations.sql
.gitignore
config.toml

================================================================
Files
================================================================

================
File: migrations/20250204124800_create_complete_schema.sql
================
-- Create complete schema for Vinci app
-- Timestamp: 2025-02-04T12:48:00-07:00

-- USERS TABLE: Supabase Auth will manage user accounts.
-- No changes needed; we'll use `auth.users`.

-- SPACES TABLE: Metadata for spaces.
CREATE TABLE spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    -- Removed color column
    is_archived BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on spaces
ALTER TABLE spaces ENABLE ROW LEVEL SECURITY;

-- RLS policies for spaces
CREATE POLICY "Users can view their own spaces"
    ON spaces FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own spaces"
    ON spaces FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own spaces"
    ON spaces FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own spaces"
    ON spaces FOR DELETE
    USING (user_id = auth.uid());

-- CONVERSATIONS TABLE: Each conversation is part of a space.
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    title TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on conversations
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for conversations
CREATE POLICY "Users can view conversations in their spaces"
    ON conversations FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = conversations.space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create conversations in their spaces"
    ON conversations FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM spaces
            WHERE spaces.id = space_id
            AND spaces.user_id = auth.uid()
        )
    );

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content TEXT NOT NULL,
    annotations JSONB DEFAULT '[]'::jsonb,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT valid_annotations CHECK (
        jsonb_typeof(annotations) = 'array'
    )
);

-- Enable RLS on messages
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- RLS policies for messages
CREATE POLICY "Users can view messages in their spaces"
    ON messages FOR SELECT
    USING (
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

CREATE POLICY "Users can insert messages in their spaces"
    ON messages FOR INSERT
    WITH CHECK (
        messages.user_id = auth.uid() AND
        EXISTS (
            SELECT 1
            FROM spaces s
            JOIN conversations c ON c.space_id = s.id
            WHERE c.id = messages.conversation_id
            AND s.user_id = auth.uid()
        )
    );

-- SPACE_USER_RELATIONS (Optional for shared spaces).
CREATE TABLE space_user_relations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces (id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users (id) ON DELETE CASCADE,
    role TEXT CHECK (role IN ('owner', 'editor', 'viewer')) DEFAULT 'viewer',
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space_user_relations
ALTER TABLE space_user_relations ENABLE ROW LEVEL SECURITY;

-- Add indexes for better query performance
CREATE INDEX idx_spaces_user_id ON spaces(user_id);
CREATE INDEX idx_conversations_space_id ON conversations(space_id);
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_space_user_relations_space_id ON space_user_relations(space_id);
CREATE INDEX idx_space_user_relations_user_id ON space_user_relations(user_id);

-- Create a function to get the latest messages in a conversation
CREATE OR REPLACE FUNCTION get_conversation_messages(conversation_uuid UUID)
RETURNS TABLE (
    id UUID,
    user_id UUID,
    role TEXT,
    content TEXT,
    annotations JSONB,
    created_at TIMESTAMPTZ,
    updated_at TIMESTAMPTZ
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        m.id,
        m.user_id,
        m.role,
        m.content,
        m.annotations,
        m.created_at,
        m.updated_at
    FROM messages m
    WHERE m.conversation_id = conversation_uuid
    AND m.is_deleted = FALSE
    ORDER BY m.created_at ASC;
END;
$$;

================
File: migrations/20250204124900_alter_space_table.sql
================
ALTER TABLE "spaces" ADD COLUMN model TEXT NOT NULL DEFAULT 'deepseek-r1-distill-llama-70b';
ALTER TABLE "spaces" ADD COLUMN provider text NOT NULL DEFAULT 'groq';

================
File: migrations/20250204125000_create_active_space_table.sql
================
CREATE TABLE active_spaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id) 
);

================
File: migrations/20250204125100_update_rls_policies.sql
================


================
File: migrations/20250221221400_add_active_conversations.sql
================
-- Create active_conversations table
CREATE TABLE active_conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(user_id)
);

-- Enable RLS on active_conversations
ALTER TABLE active_conversations ENABLE ROW LEVEL SECURITY;

-- RLS policies for active_conversations
CREATE POLICY "Users can view their own active conversation"
    ON active_conversations FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can update their own active conversation"
    ON active_conversations FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own active conversation"
    ON active_conversations FOR DELETE
    USING (user_id = auth.uid());

================
File: migrations/20250223171800_add_notifications.sql
================
-- Create notifications schema
-- Timestamp: 2025-02-23T17:18:00-07:00

-- Create notification types enum
CREATE TYPE notification_type AS ENUM (
    'space_created',
    'space_deleted',
    'model_changed',
    'conversation_created',
    'conversation_deleted'
);

-- Create notifications table
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type notification_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on notifications
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- RLS policies for notifications
CREATE POLICY "Users can view their own notifications"
    ON notifications FOR SELECT
    USING (user_id = auth.uid());

CREATE POLICY "Users can create their own notifications"
    ON notifications FOR INSERT
    WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own notifications"
    ON notifications FOR UPDATE
    USING (user_id = auth.uid())
    WITH CHECK (user_id = auth.uid());

-- Create index for faster notification lookups
CREATE INDEX notifications_user_id_idx ON notifications(user_id);
CREATE INDEX notifications_created_at_idx ON notifications(created_at DESC);

================
File: migrations/20250223171900_add_realtime_notifications.sql
================
-- Enable realtime for notifications
ALTER PUBLICATION supabase_realtime ADD TABLE notifications;

================
File: migrations/20250223175200_add_space_history.sql
================
-- Create space history schema
-- Timestamp: 2025-02-23T17:52:00-07:00

-- Create space action types enum
CREATE TYPE space_action_type AS ENUM (
    'created',
    'deleted',
    'updated',
    'model_changed',
    'conversation_added',
    'conversation_deleted'
);

-- Create space history table
CREATE TABLE space_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    space_id UUID NOT NULL REFERENCES spaces(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    action_type space_action_type NOT NULL,
    title TEXT NOT NULL,
    description TEXT NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS on space history
ALTER TABLE space_history ENABLE ROW LEVEL SECURITY;

-- RLS policies for space history
CREATE POLICY "Users can view history for spaces they have access to"
    ON space_history FOR SELECT
    USING (
        user_id = auth.uid() OR 
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

CREATE POLICY "Users can create history entries for their spaces"
    ON space_history FOR INSERT
    WITH CHECK (
        user_id = auth.uid() AND
        space_id IN (
            SELECT id FROM spaces 
            WHERE user_id = auth.uid()
        )
    );

-- Create indexes for faster lookups
CREATE INDEX space_history_space_id_idx ON space_history(space_id);
CREATE INDEX space_history_user_id_idx ON space_history(user_id);
CREATE INDEX space_history_created_at_idx ON space_history(created_at DESC);

================
File: migrations/20250223175201_migration_add_is_deleted_to_conversations.sql
================
ALTER TABLE conversations ADD COLUMN IF NOT EXISTS is_deleted BOOLEAN DEFAULT FALSE;
UPDATE conversations SET is_deleted = FALSE WHERE is_deleted IS NULL;

================
File: .gitignore
================
# Supabase
.branches
.temp
.env

================
File: config.toml
================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "ui"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083

# Use these configurations to customize your Edge Function.
# [functions.MY_FUNCTION_NAME]
# enabled = true
# verify_jwt = true
# import_map = "./functions/MY_FUNCTION_NAME/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
# entrypoint = "./functions/MY_FUNCTION_NAME/index.ts"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

================
File: types/index.ts
================
export interface Space {
  id: string;
  name: string;
  description?: string;
  model?: string;
  provider?: string;
  is_archived: boolean;
  is_deleted: boolean;
  created_at: string;
  updated_at: string;
  user_id: string;
  color?: string;
  isActive?: boolean;
}

export interface Conversation {
  id: string;
  space_id: string;
  title?: string;
  created_at?: string;
  updated_at?: string;
  is_deleted?: boolean;
  messageCount?: number;
  lastMessage?: string;
}

================
File: utils/supabase/check-env-vars.ts
================
// This check can be removed
// it is just for tutorial purposes

export const hasEnvVars =
  process.env.NEXT_PUBLIC_SUPABASE_URL &&
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

================
File: utils/supabase/client.ts
================
import { createBrowserClient } from "@supabase/ssr";

export const createClient = () =>
  createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  );

================
File: utils/supabase/middleware.ts
================
import { createServerClient } from "@supabase/ssr";
import { type NextRequest, NextResponse } from "next/server";

export const updateSession = async (request: NextRequest) => {
  // This `try/catch` block is only here for the interactive tutorial.
  // Feel free to remove once you have Supabase connected.
  try {
    // Create an unmodified response
    let response = NextResponse.next({
      request: {
        headers: request.headers,
      },
    });

    const supabase = createServerClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          getAll() {
            return request.cookies.getAll();
          },
          setAll(cookiesToSet) {
            cookiesToSet.forEach(({ name, value }) =>
              request.cookies.set(name, value),
            );
            response = NextResponse.next({
              request,
            });
            cookiesToSet.forEach(({ name, value, options }) =>
              response.cookies.set(name, value, options),
            );
          },
        },
      },
    );

    // This will refresh session if expired - required for Server Components
    // https://supabase.com/docs/guides/auth/server-side/nextjs
    const user = await supabase.auth.getUser();

    // protected routes
    if (request.nextUrl.pathname.startsWith("/protected") && user.error) {
      return NextResponse.redirect(new URL("/sign-in", request.url));
    }

    if (request.nextUrl.pathname === "/" && !user.error) {
      return NextResponse.redirect(new URL("/protected", request.url));
    }

    return response;
  } catch (e) {
    // If you are here, a Supabase client could not be created!
    // This is likely because you have not set up environment variables.
    // Check out http://localhost:3000 for Next Steps.
    return NextResponse.next({
      request: {
        headers: request.headers,
      },
    });
  }
};

================
File: utils/supabase/server.ts
================
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export const createClient = async () => {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => {
              cookieStore.set(name, value, options);
            });
          } catch (error) {
            // The `set` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    },
  );
};

================
File: utils/pinecone.ts
================
import { Pinecone } from '@pinecone-database/pinecone';
import { OpenAIEmbeddings } from '@langchain/openai';
import { RecordMetadata } from '@pinecone-database/pinecone';
import { createClient } from './supabase/server';

if (!process.env.PINECONE_API_KEY) {
  throw new Error('Missing PINECONE_API_KEY environment variable');
}

if (!process.env.PINECONE_ENVIRONMENT) {
  throw new Error('Missing PINECONE_ENVIRONMENT environment variable');
}

if (!process.env.PINECONE_INDEX) {
  throw new Error('Missing PINECONE_INDEX environment variable');
}

if (!process.env.OPENAI_API_KEY) {
  throw new Error('Missing OPENAI_API_KEY environment variable');
}

const pinecone = new Pinecone();

const index = pinecone.Index(process.env.PINECONE_INDEX!);

const embeddings = new OpenAIEmbeddings({
  openAIApiKey: process.env.OPENAI_API_KEY,
  modelName: 'text-embedding-3-large',
});

export interface ChatMessage {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  spaceId: string;
  conversationId: string;
  parentId?: string;
  childId?: string;
  metadata?: Record<string, any>;
}

interface PineconeMetadata extends RecordMetadata {
  content: string;
  role: 'user' | 'assistant';
  createdAt: number;
  spaceId: string;
  conversationId: string;
  parentId?: string;
  childId?: string;
  tags?: string[];
  similarMessagesStr?: string;
  similarMessagesCount?: number;
  [key: string]: any;
}

export async function upsertChatMessage(message: ChatMessage) {
  try {
    if (!message.id) {
      throw new Error('Message ID is required for Pinecone upsert');
    }

    const vector = await embeddings.embedQuery(message.content);

    const metadata: PineconeMetadata = {
      content: message.content,
      role: message.role,
      createdAt: message.createdAt,
      spaceId: message.spaceId,
      conversationId: message.conversationId,
      ...(message.parentId && { parentId: message.parentId }),
      ...(message.childId && { childId: message.childId }),
    };
    
    if (message.metadata) {
      Object.entries(message.metadata).forEach(([key, value]) => {
        if (key === 'similarMessages' && value) {
          metadata.similarMessagesStr = JSON.stringify(value);
          metadata.similarMessagesCount = Array.isArray(value) ? value.length : 0;
        } else if (key === 'tags' && Array.isArray(value)) {
          metadata.tags = value;
        } else if (
          typeof value === 'string' || 
          typeof value === 'number' || 
          typeof value === 'boolean' ||
          (Array.isArray(value) && value.every(item => typeof item === 'string'))
        ) {
          metadata[key] = value;
        }
      });
    }

    await index.upsert([
      {
        id: message.id,
        values: vector,
        metadata,
      },
    ]);

    if (message.role === 'assistant' && message.parentId) {
      const parentVector = await index.fetch([message.parentId]);
      const parentRecord = parentVector.records[message.parentId];
      if (parentRecord && parentRecord.metadata) {
        const parentMetadata = parentRecord.metadata as PineconeMetadata;
        await index.upsert([
          {
            id: message.parentId,
            values: parentRecord.values,
            metadata: {
              ...parentMetadata,
              childId: message.id,
            },
          },
        ]);
      }
    }
  } catch (error) {
    console.error('Error upserting chat message to Pinecone:', error);
    throw error;
  }
}

export async function searchSimilarMessages(query: string, limit = 5, tags: string[] = []) {
  try {
    const queryEmbedding = await embeddings.embedQuery(query);

    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      throw new Error('Unauthorized');
    }
    
    const filter: any = {};
    
    // Add tag filter if tags are provided
    if (tags.length > 0) {
      filter.tags = { $in: tags };
    }
    
    // Get deleted conversations and spaces to exclude them from results
    const [conversationsResult, spacesResult] = await Promise.all([
      supabase
        .from('conversations')
        .select('id')
        .eq('is_deleted', true),
      supabase
        .from('spaces')
        .select('id')
        .eq('is_deleted', true)
    ]);
    
    const deletedConversationIds = conversationsResult.data?.map(c => c.id) || [];
    const deletedSpaceIds = spacesResult.data?.map(s => s.id) || [];
    
    // Build filter for Pinecone query
    // Use $and only if we have multiple conditions
    if ((deletedConversationIds.length > 0 || deletedSpaceIds.length > 0) || tags.length > 0) {
      // Initialize $and array if we need it
      filter.$and = [];
      
      // Add tag filter to $and if tags are provided
      if (tags.length > 0) {
        filter.$and.push({ tags: { $in: tags } });
        // Remove the top-level tags filter since we're using it in $and
        delete filter.tags;
      }
      
      // Add filters to exclude deleted conversations and spaces
      if (deletedConversationIds.length > 0) {
        filter.$and.push({ conversationId: { $nin: deletedConversationIds } });
      }
      
      if (deletedSpaceIds.length > 0) {
        filter.$and.push({ spaceId: { $nin: deletedSpaceIds } });
      }
      
      // If $and has only one condition, simplify the filter
      if (filter.$and.length === 1) {
        const condition = filter.$and[0];
        delete filter.$and;
        Object.assign(filter, condition);
      } else if (filter.$and.length === 0) {
        delete filter.$and;
      }
    }

    const results = await index.query({
      vector: queryEmbedding,
      topK: limit,
      includeMetadata: true,
      ...(Object.keys(filter).length > 0 ? { filter } : {}),
    });

    return results.matches.map((match) => ({
      score: match.score,
      message: reconstructChatMessage(match.metadata as PineconeMetadata, match.id),
    }));
  } catch (error) {
    console.error('Error searching similar messages in Pinecone:', error);
    throw error;
  }
}

function reconstructChatMessage(metadata: PineconeMetadata, id: string): ChatMessage {
  const { 
    content, 
    role, 
    createdAt, 
    spaceId, 
    conversationId, 
    parentId, 
    childId, 
    similarMessagesStr, 
    similarMessagesCount,
    ...rest 
  } = metadata;
  
  // Prepare the message metadata
  const messageMetadata: Record<string, any> = { 
    ...rest
    // Don't duplicate conversationId in metadata since it's already at the top level
  };
  
  // Parse the stringified similarMessages back to an object if it exists
  if (similarMessagesStr) {
    try {
      const parsedMessages = JSON.parse(similarMessagesStr);
      // Make sure each similar message has conversationId as a direct property
      messageMetadata.similarMessages = parsedMessages.map((msg: any) => ({
        ...msg,
        // Put conversationId directly on the message object
        conversationId: msg.conversationId || msg.metadata?.conversationId
      }));
    } catch (error) {
      console.error('Error parsing similarMessages from Pinecone:', error);
      // If parsing fails, provide an empty array as fallback
      messageMetadata.similarMessages = [];
    }
  }

  return {
    id,
    content,
    role,
    createdAt,
    spaceId,
    conversationId, // This stays at the top level where it belongs
    ...(parentId && { parentId }),
    ...(childId && { childId }),
    metadata: messageMetadata,
  };
}

export async function getMessageThread(messageId: string): Promise<ChatMessage[]> {
  try {
    if (!messageId) {
      throw new Error('Message ID is required to get message thread');
    }

    const messages: ChatMessage[] = [];
    let currentId: string | undefined = messageId;

    while (currentId) {
      const result = await index.fetch([currentId]);
      const record = result.records[currentId];
      if (!record || !record.metadata) break;

      const metadata = record.metadata as PineconeMetadata;
      messages.unshift(reconstructChatMessage(metadata, currentId));
      currentId = metadata.parentId;
    }

    currentId = messageId;
    while (currentId) {
      const result = await index.fetch([currentId]);
      const record = result.records[currentId];
      if (!record || !record.metadata) break;

      const metadata = record.metadata as PineconeMetadata;
      if (!metadata.childId) break;

      const childResult = await index.fetch([metadata.childId]);
      const childRecord = childResult.records[metadata.childId];
      if (!childRecord || !childRecord.metadata) break;

      const childMetadata = childRecord.metadata as PineconeMetadata;
      messages.push(reconstructChatMessage(childMetadata, metadata.childId));
      currentId = metadata.childId;
    }

    return messages;
  } catch (error) {
    console.error('Error getting message thread:', error);
    throw error;
  }
}

export async function deleteMessagesByConversationId(conversationId: string): Promise<void> {
  try {
    if (!conversationId) {
      throw new Error('Conversation ID is required to delete messages');
    }

    console.log(`Deleting messages for conversation: ${conversationId}`);

    // Use query to find all vectors by conversationId
    const queryEmbedding = await embeddings.embedQuery(''); // Empty query to match all vectors
    const queryResponse = await index.query({
      vector: queryEmbedding,
      filter: {
        conversationId: conversationId
      },
      topK: 10000, // Set a high limit to get all messages
      includeMetadata: true,
    });

    // If we found messages to delete
    if (queryResponse.matches && queryResponse.matches.length > 0) {
      console.log(`Found ${queryResponse.matches.length} messages to delete`);
      
      // Extract the IDs from the response
      const messageIds = queryResponse.matches.map(match => match.id);
      
      if (messageIds.length > 0) {
        console.log(`Deleting ${messageIds.length} message records from Pinecone`);
        
        // Delete the vectors by their IDs
        await index.deleteMany(messageIds);
        console.log(`Successfully deleted ${messageIds.length} messages from Pinecone`);
      }
    } else {
      console.log(`No messages found for conversation ${conversationId}`);
    }
  } catch (error) {
    console.error('Error deleting messages by conversation ID:', error);
    throw error;
  }
}

export async function deleteMessagesBySpaceId(spaceId: string): Promise<void> {
  try {
    if (!spaceId) {
      throw new Error('Space ID is required to delete messages');
    }

    console.log(`Deleting messages for space: ${spaceId}`);

    // Use query to find all vectors by spaceId
    const queryEmbedding = await embeddings.embedQuery(''); // Empty query to match all vectors
    const queryResponse = await index.query({
      vector: queryEmbedding,
      filter: {
        spaceId: spaceId
      },
      topK: 10000, // Set a high limit to get all messages
      includeMetadata: true,
    });

    // If we found messages to delete
    if (queryResponse.matches && queryResponse.matches.length > 0) {
      console.log(`Found ${queryResponse.matches.length} messages to delete`);
      
      // Extract the IDs from the response
      const messageIds = queryResponse.matches.map(match => match.id);
      
      if (messageIds.length > 0) {
        console.log(`Deleting ${messageIds.length} message records from Pinecone`);
        
        // Delete the vectors by their IDs
        await index.deleteMany(messageIds);
        console.log(`Successfully deleted ${messageIds.length} messages from Pinecone`);
      }
    } else {
      console.log(`No messages found for space ${spaceId}`);
    }
  } catch (error) {
    console.error('Error deleting messages by space ID:', error);
    throw error;
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: constants.ts
================
import { Provider } from "@/config/models";

export interface AIModel {
  id: string;
  name: string;
  contextLength: number;
  provider: Provider;
}

export interface AIProvider {
  id: Provider;
  name: string;
  models: AIModel[];
}

export const API_ROUTES = {
  CHAT: '/api/chat',
  CONVERSATIONS: (spaceId: string) => `/api/conversations/${spaceId}`,
  MESSAGES: (conversationId: string) => `/api/messages/${conversationId}`,
  SPACES: '/api/spaces',
  SPACE: (id: string) => `/api/spaces/${id}`,
};


// Database Tables
export const DB_TABLES = {
  NOTIFICATIONS: 'notifications',
  SPACES: 'spaces',
  CONVERSATIONS: 'conversations',
  MESSAGES: 'messages',
  ACTIVE_SPACES: 'active_spaces',
  ACTIVE_CONVERSATIONS: 'active_conversations'
} as const

// Common Table Columns
export const COLUMNS = {
  // Common columns
  ID: 'id',
  USER_ID: 'user_id',
  CREATED_AT: 'created_at',
  UPDATED_AT: 'updated_at',
  IS_DELETED: 'is_deleted',

  // Space columns
  NAME: 'name',
  DESCRIPTION: 'description',
  MODEL: 'model',
  PROVIDER: 'provider',
  IS_ACTIVE: 'isActive',

  // Conversation columns
  SPACE_ID: 'space_id',
  TITLE: 'title',

  // Message columns
  CONVERSATION_ID: 'conversation_id',
  ROLE: 'role',
  CONTENT: 'content',
  MODEL_USED: 'model_used',
  PARENT_MESSAGE_ID: 'parent_message_id',
  ANNOTATIONS: 'annotations',
  COLOR: 'color',
} as const

// Message Roles
export const MESSAGE_ROLES = {
  USER: 'user',
  ASSISTANT: 'assistant'
} as const

// Common Error Messages
export const ERROR_MESSAGES = {
  UNAUTHORIZED: { error: 'Unauthorized', status: 401 },
  MISSING_FIELDS: { error: 'Missing required fields', status: 400 },
  INVALID_PROVIDER: { error: 'Invalid provider', status: 400 },
  INVALID_MODEL: { error: 'Invalid model for the selected provider', status: 400 },
  MISSING_SPACE_ID: { error: 'Space ID is required', status: 400 },
  MISSING_CONVERSATION_ID: { error: 'Conversation ID is required', status: 400 },
  INVALID_ROLE: { error: 'Invalid role: must be either "user" or "assistant"', status: 400 },
  MISSING_ASSISTANT_FIELDS: { error: 'Assistant messages require model_used and provider fields', status: 400 },
  SPACE_NOT_FOUND: { error: 'Space not found or access denied', status: 404 },
  CONVERSATION_NOT_FOUND: { error: 'Conversation not found', status: 404 },
  SERVER_ERROR: (message: string) => ({ error: message, status: 500 })
} as const

export const DEFAULTS = {
  CONVERSATION_TITLE: 'New Conversation',
  SPACE_NAME: 'My Space',
  SPACE_DESCRIPTION: 'My first space',
  WELCOME_MESSAGE: 'Welcome to Vinci! I\'m here to help you explore and create. What would you like to do?'
} as const

================
File: middleware.ts
================
import { type NextRequest } from "next/server";
import { updateSession } from "@/utils/supabase/middleware";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - images - .svg, .png, .jpg, .jpeg, .gif, .webp
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};

================
File: next.config.ts
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: "standalone",
  reactStrictMode: true,
  env: {
    NEXT_PUBLIC_SUPPORTED_MODELS: process.env.SUPPORTED_MODELS,
    NEXT_PUBLIC_MODEL_PROVIDERS: process.env.MODEL_PROVIDERS,
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'unpkg.com',
        pathname: '/@lobehub/**',
      },
      {
        protocol: 'https',
        hostname: 'registry.npmmirror.com',
        pathname: '/@lobehub/**',
      }
    ],
  },
  transpilePackages: ['@lobehub/icons'],
};

export default nextConfig;

================
File: nodemon.json
================
{
    "$schema": "https://json.schemastore.org/nodemon.json",
    "exec": "electron .",
    "watch": ["build"],
    "ignore": ["build", "public/build"]
  }

================
File: package.json
================
{
  "private": true,
  "main": "build/main.js",
  "scripts": {
    "next:dev": "next dev --turbopack",
    "next:build": "next build",
    "electron:build": "tsup",
    "electron:build_watch": "tsup --watch",
    "electron:watch": "cross-env NODE_ENV='development' nodemon",
    "electron:dev": "npm-run-all --parallel electron:build_watch electron:watch",
    "dev": "npm-run-all --parallel electron:dev next:dev"
  },
  "dependencies": {
    "@agentic/ai-sdk": "^7.3.1",
    "@ai-sdk/anthropic": "^1.1.6",
    "@ai-sdk/cerebras": "^0.1.8",
    "@ai-sdk/cohere": "^1.1.7",
    "@ai-sdk/deepseek": "^0.1.8",
    "@ai-sdk/fireworks": "^0.1.8",
    "@ai-sdk/google": "^1.1.10",
    "@ai-sdk/groq": "^1.1.7",
    "@ai-sdk/mistral": "^1.1.6",
    "@ai-sdk/openai": "^1.1.9",
    "@ai-sdk/perplexity": "^0.0.7",
    "@ai-sdk/togetherai": "^0.1.9",
    "@ai-sdk/xai": "^1.1.8",
    "@electron-toolkit/utils": "^3.0.0",
    "@icons-pack/react-simple-icons": "^12.0.0",
    "@langchain/openai": "^0.4.4",
    "@lobehub/icons": "^1.68.0",
    "@openrouter/ai-sdk-provider": "^0.2.0",
    "@pinecone-database/pinecone": "^5.0.0",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "latest",
    "@supabase/supabase-js": "latest",
    "@types/highlight.js": "^10.1.0",
    "@types/markdown-it": "^14.1.2",
    "@types/marked": "^6.0.0",
    "@types/prismjs": "^1.26.5",
    "@upstash/qstash": "^2.7.22",
    "@upstash/redis": "^1.34.4",
    "ai": "^4.1.34",
    "autoprefixer": "10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.4",
    "developer-icons": "^5.2.9",
    "emoji-picker-react": "^4.12.0",
    "framer-motion": "^12.0.6",
    "get-port-please": "^3.1.2",
    "highlight.js": "^11.11.1",
    "isomorphic-dompurify": "^2.21.0",
    "lodash": "^4.17.21",
    "lucide-react": "^0.468.0",
    "markdown-it": "^14.1.0",
    "markdown-it-jsx": "^1.1.0",
    "marked": "^15.0.7",
    "marked-base-url": "^1.1.6",
    "marked-gfm-heading-id": "^4.1.1",
    "marked-highlight": "^2.2.1",
    "marked-mangle": "^1.1.10",
    "next": "15.2.0",
    "next-themes": "^0.4.3",
    "prettier": "^3.3.3",
    "prismjs": "^1.29.0",
    "react": "19.0.0",
    "react-colorful": "^5.6.1",
    "react-dom": "19.0.0",
    "react-hotkeys-hook": "^4.6.1",
    "react-intersection-observer": "^9.15.1",
    "react-markdown": "^9.1.0",
    "react-syntax-highlighter": "^15.6.1",
    "react-textarea-autosize": "^8.5.7",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.1",
    "shiki": "^2.5.0",
    "sonner": "^2.0.1",
    "use-stick-to-bottom": "^1.0.46",
    "zod": "^3.24.1",
    "zod-to-json-schema": "^3.24.1",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@swc/core": "^1.10.12",
    "@swc/helpers": "^0.5.15",
    "@types/lodash": "^4.17.15",
    "@types/node": "22.10.2",
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4",
    "@types/react-syntax-highlighter": "^15.5.13",
    "cross-env": "^7.0.3",
    "electron": "^34.0.2",
    "electron-builder": "^25.1.8",
    "nodemon": "^3.1.9",
    "npm-run-all": "^4.1.5",
    "postcss": "8.4.49",
    "tailwind-merge": "^2.6.0",
    "tailwindcss": "3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "tsup": "^8.3.6",
    "typescript": "5.7.2"
  },
  "overrides": {
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4"
  }
}

================
File: postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: README.md
================
<a href="https://demo-nextjs-with-supabase.vercel.app/">
  <img alt="Next.js and Supabase Starter Kit - the fastest way to build apps with Next.js and Supabase" src="https://demo-nextjs-with-supabase.vercel.app/opengraph-image.png">
  <h1 align="center">Next.js and Supabase Starter Kit</h1>
</a>

<p align="center">
 The fastest way to build apps with Next.js and Supabase
</p>

<p align="center">
  <a href="#features"><strong>Features</strong></a> ·
  <a href="#demo"><strong>Demo</strong></a> ·
  <a href="#deploy-to-vercel"><strong>Deploy to Vercel</strong></a> ·
  <a href="#clone-and-run-locally"><strong>Clone and run locally</strong></a> ·
  <a href="#feedback-and-issues"><strong>Feedback and issues</strong></a>
  <a href="#more-supabase-examples"><strong>More Examples</strong></a>
</p>
<br/>

## Features

- Works across the entire [Next.js](https://nextjs.org) stack
  - App Router
  - Pages Router
  - Middleware
  - Client
  - Server
  - It just works!
- supabase-ssr. A package to configure Supabase Auth to use cookies
- Styling with [Tailwind CSS](https://tailwindcss.com)
- Components with [shadcn/ui](https://ui.shadcn.com/)
- Optional deployment with [Supabase Vercel Integration and Vercel deploy](#deploy-your-own)
  - Environment variables automatically assigned to Vercel project

## Demo

You can view a fully working demo at [demo-nextjs-with-supabase.vercel.app](https://demo-nextjs-with-supabase.vercel.app/).

## Deploy to Vercel

Vercel deployment will guide you through creating a Supabase account and project.

After installation of the Supabase integration, all relevant environment variables will be assigned to the project so the deployment is fully functioning.

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&project-name=nextjs-with-supabase&repository-name=nextjs-with-supabase&demo-title=nextjs-with-supabase&demo-description=This+starter+configures+Supabase+Auth+to+use+cookies%2C+making+the+user%27s+session+available+throughout+the+entire+Next.js+app+-+Client+Components%2C+Server+Components%2C+Route+Handlers%2C+Server+Actions+and+Middleware.&demo-url=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2F&external-id=https%3A%2F%2Fgithub.com%2Fvercel%2Fnext.js%2Ftree%2Fcanary%2Fexamples%2Fwith-supabase&demo-image=https%3A%2F%2Fdemo-nextjs-with-supabase.vercel.app%2Fopengraph-image.png)

The above will also clone the Starter kit to your GitHub, you can clone that locally and develop locally.

If you wish to just develop locally and not deploy to Vercel, [follow the steps below](#clone-and-run-locally).

## Clone and run locally

1. You'll first need a Supabase project which can be made [via the Supabase dashboard](https://database.new)

2. Create a Next.js app using the Supabase Starter template npx command

   ```bash
   npx create-next-app --example with-supabase with-supabase-app
   ```

   ```bash
   yarn create next-app --example with-supabase with-supabase-app
   ```

   ```bash
   pnpm create next-app --example with-supabase with-supabase-app
   ```

3. Use `cd` to change into the app's directory

   ```bash
   cd with-supabase-app
   ```

4. Rename `.env.example` to `.env.local` and update the following:

   ```
   NEXT_PUBLIC_SUPABASE_URL=[INSERT SUPABASE PROJECT URL]
   NEXT_PUBLIC_SUPABASE_ANON_KEY=[INSERT SUPABASE PROJECT API ANON KEY]
   ```

   Both `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` can be found in [your Supabase project's API settings](https://app.supabase.com/project/_/settings/api)

5. You can now run the Next.js local development server:

   ```bash
   npm run dev
   ```

   The starter kit should now be running on [localhost:3000](http://localhost:3000/).

6. This template comes with the default shadcn/ui style initialized. If you instead want other ui.shadcn styles, delete `components.json` and [re-install shadcn/ui](https://ui.shadcn.com/docs/installation/next)

> Check out [the docs for Local Development](https://supabase.com/docs/guides/getting-started/local-development) to also run Supabase locally.

## Feedback and issues

Please file feedback and issues over on the [Supabase GitHub org](https://github.com/supabase/supabase/issues/new/choose).

## More Supabase examples

- [Next.js Subscription Payments Starter](https://github.com/vercel/nextjs-subscription-payments)
- [Cookie-based Auth and the Next.js 13 App Router (free course)](https://youtube.com/playlist?list=PL5S4mPUpp4OtMhpnp93EFSo42iQ40XjbF)
- [Supabase Auth and the Next.js App Router](https://github.com/supabase/supabase/tree/master/examples/auth/nextjs)
# spatial-application

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			},
        'pulse-fast': {
          '0%, 100%': { opacity: '1' },
          '50%': { opacity: '0.4' }
        },
        'pulse-slow': {
          '0%, 100%': { opacity: '0.9' },
          '50%': { opacity: '0.4' }
        },
        'shimmer': {
          '0%': { backgroundPosition: '-100% 0' },
          '100%': { backgroundPosition: '200% 0' }
        },
        'glow': {
          '0%, 100%': { opacity: '0.8' },
          '50%': { opacity: '0.5' }
        },
        'highlight-glow': {
          '0%': { boxShadow: '0 0 5px rgba(62,207,255,0.3)', borderColor: 'rgba(62,207,255,0.3)' },
          '50%': { boxShadow: '0 0 20px rgba(62,207,255,0.8)', borderColor: 'rgba(62,207,255,0.8)' },
          '100%': { boxShadow: '0 0 5px rgba(62,207,255,0.3)', borderColor: 'rgba(62,207,255,0.3)' }
        },
        'rotate-slow': {
          '0%': { transform: 'rotate(0deg)' },
          '100%': { transform: 'rotate(360deg)' }
        },
        'halo-pulse': {
          '0%, 100%': { transform: 'scale(1)', opacity: '0.6' },
          '50%': { transform: 'scale(1.1)', opacity: '0.2' }
        },
        'float': {
          '0%, 100%': { transform: 'translateY(0px)' },
          '50%': { transform: 'translateY(-3px)' }
        },
        'appear': {
          '0%': { opacity: '0', transform: 'scale(0.97)' },
          '100%': { opacity: '1', transform: 'scale(1)' }
        }
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out',
        'pulse-fast': 'pulse-fast 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
        'pulse-slow': 'pulse-slow 3s ease-in-out infinite',
        'shimmer': 'shimmer 3s linear infinite',
        'glow': 'glow 2s ease-in-out infinite',
        'highlight-glow': 'highlight-glow 3s ease-in-out infinite',
        'rotate-slow': 'rotate-slow 10s linear infinite',
        'halo-pulse': 'halo-pulse 3s ease-in-out infinite',
        'float': 'float 3s ease-in-out infinite',
        'appear': 'appear 0.5s cubic-bezier(0.26, 0.53, 0.74, 1.48)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: tsup.config.ts
================
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["./electron/main.ts", "./electron/preload.ts"],
  splitting: false,
  sourcemap: false,
  clean: true,
  outDir: "build",
  external: ["electron"],
  format: ["cjs"]
});

================
File: utils.ts
================
import { redirect } from "next/navigation";
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

/**
 * Redirects to a specified path with an encoded message as a query parameter.
 * @param {('error' | 'success')} type - The type of message, either 'error' or 'success'.
 * @param {string} path - The path to redirect to.
 * @param {string} message - The message to be encoded and added as a query parameter.
 * @returns {never} This function doesn't return as it triggers a redirect.
 */
export function encodedRedirect(
  type: "error" | "success",
  path: string,
  message: string,
) {
  return redirect(`${path}?${type}=${encodeURIComponent(message)}`);
}

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
